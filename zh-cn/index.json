[{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/distributed-consensus-algorithm/","section":"Tags","summary":"","title":"Distributed Consensus Algorithm","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/distributed-system/","section":"Tags","summary":"","title":"Distributed System","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/raft-algorithm/","section":"Tags","summary":"","title":"Raft Algorithm","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/raft-%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"Raft 算法","type":"tags"},{"content":" 1. 背景：为什么需要分布式共识 # 1.1 分布式系统中的一致性难题 # 在分布式系统中，数据与计算分散在多台服务器之间，每台服务器（节点）通过网络连接。这样做能够提高系统的吞吐量和可用性，但也带来了核心挑战—— 如何在多个节点之间保持一致的状态或数据。\n举个简单的例子：假设我们有一个分布式键值存储系统，为了提高可靠性，需要将客户端的写操作复制到多个节点。如果某个节点宕机或网络故障，那么如何保证当该节点恢复后能拿到最新状态？如何确保不会产生“脏数据”或不一致？这就是分布式一致性算法需要解决的问题。\n1.2 常见的一致性算法 # 提到分布式一致性，很多人首先会想到 Paxos。Paxos 拥有严谨的数学证明，但实现和理解都相对晦涩。2014 年，Raft 作为对 Paxos 的“可读性改进版本”被提出，它把一致性过程分解成更易理解的几个步骤，且在保证安全性的同时更易实现，被广泛应用于 **etcd **、Consul、TiKV 等工业级项目中。\n1.3 Raft 的设计目标 # 容易理解：相比于 Paxos，Raft 在抽象和实现上都力图简单清晰。 强一致性：多个节点对日志条目的顺序与内容最终达成一致。 高可用：在大多数节点存活的情况下，系统可继续对外服务。 可扩展性：支持动态地添加或移除节点（配置变更）。 1.4 Raft 可视化 # 2. Raft 的核心思路 # 2.1 流程概览 # Raft 将共识问题分解为三个子问题：\n领导者选举（Leader Election）：如何从多个节点中选出一个“Leader”。 日志复制（Log Replication）：Leader 收到写请求后，如何安全地将日志复制到大多数节点。 安全性（Safety）：在 Leader 崩溃或网络分区时，如何确保系统不会出现日志丢失或被覆盖的情况。 在 Raft 中，节点分为三类角色：\nLeader：处理客户端请求并将其复制到其他 Follower；监控故障。 Follower：被动接收 Leader 的日志复制 RPC 和心跳。 Candidate（候选者）：在选举阶段争取成为新 Leader 的角色。 系统的时序被分割成一个又一个的 Term（任期）。同一任期里最多只能有一个合法 Leader。如果本任期没能成功选出 Leader 或 Leader 崩溃了，则进入下一个任期重新选举。\n2.2 数据结构 # 实现 Raft 时通常需要维护：\nTerm（任期号）：单调递增的数值，标识当前的任期。 Log（日志）：存储客户端请求或命令，每条日志包含 index, term, command。 commitIndex（已提交索引）：当前已对外生效的最高日志索引。 lastApplied（最后应用索引）：本节点已经应用到本地状态机的最高日志索引，$\\text{lastApplied} \\leq \\text{commitIndex}$。 nextIndex[]：在 Leader 中维护，对每个 Follower 记录下一条需要发送的日志索引。 matchIndex[]：在 Leader 中维护，对每个 Follower 记录该 Follower 已复制的最高日志索引。 3. 角色与状态变迁 # 3.1 Follower # 初始状态：系统启动时节点都处于 Follower；或者候选者选举失败后回到 Follower。 行为： 接收并响应 Leader 的日志复制 RPC、心跳消息，以及候选者的投票请求。 超过选举超时没收到任何 Leader 或候选者消息，就会转变为 Candidate。 3.2 Candidate # 触发条件：Follower 超时后，成为 Candidate 发起选举。 主要行为： 将 currentTerm + 1，给自己投票 (voteFor = self)。 并行向其他节点发送“请求投票”RPC。 若获得多数票，则成为 Leader；若有更新任期的 Leader 出现，则回到 Follower；若超时还未选出 Leader，则启动下一轮选举。 3.3 Leader # 触发条件：Candidate 获得多数票。 主要行为： 向所有节点周期性发送心跳 (AppendEntries RPC) 防止它们发起选举。 处理客户端请求，封装为日志条目写入自身日志后，再广播给其他 Follower。也就是说，强一致场景下，Follower/Candidate 是不负责处理读写操作的，只是作为 Leader 的冗余来增强可用性。 当大多数节点都复制某条日志后，更新 commitIndex 并通知 Follower 提交。 负责更新集群配置（增删节点），并以安全方式提交对应日志条目。 4. Leader 选举流程 # Raft 的选举流程概括如下：\nFollower 超时 如果 Follower 超过选举超时时间没收到 Leader 心跳或日志复制消息，便会切换到 Candidate。\nCandidate 发起选举\ncurrentTerm++ voteFor = candidateID 重置选举计时器 向所有节点发送“请求投票”RPC，包含： $\\langle \\text{candidateTerm}, \\text{candidateId}, \\text{lastLogIndex}, \\text{lastLogTerm} \\rangle$ 节点响应投票 若以下条件满足，则投票给请求者：\n请求者任期号 \u0026gt;= 本节点任期号 本节点本任期尚未投过票 请求者日志不比自己旧（Term 更新或 Index 更大） 否则拒绝投票。\n完成选举\n若 Candidate 获得多数票 =\u0026gt; 成为 Leader。 若超时前没拿到多数票 =\u0026gt; 进入下一轮选举（Term 再增 1）。 若在此期间收到了来自更高任期 Leader 的消息 =\u0026gt; 退回 Follower。 Leader 初始化 成为 Leader 后：\n初始化 nextIndex[] = (Leader 的最新日志索引 + 1) 初始化 matchIndex[] = 0 立刻广播心跳，宣告自己上任。 5. 日志复制 (Log Replication) # 5.1 AppendEntries RPC # 这是 Raft 日志复制和心跳的核心 RPC。请求与响应的字段示意：\n请求： $ \\langle \\text{term}, \\text{leaderId}, \\text{prevLogIndex}, \\text{prevLogTerm}, \\text{entries[]}, \\text{leaderCommit} \\rangle$ entries[] 为空时，就起到心跳作用。 prevLogIndex 和 prevLogTerm 用来匹配 Follower 日志，若不一致则复制失败。 响应： $\\langle \\text{term}, \\text{success} \\rangle$ term：Follower 的当前任期（如比请求者更大，则请求者更新任期，退回 Follower）。 success：是否成功匹配并追加日志。 5.2 日志复制核心逻辑 # Leader 先写入本地日志：接到客户端写请求，先形成新日志条目 [index, term, command] 写到自己日志。 Leader 发送 AppendEntries：并行向所有 Follower 发送该新日志条目。 Follower 检查并匹配：若 prevLogIndex/prevLogTerm 不匹配，则返回 success = false，Leader 会回退并重试。 提交 (Commit)：当 Leader 发现大多数节点都复制了某条日志索引 N，就将 commitIndex 更新到 N，并在后续心跳中告知 Follower “可以提交到 N 了”，从而把日志应用到状态机。 5.3 重要保证：日志一致性 # Log Matching Property：相同索引、相同任期 =\u0026gt; 前面的日志均一致；确保不会出现相同位置却存不同命令的情况。 Leader Completeness Property：在任期 $t$ 被提交的日志，在之后任何任期里当选的 Leader 日志中必然存在这条日志；保证已经提交的日志不被丢弃或覆盖。 6. 安全性 (Safety) # 6.1 为什么 Raft 能够保证一致性 # 多数派机制：决策（如提交日志）需得到大多数节点同意，容忍少量故障。 任期机制：只相信来自更大任期的消息，避免跨任期日志冲突。 日志匹配：Follower 必须先匹配前一条日志，再能追加新日志，防止分叉。 6.2 Leader 崩溃与日志安全继承 # Leader 崩溃后，Follower 超时进入 Candidate，发起新任期选举。 若新的 Leader 当选，它的日志一定是集群中最“新”的（因投票规则需多数节点认同）；因此已提交的日志不会被丢弃。 那些未复制到大多数节点的日志可能会被新 Leader 覆盖，但这是正确的“安全行为”，因为这些日志尚未在集群中达成共识。 7. 实现要点与难点 # 7.1 选举超时 (Election Timeout) # 每个节点的选举超时在 [150ms, 300ms]（或更大范围）随机化。 这样能减少“同时发起选举”导致的冲突。 7.2 心跳间隔 (Heartbeat Interval) # Leader 需要定期（如 50~100ms）给 Follower 发心跳，重置它们的选举超时。 心跳也是空的 AppendEntries RPC，只是不附带任何日志条目。 7.3 日志冲突处理 # 遇到 Follower 日志与 Leader 不匹配时，需要回退到匹配位置。 Raft 提供了几种优化方案（如在日志中维护更丰富的索引信息），以减少反复重试的 RPC。 7.4 持久化 # Raft 节点需要持久化：currentTerm、voteFor、以及写入的日志。 每当任期或日志更新，都应先写入硬盘日志再返回成功，以便节点宕机重启后能恢复状态。 Raft 通常使用顺序写入日志 + 按需截断 + 快照等方式来提高硬盘写入性能。 7.5 状态机 # 已提交的日志会被应用到状态机中，由用户定义具体逻辑（例如键值存储、数据库操作等）。 Raft 保证日志顺序一致，但具体执行过程在状态机中进行。 7.6 集群配置变更 # 实际工程中常需要添加或移除节点。 Raft 使用“两阶段”配置变更机制：旧配置 -\u0026gt; 联合配置（包含新旧节点）-\u0026gt; 新配置，防止在配置过渡中出现多数派混乱。 8. Raft 正确性证明核心性质 # 8.1 分布式环境假设与安全性/活性 # Raft 假设了部分同步网络：即大多数时候网络是同步的（有稳定的最大延迟），但偶尔可能发生长延迟或分区。只要网络最终恢复到可通信状态，Raft 就能完成共识。 安全性 (Safety)：无论网络如何不稳定，都不会出现已提交的日志遭回退或两个节点在同一索引应用不同命令等冲突。 活性 (Liveness)：只要网络处于同步状态足够长时间，Raft 最终能选出一个 Leader 并持续提交新日志。若网络一直分区或消息丢失，再好的分布式算法也可能阻塞，这是著名的 FLP (Fischer–Lynch–Paterson) 不可解定理。 8.2 主要性质与整体思路 # Raft 依赖以下两大核心性质，来保证系统日志在节点之间保持一致且不会回退：\nLog Matching Property（日志匹配性质） “若在两个节点的某日志索引 $i$ 处，任期相同，则从开头到 $i$ 的整段日志都一致。” Leader Completeness Property（领导者完备性质） “若某条日志在任期 $t$ 已经被提交，则在之后任期的任何 Leader 的日志中，也必定包含该条日志。” 基于这两点，可以推导出状态机安全性 (State Machine Safety)：\n一旦某节点在索引 $i$ 处应用到命令 $cmd$，就不会再有节点在同一索引 $i$ 处应用到与 $cmd$ 不同的命令。\n8.3 日志匹配性质 (Log Matching Property) # 性质表述：如果在任意两个节点的某索引 $i$ 处的任期号相同，则两节点从 1 到 $i$ 的日志条目都完全相同（任期与命令都一致）。\n证明思路：Raft 的复制规则要求 Follower 先匹配 prevLogIndex \u0026amp; prevLogTerm 后才能追加新日志，否则返回失败并令 Leader 回退。所以只有当它们前面的日志完全一致时，才能写入同一个 (index, term)。由此归纳可知，相同位置、相同任期必然拥有相同的前序日志。 8.4 Leader 完备性质 (Leader Completeness Property) # 性质表述：若某条日志在任期 $t$ 上被提交（写到了大多数节点），则后续任何任期的合法 Leader 都一定包含这条日志。\n证明思路：日志被提交意味着一个多数派都写了它；新的 Leader 当选需要获得多数派投票；投票时每个节点会拒绝给日志“落后”它的候选者投票，因此能当选的候选者必然已包含所有已提交日志；由此推论，那条在任期 $t$ 提交的日志不会被“忘记”或覆盖。 8.5 选举安全 (Election Safety) # 命题：同一任期 $t$ 内不可能有两个不同节点都获得多数派投票从而成为 Leader。\n核心原因：在任期 $t$ 内，每个节点只能投 1 票，若一个候选者已得到多数票，就不可能再有另一个候选者也拿到多数票（因为多数派的节点已经投票给前者，不可能重复投票）。 8.6 已提交日志不可回退 (No Commit Overwritten) # 命题：若某条日志已被提交，则不会被覆盖为不同命令或被撤销。\n证明思路：只要日志已写在多数派，后续想要覆盖它，必须取得这些多数派节点投票并成功将日志写入。但多数派节点若发现候选者“缺失”这条日志，会拒绝投票或拒绝 AppendEntries 的匹配，故无法形成新的多数派来覆盖这条日志。 8.7 状态机安全性 (State Machine Safety) # 命题：如果节点 A 在索引 $i$ 处应用了命令 $cmd$，则不会有节点 B 在同一索引 $i$ 处应用不同的命令 $cmd' \\neq cmd$。\n证明思路：应用到状态机说明该日志已提交；提交意味着它已复制到多数派，后续新 Leader 也必然携带该日志；不可能再有并行的、冲突的日志写入同一个索引被大多数节点接受。 8.8 活性 (Liveness) # 在正常的部分同步网络中，一旦 Leader 稳定，客户端的请求会被源源不断提交。 若 Leader 崩溃或网络暂时分区，也会在恢复后启动选举，最终选出新 Leader。 在完全异步或永远分区的情况下，所有分布式一致性协议都无法保证必然的活性（FLP 定理），但只要网络“偶尔稳定”，Raft 就能继续前行。 综上所述，Raft 在设计上兼顾了易理解、易实现与强一致性 三大目标，通过任期、选举、日志复制、以及多数派机制，确保了分布式系统中对数据的线性一致(Linearizable) 语义。其核心安全性可归结为：\n不会同时出现两个合法的 Leader。 已提交的日志永不回退。 已提交的日志在新的 Leader 身上依旧保留。 保证同一个 (index, term) 位置不会在不同节点上出现不同命令。 保证已经在某任期提交的日志不会在后续 Leader 上消失。 9. 从零实现一个最简 Raft：关键步骤 # 定义数据结构 currentTerm、voteFor、log[]、commitIndex、lastApplied 等 节点角色 (Follower/Candidate/Leader) 定时器、RPC 通道等 持久化层 将任期、投票、日志等关键数据写盘或存于 RocksDB 等存储引擎 重启时先从存储中加载 RPC 通信层 实现 RequestVote 和 AppendEntries 两类 RPC 处理网络异常、超时重试 事件循环 \u0026amp; 定时器 定期检查是否收到 Leader 心跳 若超时则发起选举 若是 Leader，则定期发心跳 处理网络 RPC 并更新本地状态 Leader 选举 Follower 超时 -\u0026gt; Candidate 发起投票 -\u0026gt; 若获得多数 -\u0026gt; Leader 若失败或遇到更高任期 Leader -\u0026gt; 回到 Follower 日志复制 Leader 收到新命令 -\u0026gt; 写本地日志 -\u0026gt; AppendEntries 给 Follower 大多数节点复制 -\u0026gt; Leader 提交并通知 Follower 提交 故障恢复 节点重启后先从存储中恢复状态 Leader 或网络故障后，会通过选举超时机制继续选举新的 Leader 测试与验证 模拟网络延迟、分区、节点故障等，检查 Raft 是否能正确保持一致性和对外可用性 代码样例 # 1using System; 2using System.Collections.Generic; 3using System.Linq; 4using System.Threading; 5using System.Threading.Tasks; 6 7// 这个代码示例关注 Raft 算法的核心选举逻辑，省略了网络通信和持久化等细节。 8namespace RaftDemo 9{ 10 #region 数据结构 11 12 public enum NodeRole 13 { 14 Follower, 15 Candidate, 16 Leader 17 } 18 19 public class LogEntry 20 { 21 public int Index { get; set; } 22 public int Term { get; set; } 23 public string Command { get; set; } 24 } 25 26 public class RequestVoteRequest 27 { 28 public int Term { get; set; } 29 public string CandidateId { get; set; } 30 public int LastLogIndex { get; set; } 31 public int LastLogTerm { get; set; } 32 } 33 34 public class RequestVoteResponse 35 { 36 public int Term { get; set; } 37 public bool VoteGranted { get; set; } 38 } 39 40 public class AppendEntriesRequest 41 { 42 public int Term { get; set; } 43 public string LeaderId { get; set; } 44 public int PrevLogIndex { get; set; } 45 public int PrevLogTerm { get; set; } 46 public List\u0026lt;LogEntry\u0026gt; Entries { get; set; } = new List\u0026lt;LogEntry\u0026gt;(); 47 public int LeaderCommit { get; set; } 48 } 49 50 public class AppendEntriesResponse 51 { 52 public int Term { get; set; } 53 public bool Success { get; set; } 54 // 为简化，不在这里携带更多回退信息；如果携带更多信息，可以更快回退 nextIndex 来寻找匹配位置，减少网络交互次数。 55 } 56 57 public interface IRaftRpc 58 { 59 RequestVoteResponse RequestVote(RequestVoteRequest request); 60 AppendEntriesResponse AppendEntries(AppendEntriesRequest request); 61 } 62 63 #endregion 64 65 #region RaftNode 核心类 66 67 public class RaftNode : IRaftRpc 68 { 69 private readonly string _nodeId; 70 private readonly InMemoryDispatcher _dispatcher; 71 private readonly Random _rand = new Random(); 72 73 private NodeRole _role = NodeRole.Follower; 74 private int _currentTerm = 0; 75 private string _votedFor = null; 76 77 private List\u0026lt;LogEntry\u0026gt; _log = new List\u0026lt;LogEntry\u0026gt;(); 78 private int _commitIndex = 0; 79 private int _lastApplied = 0; 80 81 // 仅 Leader 需要维护 82 private Dictionary\u0026lt;string, int\u0026gt; _nextIndex = new Dictionary\u0026lt;string, int\u0026gt;(); 83 private Dictionary\u0026lt;string, int\u0026gt; _matchIndex = new Dictionary\u0026lt;string, int\u0026gt;(); 84 85 private CancellationTokenSource _cts; 86 private Task _timerTask; 87 88 // Demo 中的状态机用一个简单的列表记录命令 89 private List\u0026lt;string\u0026gt; _stateMachine = new List\u0026lt;string\u0026gt;(); 90 91 public RaftNode(string nodeId, InMemoryDispatcher dispatcher) 92 { 93 _nodeId = nodeId; 94 _dispatcher = dispatcher; 95 } 96 97 public void Start() 98 { 99 _dispatcher.RegisterNode(_nodeId, this); 100 ResetTimer(); 101 } 102 103 public void Stop() 104 { 105 _cts?.Cancel(); 106 } 107 108 // 用于测试，从外部输入命令 109 public void SendClientCommand(string command) 110 { 111 if (_role != NodeRole.Leader) 112 { 113 Console.WriteLine($\u0026#34;[{_nodeId}] I\u0026#39;m not leader, ignoring client command.\u0026#34;); 114 return; 115 } 116 117 // 1. 将命令追加到本地日志 118 var newLogIndex = LastLogIndex() + 1; 119 _log.Add(new LogEntry 120 { 121 Index = newLogIndex, 122 Term = _currentTerm, 123 Command = command 124 }); 125 126 Console.WriteLine($\u0026#34;[{_nodeId}] Leader received client command \u0026#39;{command}\u0026#39;, logIndex={newLogIndex}.\u0026#34;); 127 128 // 2. 异步向其他节点发送 AppendEntries 129 BroadcastAppendEntries(); 130 } 131 132 #region 核心RPC实现 133 134 public RequestVoteResponse RequestVote(RequestVoteRequest request) 135 { 136 lock (this) 137 { 138 // 如果请求中的Term比本地大，更新本地Term并变成Follower 139 if (request.Term \u0026gt; _currentTerm) 140 { 141 _currentTerm = request.Term; 142 _role = NodeRole.Follower; 143 _votedFor = null; 144 } 145 146 var response = new RequestVoteResponse 147 { 148 Term = _currentTerm, 149 VoteGranted = false 150 }; 151 152 // 如果请求的任期 \u0026lt; 本地任期，则拒绝 153 if (request.Term \u0026lt; _currentTerm) 154 { 155 return response; 156 } 157 158 // 检查是否已经投票给其它候选人，或者日志是否足够新 159 var myLastLogIndex = LastLogIndex(); 160 var myLastLogTerm = LastLogTerm(); 161 162 bool logIsAtLeastUpToDate = 163 (request.LastLogTerm \u0026gt; myLastLogTerm) || 164 (request.LastLogTerm == myLastLogTerm \u0026amp;\u0026amp; request.LastLogIndex \u0026gt;= myLastLogIndex); 165 166 if ((_votedFor == null || _votedFor == request.CandidateId) \u0026amp;\u0026amp; logIsAtLeastUpToDate) 167 { 168 _votedFor = request.CandidateId; 169 response.VoteGranted = true; 170 // 重置选举超时 171 ResetTimer(); 172 } 173 174 return response; 175 } 176 } 177 178 public AppendEntriesResponse AppendEntries(AppendEntriesRequest request) 179 { 180 lock (this) 181 { 182 var response = new AppendEntriesResponse 183 { 184 Term = _currentTerm, 185 Success = false 186 }; 187 188 // 如果Term \u0026lt; 本地Term, 直接拒绝 189 if (request.Term \u0026lt; _currentTerm) 190 { 191 return response; 192 } 193 194 // 如果Term比本地大，更新Term并转为Follower 195 if (request.Term \u0026gt; _currentTerm) 196 { 197 _currentTerm = request.Term; 198 _role = NodeRole.Follower; 199 _votedFor = null; 200 } 201 202 // 收到来自 Leader 的心跳/日志复制, 重置选举超时 203 ResetTimer(); 204 205 // 由于简化，这里只做基本检查： 206 // 检查本地日志在 prevLogIndex 的Term 是否匹配 207 if (request.PrevLogIndex \u0026gt; 0) 208 { 209 if (request.PrevLogIndex \u0026gt; _log.Count) 210 { 211 // 不匹配 (本地日志比Leader提供的还短) 212 return response; 213 } 214 else 215 { 216 var localTerm = _log[request.PrevLogIndex - 1].Term; 217 if (localTerm != request.PrevLogTerm) 218 { 219 // 不匹配 (任期冲突) 220 return response; 221 } 222 } 223 } 224 225 // 如果匹配则继续：先覆盖本地冲突日志 226 foreach (var entry in request.Entries) 227 { 228 if (entry.Index \u0026lt;= _log.Count) 229 { 230 // 存在冲突或相同Index日志，覆盖掉 231 if (_log[entry.Index - 1].Term != entry.Term) 232 { 233 _log[entry.Index - 1] = entry; 234 Console.WriteLine($\u0026#34;[{_nodeId}] Overwritten log at index {entry.Index} with term {entry.Term}.\u0026#34;); 235 } 236 } 237 else 238 { 239 _log.Add(entry); 240 Console.WriteLine($\u0026#34;[{_nodeId}] Appended log at index {entry.Index} with term {entry.Term}.\u0026#34;); 241 } 242 } 243 244 // 更新commitIndex 245 if (request.LeaderCommit \u0026gt; _commitIndex) 246 { 247 _commitIndex = Math.Min(request.LeaderCommit, _log.Count); 248 ApplyStateMachine(); 249 } 250 251 response.Success = true; 252 response.Term = _currentTerm; 253 return response; 254 } 255 } 256 257 #endregion 258 259 #region 选举与心跳定时器 260 261 private void ResetTimer() 262 { 263 _cts?.Cancel(); 264 _cts = new CancellationTokenSource(); 265 _timerTask = RunTimer(_cts.Token); 266 } 267 268 private async Task RunTimer(CancellationToken token) 269 { 270 // 在实际生产环境中，选举超时一般设置为150~300ms左右， 271 // 这里为了演示效果加长到了1.5~3秒，方便我们在Console中观察到日志输出。 272 var electionTimeout = _rand.Next(1500, 3000); // 1.5~3s 之间随机 273 var heartbeatInterval = 500; // Leader 心跳间隔 0.5s 274 275 var start = DateTime.UtcNow; 276 while (!token.IsCancellationRequested) 277 { 278 await Task.Delay(100, token); 279 var elapsed = (DateTime.UtcNow - start).TotalMilliseconds; 280 281 if (_role == NodeRole.Leader) 282 { 283 // Leader 周期性发送心跳 284 if (elapsed \u0026gt;= heartbeatInterval) 285 { 286 BroadcastAppendEntries(); 287 start = DateTime.UtcNow; 288 } 289 } 290 else 291 { 292 // Follower or Candidate，需要判断是否触发选举 293 if (elapsed \u0026gt;= electionTimeout) 294 { 295 BecomeCandidate(); 296 start = DateTime.UtcNow; 297 } 298 } 299 } 300 } 301 302 private void BecomeCandidate() 303 { 304 lock (this) 305 { 306 _role = NodeRole.Candidate; 307 _currentTerm++; 308 _votedFor = _nodeId; 309 310 Console.WriteLine($\u0026#34;[{_nodeId}] Timeout -\u0026gt; Candidate. term={_currentTerm}\u0026#34;); 311 312 // 重置选举超时 313 ResetTimer(); 314 } 315 316 // 发起投票 317 var request = new RequestVoteRequest 318 { 319 Term = _currentTerm, 320 CandidateId = _nodeId, 321 LastLogIndex = LastLogIndex(), 322 LastLogTerm = LastLogTerm() 323 }; 324 325 var votesGranted = 1; // 自己投自己 326 var totalNodes = _dispatcher.GetAllNodes().Count; 327 var majority = totalNodes / 2 + 1; 328 329 foreach (var otherId in _dispatcher.GetAllNodes().Where(id =\u0026gt; id != _nodeId)) 330 { 331 Task.Run(() =\u0026gt; 332 { 333 var resp = _dispatcher.SendRequestVote(otherId, request); 334 if (resp != null) 335 { 336 lock (this) 337 { 338 // 如果对方term更大，转为Follower 339 if (resp.Term \u0026gt; _currentTerm) 340 { 341 _currentTerm = resp.Term; 342 _role = NodeRole.Follower; 343 _votedFor = null; 344 return; 345 } 346 347 if (resp.VoteGranted \u0026amp;\u0026amp; _role == NodeRole.Candidate \u0026amp;\u0026amp; resp.Term == _currentTerm) 348 { 349 votesGranted++; 350 if (votesGranted \u0026gt;= majority) 351 { 352 BecomeLeader(); 353 } 354 } 355 } 356 } 357 }); 358 } 359 } 360 361 private void BecomeLeader() 362 { 363 if (_role != NodeRole.Candidate) return; 364 365 _role = NodeRole.Leader; 366 Console.WriteLine($\u0026#34;[{_nodeId}] Became Leader at term {_currentTerm}!\u0026#34;); 367 368 // 初始化 nextIndex, matchIndex 369 foreach (var node in _dispatcher.GetAllNodes()) 370 { 371 if (node == _nodeId) continue; 372 _nextIndex[node] = LastLogIndex() + 1; 373 _matchIndex[node] = 0; 374 } 375 376 // 立即发送一次心跳 377 BroadcastAppendEntries(); 378 } 379 380 private void BroadcastAppendEntries() 381 { 382 lock (this) 383 { 384 if (_role != NodeRole.Leader) return; 385 386 foreach (var otherId in _dispatcher.GetAllNodes().Where(id =\u0026gt; id != _nodeId)) 387 { 388 var prevLogIndex = _nextIndex[otherId] - 1; 389 var prevLogTerm = (prevLogIndex \u0026gt; 0 \u0026amp;\u0026amp; prevLogIndex \u0026lt;= _log.Count) 390 ? _log[prevLogIndex - 1].Term : 0; 391 392 // 这里简化，每次只发送一段有限的日志 393 // 可以根据实际需求发送更多 394 var entriesToSend = new List\u0026lt;LogEntry\u0026gt;(); 395 if (prevLogIndex \u0026lt; _log.Count) 396 { 397 entriesToSend = _log.Skip(prevLogIndex).ToList(); 398 } 399 400 var request = new AppendEntriesRequest 401 { 402 Term = _currentTerm, 403 LeaderId = _nodeId, 404 PrevLogIndex = prevLogIndex, 405 PrevLogTerm = prevLogTerm, 406 Entries = entriesToSend, 407 LeaderCommit = _commitIndex 408 }; 409 410 Task.Run(() =\u0026gt; 411 { 412 var resp = _dispatcher.SendAppendEntries(otherId, request); 413 if (resp != null) 414 { 415 lock (this) 416 { 417 if (resp.Term \u0026gt; _currentTerm) 418 { 419 _currentTerm = resp.Term; 420 _role = NodeRole.Follower; 421 _votedFor = null; 422 return; 423 } 424 425 if (resp.Success) 426 { 427 // 说明对方已经匹配了 prevLogIndex 428 // 更新 nextIndex \u0026amp; matchIndex 429 var lastEntry = entriesToSend.LastOrDefault(); 430 if (lastEntry != null) 431 { 432 _matchIndex[otherId] = lastEntry.Index; 433 _nextIndex[otherId] = lastEntry.Index + 1; 434 } 435 436 // 更新 commitIndex 437 UpdateCommitIndex(); 438 } 439 else 440 { 441 // 回退 nextIndex 重试 (这里是最简单的回退策略) 442 _nextIndex[otherId] = Math.Max(1, _nextIndex[otherId] - 1); 443 } 444 } 445 } 446 }); 447 } 448 } 449 } 450 451 private void UpdateCommitIndex() 452 { 453 // Leader 根据 matchIndex 更新 commitIndex 454 // 找到一个N，使得N大于当前commitIndex，并且有半数以上的matchIndex \u0026gt;= N, 并且_raftLog[N].Term == currentTerm 455 for (int i = _log.Count; i \u0026gt; _commitIndex; i--) 456 { 457 var count = _matchIndex.Values.Count(m =\u0026gt; m \u0026gt;= i) + 1; // +1 包含自己 458 if (count \u0026gt;= (_dispatcher.GetAllNodes().Count / 2 + 1) \u0026amp;\u0026amp; _log[i - 1].Term == _currentTerm) 459 { 460 _commitIndex = i; 461 ApplyStateMachine(); 462 break; 463 } 464 } 465 } 466 467 private void ApplyStateMachine() 468 { 469 // 将 [lastApplied+1 ... commitIndex] 的日志应用到状态机 470 while (_lastApplied \u0026lt; _commitIndex) 471 { 472 _lastApplied++; 473 var cmd = _log[_lastApplied - 1].Command; 474 _stateMachine.Add(cmd); 475 Console.WriteLine($\u0026#34;[{_nodeId}] Apply LogIndex={_lastApplied}, Cmd={cmd}\u0026#34;); 476 } 477 } 478 479 #endregion 480 481 #region 帮助方法 482 483 private int LastLogIndex() 484 { 485 return _log.Count; 486 } 487 488 private int LastLogTerm() 489 { 490 if (_log.Count == 0) return 0; 491 return _log[_log.Count - 1].Term; 492 } 493 494 public NodeRole Role =\u0026gt; _role; 495 public int CurrentTerm =\u0026gt; _currentTerm; 496 public List\u0026lt;string\u0026gt; StateMachine =\u0026gt; _stateMachine; 497 498 #endregion 499 } 500 501 #endregion 502 503 #region 简易“RPC调度器”模拟网络 504 505 public class InMemoryDispatcher 506 { 507 private Dictionary\u0026lt;string, IRaftRpc\u0026gt; _nodes = new Dictionary\u0026lt;string, IRaftRpc\u0026gt;(); 508 509 public void RegisterNode(string nodeId, IRaftRpc node) 510 { 511 _nodes[nodeId] = node; 512 } 513 514 public List\u0026lt;string\u0026gt; GetAllNodes() =\u0026gt; _nodes.Keys.ToList(); 515 516 public RequestVoteResponse SendRequestVote(string targetNodeId, RequestVoteRequest request) 517 { 518 if (!_nodes.ContainsKey(targetNodeId)) return null; 519 return _nodes[targetNodeId].RequestVote(request); 520 } 521 522 public AppendEntriesResponse SendAppendEntries(string targetNodeId, AppendEntriesRequest request) 523 { 524 if (!_nodes.ContainsKey(targetNodeId)) return null; 525 return _nodes[targetNodeId].AppendEntries(request); 526 } 527 } 528 529 #endregion 530 531 #region Program Demo 532 533 class Program 534 { 535 static void Main(string[] args) 536 { 537 var dispatcher = new InMemoryDispatcher(); 538 539 var node1 = new RaftNode(\u0026#34;Node1\u0026#34;, dispatcher); 540 var node2 = new RaftNode(\u0026#34;Node2\u0026#34;, dispatcher); 541 var node3 = new RaftNode(\u0026#34;Node3\u0026#34;, dispatcher); 542 543 node1.Start(); 544 node2.Start(); 545 node3.Start(); 546 547 Console.WriteLine(\u0026#34;Raft cluster started with 3 nodes (Node1, Node2, Node3).\u0026#34;); 548 Console.WriteLine(\u0026#34;Wait a few seconds to see leader election...\u0026#34;); 549 550 // 等待几秒，让选举完成 551 Task.Delay(5000).Wait(); 552 553 // 尝试发送命令给节点1, 如果它是Leader则执行，否则会提示自己不是Leader 554 node1.SendClientCommand(\u0026#34;SET X=100\u0026#34;); 555 556 Task.Delay(3000).Wait(); 557 558 // 停止节点2, 模拟节点宕机 559 Console.WriteLine(\u0026#34;\\n** Stopping Node2 to simulate crash **\\n\u0026#34;); 560 node2.Stop(); 561 562 // 等待一段时间后，再发命令 563 Task.Delay(5000).Wait(); 564 node1.SendClientCommand(\u0026#34;SET Y=200\u0026#34;); 565 566 // 再等等，让日志复制结束 567 Task.Delay(5000).Wait(); 568 569 // 打印一下每个节点已应用到状态机的数据 570 Console.WriteLine($\u0026#34;\\nNode1 state: {string.Join(\u0026#34;, \u0026#34;, node1.StateMachine)}\u0026#34;); 571 Console.WriteLine($\u0026#34;\\nNode2 state: {string.Join(\u0026#34;, \u0026#34;, node2.StateMachine)} (Should not receive new logs after crash)\u0026#34;); 572 Console.WriteLine($\u0026#34;\\nNode3 state: {string.Join(\u0026#34;, \u0026#34;, node3.StateMachine)}\u0026#34;); 573 574 // 结束 575 node1.Stop(); 576 node2.Stop(); 577 node3.Stop(); 578 579 Console.WriteLine(\u0026#34;\\nDemo finished. Press any key to exit.\u0026#34;); 580 Console.ReadKey(); 581 } 582 } 583 584 #endregion 585} ","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/posts/1735548655536-raft-intro/","section":"Posts","summary":"详细讨论 Raft 算法的最简实现细节，代码示例，以及正确性证明。","title":"Raft 算法详解","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分布式一致性算法","type":"tags"},{"content":"","date":"2024年12月30日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":" 一、CAP 定理 # 1.1 什么是 CAP 定理 # CAP 定理 由 Eric Brewer 于 2000 年提出，其核心观点是：在分布式系统的设计中，一致性（C）、可用性（A） 和 **分区容错性（P） ** 三者最多只能同时满足两项。\nC（Consistency，一致性）：系统中的所有节点在同一时刻看到的数据都是相同的。更严格地说，当客户端读取数据时，无论从哪个副本读取，结果都应当与最新提交的数据保持一致（通常指强一致性/线性一致性）。 A（Availability，可用性）：系统在出现部分故障时仍然可以对外提供正常服务，每个请求都能在合理时间内得到有效响应。 P（Partition tolerance，分区容错性）：系统可以容忍网络分区（节点间通信出现不可达），即使网络发生分裂，系统也能提供一定程度的可用性或一致性。 在真实分布式环境中，网络分区不可避免，所以 P 基本被视为“必选项”。当网络分区发生时，系统无法同时兼顾所有节点对数据的* 强一致性与高可用性*，只能在 C 和 A 中做取舍，于是衍生出 CP 和 AP 两大主要类型。\n1.2 CAP 定理的局限性 # 需要指出的是，CAP 定理本身是一个相对高层次的理论，应用于概念指导，不能简单理解为“要么选 C，要么选 A”。存在一些常见的误解：\nC 并不必然是强一致性 CAP 定理中的 C 往往指的是最严格意义上的一致性（即线性一致性）。但在实际系统中，我们还有弱一致性、读已提交（Read Committed）、因果一致性（Causal Consistency）等很多细粒度模型可以选择。 可用性并非 0 或 1 并非说选了 CP，就意味着可用性完全被牺牲；或选了 AP，就意味着一致性毫无保障。可用性和一致性都有不同程度的权衡空间和降级策略。 最终一致性不违背 CAP 它是一个非常常见的折衷方案，用较低的写一致性换取更高的可用性和吞吐量，并通过异步方式在后台收敛数据。 因此，CAP 定理应和各种 一致性模型、高可用架构模式 结合到具体场景里，才能产生真正的落地指导价值。\n二、分布式系统的一致性模型 # 一致性模型的分类十分丰富，但常见的主流模型大致可以分为：强一致性 和 弱一致性（其中包含最终一致性、因果一致性等）。本文主要介绍 强一致性 与 最终一致性，并说明它们在 CP 或 AP 模式下的常见应用。\n2.1 强一致性 # 强一致性（Strong Consistency） 又称 线性一致性（Linearizability） ，指的是一旦一次写操作完成返回成功，任何后续的读取操作都能读到该更新内容。也就是说，系统对外表现得像是串行执行了所有操作。\n常见实现：依赖同步复制和一个仲裁（多数派）机制，通过协议（如 Paxos/Raft）来确保系统中只有一个有效的领导者（Leader），所有操作按顺序写入日志并复制到多数节点。 优缺点： 优点：保证最严格的数据正确性，任何时候读到的数据都不发生“回退”。 缺点：在网络抖动、分区或领导者故障时，为了维持一致性往往会阻塞写操作，导致整体可用性下降；性能和吞吐量也相对更低。 2.2 最终一致性 # 最终一致性（Eventual Consistency） 是弱一致性的一种典型形式，它只要求如果系统不再有新的更新操作，随着时间的推移，所有副本的数据会逐渐收敛到同一个状态。期间用户读取副本数据，可能会看到过时的值，但最终会变得一致。\n常见实现：Gossip 协议、多副本异步复制、CRDT（Conflict-free Replicated Data Type）等。 优缺点： 优点：高可用、高吞吐量，写操作延迟较低，对网络分区的容忍度高。 缺点：需要容忍短时间的数据不一致，应用逻辑更复杂，可能要进行冲突检测与合并。 三、常见一致性协议与算法 # 为了让分布式系统副本之间保持一致，业界提出了诸多经典算法与协议。以下简要介绍几种：\n3.1 Paxos # Paxos 是由 Leslie Lamport 在 1990 年代提出的分布式一致性算法，主要用于实现强一致性或线性一致性。\n基本原理：通过角色划分（提案者 Proposer、接受者 Acceptor、学习者 Learner）进行多轮投票，来决定一次操作或值是否被多数节点接受。 优缺点： 优点：能在网络分区、节点故障下依旧达成一致，具备很高的安全性。 缺点：实现复杂，调试和排错难度高，多轮投票导致性能受限。工业界多用其变体（Multi-Paxos 等）。 3.2 Raft # Raft 于 2013 年正式提出，目标是在保证与 Paxos 同等安全性的前提下，简化实现和理解难度。它通过建立一个稳定的 * 领导者（Leader）* 角色，集中式地进行日志复制和故障恢复：\n关键阶段：领导选举（Leader Election）、日志复制（Log Replication）、安全性（Safety）等。 常见应用：Etcd、Consul、TiKV、LogCabin 等都基于 Raft 来实现强一致复制。 优缺点： 优点：相对易懂、实现代码量更少；对中小规模集群性能较好。 缺点：依赖主节点（Leader），主节点故障或分区会造成短暂的写阻塞；在大规模集群或跨地域部署时，延迟和可用性会受到影响。 3.3 Gossip 协议 # Gossip（八卦）协议并非传统的共识协议，主要用于在去中心化的场景下通过节点随机交互来交换元数据或状态信息，从而在全网进行扩散与收敛。\n特点：去中心化、低开销、节点间周期性且随机地交换消息。 常见应用：Cassandra、Riak、分布式成员管理（如 Serf）等，用于实现最终一致性、副本状态同步等。 优缺点： 优点：扩展性佳，简单易实现，适合对一致性要求不高、对可扩展性要求高的场景。 缺点：一致性保证较弱，需要更高级别的冲突处理手段（如 CRDT、版本号合并等）来最终解决冲突。 3.4 2PC / 3PC # 在分布式事务场景下，常见的提交协议是 2PC（Two-phase Commit） 和 3PC（Three-phase Commit）：\n2PC：协调者通知所有参与者“预提交（prepare）”，若都成功则广播“提交（commit）”，否则“回滚（abort）”。 3PC：在 2PC 基础上增加一个阶段，降低单点故障带来的阻塞，但实现更复杂，仍然存在极端网络分区或故障场景下的不可用问题。 优缺点： 优点：容易理解，事务语义清晰，在分布式数据库、消息队列等广泛应用。 缺点：对协调者依赖性强，有阻塞风险；在网络出现较长时间分区时可能无法继续推进事务。 四、CAP 的两大主流选择：CP 与 AP # 当我们认定 P 是“必选”的属性之后，分布式系统若想在网络分区时继续提供服务，就要在 C 和 A 之间做抉择。常见的系统设计因此分化为 CP 和 AP 两大阵营。\n4.1 CP 系统 # CP（Consistency + Partition tolerance）：遇到网络分区时，系统会选择 优先保证一致性，在必要时牺牲可用性。\n典型实现： 多数派共识（Paxos、Raft 等），需要过半节点存活并达成一致才允许写入。 若当前无法达成 quorum（法定人数）或主节点故障，系统会阻塞或拒绝写操作，以防止脑裂导致数据不一致。 常见应用： Zookeeper、Etcd、Consul、分布式锁服务、分布式元数据管理等。 金融交易核心流程、银行账务系统等高一致性要求的场景。 特点： 拥有严格的数据保证：宁可停机也不出现双主或数据混乱。 牺牲一定的可用性：在发生网络分区或故障切换时，会有一段服务不可用或拒绝写操作的窗口。 4.2 AP 系统 # AP（Availability + Partition tolerance）：遇到网络分区时，系统会选择 优先保证可用性，同时放宽一致性。\n典型实现： 最终一致性、多主复制、Gossip 协议、Dynamo 风格可调一致性策略等。 常见应用： NoSQL 数据库（Cassandra、Riak、DynamoDB 等），分布式缓存系统（Redis Cluster）等。 社交网络、日志采集、推荐系统等需要高可用、高吞吐，对数据一致性要求相对宽松的业务。 特点： 即使分区，所有节点依旧接收读写请求，保证系统“尽可能可用”。 数据可能存在短暂不一致，但会通过异步同步、冲突合并等方式在后台逐步收敛。 五、如何在 CP 与 AP 中取舍？ # 在真实的大规模分布式系统中，往往很少只依赖单一模型，而是对不同数据或业务场景进行分层处理，以求 一致性 与 可用性 的最优平衡。\n核心数据选 CP 如用户账户余额、订单支付、金融交易流水等，对一致性要求极高。 容忍网络抖动导致的短暂不可写，但不能容忍余额或交易金额的错误。 边缘或缓存数据选 AP 如商品详情页的缓存、用户行为日志、推荐候选列表等，对一致性要求较低。 更看重高并发、高可用，能够容忍一定时间的延迟更新或脏读。 许多互联网企业会采用混合架构：核心交易流程使用 CP 式存储（如分布式关系型数据库或带强一致性的分布式存储）；外围业务或“读多写少”的场景使用 AP 式存储或缓存方案。\n六、CP 与 AP 如何实现高并发与最终一致性 # 6.1 CP 系统如何应对高并发 # 虽然共识协议在单一集群节点规模和写请求量大时，会面临较高的延迟和较低的吞吐，但依然可以通过以下手段提升并发和可扩展性：\n批量读写 将多个写操作在客户端或中间层打包，一次性在领导者节点上写入，减少网络往返和协议轮次。 分库分表 \u0026amp; 多群集 将数据按逻辑或哈希切分到多个群集（sharding），每个群集内部仍然运行 CP 协议；请求通过路由或代理层分散到不同分片。 提升整体并发能力，并将故障影响限制在单个分片范围内。 CP 系统的单分片集群吞吐量往往比 AP 系统低 2 到 10 倍。\n6.2 AP 系统如何保证最终一致性 # AP 系统通常能够提供很高的写吞吐和读取可用性，但对一致性放松，因而需要在后台或业务逻辑层实现一致性收敛的保障：\n版本号（Vector Clock）或逻辑时间戳 给每个更新操作分配一个版本号（或基于 Lamport Clock / Hybrid Clock），在冲突场景下进行合并或基于时间戳的胜出策略（Last Write Wins）。 Gossip 协议 / 反熵（Anti-entropy）机制 节点周期性地交换最新数据或元数据，发现冲突则进行合并。 可调一致性策略 以 Dynamo 模型为代表，客户端可配置 R、W 等参数（如写入多数派、副本确认），从而在一致性和可用性之间弹性调节。 自定义冲突解决策略 结合业务语义进行合并，如购物车用“并集”合并，计数器用 CRDT（G-counter、PN-counter 等）保证数据的单调性。 七、CP 的跨分片强一致性实现 # 在第七章中提到，通过分库分表（Sharding） 可以让单个 CP 集群的压力“拆分”到多个子集群，以支撑更高并发。然而，当业务需要跨分片执行事务（即涉及多个分库或分表的更新）时，仍面临 多分片一致性 的挑战。通常有以下思路：\n分布式事务：2PC / 3PC 若应用需要跨多个分片进行原子性更新，通常使用分布式事务协议（如 2PC、3PC）来协调各分片的提交或回滚。 问题与对策： 2PC/3PC 都依赖一个协调者节点，可能成为单点瓶颈。 在网络分区严重或协调者故障的极端情形下，可能出现阻塞。 一般会通过主从切换、心跳检测和超时机制、幂等重试、MVCC 等来降低阻塞影响和数据不一致风险。 单元化（Cell-based）架构 将业务切分为多个自治单元，每个单元内的数据都在同一个分片集合中，保证大多数事务都只在单一单元中完成，减少跨分片操作。 在单元边界上采用异步或最终一致性机制进行数据交换，兼顾整体的高可用与一致性。 全球分布式数据库 + 全局共识协议 例如 Google Spanner 在每个分片（Shard）上通过 Paxos 实现副本强一致复制，再利用 TrueTime API 提供全局时间戳保障跨分片一致性。 这种方案实现复杂度极高，但能在全局范围内提供接近强一致的分布式事务能力。 小结：对于严格要求强一致性的跨分片事务，2PC/3PC + 协调者 仍是常见方案，并通过尽可能提高协调者的高可用，来降低故障的可能性。但需在工程实践中尽量减少跨分片写操作，或通过单元化思路将大部分事务限制在单一分片范围，降低系统复杂度。\n八、著名案例讨论 # 下面简要探讨几款在业界常被提及的分布式系统，看看它们在 CAP 上的取舍与实现方式：\nGoogle BigTable 倾向于 CP 的 NoSQL 数据库，在 RegionServer 与 Master 之间通过分布式协调保证元数据的一致性，默认提供了单行事务强一致性保证。 读一致性可根据应用需求调整。 Google Spanner 非常强大的 CP 系统（甚至能做到外界常说的 “CA” 幻觉，但实质仍需牺牲一部分可用性）。 比 BigTable 更进一步， 提供了全球范围内的分布式 SQL 事务和外部一致性保障，支持 ACID 事务以及跨全球数据中心的读写操作。 利用 TrueTime 提供的高精度外部时间戳，确保跨数据中心的事务顺序和外部时间一致性。 在每个分片内部采用 Paxos 协议进行数据复制，保证数据的强一致性和高可用性。 采用高可用的两阶段提交（2PC）协议来实现全局事务的可靠提交，确保跨分片操作的一致性。 适合全球金融交易或其他对一致性要求极高的应用场景，但基础设施成本较高。 AWS DynamoDB 倾向于 AP的 NoSQL 数据库，提供极高可用性和最终一致性。 默认提供弱一致性读取，但可通过 ConsistentRead 参数来获取强一致性读取。 提供 DynamoDB Transaction，支持 ACID 事务，但是性能会有所下降，并且只支持同区域数据中心内的事务。 Cassandra 同样是 AP 倾向，底层采用 Gossip 协议维护节点拓扑状态。 可通过 R、W 等参数调节一致性等级，当 R + W \u0026gt; N 时保证单行读写强一致性。 支持 Lightweight Transactions（LWT），提供单行 ACID 事务保证。 对比可见：工程上不存在绝对的“AP 或 CP”，更多是多种一致性策略的混合；大部分系统都提供一定程度的可调一致性来适配不同应用场景。\n九、总结 # CAP 定理不是一刀切 真实的分布式系统无法简单地说“我选 C，放弃 A”或“我选 A，放弃 C”。 业界更常见的是针对不同的数据维度、不同的操作类型，灵活地选择 CP 或 AP 模式，甚至在同一个系统内部，对不同表/不同功能采用不同的容错与一致性策略。 AP 并非绝对 100% 可用 例如，Cassandra、DynamoDB 等在极端网络分区或节点大面积失效时，同样会出现无法满足请求的情况。 AP 系统只是设计上倾向“只要副本可写就先写”，牺牲了一部分一致性保证来换取相对更高的可用性与吞吐量。 CP 也可以尽量做到高可用 Paxos/Raft 在正常情况下也能提供 99.99% 甚至更高的可用性，只是需要投入更多的网络、硬件和工程成本，且在极端网络分区时仍会出现阻塞写、牺牲可用性来维持一致。 混合架构是主流 核心交易场景坚持强一致（CP），外围辅助场景或缓存通道采用弱一致（AP），两者相互配合。 要结合业务容忍度、网络环境、成本投入、团队技术储备来综合取舍。 CAP 定理为分布式系统的设计提供了一个高层次的思维框架，帮助我们在网络分区这一不可避免的现实面前做出理性决策。在实际系统中，则需要借助更丰富的 一致性模型、共识协议、多副本复制机制 以及工程实践（容灾、降级、幂等、冲突合并等）来平衡一致性与可用性。\n","date":"2024年12月28日","externalUrl":null,"permalink":"/zh-cn/posts/1735350760948-cap/","section":"Posts","summary":"从理论到实践讨论 CAP 定理在分布式系统中的应用。","title":"深入讲解CAP定理：打造高并发与高可用的分布式系统","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer-algorithm/","section":"Tags","summary":"","title":"Divide and Conquer Algorithm","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"快速排序是一种基于比较的非稳定排序算法，采用分治思想，平均时间复杂度为 $O(n\\log n)$，最坏情况下为 $O(n^2)$ ，空间复杂度为 $O(1)$。下面以从小到大排序一个整数数列为例，介绍其实现细节与常见错误。\n题目描述 # 给定一个长度为 $n$ 的整数数列，使用快速排序对其从小到大进行排序，并输出结果。\n输入格式 # 第一行输入整数 $n$ 第二行输入 $n$ 个整数，均在 $[1,10^9]$ 范围内 输出格式 # 一行输出排好序的数列 数据范围 # $1 \\leq n \\leq 100000$\n输入样例 # 5 3 1 2 4 5 输出样例 # 1 2 3 4 5 快速排序思路 # 快速排序每次分治时，任选一个数作为基准数 pivot（下面选中间位置的数）。\n使用左右指针相向而行，左指针 L 从左往右寻找第一个大于等于 pivot 的数，右指针 R 从右往左寻找第一个小于等于 pivot 的数，然后交换这两个数。\n不断重复这个过程，直到左指针和右指针重叠或者左指针比右指针大一位。这被称为一次循环。\n在每次指针移动和交换完成后，都保证「左边部分 ≤ pivot, 右边部分 ≥ pivot」的结构不被破坏，即有不变量 [left, L) \u0026lt;= pivot， (R, right] \u0026gt;= pivot。\n以下示例代码中，left 和 right 是当前处理的闭区间边界，pivot 则取在区间中点处的元素。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 复杂度与 pivot 的选择 # 由于在最坏情况下快速排序有 $O(n^2)$ 的复杂度，pivot 的选取很关键。如果总是选第一个或最后一个元素，在近乎有序的数组中将大概率出现最坏情况。\n除了取中间位置的元素，还可以随机选取一个元素作为 pivot，或者取左、中、右三个元素的中位数作为 pivot。\n常见错误示例 # 下面这段代码包含了多处常见错误。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 错误分析：\npivot 应该是数组中的一个数，而不是下标。 分别用 \u0026lt; 和 \u0026gt; 而不是 \u0026lt;= 和 \u0026gt;=，否则左指针可能不止超过右指针一位，这样就不能把数组分成两部分。 发现 l \u0026gt;= r 后，应立即退出循环，不再执行交换。否则不能保证左侧元素不大于 pivot，右侧元素不小于 pivot。 每次交换后，应执行 l++ 和 r--。 pivot 实际上取的是中间偏左的数。因此如果使用 $l - 1$ 和 $l$ 分割数组，考虑数组 [1, 2]，不难发现会导致死循环，不断将数组分成大小为 0 和 2 的两份。类似地，用 $r$ 和 $l$ 区分数组也不行。相反地，一轮循环结束时，$r$ 必然小于 $right$，所以可以使用 $r$ 和 $r+1$ 分割数组。读者可以模拟下算法过程看看为什么。另一种简单的避免死循环的方式是随机选 pivot或者特殊处理只有两个元素的情况。 另外，用 $l$, $l+1$ 也不行，因为这个分割不合定义，当 $r$ 在 $l$ 左边的情况下，用 $l$, $l+1$ 不能正确地将数组分成左边小于等于 pivot，右边大于等于 pivot 的两份。 本题假定数组非空，所以不存在 \u0026gt; 的情况。但是建议使用 \u0026gt;=, 更安全。 补充 # 快速排序还可演变为“快速选择”，在 $O(n)$ 的期望时间内找到无序数组中第 $k$ 小的数，具体思想与快速排序类似，只是每次只在一侧子区间继续递归，从而降低时间复杂度。\n","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/posts/1735252761946-quick-sort/","section":"Posts","summary":"正确实现快速排序算法的要点解析。","title":"快速排序","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":" 题目 # https://www.acwing.com/problem/content/2/\n有 $N$ 件物品. 第 $i$ 件物品的体积是 $s_i$, 价值是 $v_i$. 每件物品只能取一次. 在不超过最大总体积限制 $S$ 的前提下，求能够取得的最大总价值 $V$.\n输入格式 # 第一行两个整数, $N, S$, 用空格隔开, 分别表示物品数量和最大总体积限制. 接下来有 $N$ 行, 每行两个整数 $s_i, v_i$, 用空格隔开, 分别表示第 $i$ 件物品的体积和价值.\n输出格式 # 输出一个整数, 表示最大价值.\n数据范围 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 输入样例 # 4 5 1 2 2 4 3 4 4 5 输出样例 # 8 题解 # 定义状态: f[i][j] 表示前 $i$ 件物品，体积限制为 $j$ 可以获得的最大价值。 若不取第 $i$ 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 $i$ 件物品, 那么 f[i][j] = f[i - 1][j - s[i]] + v[i] 实现状态转移时, 要注意定义域范围. 若 $j \u003c s_i$, 那么不考虑取第 $i$ 件物品的情况。因为若 $j-s_i$ 为负数, 数组下标不合法。 也可以这么解释: 第 $i$ 件物品的体积大于体积限制, 所以不可能。 定义初始条件: 前 $0$ 件物品，任何体积限制都获得价值 $0$, 即 f[0][j] = 0, j $\\in [0, S]$。 时间复杂度: $O(NS)$。 代码 # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 一维DP优化 # 将二维数组压缩成一维数组, 可以显著节省空间并提高一定程度的运行速度（缺点是无法满足某些题型的特殊要求） 注意到状态转移中, f[i][j] 只与 f[i - 1][j] 和 f[i - 1][j - s[i]] 有关. 换言之在代码中的二维数组 f 中, f[i][j] 只与它的上一行中比它更靠左或同列的元素有关, 因此可以将二维数组压缩成一维数组或者滚动数组。 注意下面的代码中, 第二层循环逆序遍历, 这是因为我们要保证在计算 f[i][j] 时, f[i - 1][j - s[i]] 还没有被更新. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 如果要求方案数 # 不仅要输出能够取得的最大总价值，还需要输出“有多少种不同的选取方法可以达到这个最大总价值”。下面介绍在 01 背包问题中* 如何统计方案数*。\nhttps://www.acwing.com/problem/content/11/\n二维 DP 统计方案数 # 下面以二维 DP 为例进行讲解。\n定义状态：\ndp[i][j] 表示「前 i 件物品，容量（体积限制）为 j 时，能取得的最大价值」。 ways[i][j] 表示「前 i 件物品，容量为 j，取得最大价值时对应的方案数」。 状态转移：\n如果不选第 i 件物品： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ 如果选第 i 件物品（前提是 $ j \\ge s_i $）： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 选或不选，最终 dp[i][j] 应取二者的较大值： 如果 $$ \\text{dp}[i-1][j - s_i] + v_i $$ 那么说明「选第 i 件物品」的价值更大： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$\n如果 $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ 说明两种方式得到的最大价值相同，则方案数应该叠加： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] \\text{ways}[i-1][j - s_i]. $$ 如果 $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ 那么说明「不选第 i 件物品」的价值更大，方案数继承不选时的方案数： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 初始条件：\ndp[0][j] = 0 表示前 0 件物品时，任何容量得到的最大价值都是 0。 ways[0][0] = 1 表示「前 0 件物品、容量为 0」这一种情况是一种可行方案（即什么都不选），方案数设为 1。 对于 j \u0026gt; 0，没有物品可选时容量又大于 0，就不可能取得任何正价值，对应的方案数为 0，即 ways[0][j] = 0。 最终答案：\ndp[N][S] 即为最大价值。 ways[N][S] 即为达到该最大价值的方案数。 时间复杂度：$O(NS)$。 这道题也可以使用一维 DP 进行优化。 如果要求恰好达到体积限制的情况 # 定义状态: f[i][j] 表示前 i 件物品恰好有体积 $j$ 的最大价值. 若不取第 i 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那么 f[i][j] = f[i - 1][j - s[i]] + v[i] 可以注意到和原问题的状态转移没有区别. 但是初始条件不同. 除了 f[0][0] = 0, 其余 f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ 表示不可能的状态. 如果体积限制 $S$ 特别大 (1e9), 同时物品数量 $N$ 和最大总价值 $V$ 比较小 # 对于这样的题, 有一种复杂度为 $O(NV)$ 的解法. 定义状态: f[i][j] 表示前 i 件物品挑选若干件, 价值总和恰好为 j 的最小体积. 若不取第 i 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那么 f[i][j] = f[i - 1][j - v[i]] + s[i] 取两者的较小值. 初始条件: f[0][0] = 0, 其余 f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ 表示不可能的状态. 注意不是 $-\\infty$. 最终答案为 f[N][j] 中最大的 j 使得 f[N][j] \u0026lt;= S. 如果体积限制 $S$ 和单个物品价值 $v_i$ 都特别大($1e9$ 量级), 同时物品数量 $N$ 特别小（最高不超过 40） # https://www.acwing.com/solution/content/38250/\n当 $N \\leq 20$ 时，可以直接暴力枚举所有子集（时间复杂度 $O(2^N)$。 当 $N \\leq 40$ 时，由于 $2^{40}$ 在 $10^{12}$ 量级，直接暴力也会比较大，所以可以使用 折半搜索 ，将复杂度大致降低到 $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ ，可以在可接受的时间内完成。 ","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"最基础的经典背包问题。","title":"01背包问题","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/series/classic-knapsack-problem-set/","section":"Series","summary":"","title":"Classic Knapsack Problem Set","type":"series"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E9%9B%86/","section":"Series","summary":"","title":"背包经典问题集","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"如果有序解空间被分成左右两部分，其中一个部分满足条件，另一个部分不满足条件。那么能够使用二分搜索来在有序解空间中查找临界点。\n二分搜索的基本思路是不断地将搜索区间对半分。每次检查中点元素，如果中点元素不满足条件，就可以排除一半区间； 反之，则在另一半区间继续搜索。由于每次都抛弃一半的搜索区间，搜索时间复杂度可达到 $O(\\log n)$。\n例题 # https://www.acwing.com/problem/content/791\n题目描述：\n给定一个升序排列的长度为 $n$ 的整数数组，还有 $q$ 个查询。每个查询给出一个整数 $k$，我们需要找出在数组中 $ k$ 的「起始位置」和「终止位置」（下标从 0 开始）。如果数组中不存在这个数，则返回 -1 -1。\n输入格式 # 第一行：两个整数 $n$ 和 $q$，分别表示数组长度和查询次数。 第二行：$n$ 个整数，表示完整数组，已按升序排列。 接下来 $q$ 行：每行包含一个整数 $k$，表示一个查询元素。 数据范围 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n输出格式 # 对每个查询，在一行里输出该元素在数组中的起始和结束位置。如果数组中不存在该元素，则输出 -1 -1。\n样例：\n输入： 6 3 1 2 2 3 3 4 3 4 5 输出： 3 4 5 5 -1 -1 解释：\n元素 $3$ 出现的范围为 $[3, 4]$； 元素 $4$ 只出现了一次，在位置 $5$； 元素 $5$ 在数组里不存在，因此返回 $-1$ $-1$。 解答 # 找「起始位置」： 即找第一个大于等于 $k$ 的位置。可以把数组分成两部分：\n左边所有数都「小于」 $k$ 右边所有数都「大于等于」 $k$ 答案为右边的第一个位置 找「终止位置」： 即找最后一个小于等于 $k$ 的位置。可以把数组分成两部分：\n左边所有数都「小于等于」 $k$ 右边所有数都「大于」 $k$ 答案为左边的最后一个位置 推荐模板 # 下面是一种优雅且不易犯错的二分模板。\n定义两个指针 $l, r$，有不变量：闭区间 $[0, l]$ 都属于左半部分，闭区间 $[r, n - 1]$ 都属于右半部分。$l$ 和 $r$ 都初始化为 $-1$ 和 $n$。\n算法终止时，$l$ 和 $r$ 相邻，分别指向左半部分的最后一个元素和右半部分的第一个元素。\n因为我们想要的解可能不存在，所以如果题目没有说明一定存在解，我们需要判断一下 l 或 r 是否越界，是否指向正确的值。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. 找 k 的起始位置 15 // 将数组分成两部分，左边都 \u0026lt; k，右边都 \u0026gt;= k。 16 // 答案为右半部分的最小下标。 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // 如果 r 越界或者 nums[r] != k，说明不存在 k 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. 找 k 的终止位置 33 // 将数组分成两部分，左边都 \u0026lt;= k，右边都 \u0026gt; k。 34 // 答案为左半部分的最大下标。 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} 优势 # 这个写法有严格定义的不变量。 它同时适用于找「起始位置」和「终止位置」两种情况，不需要额外的处理和变化。 有一些写法使用 l == r 作为终止条件。当 $l$ 和 $r$ 相差 $1$ 时，会计算出 $mid$ 和 $l$ 或 $r$ 相等。如果没有正确处理，更新 $l$ 或 $r$ 为 $mid$，搜索区间没有缩小，会导致死循环。相反地，这里的写法在 $l$ 和 $r$ 相邻时终止，保证 $mid$ 小于 $l$ 且大于 $r$，更新 $l$ 或 $r$ 时搜索区间一定会缩小。 STL # 如果使用 C++ STL 提供的 lower_bound 和 upper_bound 函数，也能完成同样的事情：\nlower_bound(first, last, val) 会返回「第一个大于等于 val 的位置」 upper_bound(first, last, val) 会返回「第一个大于 val 的位置」 举个例子，假设 nums = {1,2,3,4,4,4,4,4,5,5,6}，我们想知道 4 出现的区间：\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 指向第一个值大于等于 $4$ 的位置。 it2 指向第一个值大于 $4$ 的位置。\n所以 it2 - it1 就是 $4$ 在数组中出现的次数；it2 - nums.begin() - 1 就是 $4$ 的右边界的位置。 补充 # 二分搜索还可以扩展到浮点数范围的搜索（如求方程根）、以及三分搜索求单峰函数的最值。\n练习 # LeetCode 33. Search in Rotated Sorted Array\n提示：第一步使用二分搜索找到旋转点，第二步再使用二分搜索找到目标值。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"如何优雅地实现二分搜索算法。","title":"二分搜索","type":"posts"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]