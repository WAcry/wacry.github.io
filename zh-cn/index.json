[{"content":" 一、CAP 定理 # 1.1 什么是 CAP 定理 # CAP 定理 由 Eric Brewer 于 2000 年提出，其核心观点是：在分布式系统的设计中，一致性（C）、可用性（A） 和 分区容错性（P） 三者最多只能同时满足两项。\nC（Consistency，一致性）：系统中的所有节点在同一时刻看到的数据都是相同的。更严格地说，当客户端读取数据时，无论从哪个副本读取，结果都应当与最新提交的数据保持一致（通常指强一致性/线性一致性）。 A（Availability，可用性）：系统在出现部分故障时仍然可以对外提供正常服务，每个请求都能在合理时间内得到有效响应。 P（Partition tolerance，分区容错性）：系统可以容忍网络分区（节点间通信出现不可达），即使网络发生分裂，系统也能提供一定程度的可用性或一致性。 在真实分布式环境中，网络分区不可避免，所以 P 基本被视为“必选项”。当网络分区发生时，系统无法同时兼顾所有节点对数据的* 强一致性与高可用性*，只能在 C 和 A 中做取舍，于是衍生出 CP 和 AP 两大主要类型。\n1.2 CAP 定理的局限性 # 需要指出的是，CAP 定理本身是一个相对高层次的理论，应用于概念指导，不能简单理解为“要么选 C，要么选 A”。存在一些常见的误解：\nC 并不必然是强一致性 CAP 定理中的 C 往往指的是最严格意义上的一致性（即线性一致性）。但在实际系统中，我们还有弱一致性、读已提交（Read Committed）、因果一致性（Causal Consistency）等很多细粒度模型可以选择。 可用性并非 0 或 1 并非说选了 CP，就意味着可用性完全被牺牲；或选了 AP，就意味着一致性毫无保障。可用性和一致性都有不同程度的权衡空间和降级策略。 最终一致性不违背 CAP 它是一个非常常见的折衷方案，用较低的写一致性换取更高的可用性和吞吐量，并通过异步方式在后台收敛数据。 因此，CAP 定理应和各种 一致性模型、高可用架构模式 结合到具体场景里，才能产生真正的落地指导价值。\n二、分布式系统的一致性模型 # 一致性模型的分类十分丰富，但常见的主流模型大致可以分为：强一致性 和 弱一致性（其中包含最终一致性、因果一致性等）。本文主要介绍 强一致性 与 最终一致性，并说明它们在 CP 或 AP 模式下的常见应用。\n2.1 强一致性 # 强一致性（Strong Consistency） 又称 线性一致性（Linearizability） ，指的是一旦一次写操作完成返回成功，任何后续的读取操作都能读到该更新内容。也就是说，系统对外表现得像是串行执行了所有操作。\n常见实现：依赖同步复制和一个仲裁（多数派）机制，通过协议（如 Paxos/Raft）来确保系统中只有一个有效的领导者（Leader），所有操作按顺序写入日志并复制到多数节点。 优缺点： 优点：保证最严格的数据正确性，任何时候读到的数据都不发生“回退”。 缺点：在网络抖动、分区或领导者故障时，为了维持一致性往往会阻塞写操作，导致整体可用性下降；性能和吞吐量也相对更低。 2.2 最终一致性 # 最终一致性（Eventual Consistency） 是弱一致性的一种典型形式，它只要求如果系统不再有新的更新操作，随着时间的推移，所有副本的数据会逐渐收敛到同一个状态。期间用户读取副本数据，可能会看到过时的值，但最终会变得一致。\n常见实现：Gossip 协议、多副本异步复制、CRDT（Conflict-free Replicated Data Type）等。 优缺点： 优点：高可用、高吞吐量，写操作延迟较低，对网络分区的容忍度高。 缺点：需要容忍短时间的数据不一致，应用逻辑更复杂，可能要进行冲突检测与合并。 三、常见一致性协议与算法 # 为了让分布式系统副本之间保持一致，业界提出了诸多经典算法与协议。以下简要介绍几种：\n3.1 Paxos # Paxos 是由 Leslie Lamport 在 1990 年代提出的分布式一致性算法，主要用于实现强一致性或线性一致性。\n基本原理：通过角色划分（提案者 Proposer、接受者 Acceptor、学习者 Learner）进行多轮投票，来决定一次操作或值是否被多数节点接受。 优缺点： 优点：能在网络分区、节点故障下依旧达成一致，具备很高的安全性。 缺点：实现复杂，调试和排错难度高，多轮投票导致性能受限。工业界多用其变体（Multi-Paxos 等）。 3.2 Raft # Raft 于 2013 年正式提出，目标是在保证与 Paxos 同等安全性的前提下，简化实现和理解难度。它通过建立一个稳定的 * 领导者（Leader）* 角色，集中式地进行日志复制和故障恢复：\n关键阶段：领导选举（Leader Election）、日志复制（Log Replication）、安全性（Safety）等。 常见应用：Etcd、Consul、TiKV、LogCabin 等都基于 Raft 来实现强一致复制。 优缺点： 优点：相对易懂、实现代码量更少；对中小规模集群性能较好。 缺点：依赖主节点（Leader），主节点故障或分区会造成短暂的写阻塞；在大规模集群或跨地域部署时，延迟和可用性会受到影响。 3.3 Gossip 协议 # Gossip（八卦）协议并非传统的共识协议，主要用于在去中心化的场景下通过节点随机交互来交换元数据或状态信息，从而在全网进行扩散与收敛。\n特点：去中心化、低开销、节点间周期性且随机地交换消息。 常见应用：Cassandra、Riak、分布式成员管理（如 Serf）等，用于实现最终一致性、副本状态同步等。 优缺点： 优点：扩展性佳，简单易实现，适合对一致性要求不高、对可扩展性要求高的场景。 缺点：一致性保证较弱，需要更高级别的冲突处理手段（如 CRDT、版本号合并等）来最终解决冲突。 3.4 2PC / 3PC # 在分布式事务场景下，常见的提交协议是 2PC（Two-phase Commit） 和 3PC（Three-phase Commit）：\n2PC：协调者通知所有参与者“预提交（prepare）”，若都成功则广播“提交（commit）”，否则“回滚（abort）”。 3PC：在 2PC 基础上增加一个阶段，降低单点故障带来的阻塞，但实现更复杂，仍然存在极端网络分区或故障场景下的不可用问题。 优缺点： 优点：容易理解，事务语义清晰，在分布式数据库、消息队列等广泛应用。 缺点：对协调者依赖性强，有阻塞风险；在网络出现较长时间分区时可能无法继续推进事务。 四、CAP 的两大主流选择：CP 与 AP # 当我们认定 P 是“必选”的属性之后，分布式系统若想在网络分区时继续提供服务，就要在 C 和 A 之间做抉择。常见的系统设计因此分化为 CP 和 AP 两大阵营。\n4.1 CP 系统 # CP（Consistency + Partition tolerance）：遇到网络分区时，系统会选择 优先保证一致性，在必要时牺牲可用性。\n典型实现： 多数派共识（Paxos、Raft 等），需要过半节点存活并达成一致才允许写入。 若当前无法达成 quorum（法定人数）或主节点故障，系统会阻塞或拒绝写操作，以防止脑裂导致数据不一致。 常见应用： Zookeeper、Etcd、Consul、分布式锁服务、分布式元数据管理等。 金融交易核心流程、银行账务系统等高一致性要求的场景。 特点： 拥有严格的数据保证：宁可停机也不出现双主或数据混乱。 牺牲一定的可用性：在发生网络分区或故障切换时，会有一段服务不可用或拒绝写操作的窗口。 4.2 AP 系统 # AP（Availability + Partition tolerance）：遇到网络分区时，系统会选择 优先保证可用性，同时放宽一致性。\n典型实现： 最终一致性、多主复制、Gossip 协议、Dynamo 风格可调一致性策略等。 常见应用： NoSQL 数据库（Cassandra、Riak、DynamoDB 等），分布式缓存系统（Redis Cluster）等。 社交网络、日志采集、推荐系统等需要高可用、高吞吐，对数据一致性要求相对宽松的业务。 特点： 即使分区，所有节点依旧接收读写请求，保证系统“尽可能可用”。 数据可能存在短暂不一致，但会通过异步同步、冲突合并等方式在后台逐步收敛。 五、如何在 CP 与 AP 中取舍？ # 在真实的大规模分布式系统中，往往很少只依赖单一模型，而是对不同数据或业务场景进行分层处理，以求 一致性 与 可用性 的最优平衡。\n核心数据选 CP 如用户账户余额、订单支付、金融交易流水等，对一致性要求极高。 容忍网络抖动导致的短暂不可写，但不能容忍余额或交易金额的错误。 边缘或缓存数据选 AP 如商品详情页的缓存、用户行为日志、推荐候选列表等，对一致性要求较低。 更看重高并发、高可用，能够容忍一定时间的延迟更新或脏读。 许多互联网企业会采用混合架构：核心交易流程使用 CP 式存储（如分布式关系型数据库或带强一致性的分布式存储）；外围业务或“读多写少”的场景使用 AP 式存储或缓存方案。\n六、CP 与 AP 如何实现高并发与最终一致性 # 6.1 CP 系统如何应对高并发 # 虽然共识协议在单一集群节点规模和写请求量大时，会面临较高的延迟和较低的吞吐，但依然可以通过以下手段提升并发和可扩展性：\n批量读写 将多个写操作在客户端或中间层打包，一次性在领导者节点上写入，减少网络往返和协议轮次。 分库分表 \u0026amp; 多群集 将数据按逻辑或哈希切分到多个群集（sharding），每个群集内部仍然运行 CP 协议；请求通过路由或代理层分散到不同分片。 提升整体并发能力，并将故障影响限制在单个分片范围内。 CP 系统的单分片集群吞吐量往往比 AP 系统低 2 到 10 倍。\n6.2 AP 系统如何保证最终一致性 # AP 系统通常能够提供很高的写吞吐和读取可用性，但对一致性放松，因而需要在后台或业务逻辑层实现一致性收敛的保障：\n版本号（Vector Clock）或逻辑时间戳 给每个更新操作分配一个版本号（或基于 Lamport Clock / Hybrid Clock），在冲突场景下进行合并或基于时间戳的胜出策略（Last Write Wins）。 Gossip 协议 / 反熵（Anti-entropy）机制 节点周期性地交换最新数据或元数据，发现冲突则进行合并。 可调一致性策略 以 Dynamo 模型为代表，客户端可配置 R、W 等参数（如写入多数派、副本确认），从而在一致性和可用性之间弹性调节。 自定义冲突解决策略 结合业务语义进行合并，如购物车用“并集”合并，计数器用 CRDT（G-counter、PN-counter 等）保证数据的单调性。 七、CP 的跨分片强一致性实现 # 在第七章中提到，通过分库分表（Sharding） 可以让单个 CP 集群的压力“拆分”到多个子集群，以支撑更高并发。然而，当业务需要跨分片执行事务（即涉及多个分库或分表的更新）时，仍面临 多分片一致性 的挑战。通常有以下思路：\n分布式事务：2PC / 3PC 若应用需要跨多个分片进行原子性更新，通常使用分布式事务协议（如 2PC、3PC）来协调各分片的提交或回滚。 问题与对策： 2PC/3PC 都依赖一个协调者节点，可能成为单点瓶颈。 在网络分区严重或协调者故障的极端情形下，可能出现阻塞。 一般会通过主从切换、心跳检测和超时机制、幂等重试、MVCC 等来降低阻塞影响和数据不一致风险。 单元化（Cell-based）架构 将业务切分为多个自治单元，每个单元内的数据都在同一个分片集合中，保证大多数事务都只在单一单元中完成，减少跨分片操作。 在单元边界上采用异步或最终一致性机制进行数据交换，兼顾整体的高可用与一致性。 全球分布式数据库 + 全局共识协议 例如 Google Spanner 在每个分片（Shard）上通过 Paxos 实现副本强一致复制，再利用 TrueTime API 提供全局时间戳保障跨分片一致性。 这种方案实现复杂度极高，但能在全局范围内提供接近强一致的分布式事务能力。 小结：对于严格要求强一致性的跨分片事务，2PC/3PC + 协调者 仍是常见方案，并通过尽可能提高协调者的高可用，来降低故障的可能性。但需在工程实践中尽量减少跨分片写操作，或通过单元化思路将大部分事务限制在单一分片范围，降低系统复杂度。\n八、著名案例讨论 # 下面简要探讨几款在业界常被提及的分布式系统，看看它们在 CAP 上的取舍与实现方式：\nGoogle Spanner 典型的 CP 系统（甚至能做到外界常说的 “CA” 幻觉，但实质仍需牺牲一部分可用性）。 利用 TrueTime 提供的外部精确时间戳 + 每个分片内部的 Paxos 复制，保证跨数据中心的强一致性。 适合全球金融交易或高一致性要求场景，但基础设施成本极高。 BigTable / HBase 表面上更偏向 CP，在 RegionServer 与 Master 之间通过分布式协调保证元数据的一致性。 但实际读写路径中也能通过多副本异步复制提供一定的高可用手段，读一致性可根据应用需求调整。 AWS DynamoDB 倾向 AP，早期设计灵感来自 Dynamo 论文，可通过 R、W 等参数调节一致性等级。 默认模式下提供极高可用性和最终一致性，也可开启“强一致读”（但只保证单分区的强一致，不一定跨分区）。 Cassandra 同样是 AP 倾向，底层采用 Gossip 协议维护节点拓扑状态。 读写一致性可配置读写副本数 R / W，以实现从最终一致性到较强一致性的平滑过渡。 对比可见：工程上不存在绝对的“AP 或 CP”，更多是多种一致性策略的混合；大部分系统都提供一定程度的可调一致性来适配不同应用场景。\n九、总结 # CAP 定理不是一刀切 真实的分布式系统无法简单地说“我选 C，放弃 A”或“我选 A，放弃 C”。 业界更常见的是针对不同的数据维度、不同的操作类型，灵活地选择 CP 或 AP 模式，甚至在同一个系统内部，对不同表/不同功能采用不同的容错与一致性策略。 AP 并非绝对 100% 可用 例如，Cassandra、DynamoDB 等在极端网络分区或节点大面积失效时，同样会出现无法满足请求的情况。 AP 系统只是设计上倾向“只要副本可写就先写”，牺牲了一部分一致性保证来换取相对更高的可用性与吞吐量。 CP 也可以尽量做到高可用 Paxos/Raft 在正常情况下也能提供 99.99% 甚至更高的可用性，只是需要投入更多的网络、硬件和工程成本，且在极端网络分区时仍会出现阻塞写、牺牲可用性来维持一致。 混合架构是主流 核心交易场景坚持强一致（CP），外围辅助场景或缓存通道采用弱一致（AP），两者相互配合。 要结合业务容忍度、网络环境、成本投入、团队技术储备来综合取舍。 CAP 定理为分布式系统的设计提供了一个高层次的思维框架，帮助我们在网络分区这一不可避免的现实面前做出理性决策。在实际系统中，则需要借助更丰富的 一致性模型、共识协议、多副本复制机制 以及工程实践（容灾、降级、幂等、冲突合并等）来平衡一致性与可用性。\n","date":"2024年12月20日","externalUrl":null,"permalink":"/zh-cn/posts/1735350760948-cap/","section":"Posts","summary":"从理论到实践讨论 CAP 定理在分布式系统中的应用。","title":"深入讲解CAP定理：打造高并发与高可用的分布式系统","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer-algorithm/","section":"Tags","summary":"","title":"Divide and Conquer Algorithm","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"快速排序是一种基于比较的非稳定排序算法，采用分治思想，平均时间复杂度为 $O(n\\log n)$，最坏情况下为 $O(n^2)$ ，空间复杂度为 $O(1)$。下面以从小到大排序一个整数数列为例，介绍其实现细节与常见错误。\n题目描述 # 给定一个长度为 $n$ 的整数数列，使用快速排序对其从小到大进行排序，并输出结果。\n输入格式 # 第一行输入整数 $n$ 第二行输入 $n$ 个整数，均在 $[1,10^9]$ 范围内 输出格式 # 一行输出排好序的数列 数据范围 # $1 \\leq n \\leq 100000$\n输入样例 # 5 3 1 2 4 5 输出样例 # 1 2 3 4 5 快速排序思路 # 快速排序每次分治时，任选一个数作为基准数 pivot（下面选中间位置的数）。\n使用左右指针相向而行，左指针 L 从左往右寻找第一个大于等于 pivot 的数，右指针 R 从右往左寻找第一个小于等于 pivot 的数，然后交换这两个数。\n不断重复这个过程，直到左指针和右指针重叠或者左指针比右指针大一位。这被称为一次循环。\n在每次指针移动和交换完成后，都保证「左边部分 ≤ pivot, 右边部分 ≥ pivot」的结构不被破坏，即有不变量 [left, L) \u0026lt;= pivot， (R, right] \u0026gt;= pivot。\n以下示例代码中，left 和 right 是当前处理的闭区间边界，pivot 则取在区间中点处的元素。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 复杂度与 pivot 的选择 # 由于在最坏情况下快速排序有 $O(n^2)$ 的复杂度，pivot 的选取很关键。如果总是选第一个或最后一个元素，在近乎有序的数组中将大概率出现最坏情况。\n除了取中间位置的元素，还可以随机选取一个元素作为 pivot，或者取左、中、右三个元素的中位数作为 pivot。\n常见错误示例 # 下面这段代码包含了多处常见错误。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 错误分析：\npivot 应该是数组中的一个数，而不是下标。 分别用 \u0026lt; 和 \u0026gt; 而不是 \u0026lt;= 和 \u0026gt;=，否则左指针可能不止超过右指针一位，这样就不能把数组分成两部分。 发现 l \u0026gt;= r 后，应立即退出循环，不再执行交换。否则不能保证左侧元素不大于 pivot，右侧元素不小于 pivot。 每次交换后，应执行 l++ 和 r--。 pivot 实际上取的是中间偏左的数。因此如果使用 $l - 1$ 和 $l$ 分割数组，考虑数组 [1, 2]，不难发现会导致死循环，不断将数组分成大小为 0 和 2 的两份。类似地，用 $r$ 和 $l$ 区分数组也不行。相反地，一轮循环结束时，$r$ 必然小于 $right$，所以可以使用 $r$ 和 $r+1$ 分割数组。读者可以模拟下算法过程看看为什么。另一种简单的避免死循环的方式是随机选 pivot或者特殊处理只有两个元素的情况。 另外，用 $l$, $l+1$ 也不行，因为这个分割不合定义，当 $r$ 在 $l$ 左边的情况下，用 $l$, $l+1$ 不能正确地将数组分成左边小于等于 pivot，右边大于等于 pivot 的两份。 本题假定数组非空，所以不存在 \u0026gt; 的情况。但是建议使用 \u0026gt;=, 更安全。 补充 # 快速排序还可演变为“快速选择”，在 $O(n)$ 的期望时间内找到无序数组中第 $k$ 小的数，具体思想与快速排序类似，只是每次只在一侧子区间继续递归，从而降低时间复杂度。\n","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/posts/1735252761946-quick-sort/","section":"Posts","summary":"正确实现快速排序算法的要点解析。","title":"快速排序","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":" 题目 # https://www.acwing.com/problem/content/2/\n有 $N$ 件物品. 第 $i$ 件物品的体积是 $s_i$, 价值是 $v_i$. 每件物品只能取一次. 在不超过最大总体积限制 $S$ 的前提下，求能够取得的最大总价值 $V$.\n输入格式 # 第一行两个整数, $N, S$, 用空格隔开, 分别表示物品数量和最大总体积限制. 接下来有 $N$ 行, 每行两个整数 $s_i, v_i$, 用空格隔开, 分别表示第 $i$ 件物品的体积和价值.\n输出格式 # 输出一个整数, 表示最大价值.\n数据范围 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 输入样例 # 4 5 1 2 2 4 3 4 4 5 输出样例 # 8 题解 # 定义状态: f[i][j] 表示前 $i$ 件物品，体积限制为 $j$ 可以获得的最大价值。 若不取第 $i$ 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 $i$ 件物品, 那么 f[i][j] = f[i - 1][j - s[i]] + v[i] 实现状态转移时, 要注意定义域范围. 若 $j \u003c s_i$, 那么不考虑取第 $i$ 件物品的情况。因为若 $j-s_i$ 为负数, 数组下标不合法。 也可以这么解释: 第 $i$ 件物品的体积大于体积限制, 所以不可能。 定义初始条件: 前 $0$ 件物品，任何体积限制都获得价值 $0$, 即 f[0][j] = 0, j $\\in [0, S]$。 时间复杂度: $O(NS)$。 代码 # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 一维DP优化 # 将二维数组压缩成一维数组, 可以显著节省空间并提高一定程度的运行速度（缺点是无法满足某些题型的特殊要求） 注意到状态转移中, f[i][j] 只与 f[i - 1][j] 和 f[i - 1][j - s[i]] 有关. 换言之在代码中的二维数组 f 中, f[i][j] 只与它的上一行中比它更靠左或同列的元素有关, 因此可以将二维数组压缩成一维数组或者滚动数组。 注意下面的代码中, 第二层循环逆序遍历, 这是因为我们要保证在计算 f[i][j] 时, f[i - 1][j - s[i]] 还没有被更新. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 如果要求方案数 # 不仅要输出能够取得的最大总价值，还需要输出“有多少种不同的选取方法可以达到这个最大总价值”。下面介绍在 01 背包问题中* 如何统计方案数*。\nhttps://www.acwing.com/problem/content/11/\n二维 DP 统计方案数 # 下面以二维 DP 为例进行讲解。\n定义状态：\ndp[i][j] 表示「前 i 件物品，容量（体积限制）为 j 时，能取得的最大价值」。 ways[i][j] 表示「前 i 件物品，容量为 j，取得最大价值时对应的方案数」。 状态转移：\n如果不选第 i 件物品： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ 如果选第 i 件物品（前提是 $ j \\ge s_i $）： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 选或不选，最终 dp[i][j] 应取二者的较大值： 如果 $$ \\text{dp}[i-1][j - s_i] + v_i $$ 那么说明「选第 i 件物品」的价值更大： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$\n如果 $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ 说明两种方式得到的最大价值相同，则方案数应该叠加： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] \\text{ways}[i-1][j - s_i]. $$ 如果 $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ 那么说明「不选第 i 件物品」的价值更大，方案数继承不选时的方案数： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 初始条件：\ndp[0][j] = 0 表示前 0 件物品时，任何容量得到的最大价值都是 0。 ways[0][0] = 1 表示「前 0 件物品、容量为 0」这一种情况是一种可行方案（即什么都不选），方案数设为 1。 对于 j \u0026gt; 0，没有物品可选时容量又大于 0，就不可能取得任何正价值，对应的方案数为 0，即 ways[0][j] = 0。 最终答案：\ndp[N][S] 即为最大价值。 ways[N][S] 即为达到该最大价值的方案数。 时间复杂度：$O(NS)$。 这道题也可以使用一维 DP 进行优化。 如果要求恰好达到体积限制的情况 # 定义状态: f[i][j] 表示前 i 件物品恰好有体积 $j$ 的最大价值. 若不取第 i 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那么 f[i][j] = f[i - 1][j - s[i]] + v[i] 可以注意到和原问题的状态转移没有区别. 但是初始条件不同. 除了 f[0][0] = 0, 其余 f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ 表示不可能的状态. 如果体积限制 $S$ 特别大 (1e9), 同时物品数量 $N$ 和最大总价值 $V$ 比较小 # 对于这样的题, 有一种复杂度为 $O(NV)$ 的解法. 定义状态: f[i][j] 表示前 i 件物品挑选若干件, 价值总和恰好为 j 的最小体积. 若不取第 i 件物品, 那么 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那么 f[i][j] = f[i - 1][j - v[i]] + s[i] 取两者的较小值. 初始条件: f[0][0] = 0, 其余 f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ 表示不可能的状态. 注意不是 $-\\infty$. 最终答案为 f[N][j] 中最大的 j 使得 f[N][j] \u0026lt;= S. 如果体积限制 $S$ 和单个物品价值 $v_i$ 都特别大($1e9$ 量级), 同时物品数量 $N$ 特别小（最高不超过 40） # https://www.acwing.com/solution/content/38250/\n当 $N \\leq 20$ 时，可以直接暴力枚举所有子集（时间复杂度 $O(2^N)$。 当 $N \\leq 40$ 时，由于 $2^{40}$ 在 $10^{12}$ 量级，直接暴力也会比较大，所以可以使用 折半搜索 ，将复杂度大致降低到 $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ ，可以在可接受的时间内完成。 ","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"最基础的经典背包问题。","title":"01背包问题","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/series/classic-knapsack-problem-set/","section":"Series","summary":"","title":"Classic Knapsack Problem Set","type":"series"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E9%9B%86/","section":"Series","summary":"","title":"背包经典问题集","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"如果有序解空间被分成左右两部分，其中一个部分满足条件，另一个部分不满足条件。那么能够使用二分搜索来在有序解空间中查找临界点。\n二分搜索的基本思路是不断地将搜索区间对半分。每次检查中点元素，如果中点元素不满足条件，就可以排除一半区间； 反之，则在另一半区间继续搜索。由于每次都抛弃一半的搜索区间，搜索时间复杂度可达到 $O(\\log n)$。\n例题 # https://www.acwing.com/problem/content/791\n题目描述：\n给定一个升序排列的长度为 $n$ 的整数数组，还有 $q$ 个查询。每个查询给出一个整数 $k$，我们需要找出在数组中 $ k$ 的「起始位置」和「终止位置」（下标从 0 开始）。如果数组中不存在这个数，则返回 -1 -1。\n输入格式 # 第一行：两个整数 $n$ 和 $q$，分别表示数组长度和查询次数。 第二行：$n$ 个整数，表示完整数组，已按升序排列。 接下来 $q$ 行：每行包含一个整数 $k$，表示一个查询元素。 数据范围 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n输出格式 # 对每个查询，在一行里输出该元素在数组中的起始和结束位置。如果数组中不存在该元素，则输出 -1 -1。\n样例：\n输入： 6 3 1 2 2 3 3 4 3 4 5 输出： 3 4 5 5 -1 -1 解释：\n元素 $3$ 出现的范围为 $[3, 4]$； 元素 $4$ 只出现了一次，在位置 $5$； 元素 $5$ 在数组里不存在，因此返回 $-1$ $-1$。 解答 # 找「起始位置」： 即找第一个大于等于 $k$ 的位置。可以把数组分成两部分：\n左边所有数都「小于」 $k$ 右边所有数都「大于等于」 $k$ 答案为右边的第一个位置 找「终止位置」： 即找最后一个小于等于 $k$ 的位置。可以把数组分成两部分：\n左边所有数都「小于等于」 $k$ 右边所有数都「大于」 $k$ 答案为左边的最后一个位置 推荐模板 # 下面是一种优雅且不易犯错的二分模板。\n定义两个指针 $l, r$，有不变量：闭区间 $[0, l]$ 都属于左半部分，闭区间 $[r, n - 1]$ 都属于右半部分。$l$ 和 $r$ 都初始化为 $-1$ 和 $n$。\n算法终止时，$l$ 和 $r$ 相邻，分别指向左半部分的最后一个元素和右半部分的第一个元素。\n因为我们想要的解可能不存在，所以如果题目没有说明一定存在解，我们需要判断一下 l 或 r 是否越界，是否指向正确的值。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. 找 k 的起始位置 15 // 将数组分成两部分，左边都 \u0026lt; k，右边都 \u0026gt;= k。 16 // 答案为右半部分的最小下标。 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // 如果 r 越界或者 nums[r] != k，说明不存在 k 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. 找 k 的终止位置 33 // 将数组分成两部分，左边都 \u0026lt;= k，右边都 \u0026gt; k。 34 // 答案为左半部分的最大下标。 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} 优势 # 这个写法有严格定义的不变量。 它同时适用于找「起始位置」和「终止位置」两种情况，不需要额外的处理和变化。 有一些写法使用 l == r 作为终止条件。当 $l$ 和 $r$ 相差 $1$ 时，会计算出 $mid$ 和 $l$ 或 $r$ 相等。如果没有正确处理，更新 $l$ 或 $r$ 为 $mid$，搜索区间没有缩小，会导致死循环。相反地，这里的写法在 $l$ 和 $r$ 相邻时终止，保证 $mid$ 小于 $l$ 且大于 $r$，更新 $l$ 或 $r$ 时搜索区间一定会缩小。 STL # 如果使用 C++ STL 提供的 lower_bound 和 upper_bound 函数，也能完成同样的事情：\nlower_bound(first, last, val) 会返回「第一个大于等于 val 的位置」 upper_bound(first, last, val) 会返回「第一个大于 val 的位置」 举个例子，假设 nums = {1,2,3,4,4,4,4,4,5,5,6}，我们想知道 4 出现的区间：\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 指向第一个值大于等于 $4$ 的位置。 it2 指向第一个值大于 $4$ 的位置。\n所以 it2 - it1 就是 $4$ 在数组中出现的次数；it2 - nums.begin() - 1 就是 $4$ 的右边界的位置。 补充 # 二分搜索还可以扩展到浮点数范围的搜索（如求方程根）、以及三分搜索求单峰函数的最值。\n练习 # LeetCode 33. Search in Rotated Sorted Array\n提示：第一步使用二分搜索找到旋转点，第二步再使用二分搜索找到目标值。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"如何优雅地实现二分搜索算法。","title":"二分搜索","type":"posts"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"2024年12月20日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/distributed-consensus-algorithm/","section":"Tags","summary":"","title":"Distributed Consensus Algorithm","type":"tags"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/distributed-system/","section":"Tags","summary":"","title":"Distributed System","type":"tags"},{"content":"","date":"20 December 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"2024年12月20日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月20日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分布式一致性算法","type":"tags"},{"content":"","date":"2024年12月20日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]