[{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":" İkili Arama # Sıralı bir dizide belirli bir elemanı aramak için ikili arama kullanılabilir. Doğrusal aramanın $O(n)$ zaman karmaşıklığına kıyasla, ikili arama sadece $O(\\log n)$ zaman gerektirir, bu nedenle büyük veri boyutlarında çok verimlidir.\nİkili Aramanın Temel Düşüncesi # İkili aramanın temel fikri, arama aralığını sürekli olarak ikiye bölmektir. Her karşılaştırmada, orta nokta elemanının hedef değerden büyük veya küçük olup olmadığı kontrol edilir. Orta nokta elemanı koşulu karşılamıyorsa, aralığın yarısı elenebilir; aksi takdirde, diğer yarısında aramaya devam edilir. Her seferinde arama aralığının yarısı atıldığı için arama zaman karmaşıklığı $O(\\log n)$\u0026lsquo;e ulaşabilir.\n\u0026ldquo;Mümkün çözümlerin sıralı bir aralığa (koşulu sağlayan) ve başka bir sıralı aralığa (koşulu sağlamayan) bölünebildiği\u0026rdquo; problemler için ikili arama çok kullanışlıdır. Örneğin:\nSıralı bir dizide belirli bir elemanın var olup olmadığını bulma Belirli bir sayının \u0026ldquo;ilk konumunu\u0026rdquo; veya \u0026ldquo;son konumunu\u0026rdquo; bulma Örnek Problem: Elemanların Başlangıç ve Bitiş Konumlarını Bulma # Problem Tanımı:\nUzunluğu $n$ olan sıralı bir tamsayı dizisi ve $q$ tane sorgu verilmiştir. Her sorgu bir $k$ tamsayısı verir. Dizide $k$\u0026lsquo;nin \u0026ldquo;başlangıç konumunu\u0026rdquo; ve \u0026ldquo;bitiş konumunu\u0026rdquo; bulmamız gerekir (indeksler 0\u0026rsquo;dan başlar). Eğer dizide bu sayı yoksa $-1$ $-1$ döndürün.\nGiriş Formatı:\nİlk satır: Dizi uzunluğunu ve sorgu sayısını temsil eden iki tamsayı $n$ ve $q$. İkinci satır: Tam diziyi temsil eden $n$ tane tamsayı (1 ~ 10000 aralığında), artan sırada sıralanmıştır. Sonraki $q$ satır: Her satır bir sorgu elemanı temsil eden bir $k$ tamsayısı içerir. Çıkış Formatı:\nHer sorgu için, elemanın dizideki başlangıç ve bitiş konumlarını bir satırda çıktı olarak verin. Eğer dizide böyle bir eleman yoksa, çıktı olarak $-1$ $-1$ verin.\nÖrnek:\nGiriş: 6 3 1 2 2 3 3 4 3 4 5 Çıkış: 3 4 5 5 -1 -1 Açıklama:\n3 elemanının aralığı [3, 4]\u0026lsquo;dür. 4 elemanı sadece bir kez, 5. konumda görünür. 5 elemanı dizide yoktur, bu nedenle -1 -1 döndürülür. İkili Aramanın Uygulama Düşüncesi # Bu problemde, bir değerin \u0026ldquo;sol sınırını\u0026rdquo; ve \u0026ldquo;sağ sınırını\u0026rdquo; bulmak için ikili aramaya güvenebiliriz. Önemli olan, arama aralığını nasıl tanımlayacağımızı ve karşılaştırma sonuçlarına göre işaretçileri nasıl hareket ettireceğimizi anlamaktır.\n\u0026ldquo;Sol Sınır\u0026quot;ı Bulma:\nYani, $k$\u0026lsquo;ye eşit veya ondan büyük ilk konumu bulma. Dizi iki kısma ayrılabilir:\nSoldaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya ondan büyüktür\u0026rdquo; \u0026ldquo;Sağ Sınır\u0026quot;ı Bulma:\nYani, $k$\u0026lsquo;ye eşit veya ondan küçük son konumu bulma. Dizi iki kısma ayrılabilir:\nSoldaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya ondan küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;büyüktür\u0026rdquo; Bu iki aralığı doğru bir şekilde koruyabildiğimiz sürece, ikili arama yoluyla hızlı bir şekilde sonuca ulaşabiliriz.\nÖnerilen Şablon: Sonsuz Döngüden Kaçınan İkili Arama Yazımı # Aşağıda zarif ve hataya yatkın olmayan bir ikili arama şablonu bulunmaktadır. $l$ ve $r$\u0026lsquo;nin adım adım yakınlaşmasını sağlayarak döngünün ikisi yan yana geldiğinde mutlaka sona ermesini garanti eder:\nİki işaretçi $l$ ve $r$ tanımlayın, değişmez şu şekilde olsun: kapalı aralık $[0, l]$ sol yarıya aittir ve kapalı aralık $[r, n - 1]$ sağ yarıya aittir. $l$ ve $r$ başlangıçta $-1$ ve $n$ olarak başlatılır.\nAlgoritma sona erdiğinde $l$ ve $r$ bitişiktir; sırasıyla sol yarıdaki maksimum değeri ve sağ yarıdaki minimum değeri gösterirler.\nİstediğimiz çözüm mevcut olmayabileceğinden, $l$ veya $r$ döndürülürken, ilgili değerin istediğimiz değer olup olmadığını ve sınırları aşıp aşmadığını kontrol etmemiz gerekir. Örneğin, $l$, $\\leq k$\u0026lsquo;nin maksimum değerini temsil eder ve l != -1 \u0026amp;\u0026amp; nums[l] == k kontrol etmemiz gerekir.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. k\u0026#39;nin başlangıç konumunu (sol sınırı) bulma // Diziyi iki kısma ayırın, solda \u0026lt; k olanlar, sağda \u0026gt;= k olanlar. // Sol sınır, sağ kısmın minimum indeksidir. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Eğer r sınırı aşıyorsa veya nums[r] != k ise, k\u0026#39;nin olmadığını gösterir. if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // k\u0026#39;nin sol sınırını kaydet // 2. k\u0026#39;nin bitiş konumunu (sağ sınırı) bulma // Diziyi iki kısma ayırın, solda \u0026lt;= k olanlar, sağda \u0026gt; k olanlar. // Sağ sınır, sol kısmın maksimum indeksidir. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // k\u0026#39;nin varlığını zaten kontrol ettiğimiz için burada tekrar kontrol etmeye gerek yok. int rightPos = l; // Sağ sınır cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Neden böyle yazmak hataya daha az yatkındır? # Bu yazımın kesin tanımlanmış değişmezleri vardır. Hem sol sınırı hem de sağ sınırı bulabilir, bu nedenle tüm senaryolara uygulanabilir. Bazı yazımlar $l == r$\u0026lsquo;yi bitiş koşulu olarak kullanır. $l$ ve $r$ arasındaki fark 1 olduğunda, $mid$ değeri $l$ veya $r$\u0026lsquo;ye eşit hesaplanır. Doğru şekilde işlenmezse, l veya r\u0026lsquo;yi mid olarak güncellemek arama aralığını daraltmaz ve sonsuz döngüye neden olur. Bunun yerine, buradaki yazım $l$ ve $r$ bitişik olduğunda sonlanır ve bu sorunu önler. STL Çözümü: lower_bound ve upper_bound # Eğer C++ STL tarafından sağlanan lower_bound ve upper_bound işlevlerini kullanırsanız, aynı şeyi kolayca yapabilirsiniz:\nlower_bound(first, last, val) \u0026ldquo;val\u0026rsquo;e eşit veya ondan büyük ilk konumu\u0026rdquo; döndürür. upper_bound(first, last, val) \u0026ldquo;val\u0026rsquo;den büyük ilk konumu\u0026rdquo; döndürür. Örneğin, nums = {1,2,3,4,4,4,4,4,5,5,6} olduğunu ve 4\u0026rsquo;ün göründüğü aralığı bilmek istediğimizi varsayalım:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Dizi içinde 4 yok demektir cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; } it1, 4\u0026rsquo;e eşit veya 4\u0026rsquo;ten büyük ilk değerin konumunu gösterir. it2, 4\u0026rsquo;ten büyük ilk değerin konumunu gösterir.\nBu nedenle it2 - it1, 4\u0026rsquo;ün dizide kaç kez göründüğüdür; it2 - nums.begin() - 1, 4\u0026rsquo;ün sağ sınırıdır. Bu iki fonksiyon, aralıkları ararken veya görünme sayısını sayarken özellikle kullanışlıdır.\nEk # İkili arama, kayan nokta aralıklarında (denklemlerin köklerini bulmak gibi) ve tek modlu bir fonksiyonun maksimum değerini bulmak için üçlü arama olarak genişletilebilir. \u0026ldquo;Sıralı bir aralıkta her seferinde yarısını eleyebiliyorum\u0026rdquo; şeklindeki temel ilkeyi anladığınız sürece, ikili aramanın birçok durumda sorunları verimli bir şekilde çözmenize yardımcı olabileceğini göreceksiniz.\nEv Ödevi # LeetCode 33. Search in Rotated Sorted Array\nİpucu: İlk adımda dönme noktasını bulmak için ikili aramayı kullanın, ikinci adımda hedef değeri bulmak için tekrar ikili aramayı kullanın.\n","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"İkili Arama","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series","type":"series"}]