[{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":" Hızlı Sıralama # Hızlı sıralama, karşılaştırmaya dayalı, kararlı olmayan bir sıralama algoritmasıdır. Böl ve fethet yaklaşımını kullanır. Ortalama zaman karmaşıklığı $O(n\\log n)$\u0026lsquo;dir, en kötü durumda $O(n^2)$\u0026lsquo;dir ve uzay karmaşıklığı $O(1)$\u0026lsquo;dir. Aşağıda, bir tamsayı dizisini küçükten büyüğe sıralama örneği üzerinden uygulama detayları ve yaygın hatalar tanıtılmaktadır.\nProblem Tanımı # Verilen $n$ uzunluğunda bir tamsayı dizisini, hızlı sıralama kullanarak küçükten büyüğe sıralayın ve sonucu çıktı olarak verin.\nGiriş Formatı # İlk satırda $n$ tamsayısı girilir. İkinci satırda $[1,10^9]$ aralığında $n$ adet tamsayı girilir. Çıkış Formatı # Sıralanmış diziyi tek satırda çıktı olarak verin. Veri Aralığı # $1 \\leq n \\leq 100000$\nGiriş Örneği # 5 3 1 2 4 5 Çıkış Örneği # 1 2 3 4 5 Hızlı Sıralama Yaklaşımı # Hızlı sıralama, her bölme adımında bir sayı seçerek pivot (aşağıda orta konumdaki sayı seçilmiştir) olarak kullanır.\nSol işaretçi L soldan sağa doğru pivot\u0026lsquo;a eşit veya büyük ilk sayıyı ararken, sağ işaretçi R sağdan sola doğru pivot\u0026lsquo;a eşit veya küçük ilk sayıyı arar ve ardından bu iki sayı yer değiştirir.\nBu işlem, sol işaretçi ve sağ işaretçi çakışana veya sol işaretçi sağ işaretçiden bir pozisyon büyük olana kadar tekrar edilir. Bu, bir döngü olarak adlandırılır.\nHer işaretçi hareketi ve yer değiştirme işleminden sonra, \u0026ldquo;sol kısım ≤ pivot, sağ kısım ≥ pivot\u0026rdquo; yapısının bozulmadığı, yani [left, L) \u0026lt;= pivot ve (R, right] \u0026gt;= pivot değişmezlerinin korunduğu garanti edilir.\nAşağıdaki örnek kodda, left ve right mevcut işlenen kapalı aralığın sınırlarıdır ve pivot aralığın orta noktasındaki elemanı alır.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Karmaşıklık ve pivot Seçimi # Hızlı sıralamanın en kötü durumda $O(n^2)$ karmaşıklığına sahip olması nedeniyle, pivot seçimi çok önemlidir. Her zaman ilk veya son elemanı seçmek, neredeyse sıralı dizilerde büyük olasılıkla en kötü durumun ortaya çıkmasına neden olacaktır.\nOrta konumdaki elemanı seçmenin yanı sıra, pivot olarak rastgele bir eleman seçilebilir veya sol, orta ve sağdaki üç elemanın medyanı pivot olarak alınabilir.\nYaygın Hata Örnekleri # Aşağıdaki kod, birkaç yaygın hatayı içermektedir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Hata Analizi:\npivot, dizideki bir sayı olmalıdır, indeks değil. Sırasıyla \u0026lt;= ve \u0026gt;= yerine \u0026lt; ve \u0026gt; kullanmak, sol işaretçinin sağ işaretçiyi birden fazla pozisyon geçmesine neden olabilir, bu da diziyi iki parçaya ayıramaz. l \u0026gt;= r bulunduktan sonra, döngüden hemen çıkılmalıdır ve yer değiştirme işlemi yapılmamalıdır. Aksi takdirde, sol taraftaki elemanların pivot\u0026lsquo;tan büyük olmadığı ve sağ taraftaki elemanların pivot\u0026lsquo;tan küçük olmadığı garanti edilemez. Her yer değiştirme işleminden sonra l++ ve r-- işlemleri yapılmalıdır. pivot aslında ortanın solundaki sayıyı alır. Bu nedenle, diziyi $l - 1$ ve $l$ kullanarak bölerseniz, [1, 2] dizisi için sonsuz döngüye yol açacağı ve diziyi sürekli olarak 0 ve 2 boyutlarında iki parçaya ayıracağı kolayca görülebilir. Benzer şekilde, diziyi $r$ ve $l$ kullanarak ayırmak da işe yaramaz. Aksine, bir döngü bittiğinde, $r$ kesinlikle $right$\u0026lsquo;tan küçük olacaktır, bu nedenle diziyi $r$ ve $r+1$ kullanarak bölebilirsiniz. Okuyucu, algoritma sürecini simüle ederek nedenini görebilir. Sonsuz döngüden kaçınmanın bir başka basit yolu da rastgele bir pivot seçmek veya yalnızca iki eleman olduğunda özel işlem yapmaktır. Ayrıca, $l$, $l+1$ kullanmak da işe yaramaz, çünkü bu bölme tanıma uygun değildir. $r$\u0026lsquo;nin $l$\u0026lsquo;nin solunda olduğu durumda, $l$, $l+1$ kullanmak diziyi doğru şekilde sol tarafı pivot\u0026lsquo;a eşit veya küçük ve sağ tarafı pivot\u0026lsquo;a eşit veya büyük olacak şekilde iki parçaya ayıramaz. Bu problem, dizinin boş olmadığını varsayar, bu nedenle \u0026gt; durumu yoktur. Ancak, daha güvenli olması için \u0026gt;= kullanılması önerilir. Ek Bilgiler # Hızlı sıralama, $O(n)$ beklenen sürede sıralanmamış bir dizideki $k$\u0026lsquo;inci en küçük sayıyı bulmak için \u0026ldquo;hızlı seçim\u0026quot;e de dönüştürülebilir. Temel fikir hızlı sıralamaya benzer, ancak her seferinde yalnızca bir alt aralıkta özyinelemeli olarak devam ederek zaman karmaşıklığını azaltır.\n","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Hızlı sıralama algoritmasının doğru şekilde uygulanmasının anahtar noktalarının analizi.","title":"Hızlı Sıralama","type":"posts"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":" Problem # https://www.acwing.com/problem/content/2/\n$N$ tane eşya var. $i$. eşyanın hacmi $s_i$, değeri $v_i$. Her eşya sadece bir kez alınabilir. Toplam hacim limiti $S$\u0026lsquo;yi aşmamak koşuluyla, elde edilebilecek maksimum toplam değer $V$\u0026lsquo;yi bulun.\nGiriş Formatı # İlk satırda iki tam sayı, $N$ ve $S$, boşlukla ayrılmış olarak verilir. Bunlar sırasıyla eşya sayısını ve maksimum toplam hacim limitini temsil eder. Sonraki $N$ satırda, her satırda iki tam sayı $s_i$ ve $v_i$, boşlukla ayrılmış olarak verilir. Bunlar sırasıyla $i$. eşyanın hacmini ve değerini temsil eder.\nÇıkış Formatı # Maksimum değeri temsil eden bir tam sayı yazdırın.\nVeri Aralığı # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Giriş Örneği # 4 5 1 2 2 4 3 4 4 5 Çıkış Örneği # 8 Çözüm # Durum Tanımı: f[i][j] ifadesi, ilk $i$ eşya için, hacim limiti $j$ olduğunda elde edilebilecek maksimum değeri temsil eder. Eğer $i$. eşya alınmazsa, f[i][j] = f[i - 1][j] olur. Eğer $i$. eşya alınırsa, f[i][j] = f[i - 1][j - s[i]] + v[i] olur. Durum geçişini uygularken, tanım aralığına dikkat edilmelidir. Eğer $j \u003c s_i$ ise, $i$. eşyanın alınması durumu dikkate alınmaz. Çünkü $j-s_i$ negatif olursa, dizi indeksi geçersiz olur. Bunu şöyle de açıklayabiliriz: $i$. eşyanın hacmi, hacim limitinden büyük olduğu için alınması mümkün değildir. Başlangıç Koşulu Tanımı: İlk $0$ eşya için, herhangi bir hacim limitinde elde edilecek değer $0$\u0026lsquo;dır, yani f[0][j] = 0, j $\\in [0, S]$. Zaman Karmaşıklığı: $O(NS)$. Kod # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Bir Boyutlu DP Optimizasyonu # İki boyutlu diziyi bir boyutlu diziye sıkıştırmak, önemli ölçüde yer tasarrufu sağlayabilir ve çalışma hızını bir miktar artırabilir (dezavantajı, bazı problem türlerinin özel gereksinimlerini karşılayamamasıdır). Durum geçişinde, f[i][j]\u0026lsquo;nin sadece f[i - 1][j] ve f[i - 1][j - s[i]] ile ilgili olduğuna dikkat edin. Başka bir deyişle, koddaki iki boyutlu f dizisinde, f[i][j] sadece bir önceki satırda kendisinden daha solda veya aynı sütunda bulunan elemanlarla ilgilidir. Bu nedenle, iki boyutlu dizi bir boyutlu diziye veya kayan diziye sıkıştırılabilir. Aşağıdaki kodda, ikinci döngünün ters sırada dolaştığına dikkat edin. Bunun nedeni, f[i][j]\u0026lsquo;yi hesaplarken, f[i - 1][j - s[i]]\u0026lsquo;nin henüz güncellenmemiş olmasını garanti etmektir. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Eğer Çözüm Sayısı İstenirse # Sadece elde edilebilecek maksimum toplam değeri değil, aynı zamanda \u0026ldquo;bu maksimum toplam değere ulaşabilecek kaç farklı seçim yöntemi olduğunu\u0026rdquo; da çıktı olarak vermeniz gerekiyorsa. Aşağıda, 01 sırt çantası probleminde çözüm sayısının nasıl hesaplanacağı anlatılmaktadır.\nhttps://www.acwing.com/problem/content/11/\nİki Boyutlu DP ile Çözüm Sayısını Hesaplama # Aşağıda, iki boyutlu DP örneği üzerinden anlatım yapılmaktadır.\nDurum Tanımı:\ndp[i][j] ifadesi, \u0026ldquo;ilk i eşya için, kapasite (hacim limiti) j olduğunda, elde edilebilecek maksimum değeri\u0026rdquo; temsil eder. ways[i][j] ifadesi, \u0026ldquo;ilk i eşya için, kapasite j olduğunda, maksimum değere ulaşıldığında karşılık gelen çözüm sayısını\u0026rdquo; temsil eder. Durum Geçişi:\nEğer i. eşya seçilmezse: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Eğer i. eşya seçilirse (ön koşul $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Seçme veya seçmeme durumunda, sonuç olarak dp[i][j] ikisinin daha büyük olanını almalıdır: Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ ise, bu \u0026ldquo;i. eşyayı seçmenin\u0026rdquo; daha büyük bir değer sağladığı anlamına gelir: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ ise, bu iki yöntemin de aynı maksimum değeri sağladığı anlamına gelir, bu durumda çözüm sayıları toplanmalıdır: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ ise, bu \u0026ldquo;i. eşyayı seçmemenin\u0026rdquo; daha büyük bir değer sağladığı anlamına gelir, çözüm sayısı seçmeme durumundaki çözüm sayısını devralır: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Başlangıç Koşulları:\ndp[0][j] = 0 ifadesi, ilk 0 eşya için, herhangi bir kapasitede elde edilecek maksimum değerin 0 olduğunu gösterir. ways[0][0] = 1 ifadesi, \u0026ldquo;ilk 0 eşya, kapasite 0\u0026rdquo; durumunun bir geçerli çözüm olduğunu (yani hiçbir şey seçmemek) ve çözüm sayısının 1 olarak ayarlandığını gösterir. j \u0026gt; 0 için, seçilebilecek eşya olmadığında ve kapasite 0\u0026rsquo;dan büyük olduğunda, herhangi bir pozitif değer elde etmek mümkün değildir, bu duruma karşılık gelen çözüm sayısı 0\u0026rsquo;dır, yani ways[0][j] = 0. Son Cevap:\ndp[N][S] maksimum değeri verir. ways[N][S] bu maksimum değere ulaşan çözüm sayısını verir. Zaman Karmaşıklığı: $O(NS)$. Bu problem, bir boyutlu DP ile de optimize edilebilir. Eğer Hacim Limitine Tam Olarak Ulaşılması İstenirse # Durum Tanımı: f[i][j] ifadesi, ilk i eşya için tam olarak $j$ hacmine sahip olmanın maksimum değerini temsil eder. Eğer i. eşya alınmazsa, f[i][j] = f[i - 1][j] olur. Eğer i. eşya alınırsa, f[i][j] = f[i - 1][j - s[i]] + v[i] olur. Orijinal problemdeki durum geçişiyle aynı olduğuna dikkat edilebilir. Ancak başlangıç koşulları farklıdır. f[0][0] = 0 dışında, diğer f[0][j] = $-\\infty$, j $\\in [1, S]$ olur. $-\\infty$ imkansız bir durumu temsil eder. Eğer Hacim Limiti $S$ Çok Büyük (1e9) ve Eşya Sayısı $N$ ve Maksimum Toplam Değer $V$ Küçükse # Bu tür problemler için, karmaşıklığı $O(NV)$ olan bir çözüm vardır. Durum Tanımı: f[i][j] ifadesi, ilk i eşyadan bazılarını seçerek, toplam değeri tam olarak j olan minimum hacmi temsil eder. Eğer i. eşya alınmazsa, f[i][j] = f[i - 1][j] olur. Eğer i. eşya alınırsa, f[i][j] = f[i - 1][j - v[i]] + s[i] olur. İkisinin minimum değeri alınır. Başlangıç Koşulları: f[0][0] = 0, diğer f[0][j] = $\\infty$, j $\\in [1, V]$ olur. $\\infty$ imkansız bir durumu temsil eder. $-\\infty$ değil. Son cevap, f[N][j] içinde f[N][j] \u0026lt;= S olacak şekildeki en büyük j değeridir. Eğer Hacim Limiti $S$ ve Tekil Eşya Değeri $v_i$ Çok Büyükse (1e9 mertebesinde) ve Eşya Sayısı $N$ Çok Küçükse (en fazla 40) # https://www.acwing.com/solution/content/38250/\n$N \\leq 20$ olduğunda, tüm alt kümeleri doğrudan kaba kuvvetle sayabilirsiniz (zaman karmaşıklığı $O(2^N)$). $N \\leq 40$ olduğunda, $2^{40}$ $10^{12}$ mertebesinde olduğundan, doğrudan kaba kuvvet de oldukça büyük olacaktır, bu nedenle ortadan ikiye bölme araması kullanılabilir. Bu, karmaşıklığı kabaca $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$\u0026lsquo;ye düşürür. Bu, kabul edilebilir bir süre içinde tamamlanabilir. ","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"En temel klasik sırt çantası problemi.","title":"01 Sırt Çantası Problemi","type":"posts"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"Sıralı bir çözüm uzayı iki parçaya ayrıldığında, bir parça bir koşulu sağlarken diğeri sağlamıyorsa, sıralı çözüm uzayındaki kritik noktayı bulmak için ikili arama kullanılabilir.\nİkili aramanın temel fikri, arama aralığını tekrar tekrar yarıya indirmektir. Her seferinde orta eleman kontrol edilir. Orta eleman koşulu sağlamıyorsa, aralığın yarısı elenebilir; aksi takdirde, arama diğer yarısında devam eder. Her seferinde arama aralığının yarısı atıldığı için, arama zaman karmaşıklığı $O(\\log n)$\u0026lsquo;ye ulaşabilir.\nÖrnek Problem # Problem Açıklaması: Uzunluğu $n$ olan artan sıralı bir tamsayı dizisi ve $q$ sorgu veriliyor. Her sorgu bir tamsayı $k$ verir ve dizideki $k$\u0026lsquo;nin \u0026ldquo;başlangıç pozisyonunu\u0026rdquo; ve \u0026ldquo;bitiş pozisyonunu\u0026rdquo; bulmamız gerekir (indeksler 0\u0026rsquo;dan başlar). Sayı dizide yoksa, -1 -1 döndürün.\nGiriş Formatı # İlk satır: dizinin uzunluğunu ve sorgu sayısını temsil eden iki tamsayı $n$ ve $q$. İkinci satır: artan sırada sıralanmış tam diziyi temsil eden $n$ tamsayı. Sonraki $q$ satır: her satır bir sorgu elemanını temsil eden bir tamsayı $k$ içerir. Veri Aralığı # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nÇıkış Formatı # Her sorgu için, dizideki elemanın başlangıç ve bitiş pozisyonlarını tek bir satırda çıktılayın. Eleman dizide yoksa, -1 -1 çıktılayın.\nÖrnek:\nGiriş: 6 3 1 2 2 3 3 4 3 4 5 Çıkış: 3 4 5 5 -1 -1 Açıklama:\n$3$ elemanının göründüğü aralık $[3, 4]$\u0026lsquo;tür; $4$ elemanı yalnızca bir kez, $5$ pozisyonunda görünür; $5$ elemanı dizide yok, bu yüzden $-1$ $-1$ döndürülür. Çözüm # \u0026ldquo;Başlangıç Pozisyonunu\u0026rdquo; Bulma: Yani, $k$\u0026lsquo;ye eşit veya büyük olan ilk pozisyonu bulmak. Dizi iki parçaya ayrılabilir:\nSoldaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya büyüktür\u0026rdquo; Cevap, sağdaki ilk pozisyondur \u0026ldquo;Bitiş Pozisyonunu\u0026rdquo; Bulma: Yani, $k$\u0026lsquo;ye eşit veya küçük olan son pozisyonu bulmak. Dizi iki parçaya ayrılabilir:\nSoldaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;büyüktür\u0026rdquo; Cevap, soldaki son pozisyondur Önerilen Şablon # Aşağıda zarif ve daha az hataya yatkın bir ikili arama şablonu bulunmaktadır.\nİki işaretçi $l, r$ tanımlayın, değişmez: kapalı aralık $[0, l]$ sol parçaya aittir ve kapalı aralık $[r, n - 1]$ sağ parçaya aittir. $l$ ve $r$ sırasıyla $-1$ ve $n$ olarak başlatılır.\nAlgoritma sona erdiğinde, $l$ ve $r$ bitişiktir, sırasıyla sol parçanın son elemanına ve sağ parçanın ilk elemanına işaret eder.\nİstediğimiz çözüm mevcut olmayabileceğinden, problem kesinlikle bir çözümün var olduğunu belirtmiyorsa, l veya r\u0026lsquo;nin sınırların dışında olup olmadığını ve doğru değere işaret edip etmediğini kontrol etmemiz gerekir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k\u0026#39;nin başlangıç pozisyonunu bul 15 // Diziyi iki parçaya ayır, sol parça tümü \u0026lt; k, ve sağ parça tümü \u0026gt;= k. 16 // Cevap, sağ parçanın en küçük indeksidir. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Eğer r sınırların dışındaysa veya nums[r] != k ise, bu k\u0026#39;nin mevcut olmadığı anlamına gelir 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k\u0026#39;nin bitiş pozisyonunu bul 33 // Diziyi iki parçaya ayır, sol parça tümü \u0026lt;= k, ve sağ parça tümü \u0026gt; k. 34 // Cevap, sol parçanın en büyük indeksidir. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Avantajları # Bu yaklaşımın kesin olarak tanımlanmış değişmezleri vardır. Ek bir işlem veya değişiklik olmadan hem \u0026ldquo;başlangıç pozisyonunu\u0026rdquo; hem de \u0026ldquo;bitiş pozisyonunu\u0026rdquo; bulmaya uygulanır. Bazı yaklaşımlar l == r\u0026lsquo;yi sonlandırma koşulu olarak kullanır. $l$ ve $r$ 1 farkla ayrıldığında, $mid$, $l$ veya $r$\u0026lsquo;ye eşit olacak şekilde hesaplanır. Doğru şekilde ele alınmazsa, $l$ veya $r$\u0026lsquo;yi $mid$\u0026lsquo;e güncellemek arama aralığını daraltmaz ve sonsuz döngüye yol açar. Buna karşılık, bu yaklaşım $l$ ve $r$ bitişik olduğunda sona erer, bu da $mid$\u0026lsquo;in $l$\u0026lsquo;den küçük ve $r$\u0026lsquo;den büyük olmasını sağlar ve $l$ veya $r$\u0026lsquo;yi güncellemek her zaman arama aralığını daraltır. STL # C++ STL tarafından sağlanan lower_bound ve upper_bound fonksiyonlarını kullanırsanız, aynı şeyi elde edebilirsiniz:\nlower_bound(first, last, val) \u0026ldquo;val\u0026rsquo;e eşit veya büyük olan ilk pozisyonu\u0026rdquo; döndürür upper_bound(first, last, val) \u0026ldquo;val\u0026rsquo;den büyük olan ilk pozisyonu\u0026rdquo; döndürür Örneğin, nums = {1,2,3,4,4,4,4,4,5,5,6} olduğunu ve 4\u0026rsquo;ün göründüğü aralığı bilmek istediğimizi varsayalım:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4, 0 kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;ilk 4, \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;son 4, \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4, \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1, değerin $4$\u0026lsquo;e eşit veya büyük olduğu ilk pozisyona işaret eder. it2, değerin $4$\u0026lsquo;ten büyük olduğu ilk pozisyona işaret eder. Bu nedenle, it2 - it1, $4$\u0026lsquo;ün dizide kaç kez göründüğüdür; it2 - nums.begin() - 1, $4$\u0026lsquo;ün sağ sınırının pozisyonudur. Ek Notlar # İkili arama, kayan noktalı aralıklarda arama yapmak (örneğin, bir denklemin köklerini bulmak gibi) ve tek modlu fonksiyonların ekstremalarını bulmak için üçlü arama yapmak için de genişletilebilir.\nAlıştırma # LeetCode 33. Rotated Sorted Array\u0026rsquo;de Arama\nİpucu: Önce, dönme noktasını bulmak için ikili arama kullanın ve ardından hedef değeri bulmak için ikili arama kullanın.\n","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"İkili arama algoritmasının zarif bir şekilde nasıl uygulanacağı.","title":"İkili Arama","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/las-nueve-lecciones-de-la-mochila/","section":"Series","summary":"","title":"Las Nueve Lecciones De La Mochila","type":"series"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]