[{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":" İkili Arama # Eğer sıralı bir çözüm uzayı, bir kısmı koşulu sağlayan ve diğer kısmı sağlamayan iki bölüme ayrılıyorsa, bu sıralı çözüm uzayında kritik noktayı bulmak için ikili arama kullanılabilir.\nİkili aramanın temel fikri, arama aralığını sürekli olarak ikiye bölmektir. Her seferinde orta noktadaki elemanı kontrol ederiz. Eğer orta nokta elemanı koşulu sağlamazsa, aralığın yarısını eleriz; aksi takdirde, diğer yarıda aramaya devam ederiz. Her seferinde arama aralığının yarısı atıldığı için, arama zaman karmaşıklığı \\(O(\\log n)\\) seviyesine ulaşır.\nÖrnek Problem # Problem Tanımı:\n\\(n\\) uzunluğunda artan sırada sıralanmış bir tamsayı dizisi ve \\(q\\) sorgu verildiğinde. Her sorguda bir tamsayı \\(k\\) verilir ve dizide \\(k\\) değerinin \u0026ldquo;başlangıç pozisyonunu\u0026rdquo; ve \u0026ldquo;bitiş pozisyonunu\u0026rdquo; bulmamız gerekir (indeksler 0\u0026rsquo;dan başlar). Eğer dizide bu sayı yoksa, \\(-1\\) \\(-1\\) döndürülmelidir.\nGiriş Formatı # İlk satır: İki tamsayı \\(n\\) ve \\(q\\), sırasıyla dizi uzunluğunu ve sorgu sayısını belirtir. İkinci satır: Tam diziyi temsil eden, artan sırada sıralanmış \\(n\\) adet tamsayı. Sonraki \\(q\\) satır: Her satırda bir sorgu elemanını temsil eden bir tamsayı \\(k\\) bulunur. Veri Aralığı # \\(1 \\leq n \\leq 100000\\)\n\\(1 \\leq q \\leq 10000\\)\n\\(1 \\leq k \\leq 10000\\)\nÇıkış Formatı # Her sorgu için, dizideki elemanın başlangıç ve bitiş pozisyonlarını tek bir satırda yazdırın. Eğer eleman dizide bulunmuyorsa, -1 -1 çıktısını verin.\nÖrnek:\nGiriş: 6 3 1 2 2 3 3 4 3 4 5 Çıkış: 3 4 5 5 -1 -1 Açıklama:\n\\(3\\) elemanı \\([3, 4]\\) aralığında görünür; \\(4\\) elemanı sadece bir kez, \\(5\\) pozisyonunda görünür; \\(5\\) elemanı dizide bulunmadığı için, \\(-1\\) \\(-1\\) döndürülür. Çözüm # \u0026ldquo;Başlangıç Pozisyonunu\u0026rdquo; Bulmak: Yani, \\(k\\)\u0026lsquo;ye eşit veya ondan büyük olan ilk pozisyonu bulmak. Diziyi iki kısma ayırabiliriz:\nSol taraftaki tüm sayılar \\(k\\)\u0026lsquo;den \u0026ldquo;küçüktür\u0026rdquo;. Sağ taraftaki tüm sayılar \\(k\\)\u0026lsquo;ye \u0026ldquo;eşit veya ondan büyüktür\u0026rdquo;. Cevap sağ tarafın ilk pozisyonudur. \u0026ldquo;Bitiş Pozisyonunu\u0026rdquo; Bulmak: Yani, \\(k\\)\u0026lsquo;ye eşit veya ondan küçük olan son pozisyonu bulmak. Diziyi iki kısma ayırabiliriz:\nSol taraftaki tüm sayılar \\(k\\)\u0026lsquo;ye \u0026ldquo;eşit veya ondan küçüktür\u0026rdquo;. Sağ taraftaki tüm sayılar \\(k\\)\u0026lsquo;den \u0026ldquo;büyüktür\u0026rdquo;. Cevap sol tarafın son pozisyonudur. Önerilen Şablon # Aşağıda zarif ve hataya yatkın olmayan bir ikili arama şablonu bulunmaktadır. \\(l\\) ve \\(r\\) işaretçilerini yavaşça birbirine yaklaştırarak döngünün kesinlikle birbirine komşu oldukları noktada sona ermesini sağlar:\nİki işaretçi \\(l, r\\) tanımlayın. Değişmezler: Kapalı aralık \\([0, l]\\) sol yarıya, kapalı aralık \\([r, n - 1]\\) sağ yarıya aittir. \\(l\\) ve \\(r\\) sırasıyla \\(-1\\) ve \\(n\\) olarak başlatılır.\nAlgoritma sona erdiğinde, \\(l\\) ve \\(r\\) birbirine komşu olacaktır; \\(l\\) sol yarının son elemanına ve \\(r\\) sağ yarının ilk elemanına işaret eder.\nİstediğimiz çözüm olmayabileceği için, eğer problemde çözümün kesinlikle var olduğu belirtilmiyorsa, l veya r\u0026lsquo;nin sınırları aşıp aşmadığını ve doğru değeri gösterip göstermediğini kontrol etmeliyiz.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k\u0026#39;nin başlangıç pozisyonunu bul 15 // Diziyi ikiye ayır, sol taraf \u0026lt; k, sağ taraf \u0026gt;= k. 16 // Cevap sağ tarafın en küçük indeksi. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Eğer r sınırları aşıyor veya nums[r] != k ise, k yok demektir. 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k\u0026#39;nin bitiş pozisyonunu bul 33 // Diziyi ikiye ayır, sol taraf \u0026lt;= k, sağ taraf \u0026gt; k. 34 // Cevap sol tarafın en büyük indeksi. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Neden Bu Şekilde Yazdık? # Bu yazım şeklinin kesin olarak tanımlanmış değişmezleri vardır. Hem \u0026ldquo;başlangıç pozisyonunu\u0026rdquo; hem de \u0026ldquo;bitiş pozisyonunu\u0026rdquo; bulma durumları için uygundur, ekstra işleme veya değişikliğe gerek yoktur. Bazı yazım şekilleri l == r koşulunu bitiş koşulu olarak kullanır. \\(l\\) ve \\(r\\) arasındaki fark \\(1\\) olduğunda, \\(mid\\) değeri \\(l\\) veya \\(r\\)\u0026lsquo;ye eşit hesaplanır. Eğer doğru şekilde işlenmezse, \\(l\\) veya \\(r\\)\u0026lsquo;yi \\(mid\\) olarak güncelleyerek arama aralığı küçülmez ve sonsuz bir döngüye yol açar. Aksine, buradaki yazım şekli \\(l\\) ve \\(r\\) komşu olduğunda sona erer, \\(mid\\) değerinin \\(l\\)\u0026lsquo;den küçük ve \\(r\\)\u0026lsquo;den büyük olmasını garantiler, \\(l\\) veya \\(r\\)\u0026lsquo;yi güncellerken arama aralığının kesinlikle küçülmesini sağlar. STL # C++ STL tarafından sağlanan lower_bound ve upper_bound fonksiyonlarını kullanarak da aynı şeyi yapabiliriz:\nlower_bound(first, last, val), \u0026ldquo;ilk değeri val\u0026rsquo;e eşit veya ondan büyük olan pozisyonu\u0026rdquo; döndürür. upper_bound(first, last, val), \u0026ldquo;ilk değeri val\u0026rsquo;den büyük olan pozisyonu\u0026rdquo; döndürür. Örnek olarak, nums = {1,2,3,4,4,4,4,4,5,5,6} olduğunu varsayalım ve 4\u0026rsquo;ün göründüğü aralığı bilmek istiyoruz:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4, 0 kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;ilk 4\u0026#39;ün yeri \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;son 4\u0026#39;ün yeri \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4, \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 değeri, ilk değeri \\(4\\)\u0026rsquo;e eşit veya ondan büyük olan konumu gösterir. it2 değeri, ilk değeri \\(4\\)\u0026lsquo;den büyük olan konumu gösterir. Bu nedenle, it2 - it1, dizideki \\(4\\)\u0026lsquo;ün görünme sayısıdır; it2 - nums.begin() - 1, \\(4\\)\u0026lsquo;ün sağ sınırıdır. Ek Bilgiler # İkili arama, kayan noktalı sayı aralığında (örneğin, denklem kökleri bulma) arama yapmak ve tek tepeli fonksiyonların en büyük değerini bulmak için de genişletilebilir. \u0026ldquo;Sıralı bir aralıkta, her seferinde yarısını eleyebilirsin\u0026rdquo; temel prensibini anladığın sürece, ikili aramanın birçok senaryoda sorunları verimli bir şekilde çözmene yardımcı olacağını göreceksin.\nAlıştırma # LeetCode 33. Search in Rotated Sorted Array\nİpucu: İlk adımda, dönüş noktasını bulmak için ikili arama kullanın, ikinci adımda hedef değeri bulmak için ikili arama kullanın.\n","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Tamsayı ikili arama algoritmasını nasıl zarif bir şekilde uygulayabiliriz.","title":"İkili Arama","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-dalgorithmes/","section":"Tags","summary":"","title":"Modèles D'algorithmes","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmi/","section":"Tags","summary":"","title":"Template Algoritmi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथ्म","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%81/","section":"Categories","summary":"","title":"एल्गोरिथ्म और डेटा संरचनाएँ","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथ्म टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series","type":"series"}]