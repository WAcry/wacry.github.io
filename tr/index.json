[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":" I. CAP Teoremi # 1.1 CAP Teoremi Nedir? # CAP teoremi, Eric Brewer tarafından 2000 yılında ortaya atılmıştır ve temel görüşü şudur:\nC (Consistency, Tutarlılık): Sistemdeki tüm düğümlerin aynı anda gördüğü verilerin aynı olmasıdır. Daha katı bir ifadeyle, bir istemci veri okuduğunda, hangi kopyadan okursa okusun, sonuç en son gönderilen verilerle tutarlı olmalıdır (genellikle güçlü tutarlılık/doğrusal tutarlılık anlamına gelir). A (Availability, Erişilebilirlik): Sistem, kısmi arızalar meydana geldiğinde bile normal hizmet sunmaya devam edebilmelidir. Her istek, makul bir süre içinde \u0026ldquo;geçerli bir yanıt\u0026rdquo; alabilmelidir (başarılı olmak zorunda değildir, doğru başarısız yanıtları da içerir). P (Partition tolerance, Bölünme Toleransı): Sistem, ağ bölünmelerine (düğümler arası iletişimin ulaşılamaz hale gelmesi) dayanabilmelidir. Ağ bölünmesi meydana gelse bile, sistem bir dereceye kadar erişilebilirlik veya tutarlılık sağlayabilmelidir. Gerçek dağıtık ortamlarda, ağ bölünmeleri kaçınılmazdır, bu nedenle P temel olarak \u0026ldquo;zorunlu bir seçenek\u0026rdquo; olarak kabul edilir. Ağ bölünmesi meydana geldiğinde, sistem tüm düğümlerin verilerinin güçlü tutarlılığı ve yüksek erişilebilirliğini aynı anda sağlayamaz. Bu nedenle, C ve A arasında bir seçim yapmak zorunda kalır ve bu da CP ve AP olmak üzere iki ana türün ortaya çıkmasına neden olur.\n1.2 CAP Teoreminin Sınırlamaları # CAP teoreminin kendisinin nispeten üst düzey bir teori olduğunu ve kavramsal rehberlik için kullanıldığını belirtmek gerekir. \u0026ldquo;Ya C\u0026rsquo;yi seç ya da A\u0026rsquo;yı seç\u0026rdquo; şeklinde basitçe anlaşılmamalıdır. Yaygın bazı yanlış anlamalar vardır:\nC mutlaka güçlü tutarlılık değildir CAP teoremindeki C genellikle en katı anlamda tutarlılığı (yani doğrusal tutarlılık) ifade eder. Ancak gerçek sistemlerde, zayıf tutarlılık, okunmuş taahhüt (Read Committed), nedensel tutarlılık (Causal Consistency) gibi birçok ince taneli model seçeneğimiz vardır. Erişilebilirlik 0 veya 1 değildir CP\u0026rsquo;yi seçmek, erişilebilirliğin tamamen feda edildiği anlamına gelmez; veya AP\u0026rsquo;yi seçmek, tutarlılığın hiçbir garantisi olmadığı anlamına gelmez. Erişilebilirlik ve tutarlılık, farklı derecelerde ödünleşim alanlarına ve düşürme stratejilerine sahiptir. Sonunda tutarlılık CAP\u0026rsquo;ye aykırı değildir Daha yüksek erişilebilirlik ve verim için daha düşük yazma tutarlılığıyla takas edilen ve verileri arka planda eşzamansız olarak bir araya getiren çok yaygın bir uzlaşma çözümüdür. Bu nedenle, CAP teoremi, çeşitli tutarlılık modelleri ve yüksek erişilebilirlik mimari modelleri ile belirli senaryolarda birleştirilmelidir, ancak o zaman gerçek uygulama rehberliği değeri üretebilir.\nII. Dağıtık Sistemlerin Tutarlılık Modelleri # Tutarlılık modellerinin sınıflandırılması çok zengindir, ancak yaygın ana akım modeller kabaca güçlü tutarlılık ve zayıf tutarlılık (sonunda tutarlılık, nedensel tutarlılık vb. dahil) olarak ayrılabilir. Bu makale, esas olarak güçlü tutarlılık ve sonunda tutarlılığı tanıtacak ve bunların CP veya AP modlarındaki yaygın uygulamalarını açıklayacaktır.\n2.1 Güçlü Tutarlılık # Güçlü tutarlılık (Strong Consistency), aynı zamanda doğrusal tutarlılık (Linearizability) olarak da bilinir. Bir yazma işlemi tamamlanıp başarıyla döndüğünde, sonraki tüm okuma işlemlerinin bu güncellenmiş içeriği okuyabilmesi anlamına gelir. Yani, sistem dışarıdan tüm işlemlerin seri olarak yürütüldüğü gibi davranır.\nYaygın Uygulamalar: Eşzamanlı çoğaltmaya ve bir hakem (çoğunluk) mekanizmasına dayanır. Protokoller (Paxos/Raft gibi) aracılığıyla sistemde yalnızca geçerli bir liderin (Leader) olmasını sağlar. Tüm işlemler, günlüğe sırayla yazılır ve çoğunluk düğümüne kopyalanır. Avantajları ve Dezavantajları: Avantajları: En katı veri doğruluğunu garanti eder, herhangi bir zamanda okunan verilerde \u0026ldquo;geri dönüş\u0026rdquo; olmaz. Dezavantajları: Ağ dalgalanmaları, bölünmeler veya lider arızaları durumunda, tutarlılığı korumak için genellikle yazma işlemlerini engeller, bu da genel erişilebilirliğin düşmesine neden olur; performans ve verim de nispeten düşüktür. 2.2 Sonunda Tutarlılık # Sonunda tutarlılık (Eventual Consistency), zayıf tutarlılığın tipik bir biçimidir. Yalnızca sistemde artık yeni güncelleme işlemleri yoksa, zamanla tüm kopyaların verilerinin kademeli olarak aynı duruma yakınsaması gerektiğini gerektirir. Bu süre zarfında, kullanıcılar kopya verilerini okurken eski değerler görebilir, ancak sonunda tutarlı hale gelir.\nYaygın Uygulamalar: Gossip protokolü, çoklu kopya eşzamansız çoğaltma, CRDT (Çakışmasız Çoğaltılmış Veri Türü) vb. Avantajları ve Dezavantajları: Avantajları: Yüksek erişilebilirlik, yüksek verim, düşük yazma işlemi gecikmesi, ağ bölünmelerine karşı yüksek tolerans. Dezavantajları: Kısa süreli veri tutarsızlığına tolerans göstermesi gerekir, uygulama mantığı daha karmaşıktır, çakışma tespiti ve birleştirme yapılması gerekebilir. III. Yaygın Tutarlılık Protokolleri ve Algoritmaları # Dağıtık sistem kopyalarının tutarlı kalmasını sağlamak için sektörde birçok klasik algoritma ve protokol önerilmiştir. Aşağıda birkaç tanesi kısaca tanıtılmaktadır:\n3.1 Paxos # Paxos, Leslie Lamport tarafından 1990\u0026rsquo;larda önerilen ve esas olarak güçlü tutarlılık veya doğrusal tutarlılık uygulamak için kullanılan bir dağıtık tutarlılık algoritmasıdır.\nTemel İlke: Bir işlemin veya değerin çoğunluk düğümü tarafından kabul edilip edilmediğine karar vermek için rol bölümü (Önerici Proposer, Kabul Edici Acceptor, Öğrenici Learner) aracılığıyla çok turlu oylama yapılır. Avantajları ve Dezavantajları: Avantajları: Ağ bölünmeleri ve düğüm arızaları altında bile tutarlılığa ulaşabilir, yüksek güvenlik sağlar. Dezavantajları: Uygulaması karmaşıktır, hata ayıklama ve sorun giderme zordur, çok turlu oylama performansı sınırlar. Endüstride genellikle varyantları (Multi-Paxos vb.) kullanılır. 3.2 Raft # Raft, 2013 yılında resmi olarak önerilmiştir ve amacı, Paxos ile aynı güvenlik seviyesini sağlarken, uygulama ve anlama zorluğunu basitleştirmektir. Kararlı bir lider (Leader) rolü oluşturarak, günlük çoğaltma ve arıza kurtarmayı merkezi olarak gerçekleştirir:\nTemel Aşamalar: Lider Seçimi (Leader Election), Günlük Çoğaltma (Log Replication), Güvenlik (Safety) vb. Yaygın Uygulamalar: Etcd, Consul, TiKV, LogCabin vb. güçlü tutarlı çoğaltmayı uygulamak için Raft\u0026rsquo;ı temel alır. Avantajları ve Dezavantajları: Avantajları: Anlaşılması nispeten kolaydır, daha az kod satırı gerektirir; küçük ve orta ölçekli kümeler için performansı iyidir. Dezavantajları: Ana düğüme (Lider) bağımlıdır, ana düğüm arızası veya bölünmesi kısa süreli yazma engellemesine neden olur; büyük ölçekli kümelerde veya coğrafi olarak dağıtılmış dağıtımlarda gecikme ve erişilebilirlik etkilenecektir. 3.3 Gossip Protokolü # Gossip (dedikodu) protokolü, geleneksel bir fikir birliği protokolü değildir. Esas olarak, merkezi olmayan senaryolarda, düğümlerin rastgele etkileşimi yoluyla meta verileri veya durum bilgilerini değiştirmek ve böylece tüm ağda yayılma ve yakınsama sağlamak için kullanılır.\nÖzellikler: Merkezi olmayan, düşük maliyetli, düğümler arasında periyodik ve rastgele mesaj alışverişi. Yaygın Uygulamalar: Cassandra, Riak, dağıtık üye yönetimi (Serf gibi) vb., sonunda tutarlılık, kopya durumu senkronizasyonu vb. uygulamak için kullanılır. Avantajları ve Dezavantajları: Avantajları: Ölçeklenebilirliği iyidir, uygulaması kolaydır, tutarlılık gereksinimlerinin yüksek olmadığı, ölçeklenebilirlik gereksinimlerinin yüksek olduğu senaryolar için uygundur. Dezavantajları: Tutarlılık garantisi zayıftır, çakışmaları nihai olarak çözmek için daha üst düzey çakışma işleme yöntemleri (CRDT, sürüm numarası birleştirme vb.) gerektirir. 3.4 2PC / 3PC # Dağıtık işlem senaryolarında, yaygın taahhüt protokolleri 2PC (İki Aşamalı Taahhüt) ve 3PC (Üç Aşamalı Taahhüt)\u0026lsquo;dir:\n2PC: Koordinatör, tüm katılımcılara \u0026ldquo;ön taahhüt (prepare)\u0026rdquo; bildirimi gönderir, hepsi başarılı olursa \u0026ldquo;taahhüt (commit)\u0026rdquo; yayınlar, aksi takdirde \u0026ldquo;geri alma (abort)\u0026rdquo; yayınlar. 3PC: 2PC\u0026rsquo;ye ek olarak bir aşama ekler, tek nokta arızasının neden olduğu engellemeyi azaltır, ancak uygulaması daha karmaşıktır ve hala aşırı ağ bölünmesi veya arıza senaryolarında kullanılamazlık sorunları vardır. Avantajları ve Dezavantajları: Avantajları: Anlaşılması kolaydır, işlem anlamı açıktır, dağıtık veritabanlarında, mesaj kuyruklarında vb. yaygın olarak kullanılır. Dezavantajları: Koordinatöre güçlü bir bağımlılığı vardır, engelleme riski vardır; ağda uzun süreli bölünme olduğunda işlemleri ilerletemeyebilir. IV. CAP\u0026rsquo;in İki Ana Akım Seçeneği: CP ve AP # P\u0026rsquo;nin \u0026ldquo;zorunlu\u0026rdquo; bir özellik olduğunu kabul ettiğimizde, dağıtık sistemler ağ bölünmesi sırasında hizmet sunmaya devam etmek istiyorsa, C ve A arasında bir seçim yapmalıdır. Yaygın sistem tasarımları bu nedenle CP ve AP olmak üzere iki ana kampa ayrılır.\n4.1 CP Sistemi # CP (Tutarlılık + Bölünme Toleransı): Ağ bölünmesiyle karşılaşıldığında, sistem öncelikle tutarlılığı garanti etmeyi seçer ve gerektiğinde erişilebilirliği feda eder.\nTipik Uygulamalar: Çoğunluk fikir birliği (Paxos, Raft vb.), yazmaya izin vermek için düğümlerin yarısından fazlasının hayatta kalması ve fikir birliğine varması gerekir. Mevcut durumda quorum (yasal çoğunluk) sağlanamazsa veya ana düğüm arızalanırsa, sistem beyin bölünmesinin neden olduğu veri tutarsızlığını önlemek için yazma işlemlerini engeller veya reddeder. Yaygın Uygulamalar: Zookeeper, Etcd, Consul, dağıtık kilit hizmetleri, dağıtık meta veri yönetimi vb. Finansal işlem çekirdek süreçleri, banka muhasebe sistemleri gibi yüksek tutarlılık gerektiren senaryolar. Özellikler: Katı veri garantisine sahiptir: Çift ana veya veri karışıklığı olmaktansa kapanmayı tercih eder. Belirli bir erişilebilirliği feda eder: Ağ bölünmesi veya arıza geçişi meydana geldiğinde, bir süre hizmet kullanılamaz veya yazma işlemlerini reddeder. 4.2 AP Sistemi # AP (Erişilebilirlik + Bölünme Toleransı): Ağ bölünmesiyle karşılaşıldığında, sistem öncelikle erişilebilirliği garanti etmeyi seçer ve aynı zamanda tutarlılığı gevşetir.\nTipik Uygulamalar: Sonunda tutarlılık, çoklu ana çoğaltma, Gossip protokolü, Dynamo tarzı ayarlanabilir tutarlılık stratejileri vb. Yaygın Uygulamalar: NoSQL veritabanları (Cassandra, Riak, DynamoDB vb.), dağıtık önbellek sistemleri (Redis Cluster) vb. Sosyal ağlar, günlük toplama, öneri sistemleri gibi yüksek erişilebilirlik, yüksek verim ve veri tutarlılığı gereksinimlerinin nispeten esnek olduğu işler. Özellikler: Bölünme olsa bile, tüm düğümler okuma ve yazma isteklerini almaya devam eder ve sistemin \u0026ldquo;mümkün olduğunca kullanılabilir\u0026rdquo; olmasını sağlar. Verilerde kısa süreli tutarsızlıklar olabilir, ancak arka planda eşzamansız senkronizasyon, çakışma birleştirme vb. yöntemlerle kademeli olarak yakınsar. V. CP ve AP Arasında Nasıl Seçim Yapılır? # Gerçek büyük ölçekli dağıtık sistemlerde, genellikle tek bir modele güvenmek yerine, farklı veri veya iş senaryoları için katmanlı işlem yapılır, böylece tutarlılık ve erişilebilirlik arasında en iyi denge sağlanır.\nÇekirdek Veriler için CP\u0026rsquo;yi Seçin Kullanıcı hesap bakiyeleri, sipariş ödemeleri, finansal işlem akışları vb. gibi tutarlılık gereksinimleri çok yüksektir. Ağ dalgalanmalarının neden olduğu kısa süreli yazılamazlığı tolere eder, ancak bakiye veya işlem tutarlarındaki hataları tolere edemez. Kenar veya Önbellek Verileri için AP\u0026rsquo;yi Seçin Ürün detay sayfalarının önbelleği, kullanıcı davranış günlükleri, öneri aday listeleri vb. gibi tutarlılık gereksinimleri düşüktür. Yüksek eşzamanlılığa, yüksek erişilebilirliğe daha çok önem verir, belirli bir süre gecikmeli güncellemeyi veya kirli okumayı tolere edebilir. Birçok internet şirketi karma mimari kullanır: Çekirdek işlem süreçleri CP tarzı depolama (dağıtık ilişkisel veritabanları veya güçlü tutarlılığa sahip dağıtık depolama gibi) kullanır; dış işler veya \u0026ldquo;çok okuma az yazma\u0026rdquo; senaryoları AP tarzı depolama veya önbellek çözümleri kullanır.\nVI. CP ve AP Yüksek Eşzamanlılık ve Sonunda Tutarlılık Nasıl Uygulanır? # 6.1 CP Sistemleri Yüksek Eşzamanlılıkla Nasıl Başa Çıkar? # Fikir birliği protokolleri, tek bir küme düğüm ölçeğinde ve büyük yazma isteği hacminde yüksek gecikme ve düşük verimle karşılaşsa da, eşzamanlılığı ve ölçeklenebilirliği aşağıdaki yöntemlerle artırabilir:\nToplu Okuma ve Yazma Birden çok yazma işlemini istemcide veya ara katmanda paketleyerek, lider düğüme tek seferde yazarak ağ gidiş gelişlerini ve protokol turlarını azaltır. Veritabanı Bölme ve Tablo Bölme \u0026amp; Çoklu Küme Verileri mantıksal veya karma yoluyla birden çok kümeye (parçalama) böler, her küme içinde hala CP protokolü çalışır; istekler yönlendirme veya proxy katmanı aracılığıyla farklı parçalara dağıtılır. Genel eşzamanlılık yeteneğini artırır ve arıza etkisini tek bir parça aralığıyla sınırlar. CP sistemlerinin tek parça küme verimi genellikle AP sistemlerinden 2 ila 10 kat daha düşüktür.\n6.2 AP Sistemleri Sonunda Tutarlılığı Nasıl Garanti Eder? # AP sistemleri genellikle yüksek yazma verimi ve okuma erişilebilirliği sağlayabilir, ancak tutarlılığı gevşetir, bu nedenle arka planda veya iş mantığı katmanında tutarlılık yakınsama garantisi uygulaması gerekir:\nSürüm Numarası (Vektör Saati) veya Mantıksal Zaman Damgası Her güncelleme işlemine bir sürüm numarası (veya Lamport Saati / Hibrit Saat tabanlı) atar, çakışma senaryolarında birleştirme veya zaman damgası tabanlı kazanma stratejisi (Son Yazma Kazanır) uygular. Gossip Protokolü / Anti-entropi Mekanizması Düğümler periyodik olarak en son verileri veya meta verileri değiştirir, çakışma bulursa birleştirir. Ayarlanabilir Tutarlılık Stratejisi Dynamo modeliyle temsil edilir, istemci R, W gibi parametreleri (çoğunluğa yazma, kopya onayı gibi) yapılandırabilir, böylece tutarlılık ve erişilebilirlik arasında esnek bir şekilde ayar yapabilir. Özel Çakışma Çözme Stratejisi İş anlamıyla birleştirme yapar, örneğin alışveriş sepeti \u0026ldquo;birleşim\u0026rdquo; ile birleştirilir, sayaçlar CRDT (G-sayaç, PN-sayaç vb.) ile verilerin monotonluğunu garanti eder. VII. CP\u0026rsquo;nin Parçalar Arası Güçlü Tutarlılık Uygulaması # VII. bölümde belirtildiği gibi, veritabanı bölme ve tablo bölme (Sharding), tek bir CP kümesinin basıncını birden çok alt kümeye \u0026ldquo;bölerek\u0026rdquo; daha yüksek eşzamanlılığı desteklemesini sağlayabilir. Ancak, işin parçalar arası işlem yürütmesi gerektiğinde (yani birden çok veritabanı veya tablo güncellemesi içerdiğinde), hala çoklu parça tutarlılığı zorluğuyla karşı karşıyayız. Genellikle aşağıdaki fikirler vardır:\nDağıtık İşlemler: 2PC / 3PC Uygulamanın birden çok parça arasında atomik güncelleme yapması gerekiyorsa, genellikle her parçanın taahhüdünü veya geri almasını koordine etmek için dağıtık işlem protokolleri (2PC, 3PC gibi) kullanılır. Sorunlar ve Çözümler: 2PC/3PC\u0026rsquo;nin her ikisi de tek bir koordinatör düğümüne bağlıdır ve tek nokta darboğazı haline gelebilir. Ağ bölünmesinin ciddi olduğu veya koordinatörün arızalandığı aşırı durumlarda, engelleme meydana gelebilir. Genellikle ana-yedek geçişi, kalp atışı algılama ve zaman aşımı mekanizması, idempotent yeniden deneme, MVCC vb. ile engelleme etkisini ve veri tutarsızlığı riskini azaltır. Hücre Tabanlı Mimari İşi birden çok özerk birime böler, her birimdeki veriler aynı parça kümesindedir, çoğu işlemin yalnızca tek bir birimde tamamlanmasını sağlar ve parça arası işlemleri azaltır. Birim sınırında eşzamansız veya sonunda tutarlılık mekanizması kullanarak veri alışverişi yapar, genel yüksek erişilebilirliği ve tutarlılığı dengeler. Küresel Dağıtık Veritabanı + Küresel Fikir Birliği Protokolü Örneğin, Google Spanner, her parçada (Shard) Paxos aracılığıyla kopya güçlü tutarlı çoğaltma uygular ve ardından TrueTime API\u0026rsquo;sini kullanarak parça arası tutarlılığı sağlamak için küresel zaman damgaları sağlar. Bu çözümün uygulama karmaşıklığı çok yüksektir, ancak küresel ölçekte güçlü tutarlılığa yakın dağıtık işlem yeteneği sağlayabilir. Özet: Güçlü tutarlılık gerektiren parçalar arası işlemler için, 2PC/3PC + koordinatör hala yaygın bir çözümdür ve koordinatörün yüksek erişilebilirliğini mümkün olduğunca artırarak arıza olasılığını azaltır. Ancak, mühendislik uygulamasında parça arası yazma işlemlerini en aza indirmek veya birimleştirme fikriyle çoğu işlemi tek bir parça aralığıyla sınırlayarak sistem karmaşıklığını azaltmak gerekir.\nVIII. Ünlü Vaka Tartışmaları # Aşağıda, sektörde sıkça bahsedilen birkaç dağıtık sistemi kısaca tartışalım ve bunların CAP\u0026rsquo;deki ödünleşimlerini ve uygulama yöntemlerini görelim:\nGoogle Spanner Tipik bir CP sistemidir (hatta dış dünyanın sıkça bahsettiği \u0026ldquo;CA\u0026rdquo; yanılsamasını bile yapabilir, ancak özünde hala bir miktar erişilebilirliği feda etmesi gerekir). TrueTime tarafından sağlanan harici kesin zaman damgalarını + her parça içindeki Paxos çoğaltmasını kullanarak, veri merkezleri arası güçlü tutarlılığı garanti eder. Küresel finansal işlemler veya yüksek tutarlılık gerektiren senaryolar için uygundur, ancak altyapı maliyeti çok yüksektir. BigTable / HBase Yüzeyde CP\u0026lsquo;ye daha yatkındır, RegionServer ve Master arasında meta verilerin tutarlılığını sağlamak için dağıtık koordinasyon kullanır. Ancak gerçek okuma ve yazma yollarında, çoklu kopya eşzamansız çoğaltma yoluyla belirli bir yüksek erişilebilirlik aracı da sağlayabilir ve okuma tutarlılığı uygulama gereksinimlerine göre ayarlanabilir. AWS DynamoDB AP\u0026lsquo;ye eğilimlidir, erken tasarım ilhamı Dynamo makalesinden alınmıştır ve R, W gibi parametrelerle tutarlılık seviyesini ayarlayabilir. Varsayılan modda son derece yüksek erişilebilirlik ve sonunda tutarlılık sağlar, ayrıca \u0026ldquo;güçlü tutarlı okuma\u0026rdquo; da açılabilir (ancak yalnızca tek bir parça için güçlü tutarlılığı garanti eder, parça arası olmayabilir). Cassandra Aynı şekilde AP eğilimlidir, altta yatan Gossip protokolü düğüm topoloji durumunu korur. Okuma ve yazma tutarlılığı, sonunda tutarlılıktan daha güçlü tutarlılığa yumuşak bir geçiş sağlamak için okuma ve yazma kopya sayısı R / W ile yapılandırılabilir. Karşılaştırmadan görülebilir: Mühendislikte mutlak \u0026ldquo;AP veya CP\u0026rdquo; yoktur, daha çok çeşitli tutarlılık stratejilerinin bir karışımıdır; çoğu sistem, farklı uygulama senaryolarına uyum sağlamak için belirli bir ölçüde ayarlanabilir tutarlılık sağlar.\nIX. Özet # CAP Teoremi Tek Bir Çözüm Değildir Gerçek dağıtık sistemler basitçe \u0026ldquo;C\u0026rsquo;yi seçiyorum, A\u0026rsquo;dan vazgeçiyorum\u0026rdquo; veya \u0026ldquo;A\u0026rsquo;yı seçiyorum, C\u0026rsquo;den vazgeçiyorum\u0026rdquo; diyemez. Sektörde daha yaygın olan, farklı veri boyutları, farklı işlem türleri için esnek bir şekilde CP veya AP modunu seçmek, hatta aynı sistem içinde farklı tablolar/farklı işlevler için farklı hata toleransı ve tutarlılık stratejileri kullanmaktır. AP Mutlak %100 Kullanılabilir Değildir Örneğin, Cassandra, DynamoDB vb. aşırı ağ bölünmesi veya düğümlerin büyük bir bölümünün arızalanması durumunda, istekleri karşılayamama durumu da ortaya çıkabilir. AP sistemleri yalnızca tasarımda \u0026ldquo;kopya yazılabilir olduğu sürece önce yaz\u0026rdquo; eğilimindedir ve nispeten daha yüksek erişilebilirlik ve verim karşılığında bir miktar tutarlılık garantisini feda eder. CP de Mümkün Olduğunca Yüksek Erişilebilirliğe Ulaşabilir Paxos/Raft normal koşullar altında %99,99 veya daha yüksek erişilebilirlik sağlayabilir, ancak daha fazla ağ, donanım ve mühendislik maliyeti gerektirir ve aşırı ağ bölünmesi durumunda yazmayı engelleme, tutarlılığı korumak için erişilebilirliği feda etme durumu hala ortaya çıkacaktır. Karma Mimari Ana Akımdır Çekirdek işlem senaryoları güçlü tutarlılık (CP) gerektirir, dış yardımcı senaryolar veya önbellek kanalları zayıf tutarlılık (AP) kullanır ve ikisi birbirini tamamlar. İş toleransı, ağ ortamı, maliyet yatırımı, ekip teknik rezervi ile birlikte kapsamlı bir şekilde değerlendirilmelidir. CAP teoremi, dağıtık sistemlerin tasarımı için üst düzey bir düşünce çerçevesi sağlar ve ağ bölünmesi gibi kaçınılmaz bir gerçeklik karşısında rasyonel kararlar almamıza yardımcı olur. Gerçek sistemlerde, daha zengin tutarlılık modelleri, fikir birliği protokolleri, çoklu kopya çoğaltma mekanizmaları ve mühendislik uygulamaları (felaket kurtarma, düşürme, idempotent, çakışma birleştirme vb.) aracılığıyla tutarlılık ve erişilebilirliği dengelemek gerekir.\n","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735350760948-cap/","section":"Posts","summary":"CAP teoreminin dağıtık sistemlerdeki uygulamalarını teoriden pratiğe tartışıyoruz.","title":"CAP Teoreminin Derinlemesine Analizi: Yüksek Eşzamanlılık ve Yüksek Erişilebilirlikli Dağıtık Sistemler Oluşturma","type":"posts"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 Aralık 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"Hızlı sıralama, karşılaştırmaya dayalı, kararlı olmayan bir sıralama algoritmasıdır. Böl ve fethet yaklaşımını kullanır. Ortalama zaman karmaşıklığı $O(n\\log n)$\u0026lsquo;dir, en kötü durumda $O(n^2)$\u0026lsquo;dir ve uzay karmaşıklığı $O(1)$\u0026lsquo;dir. Aşağıda, bir tamsayı dizisini küçükten büyüğe sıralama örneği üzerinden uygulama detayları ve yaygın hatalar tanıtılmaktadır.\nProblem Tanımı # $n$ uzunluğunda bir tamsayı dizisi verildiğinde, hızlı sıralama kullanarak küçükten büyüğe sıralayın ve sonucu çıktılayın.\nGiriş Formatı # İlk satırda $n$ tamsayısı girilir. İkinci satırda, her biri $[1,10^9]$ aralığında olan $n$ tamsayı girilir. Çıkış Formatı # Sıralanmış diziyi tek satırda çıktılayın. Veri Aralığı # $1 \\leq n \\leq 100000$\nGiriş Örneği # 5 3 1 2 4 5 Çıkış Örneği # 1 2 3 4 5 Hızlı Sıralama Mantığı # Hızlı sıralama, her bölme adımında bir sayı seçerek pivot (aşağıda orta konumdaki sayı seçilmiştir) olarak kullanır.\nSol işaretçi L soldan sağa doğru pivot\u0026lsquo;a eşit veya büyük ilk sayıyı ararken, sağ işaretçi R sağdan sola doğru pivot\u0026lsquo;a eşit veya küçük ilk sayıyı arar ve ardından bu iki sayıyı değiştirir.\nSol işaretçi ve sağ işaretçi çakışana veya sol işaretçi sağ işaretçiden bir pozisyon büyük olana kadar bu işlemi tekrarlayın. Bu bir döngü olarak adlandırılır.\nHer işaretçi hareketi ve takas işleminden sonra, \u0026ldquo;sol kısım ≤ pivot, sağ kısım ≥ pivot\u0026rdquo; yapısının bozulmadığı, yani [left, L) \u0026lt;= pivot ve (R, right] \u0026gt;= pivot değişmezlerinin korunduğu garanti edilir.\nAşağıdaki örnek kodda, left ve right mevcut işlenen kapalı aralığın sınırlarıdır ve pivot aralığın orta noktasındaki elemanı alır.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Karmaşıklık ve pivot Seçimi # Hızlı sıralamanın en kötü durumda $O(n^2)$ karmaşıklığına sahip olması nedeniyle, pivot seçimi çok önemlidir. Her zaman ilk veya son elemanı seçerseniz, neredeyse sıralı dizilerde büyük olasılıkla en kötü durum ortaya çıkacaktır.\nOrta konumdaki elemanı almanın yanı sıra, pivot olarak rastgele bir eleman seçebilir veya sol, orta ve sağdaki üç elemanın medyanını pivot olarak alabilirsiniz.\nYaygın Hata Örnekleri # Aşağıdaki kod, birkaç yaygın hata içermektedir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Hata Analizi:\npivot bir dizi elemanı olmalı, indeks değil. \u0026lt; ve \u0026gt; yerine \u0026lt;= ve \u0026gt;= kullanmak, sol işaretçinin sağ işaretçiyi birden fazla geçmesine neden olabilir, bu da diziyi ikiye bölmeyi imkansız hale getirir. l \u0026gt;= r bulunduktan sonra, takas işlemini yapmadan döngüden hemen çıkılmalıdır. Aksi takdirde, sol taraftaki elemanların pivot\u0026lsquo;tan büyük olmadığı ve sağ taraftaki elemanların pivot\u0026lsquo;tan küçük olmadığı garanti edilemez. Her takastan sonra l++ ve r-- yapılmalıdır. pivot aslında ortanın solundaki sayıyı alır. Bu nedenle, diziyi $l - 1$ ve $l$ kullanarak bölerseniz, [1, 2] dizisi için sonsuz döngüye neden olacağı ve diziyi sürekli olarak 0 ve 2 boyutlarında iki parçaya böleceği kolayca görülebilir. Benzer şekilde, diziyi $r$ ve $l$ kullanarak bölmek de işe yaramaz. Aksine, bir döngü bittiğinde, $r$ kesinlikle $right$\u0026lsquo;tan küçük olacaktır, bu nedenle diziyi $r$ ve $r+1$ kullanarak bölebilirsiniz. Okuyucular nedenini görmek için algoritma sürecini simüle edebilirler. Sonsuz döngüden kaçınmanın bir başka basit yolu da rastgele bir pivot seçmek veya yalnızca iki eleman olduğunda özel işlem yapmaktır. Ayrıca, $l$, $l+1$ kullanmak da işe yaramaz, çünkü bu bölme tanıma uygun değildir. $r$\u0026lsquo;nin $l$\u0026lsquo;nin solunda olduğu durumda, $l$, $l+1$ kullanmak diziyi doğru şekilde sol tarafı pivot\u0026lsquo;a eşit veya küçük ve sağ tarafı pivot\u0026lsquo;a eşit veya büyük olacak şekilde ikiye bölemez. Bu problem dizinin boş olmadığını varsayar, bu nedenle \u0026gt; durumu yoktur. Ancak, daha güvenli olması için \u0026gt;= kullanılması önerilir. Ek Bilgiler # Hızlı sıralama, $O(n)$ beklenen sürede sıralanmamış bir dizideki $k$\u0026lsquo;inci en küçük sayıyı bulmak için \u0026ldquo;hızlı seçim\u0026quot;e de dönüştürülebilir. Temel fikir hızlı sıralamaya benzer, ancak her seferinde yalnızca bir alt aralıkta özyinelemeli olarak devam ederek zaman karmaşıklığını azaltır.\n","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Hızlı sıralama algoritmasının doğru şekilde uygulanmasının anahtar noktalarının analizi.","title":"Hızlı Sıralama","type":"posts"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Problem # $N$ tane eşya var. $i$-inci eşyanın hacmi $s_i$ ve değeri $v_i$\u0026lsquo;dir. Her eşya yalnızca bir kez alınabilir. Maksimum toplam hacim sınırı $S$\u0026lsquo;yi aşmama koşulu altında, elde edilebilecek maksimum toplam değer $V$\u0026lsquo;yi bulun.\nGirdi Biçimi # İlk satırda, sırasıyla eşya sayısını ve maksimum toplam hacim sınırını temsil eden, boşlukla ayrılmış iki tam sayı $N$ ve $S$ bulunur. Aşağıdaki $N$ satırın her birinde, sırasıyla $i$-inci eşyanın hacmini ve değerini temsil eden, boşlukla ayrılmış iki tam sayı $s_i$ ve $v_i$ bulunur.\nÇıktı Biçimi # Maksimum değeri temsil eden bir tam sayı çıktısı verin.\nVeri Aralığı # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Girdi Örneği # 4 5 1 2 2 4 3 4 4 5 Çıktı Örneği # 8 Çözüm # Durumu tanımlayın: f[i][j], ilk $i$ eşyadan, hacim sınırı $j$ ile elde edilebilecek maksimum değeri temsil eder. Eğer $i$-inci eşya alınmazsa, f[i][j] = f[i - 1][j] Eğer $i$-inci eşya alınırsa, f[i][j] = f[i - 1][j - s[i]] + v[i] Durum geçişini uygularken, alan aralığına dikkat edin. Eğer $j \u003c s_i$ ise, $i$-inci eşyayı alma durumunu göz önünde bulundurmayın. Çünkü eğer $j - s_i$ negatif ise, dizi indeksi geçersiz olur. Bu şu şekilde de açıklanabilir: $i$-inci eşyanın hacmi, hacim sınırından daha büyüktür, bu yüzden imkansızdır. Başlangıç koşulunu tanımlayın: İlk $0$ eşya için, herhangi bir hacim sınırı $0$ değerini verir, yani f[0][j] = 0, j $\\in [0, S]$. Zaman karmaşıklığı: $O(NS)$. Kod # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimizasyonu # İki boyutlu diziyi tek boyutlu bir diziye sıkıştırmak, önemli ölçüde yer tasarrufu sağlayabilir ve çalışma hızını bir dereceye kadar artırabilir (dezavantajı, bazı problem türlerinin özel gereksinimlerini karşılayamamasıdır). Durum geçişinde, f[i][j]\u0026lsquo;nin yalnızca f[i - 1][j] ve f[i - 1][j - s[i]] ile ilgili olduğuna dikkat edin. Başka bir deyişle, koddaki iki boyutlu f dizisinde, f[i][j] yalnızca önceki satırda solunda veya aynı sütunda bulunan elemanlarla ilgilidir. Bu nedenle, iki boyutlu dizi tek boyutlu bir diziye veya kayan bir diziye sıkıştırılabilir. Aşağıdaki kodda, ikinci döngünün ters sırada yinelediğine dikkat edin. Bunun nedeni, f[i][j]\u0026lsquo;yi hesaplarken, f[i - 1][j - s[i]]\u0026lsquo;nin henüz güncellenmemiş olmasını sağlamak istememizdir. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Eğer Şema Sayısı Gerekliyse # Yalnızca elde edilebilecek maksimum toplam değer değil, aynı zamanda \u0026ldquo;bu maksimum toplam değere ulaşabilecek kaç farklı seçim yöntemi var\u0026rdquo; da çıktı olarak verilmelidir. Aşağıda, 01 sırt çantası probleminde şema sayısının nasıl sayılacağı açıklanmaktadır.\nŞemaları Saymak İçin 2D DP # Aşağıda, açıklamak için 2D DP örneği kullanılmaktadır.\nDurumu tanımlayın:\ndp[i][j], \u0026ldquo;ilk i eşya, j kapasite (hacim sınırı) ile değerlendirildiğinde elde edilebilecek maksimum değeri\u0026rdquo; temsil eder. ways[i][j], \u0026ldquo;ilk i eşya, j kapasite ile değerlendirildiğinde elde edilen maksimum değere karşılık gelen şema sayısını\u0026rdquo; temsil eder. Durum geçişi:\nEğer i-inci eşya seçilmezse: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Eğer i-inci eşya seçilirse ( $ j \\ge s_i $ olması koşuluyla): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Seçilip seçilmemesine bakılmaksızın, nihai dp[i][j] ikisinin daha büyüğünü almalıdır: Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ ise, bu \u0026ldquo;i-inci eşyayı seçmenin\u0026rdquo; daha büyük bir değere sahip olduğu anlamına gelir: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ ise, bu iki yöntemle elde edilen maksimum değerin aynı olduğu anlamına gelir, bu durumda şema sayısı eklenmelidir: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ ise, bu \u0026ldquo;i-inci eşyayı seçmemenin\u0026rdquo; daha büyük bir değere sahip olduğu anlamına gelir ve şema sayısı, seçilmediğinde şema sayısını devralır: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Başlangıç koşulları:\ndp[0][j] = 0, 0 eşya olduğunda, herhangi bir kapasite için elde edilen maksimum değerin 0 olduğu anlamına gelir. ways[0][0] = 1, \u0026ldquo;0 eşya, 0 kapasite\u0026rdquo; durumunun uygulanabilir bir şema olduğu (yani, hiçbir şey seçmemek) ve şema sayısının 1 olarak ayarlandığı anlamına gelir. j \u0026gt; 0 için, seçilecek eşya olmadığında ve kapasite 0\u0026rsquo;dan büyük olduğunda, herhangi bir pozitif değer elde etmek imkansızdır ve karşılık gelen şema sayısı 0\u0026rsquo;dır, yani ways[0][j] = 0. Nihai cevap:\ndp[N][S] maksimum değerdir. ways[N][S] bu maksimum değere ulaşmak için kullanılan şema sayısıdır. Zaman karmaşıklığı: $O(NS)$. Bu problem 1D DP kullanılarak da optimize edilebilir. Eğer Hacim Sınırına Tam Olarak Ulaşılması Gerekiyorsa # Durumu tanımlayın: f[i][j], ilk i eşyanın tam olarak $j$ hacmine sahip olduğunda elde edilen maksimum değeri temsil eder. Eğer i-inci eşya alınmazsa, f[i][j] = f[i - 1][j] Eğer i-inci eşya alınırsa, f[i][j] = f[i - 1][j - s[i]] + v[i] Durum geçişinde orijinal problemden bir fark olmadığı görülebilir. Ancak, başlangıç koşulları farklıdır. f[0][0] = 0 dışında, geri kalan f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ imkansız bir durumu temsil eder. Eğer Hacim Sınırı $S$ Çok Büyükse (1e9), Eşya Sayısı $N$ ve Maksimum Toplam Değer $V$ Nispeten Küçükse # Bu tür problemler için, $O(NV)$ karmaşıklığına sahip bir çözüm vardır. Durumu tanımlayın: f[i][j], ilk i eşyadan birkaç eşya seçerken, toplam değerin tam olarak j olması durumunda minimum hacmi temsil eder. Eğer i-inci eşya alınmazsa, f[i][j] = f[i - 1][j] Eğer i-inci eşya alınırsa, f[i][j] = f[i - 1][j - v[i]] + s[i] İkisinin daha küçüğünü alın. Başlangıç koşulları: f[0][0] = 0, geri kalan f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ imkansız bir durumu temsil eder. $-\\infty$ olmadığını unutmayın. Nihai cevap, f[N][j] içinde f[N][j] \u0026lt;= S olacak şekildeki en büyük j\u0026lsquo;dir. Eğer Hacim Sınırı $S$ ve Tek Bir Eşyanın Değeri $v_i$ Her İkisi de Çok Büyükse (1e9 mertebesinde), Eşya Sayısı $N$ Çok Küçükse (40\u0026rsquo;tan fazla değil) # $N \\leq 20$ olduğunda, tüm alt kümeler doğrudan kaba kuvvetle numaralandırılabilir (zaman karmaşıklığı $O(2^N)$). $N \\leq 40$ olduğunda, $2^{40}$ $10^{12}$ mertebesinde olduğundan, doğrudan kaba kuvvet de nispeten büyük olacaktır, bu nedenle karmaşıklığı yaklaşık olarak $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$\u0026lsquo;ye düşürmek için ortada buluşma araması kullanılabilir, bu da kabul edilebilir bir sürede tamamlanabilir. ","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"En temel klasik sırt çantası problemi.","title":"01 Sırt Çantası Problemi","type":"posts"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"Eğer sıralı çözüm uzayı, bir kısmı koşulu sağlayan, diğer kısmı sağlamayan iki kısma ayrılıyorsa, o zaman sıralı çözüm uzayında kritik noktayı bulmak için ikili arama kullanılabilir.\nİkili aramanın temel fikri, arama aralığını sürekli olarak ikiye bölmektir. Her kontrol sırasında orta nokta elemanı incelenir. Eğer orta nokta elemanı koşulu sağlamıyorsa, aralığın yarısı elenebilir; aksi takdirde, diğer yarısında aramaya devam edilir. Her seferinde arama aralığının yarısı atıldığı için, arama zaman karmaşıklığı $O(\\log n)$\u0026lsquo;ye ulaşabilir.\nÖrnek Soru # Soru Açıklaması:\n$n$ uzunluğunda, artan sırada sıralanmış bir tam sayı dizisi ve $q$ tane sorgu veriliyor. Her sorgu bir tam sayı $k$ veriyor. Dizide $k$\u0026lsquo;nin \u0026ldquo;başlangıç konumunu\u0026rdquo; ve \u0026ldquo;bitiş konumunu\u0026rdquo; (indeksler 0\u0026rsquo;dan başlıyor) bulmamız gerekiyor. Eğer dizide bu sayı yoksa, -1 -1 döndürülmelidir.\nGiriş Formatı # İlk satır: Dizi uzunluğunu ve sorgu sayısını temsil eden iki tam sayı $n$ ve $q$. İkinci satır: Artan sırada sıralanmış tam diziyi temsil eden $n$ tam sayı. Sonraki $q$ satır: Her satırda bir sorgu elemanını temsil eden bir tam sayı $k$. Veri Aralığı # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nÇıkış Formatı # Her sorgu için, elemanın dizideki başlangıç ve bitiş konumlarını bir satırda yazdırın. Eğer dizide bu eleman yoksa, -1 -1 yazdırın.\nÖrnek:\nGiriş: 6 3 1 2 2 3 3 4 3 4 5 Çıkış: 3 4 5 5 -1 -1 Açıklama:\n$3$ elemanının aralığı $[3, 4]$\u0026lsquo;tür; $4$ elemanı sadece bir kez, $5$ konumunda görünür; $5$ elemanı dizide bulunmadığı için $-1$ $-1$ döndürülür. Çözüm # \u0026ldquo;Başlangıç Konumunu\u0026rdquo; Bulma: Yani, $k$\u0026lsquo;ye eşit veya büyük olan ilk konumu bulmak. Diziyi iki kısma ayırabiliriz:\nSoldaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya büyüktür\u0026rdquo; Cevap, sağdaki ilk konumdur \u0026ldquo;Bitiş Konumunu\u0026rdquo; Bulma: Yani, $k$\u0026lsquo;ye eşit veya küçük olan son konumu bulmak. Diziyi iki kısma ayırabiliriz:\nSoldaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya küçüktür\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;büyüktür\u0026rdquo; Cevap, soldaki son konumdur Önerilen Şablon # Aşağıda zarif ve hataya yatkın olmayan bir ikili arama şablonu bulunmaktadır.\nİki işaretçi $l, r$ tanımlayın, değişmezler: kapalı aralık $[0, l]$ sol yarıya aittir, kapalı aralık $[r, n - 1]$ sağ yarıya aittir. $l$ ve $r$, $-1$ ve $n$ olarak başlatılır.\nAlgoritma sona erdiğinde, $l$ ve $r$ bitişiktir, sırasıyla sol yarının son elemanını ve sağ yarının ilk elemanını gösterir.\nİstediğimiz çözüm mevcut olmayabileceğinden, eğer soruda mutlaka bir çözümün var olduğu belirtilmemişse, l veya r\u0026lsquo;nin sınırların dışına çıkıp çıkmadığını, doğru değeri gösterip göstermediğini kontrol etmemiz gerekir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k\u0026#39;nin başlangıç konumunu bul 15 // Diziyi iki kısma ayır, sol taraf \u0026lt; k, sağ taraf \u0026gt;= k. 16 // Cevap, sağ yarının minimum indeksidir. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Eğer r sınırların dışındaysa veya nums[r] != k ise, k\u0026#39;nin olmadığını gösterir 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k\u0026#39;nin bitiş konumunu bul 33 // Diziyi iki kısma ayır, sol taraf \u0026lt;= k, sağ taraf \u0026gt; k. 34 // Cevap, sol yarının maksimum indeksidir. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Avantajları # Bu yazımın kesin olarak tanımlanmış değişmezleri vardır. Hem \u0026ldquo;başlangıç konumu\u0026rdquo; hem de \u0026ldquo;bitiş konumu\u0026rdquo; bulma durumları için uygundur, ek işlem veya değişiklik gerektirmez. Bazı yazımlar, durdurma koşulu olarak l == r kullanır. $l$ ve $r$ arasındaki fark $1$ olduğunda, $mid$, $l$ veya $r$\u0026lsquo;ye eşit olarak hesaplanır. Eğer doğru şekilde ele alınmazsa, $l$ veya $r$\u0026lsquo;yi $mid$ olarak güncelleyerek, arama aralığı küçülmez ve sonsuz döngüye yol açar. Aksine, buradaki yazım $l$ ve $r$ bitişik olduğunda durur, $mid$\u0026lsquo;in $l$\u0026lsquo;den küçük ve $r$\u0026lsquo;den büyük olmasını garanti eder, $l$ veya $r$ güncellendiğinde arama aralığının mutlaka küçülmesini sağlar. STL # Eğer C++ STL tarafından sağlanan lower_bound ve upper_bound fonksiyonları kullanılırsa, aynı şey yapılabilir:\nlower_bound(first, last, val) \u0026ldquo;val\u0026rsquo;e eşit veya büyük olan ilk konumu\u0026rdquo; döndürür upper_bound(first, last, val) \u0026ldquo;val\u0026rsquo;den büyük olan ilk konumu\u0026rdquo; döndürür Örneğin, nums = {1,2,3,4,4,4,4,4,5,5,6} olduğunu varsayalım, 4\u0026rsquo;ün göründüğü aralığı bilmek istiyoruz:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4, 0 kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;ilk 4, \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;son 4, \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4, \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; kez görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1, değeri $4$\u0026lsquo;e eşit veya büyük olan ilk konumu gösterir. it2, değeri $4$\u0026lsquo;ten büyük olan ilk konumu gösterir.\nBu nedenle it2 - it1, $4$\u0026lsquo;ün dizide kaç kez göründüğüdür; it2 - nums.begin() - 1, $4$\u0026lsquo;ün sağ sınırının konumudur. Ek Bilgiler # İkili arama, kayan noktalı sayı aralığında arama (örneğin, denklem köklerini bulma) ve tek tepeli fonksiyonların maksimum değerini bulmak için üçlü arama gibi durumlara da genişletilebilir.\nAlıştırma # LeetCode 33. Search in Rotated Sorted Array\nİpucu: İlk adımda dönme noktasını bulmak için ikili arama kullanın, ikinci adımda hedef değeri bulmak için tekrar ikili arama kullanın.\n","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"İkili arama algoritmasını nasıl zarif bir şekilde uygularız.","title":"İkili Arama","type":"posts"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series","type":"series"}]