[{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-dividir-para-conquistar/","section":"Tags","summary":"","title":"Algoritmo Dividir Para Conquistar","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Diviser Pour Régner","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":" Hızlı Sıralama # Hızlı sıralama, karşılaştırmaya dayalı, kararlı olmayan bir sıralama algoritmasıdır. Böl ve fethet ilkesini kullanır. Ortalama zaman karmaşıklığı $O(n\\log n)$\u0026lsquo;dir, en kötü durumdaki karmaşıklığı ise $O(n^2)$\u0026lsquo;dir. Alan karmaşıklığı $O(1)$\u0026lsquo;dir. Aşağıda, bir tam sayı dizisini küçükten büyüğe sıralama örneği verilerek, algoritmanın uygulama detayları ve yaygın hataları tanıtılmaktadır.\nProblem Tanımı # $n$ uzunluğunda bir tam sayı dizisi veriliyor. Hızlı sıralama algoritmasını kullanarak diziyi küçükten büyüğe sıralayın ve sonucu çıktı olarak verin.\nGiriş Formatı # İlk satırda tam sayı $n$ girilir. İkinci satırda $[1,10^9]$ aralığında $n$ adet tam sayı girilir. Çıkış Formatı # Sıralanmış diziyi tek bir satırda çıktı olarak verin. Veri Aralığı # $1 \\leq n \\leq 100000$\nGiriş Örneği # 5 3 1 2 4 5 Çıkış Örneği # 1 2 3 4 5 Hızlı Sıralama Yaklaşımı # Hızlı sıralama, her bölme aşamasında bir pivot (temel) sayı seçer (aşağıdaki örnekte orta konumdaki sayı seçilmiştir).\nSol ve sağ işaretçiler kullanarak birbirine doğru ilerleyin. Sol işaretçi L soldan sağa doğru pivot sayısından büyük veya eşit olan ilk sayıyı arar, sağ işaretçi R ise sağdan sola doğru pivot sayısından küçük veya eşit olan ilk sayıyı arar ve ardından bu iki sayıyı yer değiştirir.\nSol işaretçi sağ işaretçiyi geçene veya sol işaretçi sağ işaretçiden bir birim daha büyük olana kadar bu süreç tekrarlanır. Bu işleme bir döngü denir.\nHer işaretçi hareketinden ve takastan sonra, \u0026ldquo;sol kısım ≤ pivot, sağ kısım ≥ pivot\u0026rdquo; yapısının bozulmaması sağlanır. Yani değişmezler [left, L) \u0026lt;= pivot ve (R, right] \u0026gt;= pivot vardır.\nAşağıdaki örnek kodda, left ve right şu anda işlenen kapalı aralığın sınırlarıdır ve pivot aralığın orta noktasındaki elemanı alır.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Karmaşıklık ve pivot Seçimi # Hızlı sıralamanın en kötü durumdaki karmaşıklığı $O(n^2)$ olduğundan, pivot seçimi çok önemlidir. Her zaman ilk veya son elemanı seçmek, neredeyse sıralı dizilerde büyük olasılıkla en kötü durumun ortaya çıkmasına neden olacaktır.\nOrta konumdaki elemanı almak dışında, rastgele bir elemanı pivot olarak seçmek veya sol, orta ve sağ elemanların medyanını pivot olarak almak da mümkündür.\nYaygın Hata Örnekleri # Aşağıdaki kod birkaç yaygın hata içermektedir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Hata Analizi:\npivot bir dizi elemanı olmalıdır, indeks değil. \u0026lt; ve \u0026gt; yerine \u0026lt;= ve \u0026gt;= kullanıldığında, sol işaretçi sağ işaretçiden bir birimden fazla geçebilir, bu da diziyi iki parçaya bölmeyi imkansız kılar. l \u0026gt;= r durumu bulunduktan sonra döngüden hemen çıkılmalıdır ve takas yapılmamalıdır. Aksi takdirde, sol kısımdaki elemanların pivottan büyük olmaması ve sağ kısımdaki elemanların pivottan küçük olmaması garanti edilemez. Her takastan sonra l++ ve r-- yapılmalıdır. pivot aslında ortanın solunda kalan bir sayı olarak alınır. Eğer diziyi $l - 1$ ve $l$ kullanarak bölerseniz, [1, 2] dizisinde sonsuz döngü oluştuğunu göreceksiniz ve dizi sürekli olarak 0 ve 2 boyutlu parçalara ayrılacaktır. Bunun aksine, döngü bittiğinde $r$, $right$tan kesinlikle küçük olacaktır. Bu nedenle diziyi $r$ ve $r+1$ kullanarak bölmek mümkündür. Okuyucular, neden olduğunu görmek için algoritma sürecini simüle edebilirler. Sonsuz döngüden kaçınmanın bir başka basit yolu da rastgele bir pivot seçmek veya sadece iki eleman olduğu durumları özel olarak ele almaktır. Benzer şekilde, diziyi $r$ ve $l$ ile bölmek de çalışmaz. Ayrıca, $l$, $l+1$ kullanmak da işe yaramaz, çünkü bu bölme tanıma uygun değildir. $r$\u0026lsquo;nin $l$\u0026lsquo;nin solunda olduğu durumda, $l$, $l+1$ kullanmak diziyi doğru bir şekilde sol taraf pivottan küçük veya eşit, sağ taraf pivottan büyük veya eşit olacak şekilde iki parçaya ayıramaz. Bu soruda dizinin boş olmadığı varsayılmaktadır, bu nedenle \u0026gt; durumu mevcut değildir. Ancak \u0026gt;=, kullanılması daha güvenlidir. Ek Bilgiler # Hızlı sıralama, \u0026ldquo;hızlı seçim\u0026quot;e de dönüştürülebilir. $O(n)$ beklenen sürede sıralanmamış bir dizideki $k$\u0026lsquo;inci en küçük sayıyı bulmak için hızlı sıralamaya benzer bir fikir kullanılır, ancak her seferinde sadece bir alt aralıkta yineleme yapılmasıyla zaman karmaşıklığı düşürülür.\n","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Hızlı sıralama algoritmasının doğru bir şekilde uygulanmasının önemli noktalarının analizi.","title":"Hızlı Sıralama","type":"posts"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Aralık 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A4%E0%A5%8D%E0%A4%B5%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"त्वरित सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Problem # $N$ adet eşya var. $i$. eşyanın hacmi $s_i$, değeri $v_i$. Her eşya yalnızca bir kez alınabilir. Toplam hacim sınırını aşmamak ($S$) koşuluyla, elde edilebilecek maksimum toplam değeri ($V$) bulun.\nGiriş Formatı # İlk satırda iki tam sayı bulunur, $N$ ve $S$, boşlukla ayrılmış olarak, sırasıyla eşya sayısını ve maksimum toplam hacim sınırını belirtir. Sonraki $N$ satırda, her satırda iki tam sayı bulunur, $s_i$ ve $v_i$, boşlukla ayrılmış olarak, sırasıyla $i$. eşyanın hacmini ve değerini belirtir.\nÇıkış Formatı # Maksimum değeri temsil eden bir tam sayı çıktısı verin.\nVeri Aralığı # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Giriş Örneği # 4 5 1 2 2 4 3 4 4 5 Çıkış Örneği # 8 Çözüm # Durumları tanımlama: f[i][j], ilk $i$ eşya için, hacim sınırı $j$ iken elde edilebilecek maksimum değeri temsil eder. Eğer $i$. eşyayı almazsak, o zaman f[i][j] = f[i - 1][j] Eğer $i$. eşyayı alırsak, o zaman f[i][j] = f[i - 1][j - s[i]] + v[i] Durum geçişini uygularken, tanım aralığına dikkat edilmelidir. Eğer $j \u003c s_i$ ise, $i$. eşyayı alma durumu dikkate alınmaz. Çünkü eğer $j-s_i$ negatif olursa, dizi indeksi geçersiz olur. Veya şöyle de açıklanabilir: $i$. eşyanın hacmi, hacim sınırından daha büyüktür, bu yüzden mümkün değildir. Başlangıç koşullarını tanımlama: İlk 0 eşya için, herhangi bir hacim sınırında elde edilen değer 0\u0026rsquo;dır, yani f[0][j] = 0, j $\\in [0, S]$. Zaman karmaşıklığı: $O(NS)$. Kod # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Bir Boyutlu DP Optimizasyonu # İki boyutlu diziyi bir boyutlu diziye sıkıştırmak, yerden tasarruf sağlayabilir ve çalışma hızını bir dereceye kadar artırabilir (dezavantajı, bazı problem türlerinin özel gereksinimlerini karşılayamamasıdır). Durum geçişinde, f[i][j]\u0026lsquo;nin yalnızca f[i - 1][j] ve f[i - 1][j - s[i]] ile ilişkili olduğuna dikkat edin. Başka bir deyişle, koddaki iki boyutlu dizi f\u0026lsquo;de, f[i][j] yalnızca bir önceki satırda kendinden daha solda veya aynı sütundaki elemanlarla ilişkilidir, bu nedenle iki boyutlu dizi bir boyutlu diziye veya kayan diziye sıkıştırılabilir. Aşağıdaki kodda, ikinci döngünün ters sırada geçtiğine dikkat edin, çünkü f[i][j]\u0026lsquo;yi hesaplarken, f[i - 1][j - s[i]]\u0026lsquo;nin henüz güncellenmemiş olmasını sağlamak istiyoruz. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Eğer Çözüm Sayısı İstenirse # Sadece elde edilebilecek maksimum toplam değeri değil, \u0026ldquo;bu maksimum toplam değere ulaşmak için kaç farklı seçim yöntemi olduğu\u0026rdquo; da çıktı olarak verilmesi gerekiyorsa. Şimdi 01 sırt çantası probleminde çözüm sayısının nasıl sayılacağını anlatacağız.\nİki Boyutlu DP ile Çözüm Sayısı Sayımı # Aşağıda iki boyutlu DP örneği ile açıklayacağız.\nDurum tanımlama:\ndp[i][j], \u0026ldquo;ilk i eşya için, kapasite (hacim sınırı) j iken, elde edilebilecek maksimum değer\u0026rdquo; anlamına gelir. ways[i][j], \u0026ldquo;ilk i eşya için, kapasite j iken, maksimum değere ulaşılırkenki çözüm sayısı\u0026rdquo; anlamına gelir. Durum geçişi:\nEğer i\u0026lsquo;inci eşya seçilmezse: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Eğer i\u0026lsquo;inci eşya seçilirse (ön koşul $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Seçme veya seçmeme durumunda, nihai dp[i][j] iki değerin daha büyük olanını almalıdır: Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ o zaman \u0026ldquo;i\u0026rsquo;inci eşyayı seçmenin\u0026rdquo; değeri daha büyük demektir: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ o zaman iki şekilde de elde edilen maksimum değer aynıdır, bu durumda çözüm sayıları toplanmalıdır: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Eğer $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ o zaman \u0026ldquo;i\u0026rsquo;inci eşyayı seçmemenin\u0026rdquo; değeri daha büyüktür, bu durumda çözüm sayısı, seçmeme durumundaki çözüm sayısını devralır: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Başlangıç koşulları:\ndp[0][j] = 0, ilk 0 eşya için, herhangi bir kapasitede elde edilen maksimum değerin 0 olduğunu belirtir. ways[0][0] = 1, \u0026ldquo;ilk 0 eşya, kapasite 0\u0026rdquo; durumu için bir uygun çözüm olduğunu (yani hiçbir şey seçmemek) ve çözüm sayısının 1 olarak ayarlanması gerektiğini belirtir. j \u0026gt; 0 için, seçilecek eşya olmadığında kapasite 0\u0026rsquo;dan büyükse, herhangi bir pozitif değer elde etmek mümkün değildir ve karşılık gelen çözüm sayısı 0\u0026rsquo;dır, yani ways[0][j] = 0. Nihai cevap:\ndp[N][S] maksimum değerdir. ways[N][S] bu maksimum değere ulaşmanın çözüm sayısıdır. Zaman karmaşıklığı: $O(NS)$. Bu problem bir boyutlu DP ile de optimize edilebilir. Eğer Hacim Sınırına Tam Olarak Ulaşmak İstenirse # Durumları tanımlama: f[i][j], ilk i eşya için tam olarak j hacmine sahipken elde edilen maksimum değeri temsil eder. Eğer i\u0026lsquo;inci eşya seçilmezse, o zaman f[i][j] = f[i - 1][j] Eğer i\u0026lsquo;inci eşya seçilirse, o zaman f[i][j] = f[i - 1][j - s[i]] + v[i] Orijinal problemle durum geçişinin aynı olduğuna dikkat edin. Ancak başlangıç koşulları farklıdır. f[0][0] = 0 hariç, diğer tüm f[0][j] = $-\\infty$, j $\\in [1, S]$ olur. $-\\infty$ imkansız bir durumu temsil eder. Eğer Hacim Sınırı $S$ Çok Büyük (1e9) ve Aynı Zamanda Eşya Sayısı $N$ ve Maksimum Toplam Değer $V$ Küçükse # Bu tür bir problem için $O(NV)$ karmaşıklığına sahip bir çözüm vardır. Durumları tanımlama: f[i][j], ilk i eşyadan birkaç tanesini seçerek, toplam değerin tam olarak j olduğu en küçük hacmi temsil eder. Eğer i\u0026lsquo;inci eşya seçilmezse, o zaman f[i][j] = f[i - 1][j] Eğer i\u0026lsquo;inci eşya seçilirse, o zaman f[i][j] = f[i - 1][j - v[i]] + s[i] İkisinin daha küçüğü alınır. Başlangıç koşulları: f[0][0] = 0, diğer tüm f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ imkansız bir durumu temsil eder. $-\\infty$ değil. Nihai cevap, f[N][j] içinde f[N][j] \u0026lt;= S olan en büyük j olur. Eğer Hacim Sınırı $S$ ve Tek Eşya Değerleri $v_i$ Çok Büyükse (1e9 mertebesinde) ve Aynı Zamanda Eşya Sayısı $N$ Çok Küçükse (en fazla 40) # $N \\leq 20$ olduğunda, tüm alt kümeler doğrudan kabaca numaralandırılabilir (zaman karmaşıklığı $O(2^N)$). $N \\leq 40$ olduğunda, $2^{40}$ $10^{12}$ mertebesinde olduğu için, doğrudan kabaca numaralandırma da büyük olacaktır, bu nedenle ortadan bölme araması kullanılabilir. , bu da karmaşıklığı kabaca $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$\u0026lsquo;ye düşürür. , bu da kabul edilebilir bir süre içinde tamamlanabilir. ","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"En temel klasik sırt çantası problemi.","title":"01 Sırt Çantası Problemi","type":"posts"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"Eğer sıralı çözüm uzayı sol ve sağ olmak üzere iki kısma ayrılıyorsa ve bu kısımlardan biri koşulu sağlıyor diğeri ise sağlamıyorsa, sıralı çözüm uzayında kritik noktayı bulmak için ikili arama kullanılabilir.\nİkili aramanın temel fikri, arama aralığını sürekli olarak ikiye bölmektir. Her kontrol noktasında orta nokta elemanı kontrol edilir, eğer orta nokta elemanı koşulu sağlamıyorsa aralığın yarısı elenir; aksine, diğer yarısında aramaya devam edilir. Her defasında arama aralığının yarısı atıldığı için arama zaman karmaşıklığı $O(\\log n)$\u0026lsquo;ye ulaşabilir.\nÖrnek Problem # Problem Tanımı:\nUzunluğu $n$ olan sıralı bir tam sayı dizisi ve $q$ tane sorgu verilmiştir. Her sorgu bir tam sayı $k$ verir ve dizideki $k$\u0026lsquo;nin \u0026ldquo;başlangıç konumunu\u0026rdquo; ve \u0026ldquo;bitiş konumunu\u0026rdquo; bulmamız gerekir (indisler 0\u0026rsquo;dan başlar). Eğer dizide bu sayı yoksa -1 -1 döndürün.\nGiriş Formatı # İlk satır: Dizi uzunluğunu ve sorgu sayısını gösteren iki tam sayı $n$ ve $q$. İkinci satır: Sıralı bir şekilde düzenlenmiş tüm diziyi gösteren $n$ adet tam sayı. Sonraki $q$ satır: Her biri sorgu elemanını gösteren bir tam sayı $k$ içerir. Veri Aralığı # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nÇıkış Formatı # Her sorgu için, dizideki elemanın başlangıç ve bitiş konumunu bir satırda yazdırın. Eğer eleman dizide yoksa -1 -1 yazdırın.\nÖrnek:\nGiriş: 6 3 1 2 2 3 3 4 3 4 5 Çıkış: 3 4 5 5 -1 -1 Açıklama:\n$3$ elemanının aralığı $[3, 4]$\u0026lsquo;tür; $4$ elemanı yalnızca bir kez, $5$ konumunda görünür; $5$ elemanı dizide yoktur, bu nedenle $-1$ $-1$ döndürülür. Çözüm # \u0026ldquo;Başlangıç konumunu\u0026rdquo; bulmak: Yani, $k$\u0026lsquo;ye eşit veya büyük olan ilk konumu bulmak. Diziyi iki kısma bölebiliriz:\nSoldaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;küçük\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya büyük\u0026rdquo; Cevap sağdaki ilk konumdur. \u0026ldquo;Bitiş konumunu\u0026rdquo; bulmak: Yani, $k$\u0026lsquo;ye eşit veya küçük olan son konumu bulmak. Diziyi iki kısma bölebiliriz:\nSoldaki tüm sayılar $k$\u0026lsquo;ye \u0026ldquo;eşit veya küçük\u0026rdquo; Sağdaki tüm sayılar $k$\u0026lsquo;den \u0026ldquo;büyük\u0026rdquo; Cevap soldaki son konumdur. Önerilen Şablon # Aşağıda, zarif ve hataya yatkın olmayan bir ikili arama şablonu bulunmaktadır. Bu şablon, $l$ ve $r$\u0026lsquo;nin yavaşça yakınlaşmasını sağlayarak döngünün her ikisi de bitişik olduğunda sona ermesini garanti eder:\nİki işaretçi $l, r$ tanımlanır, sabitler şöyledir: kapalı aralık $[0, l]$ sol yarıya aittir ve kapalı aralık $[r, n - 1]$ sağ yarıya aittir. $l$ ve $r$ başlangıçta $-1$ ve $n$ olarak ayarlanır.\nAlgoritma bittiğinde, $l$ ve $r$ bitişiktir, sırasıyla sol yarıdaki son elemanı ve sağ yarıdaki ilk elemanı işaret eder.\nİstediğimiz çözüm mevcut olmayabileceğinden, eğer soruda mutlaka bir çözüm olduğu belirtilmemişse, l veya r\u0026lsquo;nin sınırların dışına çıkıp çıkmadığını ve doğru değeri işaret edip etmediğini kontrol etmemiz gerekir.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k\u0026#39;nin başlangıç konumunu bul 15 // Diziyi iki kısma ayır, sol taraf \u0026lt; k, sağ taraf \u0026gt;= k. 16 // Cevap sağ tarafın en küçük indeksidir. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Eğer r sınırların dışına çıktıysa veya nums[r] != k ise, k\u0026#39;nin mevcut olmadığını belirtir 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k\u0026#39;nin bitiş konumunu bul 33 // Diziyi iki kısma ayır, sol taraf \u0026lt;= k, sağ taraf \u0026gt; k. 34 // Cevap sol tarafın en büyük indeksidir. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Neden Böyle Yazıyoruz # Bu yazımın kesin olarak tanımlanmış değişmezleri vardır. Hem \u0026ldquo;başlangıç konumunu\u0026rdquo; hem de \u0026ldquo;bitiş konumunu\u0026rdquo; bulma durumlarına aynı anda uygulanabilir, ek işlem ve değişikliklere gerek kalmaz. Bazı yazımlarda durdurma koşulu olarak l == r kullanılır. $l$ ve $r$ arasındaki fark $1$ olduğunda, $mid$ $l$ veya $r$\u0026lsquo;ye eşit olarak hesaplanır. Doğru işlenmezse, $l$ veya $r$\u0026lsquo;yi $mid$ olarak güncelleyerek, arama aralığı daralmaz ve sonsuz döngüye yol açar. Aksine, buradaki yazım $l$ ve $r$ bitişik olduğunda durdurulur, $mid$\u0026lsquo;in $l$\u0026lsquo;den küçük ve $r$\u0026lsquo;den büyük olmasını sağlayarak, $l$ veya $r$ güncellendiğinde arama aralığının kesinlikle daralmasını sağlar. STL # C++ STL tarafından sağlanan lower_bound ve upper_bound işlevlerini kullanırsak, aynı işi tamamlayabiliriz:\nlower_bound(first, last, val) \u0026ldquo;val\u0026rsquo;e eşit veya büyük olan ilk konumu\u0026rdquo; döndürür. upper_bound(first, last, val) \u0026ldquo;val\u0026rsquo;den büyük olan ilk konumu\u0026rdquo; döndürür. Örnek olarak, nums = {1,2,3,4,4,4,4,4,5,5,6} olduğunu ve 4\u0026rsquo;ün aralığını öğrenmek istediğimizi varsayalım:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4, 0 kere görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;ilk 4, \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;son 4, \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; \u0026#34; konumunda\u0026#34; \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4, \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; kere görünüyor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1, değeri $4$\u0026lsquo;e eşit veya büyük olan ilk konumu işaret eder. it2, değeri $4$\u0026lsquo;ten büyük olan ilk konumu işaret eder. Bu nedenle it2 - it1, $4$\u0026lsquo;ün dizide kaç kez göründüğüdür; it2 - nums.begin() - 1 ise $4$\u0026lsquo;ün sağ sınırıdır. Ek # İkili arama, kayan noktalı sayı aralığında arama yapmaya (örneğin, bir denklemin köklerini bulmaya) ve tek tepeli fonksiyonun maksimum değerini bulmak için üçlü arama yapmaya kadar genişletilebilir. \u0026ldquo;Sıralı bir aralıkta her seferinde yarısını eleyebildiğiniz\u0026rdquo; temel ilkesini anladığınız sürece, ikili aramanın birçok senaryoda sorunları verimli bir şekilde çözmenize yardımcı olacağını göreceksiniz.\nAlıştırma # LeetCode 33. Search in Rotated Sorted Array\nİpucu: İlk adımda, dönme noktasını bulmak için ikili arama kullanın, ikinci adımda ise hedef değeri bulmak için ikili arama kullanın.\n","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"İkili arama algoritması nasıl zarif bir şekilde uygulanır.","title":"İkili Arama","type":"posts"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 Aralık 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]