[{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-dalgorithmes/","section":"Tags","summary":"","title":"Modèles D'algorithmes","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmi/","section":"Tags","summary":"","title":"Template Algoritmi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":" Tìm kiếm nhị phân # Nếu không gian nghiệm có thứ tự được chia thành hai phần bên trái và bên phải, trong đó một phần thỏa mãn điều kiện và phần còn lại không thỏa mãn điều kiện, thì có thể sử dụng tìm kiếm nhị phân để tìm điểm giới hạn trong không gian nghiệm có thứ tự.\nÝ tưởng cơ bản của tìm kiếm nhị phân là liên tục chia đôi khoảng tìm kiếm. Mỗi lần kiểm tra phần tử ở giữa, nếu phần tử giữa không thỏa mãn điều kiện, thì có thể loại bỏ một nửa khoảng; ngược lại, tiếp tục tìm kiếm ở nửa khoảng còn lại. Vì mỗi lần đều loại bỏ một nửa khoảng tìm kiếm, độ phức tạp thời gian tìm kiếm có thể đạt \\(O(\\log n)\\).\nBài toán ví dụ # Mô tả bài toán:\nCho một mảng số nguyên độ dài \\(n\\) được sắp xếp theo thứ tự tăng dần, và có \\(q\\) truy vấn. Mỗi truy vấn đưa ra một số nguyên \\(k\\), chúng ta cần tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; của \\(k\\) trong mảng (chỉ số bắt đầu từ 0). Nếu số này không tồn tại trong mảng, hãy trả về \\(-1\\) \\(-1\\).\nĐịnh dạng đầu vào # Dòng đầu tiên: Hai số nguyên \\(n\\) và \\(q\\), lần lượt biểu thị độ dài mảng và số lần truy vấn. Dòng thứ hai: \\(n\\) số nguyên, biểu thị mảng đầy đủ, đã được sắp xếp theo thứ tự tăng dần. \\(q\\) dòng tiếp theo: Mỗi dòng chứa một số nguyên \\(k\\), biểu thị một phần tử truy vấn. Phạm vi dữ liệu # \\(1 \\leq n \\leq 100000\\)\n\\(1 \\leq q \\leq 10000\\)\n\\(1 \\leq k \\leq 10000\\)\nĐịnh dạng đầu ra # Đối với mỗi truy vấn, in ra vị trí bắt đầu và kết thúc của phần tử đó trong mảng trên một dòng. Nếu phần tử đó không tồn tại trong mảng, in ra -1 -1.\nVí dụ:\nĐầu vào: 6 3 1 2 2 3 3 4 3 4 5 Đầu ra: 3 4 5 5 -1 -1 Giải thích:\nPhạm vi xuất hiện của phần tử \\(3\\) là \\([3, 4]\\); Phần tử \\(4\\) chỉ xuất hiện một lần, ở vị trí \\(5\\); Phần tử \\(5\\) không tồn tại trong mảng, do đó trả về \\(-1\\) \\(-1\\). Giải pháp # Tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo;: Tức là tìm vị trí đầu tiên lớn hơn hoặc bằng \\(k\\). Có thể chia mảng thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn\u0026rdquo; \\(k\\) Tất cả các số bên phải đều \u0026ldquo;lớn hơn hoặc bằng\u0026rdquo; \\(k\\) Đáp án là vị trí đầu tiên bên phải Tìm \u0026ldquo;vị trí kết thúc\u0026rdquo;: Tức là tìm vị trí cuối cùng nhỏ hơn hoặc bằng \\(k\\). Có thể chia mảng thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn hoặc bằng\u0026rdquo; \\(k\\) Tất cả các số bên phải đều \u0026ldquo;lớn hơn\u0026rdquo; \\(k\\) Đáp án là vị trí cuối cùng bên trái Mẫu đề xuất # Dưới đây là một mẫu tìm kiếm nhị phân thanh lịch và khó mắc lỗi. Bằng cách cho \\(l\\) và \\(r\\) dần dần tiến gần nhau, đảm bảo vòng lặp sẽ kết thúc khi cả hai liền kề nhau:\nXác định hai con trỏ \\(l, r\\), có bất biến: Khoảng đóng \\([0, l]\\) thuộc nửa bên trái, khoảng đóng \\([r, n - 1]\\) thuộc nửa bên phải. \\(l\\) và \\(r\\) được khởi tạo lần lượt là \\(-1\\) và \\(n\\).\nKhi thuật toán kết thúc, \\(l\\) và \\(r\\) liền kề nhau, lần lượt trỏ đến phần tử cuối cùng của nửa bên trái và phần tử đầu tiên của nửa bên phải.\nVì giải pháp chúng ta muốn có thể không tồn tại, nên nếu bài toán không nói rõ rằng luôn tồn tại giải pháp, chúng ta cần kiểm tra xem l hoặc r có vượt quá giới hạn hay không và có trỏ đến giá trị đúng không.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Tìm vị trí bắt đầu của k 15 // Chia mảng thành hai phần, bên trái đều \u0026lt; k, bên phải đều \u0026gt;= k. 16 // Đáp án là chỉ số nhỏ nhất của nửa bên phải. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Nếu r vượt quá giới hạn hoặc nums[r] != k, thì k không tồn tại 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Tìm vị trí kết thúc của k 33 // Chia mảng thành hai phần, bên trái đều \u0026lt;= k, bên phải đều \u0026gt; k. 34 // Đáp án là chỉ số lớn nhất của nửa bên trái. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Tại sao viết như vậy # Cách viết này có các bất biến được định nghĩa chặt chẽ. Nó đồng thời áp dụng cho cả hai trường hợp tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo;, không cần xử lý và thay đổi thêm. Một số cách viết sử dụng l == r làm điều kiện kết thúc. Khi \\(l\\) và \\(r\\) cách nhau \\(1\\), \\(mid\\) sẽ được tính bằng với \\(l\\) hoặc \\(r\\). Nếu không xử lý chính xác, việc cập nhật \\(l\\) hoặc \\(r\\) thành \\(mid\\) thì khoảng tìm kiếm sẽ không thu hẹp, dẫn đến vòng lặp vô hạn. Ngược lại, cách viết ở đây sẽ kết thúc khi \\(l\\) và \\(r\\) liền kề nhau, đảm bảo \\(mid\\) nhỏ hơn \\(l\\) và lớn hơn \\(r\\), khi cập nhật \\(l\\) hoặc \\(r\\), khoảng tìm kiếm chắc chắn sẽ thu hẹp. STL # Nếu sử dụng các hàm lower_bound và upper_bound do C++ STL cung cấp, bạn cũng có thể hoàn thành công việc tương tự:\nlower_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn hoặc bằng val\u0026rdquo; upper_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn val\u0026rdquo; Ví dụ, giả sử nums = {1,2,3,4,4,4,4,4,5,5,6}, chúng ta muốn biết khoảng xuất hiện của số 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 trỏ đến vị trí có giá trị đầu tiên lớn hơn hoặc bằng \\(4\\). it2 trỏ đến vị trí có giá trị đầu tiên lớn hơn \\(4\\). Vậy it2 - it1 là số lần \\(4\\) xuất hiện trong mảng; it2 - nums.begin() - 1 là biên phải của \\(4\\). Bổ sung # Tìm kiếm nhị phân cũng có thể mở rộng để tìm kiếm phạm vi số thực (ví dụ: tìm nghiệm của phương trình) và tìm kiếm ba phân để tìm giá trị lớn nhất của hàm đơn đỉnh. Chỉ cần bạn hiểu nguyên lý cốt lõi là \u0026ldquo;trong khoảng có thứ tự, mỗi lần có thể loại bỏ một nửa\u0026rdquo;, bạn sẽ thấy rằng tìm kiếm nhị phân có thể giúp bạn giải quyết vấn đề hiệu quả trong nhiều tình huống.\nLuyện tập # LeetCode 33. Tìm kiếm trong mảng đã xoay\nGợi ý: Bước đầu tiên sử dụng tìm kiếm nhị phân để tìm điểm xoay, bước thứ hai lại sử dụng tìm kiếm nhị phân để tìm giá trị mục tiêu.\n","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Làm thế nào để triển khai một cách thanh lịch thuật toán tìm kiếm nhị phân số nguyên.","title":"Tìm kiếm nhị phân","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथ्म","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%81/","section":"Categories","summary":"","title":"एल्गोरिथ्म और डेटा संरचनाएँ","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथ्म टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/vi/series/","section":"Series","summary":"","title":"Series","type":"series"}]