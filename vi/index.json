[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":" I. Định lý CAP # 1.1 Định lý CAP là gì # Định lý CAP được Eric Brewer đưa ra vào năm 2000, quan điểm cốt lõi của nó là:\nC (Consistency, Tính nhất quán): Tất cả các nút trong hệ thống đều nhìn thấy dữ liệu giống nhau tại cùng một thời điểm. Nói một cách chặt chẽ hơn, khi client đọc dữ liệu, bất kể đọc từ bản sao nào, kết quả phải nhất quán với dữ liệu đã được commit mới nhất (thường đề cập đến tính nhất quán mạnh/tính nhất quán tuyến tính). A (Availability, Tính khả dụng): Hệ thống vẫn có thể cung cấp dịch vụ bình thường khi có một phần lỗi xảy ra, mỗi yêu cầu đều có thể nhận được \u0026ldquo;phản hồi hợp lệ\u0026rdquo; trong một khoảng thời gian hợp lý (không nhất thiết phải thành công, bao gồm cả phản hồi lỗi chính xác). P (Partition tolerance, Tính chịu lỗi phân vùng): Hệ thống có thể chịu được phân vùng mạng (giao tiếp giữa các nút không thể truy cập được), ngay cả khi mạng bị chia cắt, hệ thống vẫn có thể cung cấp một mức độ khả dụng hoặc tính nhất quán nhất định. Trong môi trường phân tán thực tế, phân vùng mạng là điều không thể tránh khỏi, vì vậy P về cơ bản được coi là \u0026ldquo;tùy chọn bắt buộc\u0026rdquo;. Khi phân vùng mạng xảy ra, hệ thống không thể đồng thời đảm bảo tính nhất quán mạnh và tính khả dụng cao của dữ liệu trên tất cả các nút, mà chỉ có thể lựa chọn giữa C và A, do đó phát sinh hai loại chính là CP và AP.\n1.2 Hạn chế của định lý CAP # Cần lưu ý rằng, bản thân định lý CAP là một lý thuyết tương đối ở cấp độ cao, được áp dụng để hướng dẫn khái niệm, không thể hiểu đơn giản là \u0026ldquo;hoặc chọn C, hoặc chọn A\u0026rdquo;. Có một số hiểu lầm phổ biến:\nC không nhất thiết là tính nhất quán mạnh C trong định lý CAP thường đề cập đến tính nhất quán theo nghĩa chặt chẽ nhất (tức là tính nhất quán tuyến tính). Nhưng trong hệ thống thực tế, chúng ta có nhiều mô hình chi tiết hơn để lựa chọn như tính nhất quán yếu, đọc đã commit (Read Committed), tính nhất quán nhân quả (Causal Consistency), v.v. Tính khả dụng không phải là 0 hoặc 1 Không phải cứ chọn CP là tính khả dụng hoàn toàn bị hy sinh; hoặc chọn AP là tính nhất quán không được đảm bảo. Tính khả dụng và tính nhất quán đều có không gian thỏa hiệp và các chiến lược giảm cấp khác nhau. Tính nhất quán cuối cùng không vi phạm CAP Đây là một giải pháp thỏa hiệp rất phổ biến, sử dụng tính nhất quán ghi thấp hơn để đổi lấy tính khả dụng và thông lượng cao hơn, đồng thời hội tụ dữ liệu ở chế độ nền thông qua phương thức không đồng bộ. Do đó, định lý CAP nên được kết hợp với các mô hình nhất quán, mô hình kiến trúc khả dụng cao vào các tình huống cụ thể, thì mới có thể tạo ra giá trị hướng dẫn thực sự.\nII. Mô hình nhất quán của hệ thống phân tán # Việc phân loại các mô hình nhất quán rất phong phú, nhưng các mô hình chủ đạo phổ biến có thể được chia thành: tính nhất quán mạnh và tính nhất quán yếu (trong đó bao gồm tính nhất quán cuối cùng, tính nhất quán nhân quả, v.v.). Bài viết này chủ yếu giới thiệu tính nhất quán mạnh và tính nhất quán cuối cùng, đồng thời giải thích các ứng dụng phổ biến của chúng trong chế độ CP hoặc AP.\n2.1 Tính nhất quán mạnh # Tính nhất quán mạnh (Strong Consistency) còn được gọi là tính nhất quán tuyến tính (Linearizability), đề cập đến việc một khi thao tác ghi hoàn thành và trả về thành công, bất kỳ thao tác đọc nào sau đó đều có thể đọc được nội dung cập nhật đó. Nói cách khác, hệ thống thể hiện ra bên ngoài như thể đã thực hiện tất cả các thao tác một cách tuần tự.\nTriển khai phổ biến: Dựa vào sao chép đồng bộ và cơ chế trọng tài (đa số), thông qua các giao thức (như Paxos/Raft) để đảm bảo rằng chỉ có một leader (người lãnh đạo) hợp lệ trong hệ thống, tất cả các thao tác được ghi vào nhật ký theo thứ tự và sao chép đến đa số các nút. Ưu nhược điểm: Ưu điểm: Đảm bảo tính chính xác dữ liệu nghiêm ngặt nhất, dữ liệu đọc được không bao giờ bị \u0026ldquo;quay lại\u0026rdquo;. Nhược điểm: Khi mạng bị rung lắc, phân vùng hoặc leader bị lỗi, để duy trì tính nhất quán, thao tác ghi thường bị chặn, dẫn đến giảm tính khả dụng tổng thể; hiệu suất và thông lượng cũng tương đối thấp hơn. 2.2 Tính nhất quán cuối cùng # Tính nhất quán cuối cùng (Eventual Consistency) là một hình thức điển hình của tính nhất quán yếu, nó chỉ yêu cầu nếu hệ thống không còn thao tác cập nhật mới, theo thời gian, dữ liệu của tất cả các bản sao sẽ dần hội tụ về cùng một trạng thái. Trong thời gian đó, người dùng đọc dữ liệu bản sao có thể thấy các giá trị đã lỗi thời, nhưng cuối cùng sẽ trở nên nhất quán.\nTriển khai phổ biến: Giao thức Gossip, sao chép không đồng bộ nhiều bản sao, CRDT (Conflict-free Replicated Data Type), v.v. Ưu nhược điểm: Ưu điểm: Tính khả dụng cao, thông lượng cao, độ trễ thao tác ghi thấp, khả năng chịu lỗi phân vùng mạng cao. Nhược điểm: Cần chấp nhận sự không nhất quán dữ liệu trong thời gian ngắn, logic ứng dụng phức tạp hơn, có thể phải thực hiện phát hiện và hợp nhất xung đột. III. Các giao thức và thuật toán nhất quán phổ biến # Để các bản sao của hệ thống phân tán duy trì tính nhất quán, ngành công nghiệp đã đưa ra nhiều thuật toán và giao thức cổ điển. Dưới đây là giới thiệu ngắn gọn về một số loại:\n3.1 Paxos # Paxos là một thuật toán nhất quán phân tán do Leslie Lamport đề xuất vào những năm 1990, chủ yếu được sử dụng để thực hiện tính nhất quán mạnh hoặc tính nhất quán tuyến tính.\nNguyên tắc cơ bản: Thông qua việc phân chia vai trò (Proposer - Người đề xuất, Acceptor - Người chấp nhận, Learner - Người học) để thực hiện nhiều vòng bỏ phiếu, để quyết định xem một thao tác hoặc giá trị có được đa số các nút chấp nhận hay không. Ưu nhược điểm: Ưu điểm: Có thể đạt được sự nhất quán ngay cả khi có phân vùng mạng, lỗi nút, có tính bảo mật cao. Nhược điểm: Triển khai phức tạp, khó gỡ lỗi và khắc phục sự cố, nhiều vòng bỏ phiếu dẫn đến hiệu suất bị hạn chế. Ngành công nghiệp thường sử dụng các biến thể của nó (Multi-Paxos, v.v.). 3.2 Raft # Raft được chính thức đề xuất vào năm 2013, mục tiêu là đơn giản hóa việc triển khai và độ khó hiểu trong khi vẫn đảm bảo tính bảo mật tương đương với Paxos. Nó thiết lập một vai trò leader (người lãnh đạo) ổn định, tập trung vào việc sao chép nhật ký và khôi phục lỗi:\nCác giai đoạn quan trọng: Bầu chọn leader (Leader Election), sao chép nhật ký (Log Replication), tính bảo mật (Safety), v.v. Ứng dụng phổ biến: Etcd, Consul, TiKV, LogCabin, v.v. đều dựa trên Raft để thực hiện sao chép nhất quán mạnh. Ưu nhược điểm: Ưu điểm: Tương đối dễ hiểu, lượng code triển khai ít hơn; hiệu suất tốt hơn cho các cụm nhỏ và vừa. Nhược điểm: Phụ thuộc vào nút chính (Leader), lỗi hoặc phân vùng của nút chính sẽ gây ra tắc nghẽn ghi tạm thời; khi triển khai trên các cụm lớn hoặc trên nhiều khu vực địa lý, độ trễ và tính khả dụng sẽ bị ảnh hưởng. 3.3 Giao thức Gossip # Giao thức Gossip (tám chuyện) không phải là một giao thức đồng thuận truyền thống, nó chủ yếu được sử dụng trong các tình huống phi tập trung để trao đổi siêu dữ liệu hoặc thông tin trạng thái thông qua tương tác ngẫu nhiên giữa các nút, do đó khuếch tán và hội tụ trên toàn mạng.\nĐặc điểm: Phi tập trung, chi phí thấp, các nút trao đổi tin nhắn định kỳ và ngẫu nhiên. Ứng dụng phổ biến: Cassandra, Riak, quản lý thành viên phân tán (như Serf), v.v., được sử dụng để thực hiện tính nhất quán cuối cùng, đồng bộ trạng thái bản sao, v.v. Ưu nhược điểm: Ưu điểm: Khả năng mở rộng tốt, dễ triển khai, phù hợp với các tình huống không yêu cầu cao về tính nhất quán, yêu cầu cao về khả năng mở rộng. Nhược điểm: Đảm bảo tính nhất quán yếu, cần các biện pháp xử lý xung đột ở cấp độ cao hơn (như CRDT, hợp nhất số phiên bản, v.v.) để giải quyết xung đột cuối cùng. 3.4 2PC / 3PC # Trong các tình huống giao dịch phân tán, các giao thức commit phổ biến là 2PC (Two-phase Commit) và 3PC (Three-phase Commit):\n2PC: Điều phối viên thông báo cho tất cả những người tham gia \u0026ldquo;chuẩn bị commit (prepare)\u0026rdquo;, nếu tất cả đều thành công thì phát \u0026ldquo;commit\u0026rdquo;, nếu không thì \u0026ldquo;rollback (hủy bỏ)\u0026rdquo;. 3PC: Thêm một giai đoạn trên cơ sở 2PC, giảm tắc nghẽn do lỗi một điểm, nhưng việc triển khai phức tạp hơn, vẫn có vấn đề không khả dụng trong các tình huống phân vùng mạng hoặc lỗi nghiêm trọng. Ưu nhược điểm: Ưu điểm: Dễ hiểu, ngữ nghĩa giao dịch rõ ràng, được ứng dụng rộng rãi trong cơ sở dữ liệu phân tán, hàng đợi tin nhắn, v.v. Nhược điểm: Phụ thuộc nhiều vào điều phối viên, có nguy cơ bị tắc nghẽn; khi mạng bị phân vùng trong thời gian dài, có thể không thể tiếp tục giao dịch. IV. Hai lựa chọn chủ đạo của CAP: CP và AP # Khi chúng ta xác định P là thuộc tính \u0026ldquo;bắt buộc\u0026rdquo;, thì hệ thống phân tán nếu muốn tiếp tục cung cấp dịch vụ khi có phân vùng mạng, thì phải lựa chọn giữa C và A. Do đó, thiết kế hệ thống phổ biến được chia thành hai phe chính là CP và AP.\n4.1 Hệ thống CP # CP (Consistency + Partition tolerance): Khi gặp phân vùng mạng, hệ thống sẽ chọn ưu tiên đảm bảo tính nhất quán, hy sinh tính khả dụng khi cần thiết.\nTriển khai điển hình: Đồng thuận đa số (Paxos, Raft, v.v.), cần hơn một nửa số nút hoạt động và đạt được sự nhất quán thì mới cho phép ghi. Nếu không thể đạt được quorum (số đại biểu tối thiểu) hoặc nút chính bị lỗi, hệ thống sẽ chặn hoặc từ chối thao tác ghi, để tránh tình trạng chia não dẫn đến dữ liệu không nhất quán. Ứng dụng phổ biến: Zookeeper, Etcd, Consul, dịch vụ khóa phân tán, quản lý siêu dữ liệu phân tán, v.v. Các tình huống yêu cầu tính nhất quán cao như quy trình cốt lõi của giao dịch tài chính, hệ thống kế toán ngân hàng, v.v. Đặc điểm: Có đảm bảo dữ liệu nghiêm ngặt: Thà ngừng hoạt động chứ không để xảy ra tình trạng hai nút chính hoặc dữ liệu hỗn loạn. Hy sinh một phần tính khả dụng: Khi xảy ra phân vùng mạng hoặc chuyển đổi dự phòng, sẽ có một khoảng thời gian dịch vụ không khả dụng hoặc từ chối thao tác ghi. 4.2 Hệ thống AP # AP (Availability + Partition tolerance): Khi gặp phân vùng mạng, hệ thống sẽ chọn ưu tiên đảm bảo tính khả dụng, đồng thời nới lỏng tính nhất quán.\nTriển khai điển hình: Tính nhất quán cuối cùng, sao chép nhiều nút chính, giao thức Gossip, chiến lược nhất quán có thể điều chỉnh theo phong cách Dynamo, v.v. Ứng dụng phổ biến: Cơ sở dữ liệu NoSQL (Cassandra, Riak, DynamoDB, v.v.), hệ thống bộ nhớ đệm phân tán (Redis Cluster), v.v. Các nghiệp vụ yêu cầu tính khả dụng cao, thông lượng cao, yêu cầu về tính nhất quán dữ liệu tương đối lỏng lẻo như mạng xã hội, thu thập nhật ký, hệ thống đề xuất, v.v. Đặc điểm: Ngay cả khi có phân vùng, tất cả các nút vẫn nhận yêu cầu đọc và ghi, đảm bảo hệ thống \u0026ldquo;khả dụng nhất có thể\u0026rdquo;. Dữ liệu có thể không nhất quán trong thời gian ngắn, nhưng sẽ dần hội tụ ở chế độ nền thông qua đồng bộ không đồng bộ, hợp nhất xung đột, v.v. V. Làm thế nào để lựa chọn giữa CP và AP? # Trong các hệ thống phân tán quy mô lớn thực tế, thường rất ít khi chỉ dựa vào một mô hình duy nhất, mà là xử lý phân lớp cho các dữ liệu hoặc tình huống nghiệp vụ khác nhau, để đạt được sự cân bằng tối ưu giữa tính nhất quán và tính khả dụng.\nDữ liệu cốt lõi chọn CP Ví dụ như số dư tài khoản người dùng, thanh toán đơn hàng, dòng tiền giao dịch tài chính, v.v., yêu cầu tính nhất quán rất cao. Chấp nhận việc không thể ghi tạm thời do mạng bị rung lắc, nhưng không thể chấp nhận lỗi về số dư hoặc số tiền giao dịch. Dữ liệu biên hoặc dữ liệu bộ nhớ đệm chọn AP Ví dụ như bộ nhớ đệm của trang chi tiết sản phẩm, nhật ký hành vi người dùng, danh sách ứng viên đề xuất, v.v., yêu cầu về tính nhất quán thấp hơn. Coi trọng tính đồng thời cao, tính khả dụng cao hơn, có thể chấp nhận việc cập nhật chậm trễ hoặc đọc dữ liệu bẩn trong một khoảng thời gian nhất định. Nhiều doanh nghiệp internet sẽ sử dụng kiến trúc hỗn hợp: quy trình giao dịch cốt lõi sử dụng bộ nhớ kiểu CP (như cơ sở dữ liệu quan hệ phân tán hoặc bộ nhớ phân tán có tính nhất quán mạnh); các nghiệp vụ ngoại vi hoặc các tình huống \u0026ldquo;đọc nhiều ghi ít\u0026rdquo; sử dụng bộ nhớ kiểu AP hoặc giải pháp bộ nhớ đệm.\nVI. CP và AP làm thế nào để đạt được tính đồng thời cao và tính nhất quán cuối cùng # 6.1 Hệ thống CP làm thế nào để đối phó với tính đồng thời cao # Mặc dù các giao thức đồng thuận sẽ phải đối mặt với độ trễ cao hơn và thông lượng thấp hơn khi quy mô nút cụm đơn lẻ và lượng yêu cầu ghi lớn, nhưng vẫn có thể cải thiện tính đồng thời và khả năng mở rộng thông qua các phương tiện sau:\nĐọc và ghi hàng loạt Đóng gói nhiều thao tác ghi ở client hoặc lớp trung gian, ghi một lần vào nút leader, giảm số lần khứ hồi mạng và số vòng giao thức. Phân tách cơ sở dữ liệu và bảng \u0026amp; Nhiều cụm Chia dữ liệu theo logic hoặc hash thành nhiều cụm (sharding), mỗi cụm vẫn chạy giao thức CP; các yêu cầu được phân tán đến các phân đoạn khác nhau thông qua lớp định tuyến hoặc proxy. Cải thiện khả năng đồng thời tổng thể và giới hạn ảnh hưởng của lỗi trong một phân đoạn duy nhất. Thông lượng của cụm phân đoạn đơn của hệ thống CP thường thấp hơn 2 đến 10 lần so với hệ thống AP.\n6.2 Hệ thống AP làm thế nào để đảm bảo tính nhất quán cuối cùng # Hệ thống AP thường có thể cung cấp thông lượng ghi và tính khả dụng đọc rất cao, nhưng lại nới lỏng tính nhất quán, do đó cần phải thực hiện đảm bảo hội tụ tính nhất quán ở lớp nền hoặc lớp logic nghiệp vụ:\nSố phiên bản (Vector Clock) hoặc dấu thời gian logic Gán một số phiên bản cho mỗi thao tác cập nhật (hoặc dựa trên Lamport Clock / Hybrid Clock), trong các tình huống xung đột, thực hiện hợp nhất hoặc chiến lược thắng dựa trên dấu thời gian (Last Write Wins). Giao thức Gossip / Cơ chế chống entropy (Anti-entropy) Các nút định kỳ trao đổi dữ liệu hoặc siêu dữ liệu mới nhất, nếu phát hiện xung đột thì thực hiện hợp nhất. Chiến lược nhất quán có thể điều chỉnh Lấy mô hình Dynamo làm đại diện, client có thể cấu hình các tham số R, W (như ghi đa số, xác nhận bản sao), do đó điều chỉnh linh hoạt giữa tính nhất quán và tính khả dụng. Chiến lược giải quyết xung đột tùy chỉnh Kết hợp ngữ nghĩa nghiệp vụ để hợp nhất, ví dụ như giỏ hàng sử dụng hợp nhất \u0026ldquo;hợp\u0026rdquo;, bộ đếm sử dụng CRDT (G-counter, PN-counter, v.v.) để đảm bảo tính đơn điệu của dữ liệu. VII. Thực hiện tính nhất quán mạnh trên nhiều phân đoạn của CP # Như đã đề cập trong chương VII, thông qua phân tách cơ sở dữ liệu và bảng (Sharding) có thể \u0026ldquo;tách\u0026rdquo; áp lực của một cụm CP duy nhất thành nhiều cụm con, để hỗ trợ tính đồng thời cao hơn. Tuy nhiên, khi nghiệp vụ cần thực hiện giao dịch trên nhiều phân đoạn (tức là liên quan đến việc cập nhật nhiều cơ sở dữ liệu hoặc bảng), vẫn phải đối mặt với thách thức về tính nhất quán trên nhiều phân đoạn. Thông thường có các ý tưởng sau:\nGiao dịch phân tán: 2PC / 3PC Nếu ứng dụng cần thực hiện cập nhật nguyên tử trên nhiều phân đoạn, thường sử dụng giao thức giao dịch phân tán (như 2PC, 3PC) để điều phối việc commit hoặc rollback của các phân đoạn. Vấn đề và đối sách: 2PC/3PC đều phụ thuộc vào một nút điều phối viên, có thể trở thành nút thắt cổ chai. Trong trường hợp phân vùng mạng nghiêm trọng hoặc điều phối viên bị lỗi, có thể xảy ra tắc nghẽn. Thông thường sẽ giảm ảnh hưởng của tắc nghẽn và rủi ro không nhất quán dữ liệu thông qua chuyển đổi chính-phụ, phát hiện nhịp tim và cơ chế hết thời gian chờ, thử lại lũy đẳng, MVCC, v.v. Kiến trúc dựa trên ô (Cell-based) Chia nghiệp vụ thành nhiều ô tự trị, dữ liệu trong mỗi ô đều nằm trong cùng một tập hợp phân đoạn, đảm bảo rằng hầu hết các giao dịch chỉ được hoàn thành trong một ô duy nhất, giảm thao tác trên nhiều phân đoạn. Sử dụng cơ chế không đồng bộ hoặc tính nhất quán cuối cùng trên ranh giới ô để trao đổi dữ liệu, đồng thời xem xét tính khả dụng và tính nhất quán tổng thể. Cơ sở dữ liệu phân tán toàn cầu + Giao thức đồng thuận toàn cục Ví dụ như Google Spanner thực hiện sao chép nhất quán mạnh trên mỗi phân đoạn (Shard) thông qua Paxos, sau đó sử dụng TrueTime API để cung cấp dấu thời gian toàn cục để đảm bảo tính nhất quán trên nhiều phân đoạn. Giải pháp này có độ phức tạp triển khai rất cao, nhưng có thể cung cấp khả năng giao dịch phân tán gần như nhất quán mạnh trong phạm vi toàn cầu. Tóm tắt: Đối với các giao dịch trên nhiều phân đoạn yêu cầu nghiêm ngặt tính nhất quán mạnh, 2PC/3PC + điều phối viên vẫn là giải pháp phổ biến, đồng thời cố gắng tăng tính khả dụng cao của điều phối viên để giảm khả năng xảy ra lỗi. Nhưng cần cố gắng giảm thiểu thao tác ghi trên nhiều phân đoạn trong thực tiễn kỹ thuật, hoặc giảm độ phức tạp của hệ thống thông qua ý tưởng ô để giới hạn hầu hết các giao dịch trong phạm vi một phân đoạn duy nhất.\nVIII. Thảo luận về các trường hợp nổi tiếng # Dưới đây là thảo luận ngắn gọn về một số hệ thống phân tán thường được đề cập trong ngành, hãy xem cách chúng lựa chọn và thực hiện CAP:\nGoogle Spanner Một hệ thống CP điển hình (thậm chí có thể đạt được ảo giác \u0026ldquo;CA\u0026rdquo; mà bên ngoài thường nói, nhưng về bản chất vẫn cần phải hy sinh một phần tính khả dụng). Sử dụng dấu thời gian chính xác bên ngoài do TrueTime cung cấp + sao chép Paxos bên trong mỗi phân đoạn, đảm bảo tính nhất quán mạnh trên các trung tâm dữ liệu. Phù hợp với các tình huống giao dịch tài chính toàn cầu hoặc yêu cầu tính nhất quán cao, nhưng chi phí cơ sở hạ tầng rất cao. BigTable / HBase Bề ngoài thiên về CP hơn, đảm bảo tính nhất quán của siêu dữ liệu thông qua điều phối phân tán giữa RegionServer và Master. Nhưng trong đường dẫn đọc và ghi thực tế, cũng có thể cung cấp một số phương tiện khả dụng cao thông qua sao chép không đồng bộ nhiều bản sao, tính nhất quán khi đọc có thể được điều chỉnh theo nhu cầu của ứng dụng. AWS DynamoDB Thiên về AP, cảm hứng thiết kế ban đầu đến từ bài báo Dynamo, có thể điều chỉnh cấp độ nhất quán thông qua các tham số R, W, v.v. Ở chế độ mặc định, cung cấp tính khả dụng cực cao và tính nhất quán cuối cùng, cũng có thể bật \u0026ldquo;đọc nhất quán mạnh\u0026rdquo; (nhưng chỉ đảm bảo tính nhất quán mạnh của một phân vùng, không nhất thiết phải trên nhiều phân vùng). Cassandra Cũng có xu hướng AP, lớp dưới sử dụng giao thức Gossip để duy trì trạng thái topo của nút. Tính nhất quán khi đọc và ghi có thể cấu hình số lượng bản sao đọc và ghi R / W, để thực hiện chuyển đổi mượt mà từ tính nhất quán cuối cùng sang tính nhất quán mạnh hơn. So sánh có thể thấy: Về mặt kỹ thuật, không có \u0026ldquo;AP hoặc CP\u0026rdquo; tuyệt đối, mà là sự kết hợp của nhiều chiến lược nhất quán; hầu hết các hệ thống đều cung cấp một mức độ nhất quán có thể điều chỉnh để phù hợp với các tình huống ứng dụng khác nhau.\nIX. Tổng kết # Định lý CAP không phải là một kích thước phù hợp cho tất cả Các hệ thống phân tán thực tế không thể nói đơn giản là \u0026ldquo;tôi chọn C, từ bỏ A\u0026rdquo; hoặc \u0026ldquo;tôi chọn A, từ bỏ C\u0026rdquo;. Trong ngành, phổ biến hơn là linh hoạt lựa chọn chế độ CP hoặc AP cho các chiều dữ liệu khác nhau, các loại thao tác khác nhau, thậm chí trong cùng một hệ thống, sử dụng các chiến lược chịu lỗi và nhất quán khác nhau cho các bảng/chức năng khác nhau. AP không phải là khả dụng 100% tuyệt đối Ví dụ, Cassandra, DynamoDB, v.v. cũng sẽ xuất hiện tình huống không thể đáp ứng yêu cầu khi có phân vùng mạng nghiêm trọng hoặc các nút bị lỗi trên diện rộng. Hệ thống AP chỉ có thiết kế thiên về \u0026ldquo;chỉ cần bản sao có thể ghi thì cứ ghi trước\u0026rdquo;, hy sinh một phần đảm bảo tính nhất quán để đổi lấy tính khả dụng và thông lượng tương đối cao hơn. CP cũng có thể cố gắng đạt được tính khả dụng cao Paxos/Raft cũng có thể cung cấp tính khả dụng 99,99% hoặc thậm chí cao hơn trong điều kiện bình thường, chỉ là cần đầu tư nhiều chi phí mạng, phần cứng và kỹ thuật hơn, và vẫn sẽ xuất hiện tình trạng chặn ghi, hy sinh tính khả dụng để duy trì tính nhất quán khi có phân vùng mạng nghiêm trọng. Kiến trúc hỗn hợp là chủ đạo Các tình huống giao dịch cốt lõi kiên trì tính nhất quán mạnh (CP), các tình huống hỗ trợ ngoại vi hoặc kênh bộ nhớ đệm sử dụng tính nhất quán yếu (AP), cả hai phối hợp với nhau. Cần kết hợp khả năng chấp nhận của nghiệp vụ, môi trường mạng, chi phí đầu tư, dự trữ kỹ thuật của nhóm để đưa ra lựa chọn toàn diện. Định lý CAP cung cấp một khung tư duy ở cấp độ cao cho việc thiết kế hệ thống phân tán, giúp chúng ta đưa ra quyết định hợp lý trước thực tế không thể tránh khỏi của phân vùng mạng. Trong hệ thống thực tế, cần phải sử dụng các mô hình nhất quán, giao thức đồng thuận, cơ chế sao chép nhiều bản sao phong phú hơn, cũng như thực tiễn kỹ thuật (khắc phục thảm họa, giảm cấp, lũy đẳng, hợp nhất xung đột, v.v.) để cân bằng tính nhất quán và tính khả dụng.\n","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735350760948-cap/","section":"Posts","summary":"Thảo luận về ứng dụng của định lý CAP trong hệ thống phân tán từ lý thuyết đến thực tiễn.","title":"Phân tích sâu về định lý CAP: Xây dựng hệ thống phân tán có tính đồng thời và khả dụng cao","type":"posts"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 tháng 12 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"Sắp xếp nhanh là một thuật toán sắp xếp không ổn định dựa trên so sánh, sử dụng tư tưởng chia để trị, độ phức tạp thời gian trung bình là $O(n\\log n)$, trường hợp xấu nhất là $O(n^2)$, độ phức tạp không gian là $O(1)$. Dưới đây, chúng ta sẽ lấy ví dụ sắp xếp một dãy số nguyên theo thứ tự tăng dần để giới thiệu chi tiết về cách triển khai và các lỗi thường gặp.\nMô tả bài toán # Cho một dãy số nguyên có độ dài $n$, sử dụng thuật toán sắp xếp nhanh để sắp xếp dãy số theo thứ tự tăng dần và in ra kết quả.\nĐịnh dạng đầu vào # Dòng đầu tiên nhập số nguyên $n$ Dòng thứ hai nhập $n$ số nguyên, tất cả đều nằm trong phạm vi $[1,10^9]$ Định dạng đầu ra # Một dòng duy nhất in ra dãy số đã được sắp xếp Phạm vi dữ liệu # $1 \\leq n \\leq 100000$\nVí dụ đầu vào # 5 3 1 2 4 5 Ví dụ đầu ra # 1 2 3 4 5 Ý tưởng sắp xếp nhanh # Mỗi lần chia để trị trong sắp xếp nhanh, ta chọn một số bất kỳ làm số mốc pivot (dưới đây chọn số ở vị trí giữa).\nSử dụng hai con trỏ trái và phải di chuyển về phía nhau, con trỏ trái L di chuyển từ trái sang phải để tìm số đầu tiên lớn hơn hoặc bằng pivot, con trỏ phải R di chuyển từ phải sang trái để tìm số đầu tiên nhỏ hơn hoặc bằng pivot, sau đó hoán đổi hai số này.\nTiếp tục lặp lại quá trình này cho đến khi con trỏ trái và con trỏ phải trùng nhau hoặc con trỏ trái lớn hơn con trỏ phải một vị trí. Đây được gọi là một vòng lặp.\nSau mỗi lần di chuyển và hoán đổi con trỏ, đảm bảo cấu trúc \u0026ldquo;phần bên trái ≤ pivot, phần bên phải ≥ pivot\u0026rdquo; không bị phá vỡ, tức là có bất biến [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nTrong đoạn mã ví dụ dưới đây, left và right là biên của khoảng đóng đang được xử lý, pivot được lấy là phần tử ở vị trí giữa của khoảng.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Độ phức tạp và lựa chọn pivot # Vì trong trường hợp xấu nhất, sắp xếp nhanh có độ phức tạp $O(n^2)$, việc chọn pivot rất quan trọng. Nếu luôn chọn phần tử đầu tiên hoặc cuối cùng, trong mảng gần như đã được sắp xếp, khả năng cao sẽ xảy ra trường hợp xấu nhất.\nNgoài việc lấy phần tử ở vị trí giữa, ta có thể chọn ngẫu nhiên một phần tử làm pivot, hoặc lấy trung vị của ba phần tử trái, giữa và phải làm pivot.\nVí dụ các lỗi thường gặp # Đoạn mã dưới đây chứa nhiều lỗi thường gặp.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Phân tích lỗi:\npivot phải là một số trong mảng, không phải là chỉ số. Sử dụng \u0026lt; và \u0026gt; thay vì \u0026lt;= và \u0026gt;=, nếu không con trỏ trái có thể vượt quá con trỏ phải nhiều hơn một vị trí, như vậy sẽ không thể chia mảng thành hai phần. Sau khi phát hiện l \u0026gt;= r, nên thoát khỏi vòng lặp ngay lập tức, không thực hiện hoán đổi nữa. Nếu không, không thể đảm bảo các phần tử bên trái không lớn hơn pivot, các phần tử bên phải không nhỏ hơn pivot. Sau mỗi lần hoán đổi, nên thực hiện l++ và r--. pivot thực tế lấy số ở giữa lệch về bên trái. Vì vậy, nếu sử dụng $l - 1$ và $l$ để phân chia mảng, xét mảng [1, 2], không khó để thấy sẽ dẫn đến vòng lặp vô hạn, liên tục chia mảng thành hai phần có kích thước 0 và 2. Tương tự, dùng $r$ và $l$ để phân chia mảng cũng không được. Ngược lại, khi một vòng lặp kết thúc, $r$ chắc chắn nhỏ hơn $right$, vì vậy có thể sử dụng $r$ và $r+1$ để phân chia mảng. Bạn đọc có thể mô phỏng quá trình thuật toán để xem tại sao. Một cách đơn giản khác để tránh vòng lặp vô hạn là chọn pivot ngẫu nhiên hoặc xử lý đặc biệt trường hợp chỉ có hai phần tử. Ngoài ra, dùng $l$, $l+1$ cũng không được, vì cách phân chia này không hợp định nghĩa, khi $r$ ở bên trái $l$, dùng $l$, $l+1$ không thể chia mảng thành hai phần, bên trái nhỏ hơn hoặc bằng pivot, bên phải lớn hơn hoặc bằng pivot một cách chính xác. Bài toán này giả định mảng không rỗng, nên không có trường hợp \u0026gt;. Tuy nhiên, nên sử dụng \u0026gt;=, sẽ an toàn hơn. Bổ sung # Sắp xếp nhanh còn có thể được phát triển thành \u0026ldquo;chọn nhanh\u0026rdquo;, trong thời gian kỳ vọng $O(n)$ có thể tìm được số nhỏ thứ $k$ trong mảng không có thứ tự, ý tưởng cụ thể tương tự như sắp xếp nhanh, chỉ khác là mỗi lần chỉ tiếp tục đệ quy ở một phía của khoảng con, từ đó giảm độ phức tạp thời gian.\n","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735252761946-quick-sort/","section":"Posts","summary":"Phân tích các điểm chính để triển khai đúng thuật toán sắp xếp nhanh.","title":"Sắp xếp nhanh","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":" Bài toán # Có $N$ đồ vật. Thể tích của đồ vật thứ $i$ là $s_i$, và giá trị của nó là $v_i$. Mỗi đồ vật chỉ có thể được lấy một lần. Với điều kiện không vượt quá giới hạn tổng thể tích tối đa $S$, hãy tìm tổng giá trị tối đa $V$ có thể đạt được.\nĐịnh dạng đầu vào # Dòng đầu tiên chứa hai số nguyên, $N$ và $S$, được phân tách bằng một khoảng trắng, lần lượt biểu thị số lượng đồ vật và giới hạn tổng thể tích tối đa. $N$ dòng tiếp theo, mỗi dòng chứa hai số nguyên, $s_i$ và $v_i$, được phân tách bằng một khoảng trắng, lần lượt biểu thị thể tích và giá trị của đồ vật thứ $i$.\nĐịnh dạng đầu ra # Xuất ra một số nguyên biểu thị giá trị tối đa.\nPhạm vi dữ liệu # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Ví dụ đầu vào # 4 5 1 2 2 4 3 4 4 5 Ví dụ đầu ra # 8 Lời giải # Định nghĩa trạng thái: f[i][j] biểu thị giá trị tối đa có thể đạt được từ $i$ đồ vật đầu tiên với giới hạn thể tích là $j$. Nếu đồ vật thứ $i$ không được lấy, thì f[i][j] = f[i - 1][j] Nếu đồ vật thứ $i$ được lấy, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Khi thực hiện chuyển trạng thái, hãy chú ý đến phạm vi miền. Nếu $j \u003c s_i$, thì không xem xét trường hợp lấy đồ vật thứ $i$. Vì nếu $j - s_i$ là số âm, thì chỉ số mảng là không hợp lệ. Cũng có thể giải thích theo cách này: thể tích của đồ vật thứ $i$ lớn hơn giới hạn thể tích, vì vậy không thể lấy được. Định nghĩa điều kiện ban đầu: Đối với 0 đồ vật đầu tiên, bất kỳ giới hạn thể tích nào cũng cho giá trị là 0, tức là f[0][j] = 0, j $\\in [0, S]$. Độ phức tạp thời gian: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Tối ưu DP 1D # Nén mảng hai chiều thành mảng một chiều có thể tiết kiệm đáng kể không gian và cải thiện tốc độ chạy đến một mức độ nhất định (nhược điểm là không thể đáp ứng các yêu cầu đặc biệt của một số loại bài toán). Lưu ý rằng trong chuyển trạng thái, f[i][j] chỉ liên quan đến f[i - 1][j] và f[i - 1][j - s[i]]. Nói cách khác, trong mảng hai chiều f trong code, f[i][j] chỉ liên quan đến các phần tử ở hàng trước đó nằm bên trái hoặc cùng cột với nó. Do đó, mảng hai chiều có thể được nén thành mảng một chiều hoặc mảng cuộn. Lưu ý rằng trong code bên dưới, vòng lặp thứ hai lặp theo thứ tự ngược lại. Điều này là do chúng ta muốn đảm bảo rằng khi tính toán f[i][j], f[i - 1][j - s[i]] chưa được cập nhật. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Nếu Yêu cầu Số Lượng Phương Án # Không chỉ cần xuất ra tổng giá trị tối đa có thể đạt được, mà còn phải xuất ra \u0026ldquo;có bao nhiêu phương pháp lựa chọn khác nhau có thể đạt được tổng giá trị tối đa này\u0026rdquo;. Phần sau đây mô tả cách đếm số lượng phương án trong bài toán cái túi 01.\nDP 2D để Đếm Phương Án # Phần sau đây sử dụng DP 2D làm ví dụ để giải thích.\nĐịnh nghĩa trạng thái:\ndp[i][j] biểu thị \u0026ldquo;giá trị tối đa có thể đạt được khi xem xét i đồ vật đầu tiên với dung lượng (giới hạn thể tích) là j\u0026rdquo;. ways[i][j] biểu thị \u0026quot; số lượng phương án tương ứng với giá trị tối đa đạt được khi xem xét i đồ vật đầu tiên với dung lượng là j\u0026quot;. Chuyển trạng thái:\nNếu đồ vật thứ i không được chọn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Nếu đồ vật thứ i được chọn (với điều kiện $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Dù chọn hay không, dp[i][j] cuối cùng phải lấy giá trị lớn hơn trong hai giá trị: Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ thì có nghĩa là \u0026ldquo;chọn đồ vật thứ i\u0026rdquo; có giá trị lớn hơn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ thì có nghĩa là giá trị tối đa đạt được bằng hai phương pháp là như nhau, thì số lượng phương án nên được cộng vào: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ thì có nghĩa là \u0026ldquo;không chọn đồ vật thứ i\u0026rdquo; có giá trị lớn hơn, và số lượng phương án kế thừa số lượng phương án khi không chọn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Điều kiện ban đầu:\ndp[0][j] = 0 có nghĩa là khi có 0 đồ vật, giá trị tối đa đạt được cho bất kỳ dung lượng nào là 0. ways[0][0] = 1 có nghĩa là trường hợp \u0026ldquo;0 đồ vật, dung lượng 0\u0026rdquo; là một phương án khả thi (tức là không chọn gì), và số lượng phương án được đặt thành 1. Đối với j \u0026gt; 0, khi không có đồ vật nào để chọn và dung lượng lớn hơn 0, thì không thể đạt được bất kỳ giá trị dương nào, và số lượng phương án tương ứng là 0, tức là ways[0][j] = 0. Câu trả lời cuối cùng:\ndp[N][S] là giá trị tối đa. ways[N][S] là số lượng phương án để đạt được giá trị tối đa này. Độ phức tạp thời gian: $O(NS)$. Bài toán này cũng có thể được tối ưu hóa bằng cách sử dụng DP 1D. Nếu Yêu Cầu Phải Đạt Chính Xác Giới Hạn Thể Tích # Định nghĩa trạng thái: f[i][j] biểu thị giá trị tối đa khi $i$ đồ vật đầu tiên có chính xác thể tích là $j$. Nếu đồ vật thứ i không được lấy, thì f[i][j] = f[i - 1][j] Nếu đồ vật thứ i được lấy, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Có thể thấy rằng không có sự khác biệt trong chuyển trạng thái so với bài toán ban đầu. Tuy nhiên, các điều kiện ban đầu là khác nhau. Ngoại trừ f[0][0] = 0, phần còn lại f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ biểu thị một trạng thái không thể xảy ra. Nếu Giới Hạn Thể Tích $S$ Rất Lớn (1e9), Trong Khi Số Lượng Đồ Vật $N$ và Tổng Giá Trị Tối Đa $V$ Tương Đối Nhỏ # Đối với các bài toán như vậy, có một giải pháp với độ phức tạp là $O(NV)$. Định nghĩa trạng thái: f[i][j] biểu thị thể tích tối thiểu khi chọn một số đồ vật từ i đồ vật đầu tiên, và tổng giá trị chính xác là j. Nếu đồ vật thứ i không được lấy, thì f[i][j] = f[i - 1][j] Nếu đồ vật thứ i được lấy, thì f[i][j] = f[i - 1][j - v[i]] + s[i] Lấy giá trị nhỏ hơn trong hai giá trị. Điều kiện ban đầu: f[0][0] = 0, phần còn lại f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ biểu thị một trạng thái không thể xảy ra. Lưu ý rằng nó không phải là $-\\infty$. Câu trả lời cuối cùng là j lớn nhất trong f[N][j] sao cho f[N][j] \u0026lt;= S. Nếu Giới Hạn Thể Tích $S$ và Giá Trị của Một Đồ Vật $v_i$ Đều Rất Lớn (cỡ 1e9), Trong Khi Số Lượng Đồ Vật $N$ Rất Nhỏ (không quá 40) # Khi $N \\leq 20$, tất cả các tập con có thể được liệt kê trực tiếp bằng vét cạn (độ phức tạp thời gian $O(2^N)$). Khi $N \\leq 40$, vì $2^{40}$ có cỡ $10^{12}$, vét cạn trực tiếp cũng sẽ tương đối lớn, vì vậy tìm kiếm meet-in-the-middle có thể được sử dụng để giảm độ phức tạp xuống xấp xỉ $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, có thể hoàn thành trong một thời gian chấp nhận được. ","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Bài toán cái túi cổ điển cơ bản nhất.","title":"Bài toán Cái túi 01","type":"posts"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"Nếu không gian nghiệm có thứ tự được chia thành hai phần, trong đó một phần thỏa mãn điều kiện và phần còn lại không thỏa mãn điều kiện. Thì có thể sử dụng tìm kiếm nhị phân để tìm điểm tới hạn trong không gian nghiệm có thứ tự.\nÝ tưởng cơ bản của tìm kiếm nhị phân là liên tục chia đôi khoảng tìm kiếm. Mỗi lần kiểm tra phần tử ở giữa, nếu phần tử ở giữa không thỏa mãn điều kiện, có thể loại bỏ một nửa khoảng; ngược lại, tiếp tục tìm kiếm trong nửa khoảng còn lại. Vì mỗi lần đều loại bỏ một nửa khoảng tìm kiếm, độ phức tạp thời gian tìm kiếm có thể đạt $O(\\log n)$.\nBài tập ví dụ # Mô tả bài toán:\nCho một mảng số nguyên có độ dài $n$ được sắp xếp tăng dần, và $q$ truy vấn. Mỗi truy vấn cho một số nguyên $k$, chúng ta cần tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; của $k$ trong mảng (chỉ số bắt đầu từ 0). Nếu số này không tồn tại trong mảng, trả về -1 -1.\nĐịnh dạng đầu vào # Dòng đầu tiên: Hai số nguyên $n$ và $q$, lần lượt biểu thị độ dài mảng và số lần truy vấn. Dòng thứ hai: $n$ số nguyên, biểu thị mảng đầy đủ, đã được sắp xếp theo thứ tự tăng dần. $q$ dòng tiếp theo: Mỗi dòng chứa một số nguyên $k$, biểu thị một phần tử truy vấn. Phạm vi dữ liệu # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nĐịnh dạng đầu ra # Đối với mỗi truy vấn, in ra vị trí bắt đầu và kết thúc của phần tử đó trong mảng trên một dòng. Nếu phần tử đó không tồn tại trong mảng, in ra -1 -1.\nVí dụ:\nĐầu vào: 6 3 1 2 2 3 3 4 3 4 5 Đầu ra: 3 4 5 5 -1 -1 Giải thích:\nPhạm vi xuất hiện của phần tử $3$ là $[3, 4]$; Phần tử $4$ chỉ xuất hiện một lần, ở vị trí $5$; Phần tử $5$ không tồn tại trong mảng, do đó trả về $-1$ $-1$. Giải đáp # Tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo;: Tức là tìm vị trí đầu tiên lớn hơn hoặc bằng $k$. Có thể chia mảng thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn\u0026rdquo; $k$ Tất cả các số bên phải đều \u0026ldquo;lớn hơn hoặc bằng\u0026rdquo; $k$ Đáp án là vị trí đầu tiên của phần bên phải Tìm \u0026ldquo;vị trí kết thúc\u0026rdquo;: Tức là tìm vị trí cuối cùng nhỏ hơn hoặc bằng $k$. Có thể chia mảng thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn hoặc bằng\u0026rdquo; $k$ Tất cả các số bên phải đều \u0026ldquo;lớn hơn\u0026rdquo; $k$ Đáp án là vị trí cuối cùng của phần bên trái Mẫu đề xuất # Dưới đây là một mẫu tìm kiếm nhị phân thanh lịch và khó mắc lỗi.\nĐịnh nghĩa hai con trỏ $l, r$, có bất biến: khoảng đóng $[0, l]$ thuộc về nửa bên trái, khoảng đóng $[r, n - 1]$ thuộc về nửa bên phải. $l$ và $r$ đều được khởi tạo là $-1$ và $n$.\nKhi thuật toán kết thúc, $l$ và $r$ liền kề nhau, lần lượt trỏ đến phần tử cuối cùng của nửa bên trái và phần tử đầu tiên của nửa bên phải.\nVì nghiệm chúng ta muốn có thể không tồn tại, nên nếu đề bài không nói rõ là chắc chắn có nghiệm, chúng ta cần kiểm tra xem l hoặc r có vượt quá giới hạn hay không, có trỏ đến giá trị đúng hay không.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Tìm vị trí bắt đầu của k 15 // Chia mảng thành hai phần, bên trái đều \u0026lt; k, bên phải đều \u0026gt;= k. 16 // Đáp án là chỉ số nhỏ nhất của nửa bên phải. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Nếu r vượt quá giới hạn hoặc nums[r] != k, nghĩa là không tồn tại k 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Tìm vị trí kết thúc của k 33 // Chia mảng thành hai phần, bên trái đều \u0026lt;= k, bên phải đều \u0026gt; k. 34 // Đáp án là chỉ số lớn nhất của nửa bên trái. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Ưu điểm # Cách viết này có bất biến được định nghĩa rõ ràng. Nó đồng thời áp dụng cho cả hai trường hợp tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo;, không cần xử lý và thay đổi thêm. Một số cách viết sử dụng l == r làm điều kiện dừng. Khi $l$ và $r$ cách nhau $1$, sẽ tính ra $mid$ bằng $l$ hoặc $r$. Nếu không xử lý đúng, cập nhật $l$ hoặc $r$ thành $mid$, khoảng tìm kiếm không thu hẹp, sẽ dẫn đến vòng lặp vô hạn. Ngược lại, cách viết ở đây dừng khi $l$ và $r$ liền kề nhau, đảm bảo $mid$ nhỏ hơn $l$ và lớn hơn $r$, khi cập nhật $l$ hoặc $r$ thì khoảng tìm kiếm chắc chắn sẽ thu hẹp. STL # Nếu sử dụng các hàm lower_bound và upper_bound do C++ STL cung cấp, cũng có thể hoàn thành công việc tương tự:\nlower_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn hoặc bằng val\u0026rdquo; upper_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn val\u0026rdquo; Ví dụ, giả sử nums = {1,2,3,4,4,4,4,4,5,5,6}, chúng ta muốn biết khoảng xuất hiện của 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện 0 lần\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;số 4 đầu tiên ở vị trí \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;số 4 cuối cùng ở vị trí \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; lần\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 trỏ đến vị trí của giá trị đầu tiên lớn hơn hoặc bằng $4$. it2 trỏ đến vị trí của giá trị đầu tiên lớn hơn $4$.\nVậy it2 - it1 chính là số lần $4$ xuất hiện trong mảng; it2 - nums.begin() - 1 chính là vị trí biên phải của $4$. Bổ sung # Tìm kiếm nhị phân còn có thể mở rộng sang tìm kiếm trong phạm vi số thực (ví dụ như tìm nghiệm của phương trình), cũng như tìm kiếm tam phân để tìm giá trị lớn nhất của hàm đơn đỉnh.\nLuyện tập # LeetCode 33. Search in Rotated Sorted Array\nGợi ý: Bước đầu tiên sử dụng tìm kiếm nhị phân để tìm điểm xoay, bước thứ hai sử dụng tìm kiếm nhị phân để tìm giá trị mục tiêu.\n","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Làm thế nào để triển khai thuật toán tìm kiếm nhị phân một cách thanh lịch.","title":"Tìm kiếm nhị phân","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/vi/series/","section":"Series","summary":"","title":"Series","type":"series"}]