[{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":" Tìm kiếm nhị phân # Tìm kiếm nhị phân có thể được sử dụng để nhanh chóng tìm một phần tử cụ thể trong một chuỗi đã được sắp xếp. So với tìm kiếm tuyến tính với độ phức tạp thời gian là $O(n)$, tìm kiếm nhị phân chỉ yêu cầu thời gian $O(\\log n)$, khiến nó rất hiệu quả khi xử lý các tập dữ liệu lớn.\nÝ tưởng cốt lõi của tìm kiếm nhị phân # Ý tưởng cơ bản của tìm kiếm nhị phân là liên tục chia đôi khoảng tìm kiếm. Mỗi lần, phần tử ở giữa được so sánh với giá trị mục tiêu. Nếu phần tử ở giữa không thỏa mãn điều kiện, một nửa khoảng có thể bị loại bỏ; nếu không, việc tìm kiếm tiếp tục trong nửa khoảng còn lại. Vì một nửa khoảng tìm kiếm bị loại bỏ mỗi lần, độ phức tạp thời gian tìm kiếm có thể đạt $O(\\log n)$.\nTìm kiếm nhị phân rất hữu ích cho các bài toán mà \u0026ldquo;các nghiệm khả thi có thể được chia thành một khoảng được sắp xếp (thỏa mãn điều kiện) và một khoảng được sắp xếp khác (không thỏa mãn điều kiện)\u0026rdquo;. Ví dụ:\nTìm xem một phần tử có tồn tại trong một mảng đã sắp xếp hay không Tìm \u0026ldquo;vị trí đầu tiên\u0026rdquo; hoặc \u0026ldquo;vị trí cuối cùng\u0026rdquo; mà một số xuất hiện Ví dụ: Tìm vị trí bắt đầu và kết thúc của một phần tử # Mô tả bài toán: Cho một mảng số nguyên đã được sắp xếp tăng dần có độ dài $n$, và $q$ truy vấn. Mỗi truy vấn cho một số nguyên $k$, và chúng ta cần tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; của $k$ trong mảng (chỉ số bắt đầu từ 0). Nếu số đó không tồn tại trong mảng, trả về $-1$ $-1$.\nĐịnh dạng đầu vào:\nDòng đầu tiên: hai số nguyên $n$ và $q$, lần lượt đại diện cho độ dài của mảng và số lượng truy vấn. Dòng thứ hai: $n$ số nguyên (trong phạm vi 1 ~ 10000), đại diện cho toàn bộ mảng, đã được sắp xếp theo thứ tự tăng dần. $q$ dòng tiếp theo: mỗi dòng chứa một số nguyên $k$, đại diện cho một phần tử truy vấn. Định dạng đầu ra: Đối với mỗi truy vấn, xuất vị trí bắt đầu và kết thúc của phần tử trong mảng trên một dòng duy nhất. Nếu phần tử không tồn tại trong mảng, xuất $-1$ $-1$.\nVí dụ:\nĐầu vào: 6 3 1 2 2 3 3 4 3 4 5 Đầu ra: 3 4 5 5 -1 -1 Giải thích:\nPhạm vi mà phần tử 3 xuất hiện là [3, 4]; Phần tử 4 chỉ xuất hiện một lần, tại vị trí 5; Phần tử 5 không tồn tại trong mảng, vì vậy trả về -1 -1. Cách tiếp cận ứng dụng của tìm kiếm nhị phân # Trong bài toán này, chúng ta có thể dựa vào tìm kiếm nhị phân để tìm \u0026ldquo;biên trái\u0026rdquo; và \u0026ldquo;biên phải\u0026rdquo; của một giá trị nhất định. Điều quan trọng là phải hiểu cách xác định khoảng tìm kiếm và cách di chuyển các con trỏ dựa trên kết quả so sánh.\nTìm \u0026ldquo;biên trái\u0026rdquo;: Tức là tìm vị trí đầu tiên lớn hơn hoặc bằng $k$. Mảng có thể được chia thành hai phần:\nTất cả các số ở bên trái đều \u0026ldquo;nhỏ hơn\u0026rdquo; $k$ Tất cả các số ở bên phải đều \u0026ldquo;lớn hơn hoặc bằng\u0026rdquo; $k$ Tìm \u0026ldquo;biên phải\u0026rdquo;: Tức là tìm vị trí cuối cùng nhỏ hơn hoặc bằng $k$. Mảng có thể được chia thành hai phần:\nTất cả các số ở bên trái đều \u0026ldquo;nhỏ hơn hoặc bằng\u0026rdquo; $k$ Tất cả các số ở bên phải đều \u0026ldquo;lớn hơn\u0026rdquo; $k$ Chỉ cần duy trì đúng hai khoảng này, kết quả có thể thu được nhanh chóng thông qua tìm kiếm nhị phân.\nMẫu khuyến nghị: Mã tìm kiếm nhị phân để tránh vòng lặp vô hạn # Đây là một mẫu tìm kiếm nhị phân thanh lịch và chống lỗi. Nó đảm bảo vòng lặp kết thúc khi $l$ và $r$ liền kề nhau bằng cách dần dần đưa $l$ và $r$ đến gần nhau hơn:\nXác định hai con trỏ $l, r$, với các bất biến: khoảng đóng $[0, l]$ đều thuộc phần bên trái, khoảng đóng $[r, n - 1]$ đều thuộc phần bên phải. $l$ và $r$ được khởi tạo lần lượt là $-1$ và $n$.\nKhi thuật toán kết thúc, $l$ và $r$ liền kề nhau, trỏ đến giá trị lớn nhất trong phần bên trái và giá trị nhỏ nhất trong phần bên phải.\nVì nghiệm mong muốn có thể không tồn tại, khi trả về $l$ hoặc $r$, cần phải kiểm tra xem giá trị tương ứng có phải là giá trị chúng ta muốn hay không và có nằm ngoài giới hạn hay không. Ví dụ: $l$ đại diện cho giá trị lớn nhất $\\leq k$, và chúng ta cần kiểm tra l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Tìm vị trí bắt đầu của k (biên trái) // Chia mảng thành hai phần, phần bên trái tất cả \u0026lt; k, và phần bên phải tất cả \u0026gt;= k. // Biên trái là chỉ số nhỏ nhất của phần bên phải. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Nếu r nằm ngoài giới hạn hoặc nums[r] != k, có nghĩa là k không tồn tại if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Ghi lại biên trái của k // 2. Tìm vị trí kết thúc của k (biên phải) // Chia mảng thành hai phần, phần bên trái tất cả \u0026lt;= k, và phần bên phải tất cả \u0026gt; k. // Biên phải là chỉ số lớn nhất của phần bên trái. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Vì chúng ta đã xác minh rằng k tồn tại, không cần phải xác minh lại ở đây int rightPos = l; // Biên phải cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Tại sao phương pháp này ít gây lỗi hơn? # Phương pháp này có các bất biến được xác định nghiêm ngặt. Nó có thể tìm thấy cả biên trái và biên phải, giúp nó áp dụng được cho tất cả các tình huống. Một số phương pháp sử dụng $l == r$ làm điều kiện kết thúc. Khi $l$ và $r$ khác nhau 1, $mid$ được tính toán sẽ bằng l hoặc r. Nếu không được xử lý đúng cách, việc cập nhật l hoặc r thành mid sẽ không thu hẹp khoảng tìm kiếm, dẫn đến vòng lặp vô hạn. Ngược lại, phương pháp này kết thúc khi $l$ và $r$ liền kề nhau, tránh được vấn đề này. Giải pháp STL: lower_bound và upper_bound # Nếu bạn sử dụng các hàm lower_bound và upper_bound do C++ STL cung cấp, bạn có thể dễ dàng hoàn thành điều tương tự:\nlower_bound(first, last, val) trả về \u0026ldquo;vị trí đầu tiên lớn hơn hoặc bằng val\u0026rdquo; upper_bound(first, last, val) trả về \u0026ldquo;vị trí đầu tiên lớn hơn val\u0026rdquo; Ví dụ: giả sử nums = {1,2,3,4,4,4,4,4,5,5,6}, và chúng ta muốn biết khoảng mà 4 xuất hiện:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Cho biết rằng 4 không tồn tại trong mảng cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện 0 lần\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Số 4 đầu tiên ở \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Số 4 cuối cùng ở \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; lần\u0026#34; \u0026lt;\u0026lt; endl; } it1 trỏ đến vị trí đầu tiên mà giá trị lớn hơn hoặc bằng 4. it2 trỏ đến vị trí đầu tiên mà giá trị lớn hơn 4. Do đó, it2 - it1 là số lần 4 xuất hiện trong mảng; it2 - nums.begin() - 1 là biên phải của 4. Hai hàm này đặc biệt thuận tiện khi tìm kiếm khoảng hoặc đếm số lần xuất hiện.\nBổ sung # Tìm kiếm nhị phân cũng có thể được mở rộng để tìm kiếm trong các số dấu phẩy động (ví dụ: tìm nghiệm của một phương trình), cũng như tìm kiếm tam phân để tìm giá trị cực trị của các hàm đơn mode. Chỉ cần bạn hiểu nguyên tắc cốt lõi của việc \u0026ldquo;mỗi lần loại bỏ một nửa trong một khoảng được sắp xếp\u0026rdquo;, bạn sẽ thấy rằng tìm kiếm nhị phân có thể giúp bạn giải quyết vấn đề một cách hiệu quả trong nhiều tình huống.\nBài tập về nhà # LeetCode 33. Tìm kiếm trong mảng đã sắp xếp bị xoay vòng\nGợi ý: Sử dụng tìm kiếm nhị phân để tìm điểm xoay trước, sau đó sử dụng tìm kiếm nhị phân để tìm giá trị mục tiêu.\n","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"Tìm kiếm nhị phân","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/vi/series/","section":"Series","summary":"","title":"Series","type":"series"}]