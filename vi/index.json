[{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":" Sắp xếp nhanh # Sắp xếp nhanh là một thuật toán sắp xếp dựa trên so sánh không ổn định, sử dụng tư tưởng chia để trị, có độ phức tạp thời gian trung bình là $O(n\\log n)$, trường hợp xấu nhất là $O(n^2)$, độ phức tạp không gian là $O(1)$. Dưới đây, chúng ta sẽ lấy ví dụ sắp xếp một dãy số nguyên theo thứ tự tăng dần để giới thiệu chi tiết cách triển khai và các lỗi thường gặp.\nMô tả bài toán # Cho một dãy số nguyên có độ dài $n$, sử dụng sắp xếp nhanh để sắp xếp dãy số này theo thứ tự tăng dần và in ra kết quả.\nĐịnh dạng đầu vào # Dòng đầu tiên nhập số nguyên $n$ Dòng thứ hai nhập $n$ số nguyên, tất cả đều nằm trong phạm vi $[1,10^9]$ Định dạng đầu ra # Một dòng duy nhất chứa dãy số đã được sắp xếp Phạm vi dữ liệu # $1 \\leq n \\leq 100000$\nVí dụ đầu vào # 5 3 1 2 4 5 Ví dụ đầu ra # 1 2 3 4 5 Ý tưởng sắp xếp nhanh # Mỗi lần chia để trị trong sắp xếp nhanh, ta chọn một số bất kỳ làm số mốc pivot (dưới đây chọn số ở vị trí giữa).\nSử dụng hai con trỏ trái L và phải R di chuyển về phía nhau, con trỏ trái L di chuyển từ trái sang phải để tìm số đầu tiên lớn hơn hoặc bằng pivot, con trỏ phải R di chuyển từ phải sang trái để tìm số đầu tiên nhỏ hơn hoặc bằng pivot, sau đó hoán đổi hai số này.\nTiếp tục lặp lại quá trình này cho đến khi con trỏ trái và con trỏ phải trùng nhau hoặc con trỏ trái lớn hơn con trỏ phải một vị trí. Đây được gọi là một vòng lặp.\nTrong mỗi lần di chuyển con trỏ và hoán đổi, ta luôn đảm bảo cấu trúc \u0026ldquo;phần bên trái ≤ pivot, phần bên phải ≥ pivot\u0026rdquo; không bị phá vỡ, tức là có bất biến [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nTrong đoạn mã ví dụ dưới đây, left và right là biên của khoảng đóng đang được xử lý, pivot được lấy là phần tử ở vị trí giữa của khoảng.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Độ phức tạp và lựa chọn pivot # Vì trong trường hợp xấu nhất, sắp xếp nhanh có độ phức tạp $O(n^2)$, việc chọn pivot rất quan trọng. Nếu luôn chọn phần tử đầu tiên hoặc cuối cùng, trong mảng gần như đã được sắp xếp, khả năng cao sẽ xảy ra trường hợp xấu nhất.\nNgoài việc lấy phần tử ở vị trí giữa, ta có thể chọn ngẫu nhiên một phần tử làm pivot, hoặc lấy trung vị của ba phần tử trái, giữa và phải làm pivot.\nVí dụ các lỗi thường gặp # Đoạn mã dưới đây chứa nhiều lỗi thường gặp.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Phân tích lỗi:\npivot phải là một số trong mảng, không phải là chỉ số. Sử dụng \u0026lt; và \u0026gt; thay vì \u0026lt;= và \u0026gt;=, nếu không con trỏ trái có thể vượt quá con trỏ phải nhiều hơn một vị trí, như vậy sẽ không thể chia mảng thành hai phần. Sau khi phát hiện l \u0026gt;= r, cần thoát khỏi vòng lặp ngay lập tức, không thực hiện hoán đổi nữa. Nếu không, không thể đảm bảo các phần tử bên trái không lớn hơn pivot, các phần tử bên phải không nhỏ hơn pivot. Sau mỗi lần hoán đổi, cần thực hiện l++ và r--. pivot thực tế lấy số ở giữa lệch về bên trái. Vì vậy, nếu sử dụng $l - 1$ và $l$ để phân chia mảng, xét mảng [1, 2], không khó để thấy sẽ dẫn đến vòng lặp vô hạn, liên tục chia mảng thành hai phần có kích thước 0 và 2. Tương tự, dùng $r$ và $l$ để phân chia mảng cũng không được. Ngược lại, khi kết thúc một vòng lặp, $r$ chắc chắn nhỏ hơn $right$, vì vậy có thể sử dụng $r$ và $r+1$ để phân chia mảng. Bạn đọc có thể mô phỏng quá trình thuật toán để xem tại sao. Một cách đơn giản khác để tránh vòng lặp vô hạn là chọn pivot ngẫu nhiên hoặc xử lý đặc biệt trường hợp chỉ có hai phần tử. Ngoài ra, dùng $l$, $l+1$ cũng không được, vì cách phân chia này không hợp định nghĩa, khi $r$ ở bên trái $l$, dùng $l$, $l+1$ không thể chia mảng thành hai phần, bên trái nhỏ hơn hoặc bằng pivot, bên phải lớn hơn hoặc bằng pivot một cách chính xác. Bài toán này giả định mảng không rỗng, nên không có trường hợp \u0026gt;. Tuy nhiên, nên sử dụng \u0026gt;=, sẽ an toàn hơn. Bổ sung # Sắp xếp nhanh còn có thể được phát triển thành \u0026ldquo;chọn nhanh\u0026rdquo;, trong thời gian kỳ vọng $O(n)$ có thể tìm được số nhỏ thứ $k$ trong mảng không có thứ tự, ý tưởng cụ thể tương tự như sắp xếp nhanh, chỉ khác là mỗi lần chỉ tiếp tục đệ quy ở một phía của khoảng con, từ đó giảm độ phức tạp thời gian.\n","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735252761946-quick-sort/","section":"Posts","summary":"Phân tích các điểm chính để triển khai đúng thuật toán sắp xếp nhanh.","title":"Sắp xếp nhanh","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 tháng 12 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":" Đề bài # Có $N$ món đồ. Món đồ thứ $i$ có thể tích là $s_i$, giá trị là $v_i$. Mỗi món đồ chỉ được lấy một lần. Trong điều kiện không vượt quá giới hạn tổng thể tích tối đa $S$, hãy tìm tổng giá trị lớn nhất $V$ có thể đạt được.\nĐịnh dạng đầu vào # Dòng đầu tiên chứa hai số nguyên, $N, S$, cách nhau bằng dấu cách, lần lượt biểu thị số lượng món đồ và giới hạn tổng thể tích tối đa. Tiếp theo là $N$ dòng, mỗi dòng chứa hai số nguyên $s_i, v_i$, cách nhau bằng dấu cách, lần lượt biểu thị thể tích và giá trị của món đồ thứ $i$.\nĐịnh dạng đầu ra # Xuất ra một số nguyên, biểu thị giá trị lớn nhất.\nPhạm vi dữ liệu # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Ví dụ đầu vào # 4 5 1 2 2 4 3 4 4 5 Ví dụ đầu ra # 8 Lời giải # Định nghĩa trạng thái: f[i][j] biểu thị giá trị lớn nhất có thể đạt được khi xem xét $i$ món đồ đầu tiên, với giới hạn thể tích là $j$. Nếu không lấy món đồ thứ $i$, thì f[i][j] = f[i - 1][j] Nếu lấy món đồ thứ $i$, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Khi thực hiện chuyển trạng thái, cần chú ý đến phạm vi định nghĩa. Nếu $j \u003c s_i$, thì không xét trường hợp lấy món đồ thứ $i$. Vì nếu $j-s_i$ là số âm, chỉ số mảng sẽ không hợp lệ. Cũng có thể giải thích như sau: Thể tích của món đồ thứ $i$ lớn hơn giới hạn thể tích, nên không thể lấy được. Định nghĩa điều kiện ban đầu: Với $0$ món đồ đầu tiên, bất kỳ giới hạn thể tích nào cũng có giá trị là $0$, tức là f[0][j] = 0, j $\\in [0, S]$. Độ phức tạp thời gian: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Tối ưu DP một chiều # Việc nén mảng hai chiều thành mảng một chiều có thể tiết kiệm đáng kể không gian và tăng tốc độ chạy (nhược điểm là không thể đáp ứng các yêu cầu đặc biệt của một số dạng bài) Lưu ý rằng trong chuyển trạng thái, f[i][j] chỉ liên quan đến f[i - 1][j] và f[i - 1][j - s[i]]. Nói cách khác, trong mảng hai chiều f trong code, f[i][j] chỉ liên quan đến các phần tử ở hàng trên nó, nằm bên trái hoặc cùng cột, do đó có thể nén mảng hai chiều thành mảng một chiều hoặc mảng cuộn. Lưu ý trong code dưới đây, vòng lặp thứ hai duyệt ngược, điều này là do chúng ta muốn đảm bảo rằng khi tính f[i][j], f[i - 1][j - s[i]] chưa bị cập nhật. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Nếu yêu cầu số lượng phương án # Không chỉ xuất ra tổng giá trị lớn nhất có thể đạt được, mà còn cần xuất ra \u0026ldquo;có bao nhiêu cách chọn khác nhau để đạt được tổng giá trị lớn nhất này\u0026rdquo;. Dưới đây là cách thống kê số lượng phương án trong bài toán cái túi 01.\nThống kê số lượng phương án bằng DP hai chiều # Dưới đây là ví dụ minh họa bằng DP hai chiều.\nĐịnh nghĩa trạng thái:\ndp[i][j] biểu thị \u0026ldquo;giá trị lớn nhất có thể đạt được khi xem xét i món đồ đầu tiên, với dung lượng (giới hạn thể tích) là j\u0026rdquo;. ways[i][j] biểu thị \u0026ldquo;số lượng phương án tương ứng khi xem xét i món đồ đầu tiên, với dung lượng là j, để đạt được giá trị lớn nhất\u0026rdquo;. Chuyển trạng thái:\nNếu không chọn món đồ thứ i: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Nếu chọn món đồ thứ i (với điều kiện $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Chọn hoặc không chọn, cuối cùng dp[i][j] nên lấy giá trị lớn hơn trong hai giá trị: Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ thì điều này có nghĩa là \u0026ldquo;chọn món đồ thứ i\u0026rdquo; có giá trị lớn hơn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ thì điều này có nghĩa là hai cách có cùng giá trị lớn nhất, số lượng phương án nên được cộng dồn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ thì điều này có nghĩa là \u0026ldquo;không chọn món đồ thứ i\u0026rdquo; có giá trị lớn hơn, số lượng phương án kế thừa số lượng phương án khi không chọn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Điều kiện ban đầu:\ndp[0][j] = 0 có nghĩa là khi có 0 món đồ, bất kỳ dung lượng nào cũng có giá trị lớn nhất là 0. ways[0][0] = 1 có nghĩa là trường hợp \u0026ldquo;0 món đồ đầu tiên, dung lượng là 0\u0026rdquo; là một phương án khả thi (tức là không chọn gì cả), số lượng phương án được đặt là 1. Với j \u0026gt; 0, khi không có món đồ nào để chọn mà dung lượng lại lớn hơn 0, thì không thể đạt được bất kỳ giá trị dương nào, số lượng phương án tương ứng là 0, tức là ways[0][j] = 0. Đáp án cuối cùng:\ndp[N][S] là giá trị lớn nhất. ways[N][S] là số lượng phương án để đạt được giá trị lớn nhất đó. Độ phức tạp thời gian: $O(NS)$. Bài toán này cũng có thể được tối ưu bằng DP một chiều. Nếu yêu cầu đạt đúng giới hạn thể tích # Định nghĩa trạng thái: f[i][j] biểu thị giá trị lớn nhất khi chọn các món đồ từ i món đồ đầu tiên sao cho tổng thể tích đúng bằng $j$. Nếu không lấy món đồ thứ i, thì f[i][j] = f[i - 1][j] Nếu lấy món đồ thứ i, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Có thể thấy rằng không có sự khác biệt trong chuyển trạng thái so với bài toán gốc. Tuy nhiên, điều kiện ban đầu khác nhau. Ngoài f[0][0] = 0, các f[0][j] còn lại đều bằng $-\\infty$, j $\\in [1, S]$. $-\\infty$ biểu thị trạng thái không thể xảy ra. Nếu giới hạn thể tích $S$ đặc biệt lớn (1e9), đồng thời số lượng món đồ $N$ và tổng giá trị lớn nhất $V$ tương đối nhỏ # Đối với dạng bài này, có một cách giải với độ phức tạp $O(NV)$. Định nghĩa trạng thái: f[i][j] biểu thị thể tích nhỏ nhất khi chọn một số món đồ từ i món đồ đầu tiên sao cho tổng giá trị đúng bằng j. Nếu không lấy món đồ thứ i, thì f[i][j] = f[i - 1][j] Nếu lấy món đồ thứ i, thì f[i][j] = f[i - 1][j - v[i]] + s[i] Lấy giá trị nhỏ hơn trong hai giá trị. Điều kiện ban đầu: f[0][0] = 0, các f[0][j] còn lại đều bằng $\\infty$, j $\\in [1, V]$. $\\infty$ biểu thị trạng thái không thể xảy ra. Lưu ý không phải là $-\\infty$. Đáp án cuối cùng là j lớn nhất trong các f[N][j] sao cho f[N][j] \u0026lt;= S. Nếu giới hạn thể tích $S$ và giá trị của từng món đồ $v_i$ đều đặc biệt lớn (cỡ $1e9$), đồng thời số lượng món đồ $N$ đặc biệt nhỏ (tối đa không quá 40) # Khi $N \\leq 20$, có thể trực tiếp duyệt tất cả các tập con (độ phức tạp thời gian $O(2^N)$). Khi $N \\leq 40$, vì $2^{40}$ ở cỡ $10^{12}$, việc duyệt trực tiếp cũng sẽ khá lớn, vì vậy có thể sử dụng tìm kiếm chia đôi , giảm độ phức tạp xuống xấp xỉ $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ , có thể hoàn thành trong thời gian chấp nhận được. ","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Bài toán cái túi cổ điển cơ bản nhất.","title":"Bài toán cái túi 01","type":"posts"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/las-nueve-lecciones-de-la-mochila/","section":"Series","summary":"","title":"Las Nueve Lecciones De La Mochila","type":"series"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"Nếu một không gian nghiệm có thứ tự được chia thành hai phần, trong đó một phần thỏa mãn một điều kiện và phần còn lại thì không, thì có thể sử dụng tìm kiếm nhị phân để tìm điểm tới hạn trong không gian nghiệm có thứ tự đó.\nÝ tưởng cơ bản của tìm kiếm nhị phân là liên tục chia đôi khoảng tìm kiếm. Mỗi lần, phần tử ở giữa được kiểm tra. Nếu phần tử ở giữa không thỏa mãn điều kiện, một nửa khoảng có thể bị loại bỏ; nếu không, việc tìm kiếm tiếp tục ở nửa còn lại. Vì một nửa khoảng tìm kiếm bị loại bỏ mỗi lần, độ phức tạp thời gian tìm kiếm có thể đạt $O(\\log n)$.\nBài toán ví dụ # Mô tả bài toán: Cho một mảng số nguyên được sắp xếp tăng dần có độ dài $n$, và $q$ truy vấn. Mỗi truy vấn cho một số nguyên $k$, và chúng ta cần tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; của $k$ trong mảng (chỉ số bắt đầu từ 0). Nếu số đó không tồn tại trong mảng, trả về -1 -1.\nĐịnh dạng đầu vào # Dòng đầu tiên: hai số nguyên $n$ và $q$, lần lượt biểu thị độ dài của mảng và số lượng truy vấn. Dòng thứ hai: $n$ số nguyên, biểu thị mảng hoàn chỉnh, đã được sắp xếp theo thứ tự tăng dần. $q$ dòng tiếp theo: mỗi dòng chứa một số nguyên $k$, biểu thị một phần tử truy vấn. Phạm vi dữ liệu # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nĐịnh dạng đầu ra # Đối với mỗi truy vấn, xuất ra vị trí bắt đầu và kết thúc của phần tử trong mảng trên một dòng duy nhất. Nếu phần tử không tồn tại trong mảng, xuất ra -1 -1.\nVí dụ:\nĐầu vào: 6 3 1 2 2 3 3 4 3 4 5 Đầu ra: 3 4 5 5 -1 -1 Giải thích:\nPhạm vi mà phần tử $3$ xuất hiện là $[3, 4]$; Phần tử $4$ chỉ xuất hiện một lần, tại vị trí $5$; Phần tử $5$ không tồn tại trong mảng, vì vậy trả về $-1$ $-1$. Giải pháp # Tìm \u0026ldquo;Vị trí bắt đầu\u0026rdquo;: Tức là, tìm vị trí đầu tiên lớn hơn hoặc bằng $k$. Mảng có thể được chia thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn\u0026rdquo; $k$ Tất cả các số bên phải đều \u0026ldquo;lớn hơn hoặc bằng\u0026rdquo; $k$ Câu trả lời là vị trí đầu tiên ở bên phải Tìm \u0026ldquo;Vị trí kết thúc\u0026rdquo;: Tức là, tìm vị trí cuối cùng nhỏ hơn hoặc bằng $k$. Mảng có thể được chia thành hai phần:\nTất cả các số bên trái đều \u0026ldquo;nhỏ hơn hoặc bằng\u0026rdquo; $k$ Tất cả các số bên phải đều \u0026ldquo;lớn hơn\u0026rdquo; $k$ Câu trả lời là vị trí cuối cùng ở bên trái Mẫu khuyến nghị # Dưới đây là một mẫu tìm kiếm nhị phân thanh lịch và ít lỗi hơn.\nXác định hai con trỏ $l, r$, với bất biến: khoảng đóng $[0, l]$ thuộc phần bên trái và khoảng đóng $[r, n - 1]$ thuộc phần bên phải. $l$ và $r$ được khởi tạo lần lượt là $-1$ và $n$.\nKhi thuật toán kết thúc, $l$ và $r$ liền kề nhau, trỏ đến phần tử cuối cùng của phần bên trái và phần tử đầu tiên của phần bên phải.\nVì giải pháp chúng ta muốn có thể không tồn tại, nếu bài toán không nói rằng một giải pháp chắc chắn tồn tại, chúng ta cần kiểm tra xem l hoặc r có nằm ngoài giới hạn hay không và liệu nó có trỏ đến giá trị chính xác hay không.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Tìm vị trí bắt đầu của k 15 // Chia mảng thành hai phần, phần bên trái là tất cả \u0026lt; k, và phần bên phải là tất cả \u0026gt;= k. 16 // Câu trả lời là chỉ số nhỏ nhất của phần bên phải. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Nếu r nằm ngoài giới hạn hoặc nums[r] != k, có nghĩa là k không tồn tại 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Tìm vị trí kết thúc của k 33 // Chia mảng thành hai phần, phần bên trái là tất cả \u0026lt;= k, và phần bên phải là tất cả \u0026gt; k. 34 // Câu trả lời là chỉ số lớn nhất của phần bên trái. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Ưu điểm # Cách tiếp cận này có các bất biến được xác định chặt chẽ. Nó áp dụng cho cả việc tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; mà không cần xử lý hoặc thay đổi thêm. Một số cách tiếp cận sử dụng l == r làm điều kiện kết thúc. Khi $l$ và $r$ khác nhau $1$, $mid$ sẽ được tính bằng $l$ hoặc $r$. Nếu không được xử lý đúng cách, việc cập nhật $l$ hoặc $r$ thành $mid$ sẽ không thu hẹp khoảng tìm kiếm, dẫn đến vòng lặp vô hạn. Ngược lại, cách tiếp cận này kết thúc khi $l$ và $r$ liền kề nhau, đảm bảo rằng $mid$ nhỏ hơn $l$ và lớn hơn $r$, và việc cập nhật $l$ hoặc $r$ sẽ luôn thu hẹp khoảng tìm kiếm. STL # Nếu bạn sử dụng các hàm lower_bound và upper_bound do C++ STL cung cấp, bạn có thể đạt được điều tương tự:\nlower_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn hoặc bằng val\u0026rdquo; upper_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn val\u0026rdquo; Ví dụ, giả sử nums = {1,2,3,4,4,4,4,4,5,5,6}, và chúng ta muốn biết phạm vi mà 4 xuất hiện:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện 0 lần\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;số 4 đầu tiên ở vị trí \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;số 4 cuối cùng ở vị trí \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 xuất hiện \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; lần\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 trỏ đến vị trí đầu tiên mà giá trị lớn hơn hoặc bằng $4$. it2 trỏ đến vị trí đầu tiên mà giá trị lớn hơn $4$. Do đó, it2 - it1 là số lần $4$ xuất hiện trong mảng; it2 - nums.begin() - 1 là vị trí của ranh giới bên phải của $4$. Ghi chú bổ sung # Tìm kiếm nhị phân cũng có thể được mở rộng để tìm kiếm trong các phạm vi số thực (chẳng hạn như tìm nghiệm của một phương trình) và tìm kiếm tam phân để tìm cực trị của các hàm đơn mode.\nLuyện tập # LeetCode 33. Search in Rotated Sorted Array\nGợi ý: Đầu tiên, sử dụng tìm kiếm nhị phân để tìm điểm xoay, sau đó sử dụng tìm kiếm nhị phân để tìm giá trị mục tiêu.\n","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Cách triển khai thuật toán tìm kiếm nhị phân một cách thanh lịch.","title":"Tìm kiếm nhị phân","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]