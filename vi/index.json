[{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":" Đề bài # Có $N$ đồ vật. Đồ vật thứ $i$ có thể tích là $s_i$, giá trị là $v_i$. Mỗi đồ vật chỉ được lấy một lần. Trong giới hạn tổng thể tích tối đa $S$, hãy tìm tổng giá trị lớn nhất $V$ có thể đạt được.\nĐịnh dạng đầu vào # Dòng đầu tiên gồm hai số nguyên, $N, S$, cách nhau bằng dấu cách, lần lượt biểu thị số lượng đồ vật và giới hạn tổng thể tích tối đa. Tiếp theo có $N$ dòng, mỗi dòng gồm hai số nguyên $s_i, v_i$, cách nhau bằng dấu cách, lần lượt biểu thị thể tích và giá trị của đồ vật thứ $i$.\nĐịnh dạng đầu ra # In ra một số nguyên, biểu thị giá trị lớn nhất.\nPhạm vi dữ liệu # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Ví dụ đầu vào # 4 5 1 2 2 4 3 4 4 5 Ví dụ đầu ra # 8 Lời giải # Định nghĩa trạng thái: f[i][j] biểu thị giá trị lớn nhất có thể nhận được khi xét $i$ đồ vật đầu tiên với giới hạn thể tích là $j$. Nếu không lấy đồ vật thứ $i$, thì f[i][j] = f[i - 1][j] Nếu lấy đồ vật thứ $i$, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Khi thực hiện chuyển trạng thái, cần chú ý đến phạm vi định nghĩa. Nếu $j \u003c s_i$, thì không xét trường hợp lấy đồ vật thứ $i$. Bởi vì nếu $j - s_i$ là số âm, thì chỉ số mảng không hợp lệ. Cũng có thể giải thích như sau: Thể tích của đồ vật thứ $i$ lớn hơn giới hạn thể tích, nên không thể lấy được. Định nghĩa điều kiện ban đầu: Với $0$ đồ vật đầu tiên, mọi giới hạn thể tích đều nhận được giá trị $0$, tức là f[0][j] = 0, j $\\in [0, S]$. Độ phức tạp thời gian: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Tối ưu DP một chiều # Nén mảng hai chiều thành mảng một chiều, có thể tiết kiệm không gian đáng kể và tăng tốc độ chạy ở một mức độ nhất định (nhược điểm là không thể đáp ứng các yêu cầu đặc biệt của một số dạng bài) Lưu ý rằng trong chuyển trạng thái, f[i][j] chỉ liên quan đến f[i - 1][j] và f[i - 1][j - s[i]]. Nói cách khác, trong mảng hai chiều f trong code, f[i][j] chỉ liên quan đến các phần tử ở hàng trên nó và ở bên trái hoặc cùng cột, do đó có thể nén mảng hai chiều thành mảng một chiều hoặc mảng cuộn. Lưu ý rằng trong code dưới đây, vòng lặp thứ hai duyệt ngược, điều này là để đảm bảo rằng khi tính f[i][j], f[i - 1][j - s[i]] chưa bị cập nhật. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Nếu yêu cầu số lượng phương án # Không chỉ phải in ra tổng giá trị lớn nhất có thể đạt được, mà còn phải in ra \u0026ldquo;có bao nhiêu cách chọn khác nhau để đạt được tổng giá trị lớn nhất này\u0026rdquo;. Dưới đây giới thiệu cách thống kê số lượng phương án trong bài toán cái túi 01.\nThống kê số lượng phương án bằng DP hai chiều # Dưới đây lấy DP hai chiều làm ví dụ để giải thích.\nĐịnh nghĩa trạng thái:\ndp[i][j] biểu thị \u0026ldquo;khi xét $i$ đồ vật đầu tiên, với dung lượng (giới hạn thể tích) là $j$, giá trị lớn nhất có thể đạt được\u0026rdquo;. ways[i][j] biểu thị \u0026ldquo;khi xét $i$ đồ vật đầu tiên, với dung lượng là $j$, số lượng phương án tương ứng khi đạt được giá trị lớn nhất\u0026rdquo;. Chuyển trạng thái:\nNếu không chọn đồ vật thứ i: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Nếu chọn đồ vật thứ i (với điều kiện $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Chọn hoặc không chọn, cuối cùng dp[i][j] nên lấy giá trị lớn hơn trong hai giá trị: Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ thì có nghĩa là \u0026ldquo;chọn đồ vật thứ i\u0026rdquo; có giá trị lớn hơn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ thì có nghĩa là hai cách đều đạt được giá trị lớn nhất giống nhau, thì số lượng phương án nên được cộng vào: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Nếu $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ thì có nghĩa là \u0026ldquo;không chọn đồ vật thứ i\u0026rdquo; có giá trị lớn hơn, số lượng phương án được kế thừa từ phương án không chọn: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Điều kiện ban đầu:\ndp[0][j] = 0 biểu thị khi xét 0 đồ vật đầu tiên, mọi dung lượng đều nhận được giá trị lớn nhất là 0. ways[0][0] = 1 biểu thị \u0026ldquo;0 đồ vật đầu tiên, dung lượng là 0\u0026rdquo; là một phương án khả thi (tức là không chọn gì cả), số lượng phương án được đặt là 1. Với j \u0026gt; 0, khi không có đồ vật nào để chọn mà dung lượng lại lớn hơn 0, thì không thể đạt được bất kỳ giá trị dương nào, số lượng phương án tương ứng là 0, tức là ways[0][j] = 0. Đáp án cuối cùng:\ndp[N][S] chính là giá trị lớn nhất. ways[N][S] chính là số lượng phương án để đạt được giá trị lớn nhất đó. Độ phức tạp thời gian: $O(NS)$. Bài này cũng có thể dùng DP một chiều để tối ưu. Nếu yêu cầu đạt đúng giới hạn thể tích # Định nghĩa trạng thái: f[i][j] biểu thị giá trị lớn nhất khi chọn i đồ vật đầu tiên có tổng thể tích đúng bằng j. Nếu không lấy đồ vật thứ i, thì f[i][j] = f[i - 1][j] Nếu lấy đồ vật thứ i, thì f[i][j] = f[i - 1][j - s[i]] + v[i] Có thể nhận thấy rằng việc chuyển trạng thái không khác gì bài toán gốc. Nhưng điều kiện ban đầu lại khác. Ngoài f[0][0] = 0, các f[0][j] còn lại đều bằng $-\\infty$, j $\\in [1, S]$. $-\\infty$ biểu thị trạng thái không thể xảy ra. Nếu giới hạn thể tích $S$ quá lớn (1e9), đồng thời số lượng đồ vật $N$ và tổng giá trị lớn nhất $V$ lại nhỏ # Với các bài như vậy, có một cách giải với độ phức tạp $O(NV)$. Định nghĩa trạng thái: f[i][j] biểu thị thể tích nhỏ nhất khi chọn một số đồ vật trong i đồ vật đầu tiên mà có tổng giá trị đúng bằng j. Nếu không lấy đồ vật thứ i, thì f[i][j] = f[i - 1][j] Nếu lấy đồ vật thứ i, thì f[i][j] = f[i - 1][j - v[i]] + s[i] Lấy giá trị nhỏ hơn trong hai giá trị. Điều kiện ban đầu: f[0][0] = 0, các f[0][j] còn lại bằng $\\infty$, j $\\in [1, V]$. $\\infty$ biểu thị trạng thái không thể xảy ra. Lưu ý không phải là $-\\infty$. Đáp án cuối cùng là giá trị j lớn nhất trong các f[N][j] sao cho f[N][j] \u0026lt;= S. Nếu giới hạn thể tích $S$ và giá trị của từng đồ vật $v_i$ đều rất lớn (cỡ $1e9$), đồng thời số lượng đồ vật $N$ lại rất nhỏ (tối đa không quá 40) # Khi $N \\leq 20$, có thể trực tiếp duyệt trâu tất cả các tập con (độ phức tạp thời gian $O(2^N)$). Khi $N \\leq 40$, vì $2^{40}$ ở cỡ $10^{12}$, duyệt trâu trực tiếp cũng sẽ khá lớn, vì vậy có thể sử dụng tìm kiếm chia đôi , giảm độ phức tạp xuống xấp xỉ $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ , có thể hoàn thành trong thời gian chấp nhận được. ","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Bài toán cái túi cổ điển cơ bản nhất.","title":"Bài toán cái túi 01","type":"posts"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 tháng 12 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"Nếu không gian nghiệm có thứ tự được chia thành hai phần, trong đó một phần thỏa mãn điều kiện và phần còn lại không thỏa mãn điều kiện. Vậy thì có thể sử dụng tìm kiếm nhị phân để tìm điểm tới hạn trong không gian nghiệm có thứ tự.\nÝ tưởng cơ bản của tìm kiếm nhị phân là liên tục chia đôi khoảng tìm kiếm. Mỗi lần kiểm tra phần tử ở giữa, nếu phần tử ở giữa không thỏa mãn điều kiện, thì có thể loại bỏ một nửa khoảng; ngược lại, thì tiếp tục tìm kiếm ở nửa khoảng còn lại. Vì mỗi lần đều loại bỏ một nửa khoảng tìm kiếm, nên độ phức tạp thời gian tìm kiếm có thể đạt được $O(\\log n)$.\nVí dụ # Mô tả bài toán:\nCho một mảng số nguyên có độ dài $n$ được sắp xếp tăng dần, và $q$ truy vấn. Mỗi truy vấn đưa ra một số nguyên $k$, chúng ta cần tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo; của $k$ trong mảng (chỉ số bắt đầu từ 0). Nếu số này không tồn tại trong mảng, hãy trả về -1 -1.\nĐịnh dạng đầu vào # Dòng đầu tiên: Hai số nguyên $n$ và $q$, lần lượt biểu thị độ dài của mảng và số lần truy vấn. Dòng thứ hai: $n$ số nguyên, biểu thị mảng đầy đủ, đã được sắp xếp theo thứ tự tăng dần. $q$ dòng tiếp theo: Mỗi dòng chứa một số nguyên $k$, biểu thị một phần tử truy vấn. Phạm vi dữ liệu # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nĐịnh dạng đầu ra # Đối với mỗi truy vấn, xuất ra vị trí bắt đầu và kết thúc của phần tử đó trong mảng trên một dòng. Nếu phần tử đó không tồn tại trong mảng, xuất ra -1 -1.\nVí dụ:\nĐầu vào: 6 3 1 2 2 3 3 4 3 4 5 Đầu ra: 3 4 5 5 -1 -1 Giải thích:\nPhạm vi xuất hiện của phần tử $3$ là $[3, 4]$; Phần tử $4$ chỉ xuất hiện một lần, ở vị trí $5$; Phần tử $5$ không tồn tại trong mảng, do đó trả về $-1$ $-1$. Giải đáp # Tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo;: Tức là tìm vị trí đầu tiên lớn hơn hoặc bằng $k$. Có thể chia mảng thành hai phần:\nTất cả các số ở bên trái đều \u0026ldquo;nhỏ hơn\u0026rdquo; $k$ Tất cả các số ở bên phải đều \u0026ldquo;lớn hơn hoặc bằng\u0026rdquo; $k$ Đáp án là vị trí đầu tiên ở bên phải Tìm \u0026ldquo;vị trí kết thúc\u0026rdquo;: Tức là tìm vị trí cuối cùng nhỏ hơn hoặc bằng $k$. Có thể chia mảng thành hai phần:\nTất cả các số ở bên trái đều \u0026ldquo;nhỏ hơn hoặc bằng\u0026rdquo; $k$ Tất cả các số ở bên phải đều \u0026ldquo;lớn hơn\u0026rdquo; $k$ Đáp án là vị trí cuối cùng ở bên trái Mẫu đề xuất # Dưới đây là một mẫu nhị phân thanh lịch và không dễ mắc lỗi. Nó đảm bảo vòng lặp sẽ kết thúc khi hai con trỏ $l$ và $r$ liền kề nhau bằng cách cho $l$ và $r$ từ từ tiến lại gần nhau:\nĐịnh nghĩa hai con trỏ $l, r$, có bất biến: khoảng đóng $[0, l]$ thuộc về nửa bên trái, khoảng đóng $[r, n - 1]$ thuộc về nửa bên phải. $l$ và $r$ đều khởi tạo là $-1$ và $n$.\nKhi thuật toán kết thúc, $l$ và $r$ liền kề nhau, lần lượt trỏ đến phần tử cuối cùng của nửa bên trái và phần tử đầu tiên của nửa bên phải.\nVì lời giải chúng ta muốn có thể không tồn tại, nên nếu bài toán không nói rõ là chắc chắn tồn tại lời giải, chúng ta cần phải kiểm tra xem l hoặc r có vượt quá giới hạn không, có trỏ đến giá trị đúng không.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Tìm vị trí bắt đầu của k 15 // Chia mảng thành hai phần, bên trái đều \u0026lt; k, bên phải đều \u0026gt;= k. 16 // Đáp án là chỉ số nhỏ nhất của nửa bên phải. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Nếu r vượt quá giới hạn hoặc nums[r] != k, tức là k không tồn tại 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Tìm vị trí kết thúc của k 33 // Chia mảng thành hai phần, bên trái đều \u0026lt;= k, bên phải đều \u0026gt; k. 34 // Đáp án là chỉ số lớn nhất của nửa bên trái. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Tại sao lại viết như vậy # Cách viết này có bất biến được định nghĩa chặt chẽ. Nó đồng thời áp dụng cho cả hai trường hợp tìm \u0026ldquo;vị trí bắt đầu\u0026rdquo; và \u0026ldquo;vị trí kết thúc\u0026rdquo;, không cần xử lý và thay đổi thêm. Một số cách viết sử dụng l == r làm điều kiện dừng. Khi $l$ và $r$ cách nhau $1$, sẽ tính ra $mid$ bằng $l$ hoặc $r$. Nếu không xử lý đúng, cập nhật $l$ hoặc $r$ thành $mid$, khoảng tìm kiếm không thu hẹp, sẽ dẫn đến vòng lặp vô hạn. Ngược lại, cách viết ở đây dừng lại khi $l$ và $r$ liền kề nhau, đảm bảo $mid$ nhỏ hơn $l$ và lớn hơn $r$, khi cập nhật $l$ hoặc $r$, khoảng tìm kiếm chắc chắn sẽ thu hẹp. STL # Nếu sử dụng các hàm lower_bound và upper_bound do C++ STL cung cấp, cũng có thể hoàn thành cùng một việc:\nlower_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn hoặc bằng val\u0026rdquo; upper_bound(first, last, val) sẽ trả về \u0026ldquo;vị trí đầu tiên lớn hơn val\u0026rdquo; Ví dụ, giả sử nums = {1,2,3,4,4,4,4,4,5,5,6}, chúng ta muốn biết khoảng mà 4 xuất hiện:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 trỏ đến vị trí của giá trị đầu tiên lớn hơn hoặc bằng $4$. it2 trỏ đến vị trí của giá trị đầu tiên lớn hơn $4$. Vì vậy it2 - it1 là số lần $4$ xuất hiện trong mảng; it2 - nums.begin() - 1 là biên phải của $4$. Bổ sung # Tìm kiếm nhị phân còn có thể mở rộng đến việc tìm kiếm trong phạm vi số thực (ví dụ như tìm nghiệm của phương trình), cũng như tìm kiếm tam phân để tìm giá trị lớn nhất của hàm đơn đỉnh. Chỉ cần bạn hiểu được nguyên tắc cốt lõi \u0026quot; Trong khoảng có thứ tự, mỗi lần đều có thể loại bỏ một nửa\u0026quot;, bạn sẽ thấy tìm kiếm nhị phân có thể giúp bạn giải quyết vấn đề một cách hiệu quả trong nhiều trường hợp.\nLuyện tập # LeetCode 33. Search in Rotated Sorted Array\nGợi ý: Bước đầu tiên sử dụng tìm kiếm nhị phân để tìm điểm xoay, bước thứ hai lại sử dụng tìm kiếm nhị phân để tìm giá trị mục tiêu.\n","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Làm thế nào để thực hiện thuật toán tìm kiếm nhị phân một cách thanh lịch.","title":"Tìm kiếm nhị phân","type":"posts"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]