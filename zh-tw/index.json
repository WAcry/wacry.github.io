[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":" 一、CAP 定理 # 1.1 什麼是 CAP 定理 # CAP 定理 由 Eric Brewer 在 2000 年提出，其核心觀點是：\nC（Consistency，一致性）：系統中的所有節點在同一時刻看到的數據都是相同的。更嚴格地說，當客戶端讀取數據時，無論從哪個副本讀取，結果都應當與最新提交的數據保持一致（通常指強一致性/線性一致性）。 A（Availability，可用性）：系統在出現部分故障時仍然可以對外提供正常服務，每個請求都能在合理時間內得到「有效響應」（不一定都是成功，也包括正確的失敗響應）。 P（Partition tolerance，分區容錯性）：系統可以容忍網路分區（節點間通訊出現不可達），即使網路發生分裂，系統也能提供一定程度的可用性或一致性。 在真實分散式環境中，網路分區不可避免，所以 P 基本被視為「必選項」。當網路分區發生時，系統無法同時兼顧所有節點對數據的強一致性與高可用性，只能在 C 和 A 中做取捨，於是衍生出 CP 和 AP 兩大主要類型。\n1.2 CAP 定理的局限性 # 需要指出的是，CAP 定理本身是一個相對高層次的理論，應用於概念指導，不能簡單理解為「要麼選 C，要麼選 A」。存在一些常見的誤解：\nC 並不必然是強一致性 CAP 定理中的 C 往往指的是最嚴格意義上的一致性（即線性一致性）。但在實際系統中，我們還有弱一致性、讀已提交（Read Committed）、因果一致性（Causal Consistency）等很多細粒度模型可以選擇。 可用性並非 0 或 1 並非說選了 CP，就意味著可用性完全被犧牲；或選了 AP，就意味著一致性毫無保障。可用性和一致性都有不同程度的權衡空間和降級策略。 最終一致性 不違背 CAP 它是一個非常常見的折衷方案，用較低的寫一致性換取更高的可用性和吞吐量，並通過非同步方式在後台收斂數據。 因此，CAP 定理應和各種 一致性模型、高可用架構模式 結合到具體場景裡，才能產生真正的落地指導價值。\n二、分散式系統的一致性模型 # 一致性模型的分類十分豐富，但常見的主流模型大致可以分為：強一致性 和 弱一致性（其中包含最終一致性、因果一致性等）。本文主要介紹 強一致性 與 最終一致性，並說明它們在 CP 或 AP 模式下的常見應用。\n2.1 強一致性 # 強一致性（Strong Consistency） 又稱 線性一致性（Linearizability） ，指的是一旦一次寫操作完成返回成功，任何後續的讀取操作都能讀到該更新內容。也就是說，系統對外表現得像是串行執行了所有操作。\n常見實現：依賴同步複製和一個仲裁（多數派）機制，通過協議（如 Paxos/Raft）來確保系統中只有一個有效的領導者（Leader），所有操作按順序寫入日誌並複製到多數節點。 優缺點： 優點：保證最嚴格的數據正確性，任何時候讀到的數據都不發生「回退」。 缺點：在網路抖動、分區或領導者故障時，為了維持一致性往往會阻塞寫操作，導致整體可用性下降；效能和吞吐量也相對更低。 2.2 最終一致性 # 最終一致性（Eventual Consistency） 是弱一致性的一種典型形式，它只要求如果系統不再有新的更新操作，隨著時間的推移，所有副本的數據會逐漸收斂到同一個狀態。期間用戶讀取副本數據，可能會看到過時的值，但最終會變得一致。\n常見實現：Gossip 協議、多副本非同步複製、CRDT（Conflict-free Replicated Data Type）等。 優缺點： 優點：高可用、高吞吐量，寫操作延遲較低，對網路分區的容忍度高。 缺點：需要容忍短時間的數據不一致，應用邏輯更複雜，可能要進行衝突檢測與合併。 三、常見一致性協議與演算法 # 為了讓分散式系統副本之間保持一致，業界提出了諸多經典演算法與協議。以下簡要介紹幾種：\n3.1 Paxos # Paxos 是由 Leslie Lamport 在 1990 年代提出的分散式一致性演算法，主要用於實現強一致性或線性一致性。\n基本原理：通過角色劃分（提案者 Proposer、接受者 Acceptor、學習者 Learner）進行多輪投票，來決定一次操作或值是否被多數節點接受。 優缺點： 優點：能在網路分區、節點故障下依舊達成一致，具備很高的安全性。 缺點：實現複雜，除錯和排錯難度高，多輪投票導致效能受限。工業界多用其變體（Multi-Paxos 等）。 3.2 Raft # Raft 於 2013 年正式提出，目標是在保證與 Paxos 同等安全性的前提下，簡化實現和理解難度。它通過建立一個穩定的領導者（Leader） 角色，集中式地進行日誌複製和故障恢復：\n關鍵階段：領導選舉（Leader Election）、日誌複製（Log Replication）、安全性（Safety）等。 常見應用：Etcd、Consul、TiKV、LogCabin 等都基於 Raft 來實現強一致複製。 優缺點： 優點：相對易懂、實現程式碼量更少；對中小規模叢集效能較好。 缺點：依賴主節點（Leader），主節點故障或分區會造成短暫的寫阻塞；在大規模叢集或跨地域部署時，延遲和可用性會受到影響。 3.3 Gossip 協議 # Gossip（八卦）協議並非傳統的共識協議，主要用於在去中心化的場景下通過節點隨機互動來交換元數據或狀態資訊，從而在全網進行擴散與收斂。\n特點：去中心化、低開銷、節點間週期性且隨機地交換訊息。 常見應用：Cassandra、Riak、分散式成員管理（如 Serf）等，用於實現最終一致性、副本狀態同步等。 優缺點： 優點：擴展性佳，簡單易實現，適合對一致性要求不高、對可擴展性要求高的場景。 缺點：一致性保證較弱，需要更高級別的衝突處理手段（如 CRDT、版本號合併等）來最終解決衝突。 3.4 2PC / 3PC # 在分散式事務場景下，常見的提交協議是 2PC（Two-phase Commit） 和 3PC（Three-phase Commit）：\n2PC：協調者通知所有參與者「預提交（prepare）」，若都成功則廣播「提交（commit）」，否則「回滾（abort）」。 3PC：在 2PC 基礎上增加一個階段，降低單點故障帶來的阻塞，但實現更複雜，仍然存在極端網路分區或故障場景下的不可用問題。 優缺點： 優點：容易理解，事務語義清晰，在分散式資料庫、訊息佇列等廣泛應用。 缺點：對協調者依賴性強，有阻塞風險；在網路出現較長時間分區時可能無法繼續推進事務。 四、CAP 的兩大主流選擇：CP 與 AP # 當我們認定 P 是「必選」的屬性之後，分散式系統若想在網路分區時繼續提供服務，就要在 C 和 A 之間做抉擇。常見的系統設計因此分化為 CP 和 AP 兩大陣營。\n4.1 CP 系統 # CP（Consistency + Partition tolerance）：遇到網路分區時，系統會選擇 優先保證一致性，在必要時犧牲可用性。\n典型實現： 多數派共識（Paxos、Raft 等），需要過半節點存活並達成一致才允許寫入。 若當前無法達成 quorum（法定人數）或主節點故障，系統會阻塞或拒絕寫操作，以防止腦裂導致數據不一致。 常見應用： Zookeeper、Etcd、Consul、分散式鎖服務、分散式元數據管理等。 金融交易核心流程、銀行帳務系統等高一致性要求的場景。 特點： 擁有嚴格的數據保證：寧可停機也不出現雙主或數據混亂。 犧牲一定的可用性：在發生網路分區或故障切換時，會有一段服務不可用或拒絕寫操作的視窗。 4.2 AP 系統 # AP（Availability + Partition tolerance）：遇到網路分區時，系統會選擇 優先保證可用性，同時放寬一致性。\n典型實現： 最終一致性、多主複製、Gossip 協議、Dynamo 風格可調一致性策略等。 常見應用： NoSQL 資料庫（Cassandra、Riak、DynamoDB 等），分散式快取系統（Redis Cluster）等。 社群網路、日誌採集、推薦系統等需要高可用、高吞吐，對數據一致性要求相對寬鬆的業務。 特點： 即使分區，所有節點依舊接收讀寫請求，保證系統「盡可能可用」。 數據可能存在短暫不一致，但會通過非同步同步、衝突合併等方式在後台逐步收斂。 五、如何在 CP 與 AP 中取捨？ # 在真實的大規模分散式系統中，往往很少只依賴單一模型，而是對不同數據或業務場景進行分層處理，以求 一致性 與 可用性 的最優平衡。\n核心數據選 CP 如用戶帳戶餘額、訂單支付、金融交易流水等，對一致性要求極高。 容忍網路抖動導致的短暫不可寫，但不能容忍餘額或交易金額的錯誤。 邊緣或快取數據選 AP 如商品詳情頁的快取、用戶行為日誌、推薦候選列表等，對一致性要求較低。 更看重高並發、高可用，能夠容忍一定時間的延遲更新或髒讀。 許多網際網路企業會採用混合架構：核心交易流程使用 CP 式儲存（如分散式關聯式資料庫或帶強一致性的分散式儲存）；外圍業務或「讀多寫少」的場景使用 AP 式儲存或快取方案。\n六、CP 與 AP 如何實現高並發與最終一致性 # 6.1 CP 系統如何應對高並發 # 雖然共識協議在單一叢集節點規模和寫請求量大時，會面臨較高的延遲和較低的吞吐，但依然可以通過以下手段提升並發和可擴展性：\n批量讀寫 將多個寫操作在客戶端或中間層打包，一次性在領導者節點上寫入，減少網路往返和協議輪次。 分庫分表 \u0026amp; 多叢集 將數據按邏輯或雜湊切分到多個叢集（sharding），每個叢集內部仍然運行 CP 協議；請求通過路由或代理層分散到不同分片。 提升整體並發能力，並將故障影響限制在單個分片範圍內。 CP 系統的單分片叢集吞吐量往往比 AP 系統低 2 到 10 倍。\n6.2 AP 系統如何保證最終一致性 # AP 系統通常能夠提供很高的寫吞吐和讀取可用性，但對一致性放鬆，因而需要在後台或業務邏輯層實現一致性收斂的保障：\n版本號（Vector Clock）或邏輯時間戳 給每個更新操作分配一個版本號（或基於 Lamport Clock / Hybrid Clock），在衝突場景下進行合併或基於時間戳的勝出策略（Last Write Wins）。 Gossip 協議 / 反熵（Anti-entropy）機制 節點週期性地交換最新數據或元數據，發現衝突則進行合併。 可調一致性策略 以 Dynamo 模型為代表，客戶端可配置 R、W 等參數（如寫入多數派、副本確認），從而在一致性和可用性之間彈性調節。 自定義衝突解決策略 結合業務語義進行合併，如購物車用「並集」合併，計數器用 CRDT（G-counter、PN-counter 等）保證數據的單調性。 七、CP 的跨分片強一致性實現 # 在第七章中提到，通過分庫分表（Sharding） 可以讓單個 CP 叢集的壓力「拆分」到多個子叢集，以支撐更高並發。然而，當業務需要跨分片執行事務（即涉及多個分庫或分表的更新）時，仍面臨 多分片一致性 的挑戰。通常有以下思路：\n分散式事務：2PC / 3PC 若應用需要跨多個分片進行原子性更新，通常使用分散式事務協議（如 2PC、3PC）來協調各分片的提交或回滾。 問題與對策： 2PC/3PC 都依賴一個協調者節點，可能成為單點瓶頸。 在網路分區嚴重或協調者故障的極端情形下，可能出現阻塞。 一般會通過主從切換、心跳檢測和逾時機制、冪等重試、MVCC 等來降低阻塞影響和數據不一致風險。 單元化（Cell-based）架構 將業務切分為多個自治單元，每個單元內的數據都在同一個分片集合中，保證大多數事務都只在單一單元中完成，減少跨分片操作。 在單元邊界上採用非同步或最終一致性機制進行數據交換，兼顧整體的高可用與一致性。 全球分散式資料庫 + 全局共識協議 例如 Google Spanner 在每個分片（Shard）上通過 Paxos 實現副本強一致複製，再利用 TrueTime API 提供全局時間戳保障跨分片一致性。 這種方案實現複雜度極高，但能在全局範圍內提供接近強一致的分散式事務能力。 小結：對於嚴格要求強一致性的跨分片事務，2PC/3PC + 協調者 仍是常見方案，並通過盡可能提高協調者的高可用，來降低故障的可能性。但需在工程實踐中盡量減少跨分片寫操作，或通過單元化思路將大部分事務限制在單一分片範圍，降低系統複雜度。\n八、著名案例討論 # 下面簡要探討幾款在業界常被提及的分散式系統，看看它們在 CAP 上的取捨與實現方式：\nGoogle Spanner 典型的 CP 系統（甚至能做到外界常說的 「CA」 幻覺，但實質仍需犧牲一部分可用性）。 利用 TrueTime 提供的外部精確時間戳 + 每個分片內部的 Paxos 複製，保證跨數據中心的強一致性。 適合全球金融交易或高一致性要求場景，但基礎設施成本極高。 BigTable / HBase 表面上更偏向 CP，在 RegionServer 與 Master 之間通過分散式協調保證元數據的一致性。 但實際讀寫路徑中也能通過多副本非同步複製提供一定的高可用手段，讀一致性可根據應用需求調整。 AWS DynamoDB 傾向 AP，早期設計靈感來自 Dynamo 論文，可通過 R、W 等參數調節一致性等級。 預設模式下提供極高可用性和最終一致性，也可開啟「強一致讀」（但只保證單分區的強一致，不一定跨分區）。 Cassandra 同樣是 AP 傾向，底層採用 Gossip 協議維護節點拓撲狀態。 讀寫一致性可配置讀寫副本數 R / W，以實現從最終一致性到較強一致性的平滑過渡。 對比可見：工程上不存在絕對的「AP 或 CP」，更多是多種一致性策略的混合；大部分系統都提供一定程度的可調一致性來適配不同應用場景。\n九、總結 # CAP 定理不是一刀切 真實的分散式系統無法簡單地說「我選 C，放棄 A」或「我選 A，放棄 C」。 業界更常見的是針對不同的數據維度、不同的操作類型，靈活地選擇 CP 或 AP 模式，甚至在同一個系統內部，對不同表/不同功能採用不同的容錯與一致性策略。 AP 並非絕對 100% 可用 例如，Cassandra、DynamoDB 等在極端網路分區或節點大面積失效時，同樣會出現無法滿足請求的情況。 AP 系統只是設計上傾向「只要副本可寫就先寫」，犧牲了一部分一致性保證來換取相對更高的可用性與吞吐量。 CP 也可以盡量做到高可用 Paxos/Raft 在正常情況下也能提供 99.99% 甚至更高的可用性，只是需要投入更多的網路、硬體和工程成本，且在極端網路分區時仍會出現阻塞寫、犧牲可用性來維持一致。 混合架構是主流 核心交易場景堅持強一致（CP），外圍輔助場景或快取通道採用弱一致（AP），兩者相互配合。 要結合業務容忍度、網路環境、成本投入、團隊技術儲備來綜合取捨。 CAP 定理為分散式系統的設計提供了一個高層次的思維框架，幫助我們在網路分區這一不可避免的現實面前做出理性決策。在實際系統中，則需要借助更豐富的 一致性模型、共識協議、多副本複製機制 以及工程實踐（容災、降級、冪等、衝突合併等）來平衡一致性與可用性。\n","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/posts/1735350760948-cap/","section":"Posts","summary":"從理論到實踐討論 CAP 定理在分散式系統中的應用。","title":"深入解析CAP定理：打造高並發與高可用的分散式系統","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"快速排序是一種基於比較的非穩定排序演算法，採用分治思想，平均時間複雜度為 $O(n\\log n)$，最壞情況下為 $O(n^2)$ ，空間複雜度為 $O(1)$。下面以從小到大排序一個整數數列為例，介紹其實現細節與常見錯誤。\n題目描述 # 給定一個長度為 $n$ 的整數數列，使用快速排序對其從小到大進行排序，並輸出結果。\n輸入格式 # 第一行輸入整數 $n$ 第二行輸入 $n$ 個整數，均在 $[1,10^9]$ 範圍內 輸出格式 # 一行輸出排好序的數列 數據範圍 # $1 \\leq n \\leq 100000$\n輸入範例 # 5 3 1 2 4 5 輸出範例 # 1 2 3 4 5 快速排序思路 # 快速排序每次分治時，任選一個數作為基準數 pivot（下面選中間位置的數）。\n使用左右指針相向而行，左指針 L 從左往右尋找第一個大於等於 pivot 的數，右指針 R 從右往左尋找第一個小於等於 pivot 的數，然後交換這兩個數。\n不斷重複這個過程，直到左指針和右指針重疊或者左指針比右指針大一位。這被稱為一次循環。\n在每次指針移動和交換完成後，都保證「左邊部分 ≤ pivot, 右邊部分 ≥ pivot」的結構不被破壞，即有不變量 [left, L) \u0026lt;= pivot， (R, right] \u0026gt;= pivot。\n以下示例程式碼中，left 和 right 是當前處理的閉區間邊界，pivot 則取在區間中點處的元素。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 複雜度與 pivot 的選擇 # 由於在最壞情況下快速排序有 $O(n^2)$ 的複雜度，pivot 的選取很關鍵。如果總是選第一個或最後一個元素，在近乎有序的陣列中將大概率出現最壞情況。\n除了取中間位置的元素，還可以隨機選取一個元素作為 pivot，或者取左、中、右三個元素的中位數作為 pivot。\n常見錯誤示例 # 下面這段程式碼包含了多處常見錯誤。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 錯誤分析：\npivot 應該是陣列中的一個數，而不是下標。 分別用 \u0026lt; 和 \u0026gt; 而不是 \u0026lt;= 和 \u0026gt;=，否則左指針可能不止超過右指針一位，這樣就不能把陣列分成兩部分。 發現 l \u0026gt;= r 後，應立即退出循環，不再執行交換。否則不能保證左側元素不大於 pivot，右側元素不小於 pivot。 每次交換後，應執行 l++ 和 r--。 pivot 實際上取的是中間偏左的數。因此如果使用 $l - 1$ 和 $l$ 分割陣列，考慮陣列 [1, 2]，不難發現會導致死循環，不斷將陣列分成大小為 0 和 2 的兩份。類似地，用 $r$ 和 $l$ 區分陣列也不行。相反地，一輪循環結束時，$r$ 必然小於 $right$，所以可以使用 $r$ 和 $r+1$ 分割陣列。讀者可以模擬下演算法過程看看為什麼。另一種簡單的避免死循環的方式是隨機選 pivot或者特殊處理只有兩個元素的情況。 另外，用 $l$, $l+1$ 也不行，因為這個分割不合定義，當 $r$ 在 $l$ 左邊的情況下，用 $l$, $l+1$ 不能正確地將陣列分成左邊小於等於 pivot，右邊大於等於 pivot 的兩份。 本題假定陣列非空，所以不存在 \u0026gt; 的情況。但是建議使用 \u0026gt;=, 更安全。 補充 # 快速排序還可演變為“快速選擇”，在 $O(n)$ 的期望時間內找到無序陣列中第 $k$ 小的數，具體思想與快速排序類似，只是每次只在一側子區間繼續遞迴，從而降低時間複雜度。\n","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/posts/1735252761946-quick-sort/","section":"Posts","summary":"正確實現快速排序演算法的要點解析。","title":"快速排序","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" 題目 # 有 $N$ 件物品. 第 $i$ 件物品的體積是 $s_i$, 價值是 $v_i$. 每件物品只能取一次. 在不超過最大總體積限制 $S$ 的前提下，求能夠取得的最大總價值 $V$.\n輸入格式 # 第一行兩個整數, $N, S$, 用空格隔開, 分別表示物品數量和最大總體積限制. 接下來有 $N$ 行, 每行兩個整數 $s_i, v_i$, 用空格隔開, 分別表示第 $i$ 件物品的體積和價值.\n輸出格式 # 輸出一個整數, 表示最大價值.\n數據範圍 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 輸入範例 # 4 5 1 2 2 4 3 4 4 5 輸出範例 # 8 題解 # 定義狀態: f[i][j] 表示前 $i$ 件物品，體積限制為 $j$ 可以獲得的最大價值。 若不取第 $i$ 件物品, 那麼 f[i][j] = f[i - 1][j] 若取第 $i$ 件物品, 那麼 f[i][j] = f[i - 1][j - s[i]] + v[i] 實現狀態轉移時, 要注意定義域範圍. 若 $j \u003c s_i$, 那麼不考慮取第 $i$ 件物品的情況。因為若 $j-s_i$ 為負數, 數組下標不合法。 也可以這麼解釋: 第 $i$ 件物品的體積大於體積限制, 所以不可能。 定義初始條件: 前 $0$ 件物品，任何體積限制都獲得價值 $0$, 即 f[0][j] = 0, j $\\in [0, S]$。 時間複雜度: $O(NS)$。 代碼 # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 一維DP優化 # 將二維數組壓縮成一維數組, 可以顯著節省空間並提高一定程度的運行速度（缺點是無法滿足某些題型的特殊要求） 注意到狀態轉移中, f[i][j] 只與 f[i - 1][j] 和 f[i - 1][j - s[i]] 有關. 換言之在代碼中的二維數組 f 中, f[i][j] 只與它的上一行中比它更靠左或同列的元素有關, 因此可以將二維數組壓縮成一維數組或者滾動數組。 注意下面的代碼中, 第二層循環逆序遍歷, 這是因為我們要保證在計算 f[i][j] 時, f[i - 1][j - s[i]] 還沒有被更新. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 如果要求方案數 # 不僅要輸出能夠取得的最大總價值，還需要輸出“有多少種不同的選取方法可以達到這個最大總價值”。下面介紹在 01 背包問題中如何統計方案數。\n二維 DP 統計方案數 # 下面以二維 DP 為例進行講解。\n定義狀態：\ndp[i][j] 表示「前 i 件物品，容量（體積限制）為 j 時，能取得的最大價值」。 ways[i][j] 表示「前 i 件物品，容量為 j，取得最大價值時對應的方案數」。 狀態轉移：\n如果不選第 i 件物品： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ 如果選第 i 件物品（前提是 $ j \\ge s_i $）： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 選或不選，最終 dp[i][j] 應取二者的較大值： 如果 $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ 那麼說明「選第 i 件物品」的價值更大： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ 如果 $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ 說明兩種方式得到的最大價值相同，則方案數應該疊加： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ 如果 $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ 那麼說明「不選第 i 件物品」的價值更大，方案數繼承不選時的方案數： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 初始條件：\ndp[0][j] = 0 表示前 0 件物品時，任何容量得到的最大價值都是 0。 ways[0][0] = 1 表示「前 0 件物品、容量為 0」這一種情況是一種可行方案（即什麼都不選），方案數設為 1。 對於 j \u0026gt; 0，沒有物品可選時容量又大於 0，就不可能取得任何正價值，對應的方案數為 0，即 ways[0][j] = 0。 最終答案：\ndp[N][S] 即為最大價值。 ways[N][S] 即為達到該最大價值的方案數。 時間複雜度：$O(NS)$。 這道題也可以使用一維 DP 進行優化。 如果要求恰好達到體積限制的情況 # 定義狀態: f[i][j] 表示前 i 件物品恰好有體積 $j$ 的最大價值. 若不取第 i 件物品, 那麼 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那麼 f[i][j] = f[i - 1][j - s[i]] + v[i] 可以注意到和原問題的狀態轉移沒有區別. 但是初始條件不同. 除了 f[0][0] = 0, 其餘 f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ 表示不可能的狀態. 如果體積限制 $S$ 特別大 (1e9), 同時物品數量 $N$ 和最大總價值 $V$ 比較小 # 對於這樣的題, 有一種複雜度為 $O(NV)$ 的解法. 定義狀態: f[i][j] 表示前 i 件物品挑選若干件, 價值總和恰好為 j 的最小體積. 若不取第 i 件物品, 那麼 f[i][j] = f[i - 1][j] 若取第 i 件物品, 那麼 f[i][j] = f[i - 1][j - v[i]] + s[i] 取兩者的較小值. 初始條件: f[0][0] = 0, 其餘 f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ 表示不可能的狀態. 注意不是 $-\\infty$. 最終答案為 f[N][j] 中最大的 j 使得 f[N][j] \u0026lt;= S. 如果體積限制 $S$ 和單個物品價值 $v_i$ 都特別大($1e9$ 量級), 同時物品數量 $N$ 特別小（最高不超過 40） # 當 $N \\leq 20$ 時，可以直接暴力枚舉所有子集（時間複雜度 $O(2^N)$。 當 $N \\leq 40$ 時，由於 $2^{40}$ 在 $10^{12}$ 量級，直接暴力也會比較大，所以可以使用 折半搜索 ，將複雜度大致降低到 $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ ，可以在可接受的時間內完成。 ","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"最基礎的經典背包問題。","title":"01背包問題","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"如果有序解空間被分成左右兩部分，其中一個部分滿足條件，另一個部分不滿足條件。那麼能夠使用二分搜尋來在有序解空間中查找臨界點。\n二分搜尋的基本思路是不斷地將搜尋區間對半分。每次檢查中點元素，如果中點元素不滿足條件，就可以排除一半區間； 反之，則在另一半區間繼續搜尋。由於每次都拋棄一半的搜尋區間，搜尋時間複雜度可達到 $O(\\log n)$。\n例題 # 題目描述：\n給定一個升序排列的長度為 $n$ 的整數陣列，還有 $q$ 個查詢。每個查詢給出一個整數 $k$，我們需要找出在陣列中 $ k$ 的「起始位置」和「終止位置」（下標從 0 開始）。如果陣列中不存在這個數，則返回 -1 -1。\n輸入格式 # 第一行：兩個整數 $n$ 和 $q$，分別表示陣列長度和查詢次數。 第二行：$n$ 個整數，表示完整陣列，已按升序排列。 接下來 $q$ 行：每行包含一個整數 $k$，表示一個查詢元素。 數據範圍 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n輸出格式 # 對每個查詢，在一行裡輸出該元素在陣列中的起始和結束位置。如果陣列中不存在該元素，則輸出 -1 -1。\n樣例：\n輸入： 6 3 1 2 2 3 3 4 3 4 5 輸出： 3 4 5 5 -1 -1 解釋：\n元素 $3$ 出現的範圍為 $[3, 4]$； 元素 $4$ 只出現了一次，在位置 $5$； 元素 $5$ 在陣列裡不存在，因此返回 $-1$ $-1$。 解答 # 找「起始位置」： 即找第一個大於等於 $k$ 的位置。可以把陣列分成兩部分：\n左邊所有數都「小於」 $k$ 右邊所有數都「大於等於」 $k$ 答案為右邊的第一個位置 找「終止位置」： 即找最後一個小於等於 $k$ 的位置。可以把陣列分成兩部分：\n左邊所有數都「小於等於」 $k$ 右邊所有數都「大於」 $k$ 答案為左邊的最後一個位置 推薦模板 # 下面是一種優雅且不易犯錯的二分模板。\n定義兩個指標 $l, r$，有不變量：閉區間 $[0, l]$ 都屬於左半部分，閉區間 $[r, n - 1]$ 都屬於右半部分。$l$ 和 $r$ 都初始化為 $-1$ 和 $n$。\n演算法終止時，$l$ 和 $r$ 相鄰，分別指向左半部分的最後一個元素和右半部分的第一個元素。\n因為我們想要的解可能不存在，所以如果題目沒有說明一定存在解，我們需要判斷一下 l 或 r 是否越界，是否指向正確的值。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. 找 k 的起始位置 15 // 將陣列分成兩部分，左邊都 \u0026lt; k，右邊都 \u0026gt;= k。 16 // 答案為右半部分的最小下標。 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // 如果 r 越界或者 nums[r] != k，說明不存在 k 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. 找 k 的終止位置 33 // 將陣列分成兩部分，左邊都 \u0026lt;= k，右邊都 \u0026gt; k。 34 // 答案為左半部分的最大下標。 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} 優勢 # 這個寫法有嚴格定義的不變量。 它同時適用於找「起始位置」和「終止位置」兩種情況，不需要額外的處理和變化。 有一些寫法使用 l == r 作為終止條件。當 $l$ 和 $r$ 相差 $1$ 時，會計算出 $mid$ 和 $l$ 或 $r$ 相等。如果沒有正確處理，更新 $l$ 或 $r$ 為 $mid$，搜尋區間沒有縮小，會導致死循環。相反地，這裡的寫法在 $l$ 和 $r$ 相鄰時終止，保證 $mid$ 小於 $l$ 且大於 $r$，更新 $l$ 或 $r$ 時搜尋區間一定會縮小。 STL # 如果使用 C++ STL 提供的 lower_bound 和 upper_bound 函數，也能完成同樣的事情：\nlower_bound(first, last, val) 會返回「第一個大於等於 val 的位置」 upper_bound(first, last, val) 會返回「第一個大於 val 的位置」 舉個例子，假設 nums = {1,2,3,4,4,4,4,4,5,5,6}，我們想知道 4 出現的區間：\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 指向第一個值大於等於 $4$ 的位置。 it2 指向第一個值大於 $4$ 的位置。\n所以 it2 - it1 就是 $4$ 在陣列中出現的次數；it2 - nums.begin() - 1 就是 $4$ 的右邊界的位置。 補充 # 二分搜尋還可以擴展到浮點數範圍的搜尋（如求方程根）、以及三分搜尋求單峰函數的最值。\n練習 # LeetCode 33. Search in Rotated Sorted Array\n提示：第一步使用二分搜尋找到旋轉點，第二步再使用二分搜尋找到目標值。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"如何優雅地實現二分搜尋演算法。","title":"二分搜尋","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/zh-tw/series/","section":"Series","summary":"","title":"Series","type":"series"}]