[{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":" 二分搜尋 # 在一個有序序列中尋找特定元素，可以用二分搜尋來快速完成。與線性搜尋的時間複雜度 $O(n)$ 相比，二分搜尋只需要 $O(\\log n)$ 的時間，因此在資料規模較大的情況下非常高效。\n二分搜尋的核心思想 # 二分搜尋的基本思路是不斷地將搜尋區間對半分。每次比較中點元素與目標值的大小，如果中點元素不滿足條件，就可以排除一半區間；反之，則在另一半區間繼續搜尋。由於每次都拋棄一半的搜尋區間，搜尋時間複雜度可達到 $O(\\log n)$。\n對「可行解可以被分為一個有序區間（滿足條件）和另一個有序區間（不滿足條件）」的問題，二分搜尋是非常好用的。比如：\n在有序陣列中找是否存在某個元素 找到某個數出現的「第一位置」或「最後位置」 例題：找元素的起始位置和終止位置 # 題目描述：\n給定一個升序排列的長度為 $n$ 的整數陣列，還有 $q$ 個查詢。每個查詢給出一個整數 $k$，我們需要找出在陣列中 $k$ 的「起始位置」和「終止位置」（下標從 0 開始）。如果陣列中不存在這個數，則返回 $-1$ $-1$。\n輸入格式：\n第一行：兩個整數 $n$ 和 $q$，分別表示陣列長度和查詢次數。 第二行：$n$ 個整數（1 ~ 10000 範圍內），表示完整陣列，已按升序排列。 接下來 $q$ 行：每行包含一個整數 $k$，表示一個查詢元素。 輸出格式：\n對每個查詢，在一行裡輸出該元素在陣列中的起始和結束位置。如果陣列中不存在該元素，則輸出 $-1$ $-1$。\n範例：\n輸入： 6 3 1 2 2 3 3 4 3 4 5 輸出： 3 4 5 5 -1 -1 解釋：\n元素 3 出現的範圍為 [3, 4]； 元素 4 只出現了一次，在位置 5； 元素 5 在陣列裡不存在，因此返回 -1 -1。 二分搜尋的應用思路 # 在這個問題中，為了找到某個值的「左邊界」和「右邊界」，我們都可以依賴二分搜尋。關鍵是理解如何定義搜尋區間，以及如何根據比較結果來移動指標。\n找「左邊界」：\n即找第一個大於等於 $k$ 的位置。可以把陣列分成兩部分：\n左邊所有數都「小於」 $k$ 右邊所有數都「大於等於」 $k$ 找「右邊界」：\n即找最後一個小於等於 $k$ 的位置。可以把陣列分成兩部分：\n左邊所有數都「小於等於」 $k$ 右邊所有數都「大於」 $k$ 只要能正確維護這兩種區間，就能透過二分快速得出結果。\n推薦模板：避免死循環的二分寫法 # 下面是一種優雅且不易犯錯的二分模板。它透過讓 $l$ 和 $r$ 逐步靠攏，保證循環一定在兩者相鄰時結束：\n定義兩個指標 $l, r$，有不變量：閉區間 $[0, l]$ 都屬於左半部分，閉區間 $[r, n - 1]$ 都屬於右半部分。$l$ 和 $r$ 都初始化為 $-1$ 和 $n$。\n演算法終止時，$l$ 和 $r$ 相鄰，分別指向左半部分的最大值和右半部分的最小值。\n因為我們想要的解可能不存在，所以返回 $l$ 或者 $r$ 時，需要檢驗對應的值是否是我們想要的值，是否越界。 比如，$l$ 表示 $\\leq k$ 的最大值，而我們需要檢驗 l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. 找 k 的起始位置（左邊界） // 將陣列分成兩部分，左邊都 \u0026lt; k，右邊都 \u0026gt;= k。 // 左邊界就是右邊那部分的最小下標。 int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // 如果 r 超界或者 nums[r] != k，說明不存在 k if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // 記錄 k 的左邊界 // 2. 找 k 的終止位置（右邊界） // 將陣列分成兩部分，左邊都 \u0026lt;= k，右邊都 \u0026gt; k。 // 右邊界就是左邊那部分的最大下標。 l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // 因為我們已經檢驗過 k 存在，這裡不需要再次檢驗 int rightPos = l; // 右邊界 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } 為什麼這樣寫不容易錯？ # 這個寫法有嚴格定義的不變量。 它既能找到左邊界，又能找到右邊界，可以適用於所有場景。 有一些寫法使用 $l == r$ 作為終止條件。當 $l$ 和 $r$ 相差 1 時，會計算出 $mid$ 和 l 或 r 相等。如果沒有正確處理，更新 l 或 r 為 mid，搜尋區間沒有縮小，會導致死循環。相反地，這裡的寫法在 $l$ 和 $r$ 相鄰時終止，避免了這個問題。 STL 解法：lower_bound 和 upper_bound # 如果使用 C++ STL 提供的 lower_bound 和 upper_bound 函數，也能輕鬆完成同樣的事情：\nlower_bound(first, last, val) 會返回「第一個大於等於 val 的位置」 upper_bound(first, last, val) 會返回「第一個大於 val 的位置」 舉個例子，假設 nums = {1,2,3,4,4,4,4,4,5,5,6}，我們想知道 4 出現的區間：\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // 說明陣列裡不存在 4 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; } it1 指向第一個值大於等於 4 的位置。 it2 指向第一個值大於 4 的位置。\n所以 it2 - it1 就是 4 在陣列中出現的次數；it2 - nums.begin() - 1 就是 4 的右邊界。 這兩個函數在查找區間或統計出現次數的時候尤其方便。\n補充 # 二分搜尋還可以擴展到浮點數範圍的搜尋（如求方程根）、以及三分搜尋求單峰函數的最值。只要你理解了「**在有序區間中，每次都能排除一半 **」這一核心原理，你就會發現二分搜尋能幫你在很多場景下高效解決問題。\n課後練習 # LeetCode 33. Search in Rotated Sorted Array\n提示：第一步使用二分搜尋找到旋轉點，第二步再使用二分搜尋找到目標值。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"如何優雅地實現整數二分搜尋演算法","title":"二分搜尋","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/zh-tw/series/","section":"Series","summary":"","title":"Series","type":"series"}]