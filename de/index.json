[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP-Theorem","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 Dezember 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 Dezember 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 Dezember 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 Dezember 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 Dezember 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":" I. Das CAP-Theorem # 1.1 Was ist das CAP-Theorem? # Das CAP-Theorem wurde im Jahr 2000 von Eric Brewer aufgestellt und besagt im Kern:\nC (Consistency, Konsistenz): Alle Knoten im System sehen zu jedem Zeitpunkt die gleichen Daten. Genauer gesagt, wenn ein Client Daten liest, sollte das Ergebnis, unabhängig davon, von welcher Replik gelesen wird, mit den zuletzt übermittelten Daten übereinstimmen (normalerweise bezieht sich dies auf starke Konsistenz/lineare Konsistenz). A (Availability, Verfügbarkeit): Das System kann auch bei Teilausfällen weiterhin normale Dienste anbieten, und jede Anfrage erhält innerhalb einer angemessenen Zeit eine \u0026ldquo;gültige Antwort\u0026rdquo; (nicht unbedingt erfolgreich, sondern auch eine korrekte Fehlerantwort). P (Partition tolerance, Partitionstoleranz): Das System kann Netzwerkpartitionen tolerieren (Kommunikation zwischen Knoten ist nicht erreichbar), und selbst wenn das Netzwerk aufgeteilt ist, kann das System ein gewisses Maß an Verfügbarkeit oder Konsistenz bieten. In realen verteilten Umgebungen sind Netzwerkpartitionen unvermeidlich, daher wird P im Grunde als \u0026ldquo;Pflichtoption\u0026rdquo; angesehen. Wenn eine Netzwerkpartition auftritt, kann das System nicht gleichzeitig die * starke Konsistenz* und hohe Verfügbarkeit aller Knoten für Daten gewährleisten, sondern muss zwischen C und A abwägen, woraus die beiden Haupttypen CP und AP hervorgehen.\n1.2 Einschränkungen des CAP-Theorems # Es ist wichtig zu betonen, dass das CAP-Theorem selbst eine relativ hochrangige Theorie ist, die als konzeptionelle Richtlinie dient und nicht einfach als \u0026ldquo;entweder C oder A wählen\u0026rdquo; verstanden werden sollte. Es gibt einige häufige Missverständnisse:\nC ist nicht unbedingt starke Konsistenz Das C im CAP-Theorem bezieht sich oft auf die strengste Form der Konsistenz (d. h. lineare Konsistenz). In der Praxis gibt es jedoch viele feinere Modelle zur Auswahl, wie z. B. schwache Konsistenz, Read Committed, kausale Konsistenz usw. Verfügbarkeit ist nicht 0 oder 1 Es bedeutet nicht, dass die Verfügbarkeit vollständig geopfert wird, wenn CP gewählt wird, oder dass die Konsistenz nicht gewährleistet ist, wenn AP gewählt wird. Sowohl Verfügbarkeit als auch Konsistenz haben unterschiedliche Spielräume für Kompromisse und Downgrade-Strategien. Letztendliche Konsistenz verstößt nicht gegen CAP Es ist ein sehr häufiger Kompromiss, bei dem eine geringere Schreibkonsistenz gegen eine höhere Verfügbarkeit und einen höheren Durchsatz eingetauscht wird und die Daten im Hintergrund asynchron konvergieren. Daher sollte das CAP-Theorem in Kombination mit verschiedenen Konsistenzmodellen und Architekturmustern für hohe Verfügbarkeit in konkreten Szenarien angewendet werden, um einen echten praktischen Nutzen zu erzielen.\nII. Konsistenzmodelle für verteilte Systeme # Die Klassifizierung von Konsistenzmodellen ist sehr vielfältig, aber die gängigen Mainstream-Modelle lassen sich grob in starke Konsistenz und schwache Konsistenz (einschließlich letztendlicher Konsistenz, kausaler Konsistenz usw.) unterteilen. In diesem Artikel werden hauptsächlich starke Konsistenz und letztendliche Konsistenz vorgestellt und ihre gängigen Anwendungen im CP- oder AP-Modus erläutert.\n2.1 Starke Konsistenz # Starke Konsistenz (Strong Consistency), auch bekannt als lineare Konsistenz (Linearizability), bedeutet, dass, sobald ein Schreibvorgang erfolgreich abgeschlossen wurde, jeder nachfolgende Lesevorgang den aktualisierten Inhalt lesen kann. Das heißt, das System verhält sich nach außen so, als ob alle Operationen seriell ausgeführt würden.\nGängige Implementierungen: Sie beruhen auf synchroner Replikation und einem Quorum-Mechanismus (Mehrheitsprinzip), um sicherzustellen, dass es im System nur einen gültigen Leader gibt, und alle Operationen werden sequenziell in ein Protokoll geschrieben und auf die Mehrheit der Knoten repliziert. Vor- und Nachteile: Vorteile: Gewährleistet die strengste Datenkorrektheit, und die gelesenen Daten werden zu keinem Zeitpunkt \u0026ldquo;zurückgesetzt\u0026rdquo;. Nachteile: Bei Netzwerkstörungen, Partitionen oder Ausfällen des Leaders werden Schreibvorgänge oft blockiert, um die Konsistenz aufrechtzuerhalten, was zu einer geringeren Gesamtverfügbarkeit führt; Leistung und Durchsatz sind ebenfalls relativ geringer. 2.2 Letztendliche Konsistenz # Letztendliche Konsistenz (Eventual Consistency) ist eine typische Form der schwachen Konsistenz, die nur verlangt, dass, wenn das System keine neuen Aktualisierungen mehr vornimmt, die Daten aller Replikate im Laufe der Zeit allmählich in denselben Zustand konvergieren. Während dieser Zeit können Benutzer beim Lesen von Replikaten veraltete Werte sehen, die aber schließlich konsistent werden.\nGängige Implementierungen: Gossip-Protokoll, asynchrone Replikation mehrerer Replikate, CRDT (Conflict-free Replicated Data Type) usw. Vor- und Nachteile: Vorteile: Hohe Verfügbarkeit, hoher Durchsatz, geringe Latenz bei Schreibvorgängen, hohe Toleranz gegenüber Netzwerkpartitionen. Nachteile: Es ist notwendig, kurzzeitige Dateninkonsistenzen zu tolerieren, die Anwendungslogik ist komplexer und es kann erforderlich sein, Konflikte zu erkennen und zusammenzuführen. III. Gängige Konsistenzprotokolle und -algorithmen # Um die Konsistenz zwischen den Replikaten eines verteilten Systems zu gewährleisten, hat die Branche viele klassische Algorithmen und Protokolle entwickelt. Im Folgenden werden einige davon kurz vorgestellt:\n3.1 Paxos # Paxos ist ein Algorithmus für verteilte Konsistenz, der in den 1990er Jahren von Leslie Lamport entwickelt wurde und hauptsächlich zur Implementierung starker oder linearer Konsistenz verwendet wird.\nGrundprinzip: Durch die Aufteilung in Rollen (Proposer, Acceptor, Learner) werden mehrere Abstimmungsrunden durchgeführt, um zu entscheiden, ob eine Operation oder ein Wert von der Mehrheit der Knoten akzeptiert wird. Vor- und Nachteile: Vorteile: Kann auch bei Netzwerkpartitionen und Knotenausfällen eine Einigung erzielen und ist sehr sicher. Nachteile: Komplex in der Implementierung, schwierig zu debuggen und zu beheben, und die Leistung ist durch mehrere Abstimmungsrunden eingeschränkt. In der Industrie werden häufiger Varianten davon verwendet (Multi-Paxos usw.). 3.2 Raft # Raft wurde 2013 offiziell vorgestellt und zielt darauf ab, die Implementierung und das Verständnis zu vereinfachen, während gleichzeitig die gleiche Sicherheit wie Paxos gewährleistet wird. Es verwendet eine stabile * Leader-Rolle*, um die Protokollreplikation und die Fehlerbehebung zentralisiert durchzuführen:\nSchlüsselphasen: Leader-Wahl (Leader Election), Protokollreplikation (Log Replication), Sicherheit (Safety) usw. Gängige Anwendungen: Etcd, Consul, TiKV, LogCabin usw. basieren alle auf Raft, um eine stark konsistente Replikation zu implementieren. Vor- und Nachteile: Vorteile: Relativ einfach zu verstehen, weniger Code für die Implementierung; gute Leistung für kleine und mittlere Cluster. Nachteile: Abhängig vom Hauptknoten (Leader), Ausfälle oder Partitionen des Hauptknotens verursachen eine kurzzeitige Blockierung des Schreibens; bei großen Clustern oder standortübergreifenden Bereitstellungen werden Latenz und Verfügbarkeit beeinträchtigt. 3.3 Gossip-Protokoll # Das Gossip-Protokoll (Klatschprotokoll) ist kein traditionelles Konsensprotokoll, sondern wird hauptsächlich in dezentralen Szenarien verwendet, um Metadaten oder Statusinformationen durch zufällige Interaktion zwischen Knoten auszutauschen und so im gesamten Netzwerk zu verbreiten und zu konvergieren.\nMerkmale: Dezentralisiert, geringer Aufwand, periodischer und zufälliger Nachrichtenaustausch zwischen Knoten. Gängige Anwendungen: Cassandra, Riak, verteiltes Mitgliedschaftsmanagement (z. B. Serf) usw., die zur Implementierung von letztendlicher Konsistenz, Replikatsynchronisation usw. verwendet werden. Vor- und Nachteile: Vorteile: Gute Skalierbarkeit, einfach zu implementieren, geeignet für Szenarien, in denen die Konsistenzanforderungen nicht hoch und die Skalierbarkeitsanforderungen hoch sind. Nachteile: Schwache Konsistenzgarantie, erfordert fortgeschrittenere Methoden zur Konfliktbehandlung (z. B. CRDT, Versionsnummernzusammenführung usw.), um Konflikte letztendlich zu lösen. 3.4 2PC / 3PC # In verteilten Transaktionsszenarien sind die gängigen Commit-Protokolle 2PC (Two-phase Commit) und 3PC (Three-phase Commit):\n2PC: Der Koordinator benachrichtigt alle Teilnehmer über \u0026ldquo;Prepare\u0026rdquo;, und wenn alle erfolgreich sind, wird \u0026ldquo;Commit\u0026rdquo; gesendet, andernfalls \u0026ldquo;Abort\u0026rdquo;. 3PC: Fügt dem 2PC eine weitere Phase hinzu, um die Blockierung durch Single-Point-of-Failure zu reduzieren, ist aber komplexer zu implementieren und weist immer noch Probleme mit der Nichtverfügbarkeit in extremen Netzwerkpartitionen oder Ausfallszenarien auf. Vor- und Nachteile: Vorteile: Leicht zu verstehen, klare Transaktionssemantik, weit verbreitet in verteilten Datenbanken, Message Queues usw. Nachteile: Starke Abhängigkeit vom Koordinator, Blockierungsrisiko; Transaktionen können bei längeren Netzwerkpartitionen möglicherweise nicht fortgesetzt werden. IV. Die beiden wichtigsten CAP-Optionen: CP und AP # Nachdem wir P als \u0026ldquo;Pflichtattribut\u0026rdquo; festgelegt haben, muss ein verteiltes System, wenn es bei Netzwerkpartitionen weiterhin Dienste anbieten möchte, zwischen C und A wählen. Das gängige Systemdesign ist daher in zwei Lager unterteilt: CP und AP.\n4.1 CP-System # CP (Consistency + Partition tolerance): Wenn eine Netzwerkpartition auftritt, wählt das System die Priorität der Konsistenz und opfert bei Bedarf die Verfügbarkeit.\nTypische Implementierungen: Mehrheitskonsens (Paxos, Raft usw.), bei dem mehr als die Hälfte der Knoten aktiv sein und sich einigen müssen, um das Schreiben zu erlauben. Wenn kein Quorum erreicht werden kann oder der Hauptknoten ausfällt, blockiert oder verweigert das System Schreibvorgänge, um zu verhindern, dass ein Split-Brain zu Dateninkonsistenzen führt. Gängige Anwendungen: Zookeeper, Etcd, Consul, verteilte Lock-Dienste, verteiltes Metadatenmanagement usw. Kernprozesse für Finanztransaktionen, Bankbuchhaltungssysteme und andere Szenarien mit hohen Konsistenzanforderungen. Merkmale: Strenge Datensicherung: Lieber herunterfahren, als Dual-Master oder Datenchaos zu verursachen. Opfert ein gewisses Maß an Verfügbarkeit: Bei Netzwerkpartitionen oder Failover gibt es ein Zeitfenster, in dem der Dienst nicht verfügbar ist oder Schreibvorgänge abgelehnt werden. 4.2 AP-System # AP (Availability + Partition tolerance): Wenn eine Netzwerkpartition auftritt, wählt das System die Priorität der Verfügbarkeit und lockert gleichzeitig die Konsistenz.\nTypische Implementierungen: Letztendliche Konsistenz, Multi-Master-Replikation, Gossip-Protokoll, Dynamo-ähnliche Strategien für einstellbare Konsistenz usw. Gängige Anwendungen: NoSQL-Datenbanken (Cassandra, Riak, DynamoDB usw.), verteilte Caching-Systeme (Redis Cluster) usw. Soziale Netzwerke, Protokollerfassung, Empfehlungssysteme und andere Dienste, die eine hohe Verfügbarkeit und einen hohen Durchsatz erfordern und bei denen die Datenkonsistenz relativ gering ist. Merkmale: Auch bei Partitionen akzeptieren alle Knoten weiterhin Lese- und Schreibanfragen, um sicherzustellen, dass das System \u0026ldquo;so weit wie möglich verfügbar\u0026rdquo; ist. Daten können kurzzeitig inkonsistent sein, werden aber durch asynchrone Synchronisation, Konfliktzusammenführung usw. im Hintergrund schrittweise konvergiert. V. Wie wählt man zwischen CP und AP? # In realen, groß angelegten verteilten Systemen wird selten nur ein einziges Modell verwendet, sondern verschiedene Daten oder Geschäftsszenarien werden in Schichten verarbeitet, um ein optimales Gleichgewicht zwischen Konsistenz und Verfügbarkeit zu erreichen.\nKern-Daten wählen CP Wie z. B. Kontostände von Benutzern, Auftragszahlungen, Finanztransaktionsflüsse usw., die sehr hohe Konsistenzanforderungen haben. Toleriert kurzzeitige Schreibsperren aufgrund von Netzwerkstörungen, aber keine Fehler bei Salden oder Transaktionsbeträgen. Rand- oder Cache-Daten wählen AP Wie z. B. der Cache von Produktdetailseiten, Benutzerverhaltensprotokolle, Empfehlungskandidatenlisten usw., die geringere Konsistenzanforderungen haben. Legt mehr Wert auf hohe Parallelität und hohe Verfügbarkeit und kann eine gewisse Zeitverzögerung bei Aktualisierungen oder Dirty Reads tolerieren. Viele Internetunternehmen verwenden eine Hybridarchitektur: Kern-Transaktionsprozesse verwenden CP-Speicher (z. B. verteilte relationale Datenbanken oder verteilter Speicher mit starker Konsistenz); Peripheriegeschäfte oder \u0026ldquo;Read-Heavy\u0026rdquo;-Szenarien verwenden AP-Speicher oder Caching-Lösungen.\nVI. Wie erreichen CP und AP hohe Parallelität und letztendliche Konsistenz? # 6.1 Wie bewältigen CP-Systeme hohe Parallelität? # Obwohl Konsensprotokolle bei einer großen Anzahl von Knoten in einem einzelnen Cluster und einer großen Anzahl von Schreibanfragen mit hoher Latenz und geringem Durchsatz konfrontiert sind, können Parallelität und Skalierbarkeit dennoch durch die folgenden Mittel verbessert werden:\nBatch-Lese- und -Schreibvorgänge Mehrere Schreibvorgänge werden auf der Client- oder Zwischenschicht gebündelt und einmalig auf den Leader-Knoten geschrieben, wodurch Netzwerk-Roundtrips und Protokollrunden reduziert werden. Datenbank- und Tabellenpartitionierung \u0026amp; Multi-Cluster Daten werden logisch oder per Hash in mehrere Cluster (Sharding) aufgeteilt, wobei jedes Cluster intern weiterhin das CP-Protokoll ausführt; Anfragen werden über die Routing- oder Proxy-Schicht auf verschiedene Shards verteilt. Verbessert die gesamte Parallelität und begrenzt die Auswirkungen von Fehlern auf einen einzelnen Shard. Der Durchsatz eines einzelnen Shard-Clusters in einem CP-System ist oft 2 bis 10 Mal geringer als der eines AP-Systems.\n6.2 Wie stellen AP-Systeme die letztendliche Konsistenz sicher? # AP-Systeme können in der Regel einen sehr hohen Schreibdurchsatz und eine hohe Leseverfügbarkeit bieten, aber die Konsistenz wird gelockert, so dass im Hintergrund oder in der Geschäftslogikschicht eine Konsistenzkonvergenz gewährleistet werden muss:\nVersionsnummer (Vektor-Uhr) oder logischer Zeitstempel Weist jedem Aktualisierungsvorgang eine Versionsnummer zu (oder basierend auf Lamport Clock / Hybrid Clock), um Konflikte zusammenzuführen oder eine auf Zeitstempeln basierende Gewinnstrategie (Last Write Wins) zu verwenden. Gossip-Protokoll / Anti-Entropie-Mechanismus Knoten tauschen regelmäßig die neuesten Daten oder Metadaten aus und führen bei Konflikten eine Zusammenführung durch. Einstellbare Konsistenzstrategie Repräsentiert durch das Dynamo-Modell können Clients Parameter wie R und W konfigurieren (z. B. Schreiben in die Mehrheit, Replikatsbestätigung), um die Konsistenz und Verfügbarkeit flexibel anzupassen. Benutzerdefinierte Strategie zur Konfliktlösung Kombiniert die Geschäftssemantik zur Zusammenführung, z. B. Warenkörbe werden mit \u0026ldquo;Vereinigung\u0026rdquo; zusammengeführt, Zähler verwenden CRDT (G-Zähler, PN-Zähler usw.), um die Monotonie der Daten zu gewährleisten. VII. Implementierung starker Konsistenz über Shards in CP # Wie in Kapitel VII erwähnt, kann durch Datenbank- und Tabellenpartitionierung (Sharding) der Druck eines einzelnen CP-Clusters auf mehrere Subcluster \u0026ldquo;aufgeteilt\u0026rdquo; werden, um eine höhere Parallelität zu unterstützen. Wenn jedoch Transaktionen über Shards hinweg ausgeführt werden müssen (d. h. Aktualisierungen, die mehrere Datenbanken oder Tabellen betreffen), steht man immer noch vor der Herausforderung der Multi-Shard-Konsistenz. Es gibt in der Regel die folgenden Ansätze:\nVerteilte Transaktionen: 2PC / 3PC Wenn eine Anwendung atomare Aktualisierungen über mehrere Shards hinweg benötigt, werden in der Regel verteilte Transaktionsprotokolle (z. B. 2PC, 3PC) verwendet, um die Commits oder Rollbacks der einzelnen Shards zu koordinieren. Probleme und Gegenmaßnahmen: 2PC/3PC sind beide von einem Koordinator-Knoten abhängig, der zu einem Single-Point-of-Failure werden kann. In extremen Fällen von schweren Netzwerkpartitionen oder Ausfällen des Koordinators kann es zu Blockierungen kommen. Im Allgemeinen werden Master-Slave-Umschaltung, Heartbeat-Erkennung und Timeout-Mechanismen, idempotente Wiederholungen, MVCC usw. verwendet, um die Auswirkungen von Blockierungen und Dateninkonsistenzrisiken zu reduzieren. Zellbasierte Architektur Unterteilt die Dienste in mehrere autonome Einheiten, wobei die Daten in jeder Einheit in derselben Shard-Menge liegen, um sicherzustellen, dass die meisten Transaktionen nur in einer einzigen Einheit abgeschlossen werden und die Anzahl der Shard-übergreifenden Operationen reduziert wird. An den Einheitsgrenzen werden asynchrone oder letztendliche Konsistenzmechanismen für den Datenaustausch verwendet, um sowohl eine hohe Gesamtverfügbarkeit als auch Konsistenz zu gewährleisten. Globale verteilte Datenbank + globales Konsensprotokoll Beispielsweise implementiert Google Spanner eine stark konsistente Replikation über Paxos auf jedem Shard und verwendet die TrueTime-API, um globale Zeitstempel bereitzustellen, die die Konsistenz über Shards hinweg gewährleisten. Diese Lösung ist extrem komplex zu implementieren, kann aber im globalen Maßstab nahezu stark konsistente verteilte Transaktionsfunktionen bereitstellen. Zusammenfassung: Für Shard-übergreifende Transaktionen, die eine strenge starke Konsistenz erfordern, ist 2PC/3PC + Koordinator immer noch eine gängige Lösung, und die Wahrscheinlichkeit von Ausfällen wird durch eine möglichst hohe Verfügbarkeit des Koordinators reduziert. In der Praxis sollte man jedoch versuchen, Shard-übergreifende Schreibvorgänge zu minimieren oder die meisten Transaktionen durch eine zellbasierte Denkweise auf einen einzigen Shard-Bereich zu beschränken, um die Systemkomplexität zu reduzieren.\nVIII. Diskussion berühmter Fälle # Im Folgenden werden einige in der Branche häufig erwähnte verteilte Systeme kurz diskutiert, um zu sehen, welche Kompromisse sie bei CAP eingehen und wie sie implementiert werden:\nGoogle Spanner Ein typisches CP-System (das sogar die Illusion von \u0026ldquo;CA\u0026rdquo; erzeugen kann, die oft von Außenstehenden wahrgenommen wird, aber im Wesentlichen immer noch einen Teil der Verfügbarkeit opfern muss). Verwendet die von TrueTime bereitgestellten externen präzisen Zeitstempel + Paxos-Replikation innerhalb jedes Shards, um eine starke Konsistenz über Rechenzentren hinweg zu gewährleisten. Geeignet für globale Finanztransaktionen oder Szenarien mit hohen Konsistenzanforderungen, aber die Infrastrukturkosten sind extrem hoch. BigTable / HBase Oberflächlich betrachtet eher CP, wobei die Konsistenz der Metadaten zwischen RegionServer und Master durch verteilte Koordination gewährleistet wird. Tatsächlich kann der Lese- und Schreibpfad jedoch auch durch asynchrone Replikation mehrerer Replikate ein gewisses Maß an hoher Verfügbarkeit bieten, und die Lesekonsistenz kann je nach Anwendungsanforderungen angepasst werden. AWS DynamoDB Tendenziell AP, das frühe Design wurde von der Dynamo-Veröffentlichung inspiriert und die Konsistenzstufe kann durch Parameter wie R und W angepasst werden. Bietet standardmäßig eine extrem hohe Verfügbarkeit und letztendliche Konsistenz, kann aber auch \u0026ldquo;starkes Lesen\u0026rdquo; aktivieren (garantiert aber nur eine starke Konsistenz für eine einzelne Partition, nicht unbedingt über Partitionen hinweg). Cassandra Ebenfalls AP-orientiert, verwendet das zugrunde liegende Gossip-Protokoll, um den Topologiezustand der Knoten zu verwalten. Die Lese- und Schreibkonsistenz kann durch die Anzahl der Lese- und Schreibreplikate R / W konfiguriert werden, um einen reibungslosen Übergang von der letztendlichen Konsistenz zu einer stärkeren Konsistenz zu erreichen. Vergleich zeigt: In der Praxis gibt es kein absolutes \u0026ldquo;AP oder CP\u0026rdquo;, sondern eher eine Mischung aus verschiedenen Konsistenzstrategien; die meisten Systeme bieten ein gewisses Maß an einstellbarer Konsistenz, um sich an verschiedene Anwendungsszenarien anzupassen.\nIX. Zusammenfassung # Das CAP-Theorem ist keine Einheitslösung In realen verteilten Systemen kann man nicht einfach sagen: \u0026ldquo;Ich wähle C und verzichte auf A\u0026rdquo; oder \u0026ldquo;Ich wähle A und verzichte auf C\u0026rdquo;. In der Branche ist es üblicher, für verschiedene Datendimensionen und verschiedene Operationstypen flexibel den CP- oder AP-Modus zu wählen, und sogar innerhalb desselben Systems werden für verschiedene Tabellen/Funktionen unterschiedliche Fehlertoleranz- und Konsistenzstrategien verwendet. AP ist nicht absolut 100 % verfügbar Beispielsweise können Cassandra, DynamoDB usw. bei extremen Netzwerkpartitionen oder dem Ausfall einer großen Anzahl von Knoten ebenfalls Anfragen nicht erfüllen. AP-Systeme sind so konzipiert, dass sie \u0026ldquo;schreiben, solange ein Replikat schreibbar ist\u0026rdquo;, und opfern einen Teil der Konsistenzgarantie, um eine relativ höhere Verfügbarkeit und einen höheren Durchsatz zu erreichen. CP kann auch versuchen, eine hohe Verfügbarkeit zu erreichen Paxos/Raft können unter normalen Bedingungen auch eine Verfügbarkeit von 99,99 % oder sogar mehr bieten, erfordern aber mehr Netzwerk-, Hardware- und Engineering-Kosten, und bei extremen Netzwerkpartitionen kann es immer noch zu Blockierungen beim Schreiben und zum Verlust der Verfügbarkeit kommen, um die Konsistenz aufrechtzuerhalten. Hybridarchitektur ist der Mainstream Kern-Transaktionsszenarien bestehen auf starker Konsistenz (CP), während periphere Hilfsszenarien oder Caching-Kanäle schwache Konsistenz (AP) verwenden, wobei beide zusammenarbeiten. Es ist notwendig, die Geschäftstoleranz, die Netzwerkumgebung, die Kosteninvestitionen und die technischen Ressourcen des Teams zu berücksichtigen, um eine umfassende Entscheidung zu treffen. Das CAP-Theorem bietet einen hochrangigen Denkrahmen für das Design verteilter Systeme und hilft uns, angesichts der unvermeidlichen Realität von Netzwerkpartitionen rationale Entscheidungen zu treffen. In der Praxis ist es notwendig, sich auf umfassendere Konsistenzmodelle, Konsensprotokolle, Replikationsmechanismen mit mehreren Replikaten und die technische Praxis (Notfallwiederherstellung, Downgrade, Idempotenz, Konfliktzusammenführung usw.) zu stützen, um Konsistenz und Verfügbarkeit in Einklang zu bringen.\n","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735350760948-cap/","section":"Posts","summary":"Diskussion der Anwendung des CAP-Theorems in verteilten Systemen von der Theorie zur Praxis.","title":"Tiefe Einblicke in das CAP-Theorem: Entwicklung hochgradig paralleler und hochverfügbarer verteilter Systeme","type":"posts"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"Quicksort ist ein vergleichsbasierter, nicht stabiler Sortieralgorithmus, der das Divide-and-Conquer-Prinzip verwendet. Die durchschnittliche Zeitkomplexität beträgt $O(n\\log n)$, im schlechtesten Fall $O(n^2)$, und die Raumkomplexität ist $O(1)$. Im Folgenden werden die Implementierungsdetails und häufige Fehler anhand eines Beispiels zum Sortieren einer Integer-Sequenz in aufsteigender Reihenfolge erläutert.\nAufgabenbeschreibung # Gegeben ist eine Integer-Sequenz der Länge $n$. Sortiere diese mit Quicksort in aufsteigender Reihenfolge und gib das Ergebnis aus.\nEingabeformat # Die erste Zeile enthält die ganze Zahl $n$. Die zweite Zeile enthält $n$ ganze Zahlen, die alle im Bereich $[1,10^9]$ liegen. Ausgabeformat # Gib die sortierte Sequenz in einer Zeile aus. Datenbereich # $1 \\leq n \\leq 100000$\nEingabebeispiel # 5 3 1 2 4 5 Ausgabebeispiel # 1 2 3 4 5 Quicksort-Ansatz # Bei jeder Divide-and-Conquer-Operation in Quicksort wird eine beliebige Zahl als Pivot-Element pivot ausgewählt (im Folgenden wird die Zahl in der Mitte gewählt).\nEs werden zwei Zeiger verwendet, die sich aufeinander zu bewegen: Der linke Zeiger L sucht von links nach rechts die erste Zahl, die größer oder gleich pivot ist, und der rechte Zeiger R sucht von rechts nach links die erste Zahl, die kleiner oder gleich pivot ist. Dann werden diese beiden Zahlen vertauscht.\nDieser Vorgang wird so lange wiederholt, bis sich der linke und der rechte Zeiger überlappen oder der linke Zeiger um eine Position größer ist als der rechte Zeiger. Dies wird als eine Iteration bezeichnet.\nNach jeder Zeigerbewegung und jedem Tausch wird sichergestellt, dass die Struktur \u0026ldquo;linker Teil ≤ pivot, rechter Teil ≥ pivot\u0026rdquo; nicht beschädigt wird, d. h. es gilt die Invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIm folgenden Beispielcode sind left und right die Grenzen des aktuellen geschlossenen Intervalls, und pivot ist das Element in der Mitte des Intervalls.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Komplexität und Auswahl des pivot # Da Quicksort im schlechtesten Fall eine Komplexität von $O(n^2)$ hat, ist die Wahl des pivot entscheidend. Wenn immer das erste oder letzte Element gewählt wird, tritt bei fast sortierten Arrays mit hoher Wahrscheinlichkeit der schlechteste Fall ein.\nNeben der Wahl des Elements in der Mitte kann auch ein zufälliges Element als pivot gewählt werden, oder der Median aus dem linken, mittleren und rechten Element.\nHäufige Fehlerbeispiele # Der folgende Code enthält mehrere häufige Fehler.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Fehleranalyse:\npivot sollte eine Zahl im Array sein, nicht ein Index. Verwende \u0026lt; und \u0026gt; anstelle von \u0026lt;= und \u0026gt;=, da sonst der linke Zeiger möglicherweise mehr als eine Position über den rechten Zeiger hinausgeht, wodurch das Array nicht in zwei Teile geteilt werden kann. Wenn l \u0026gt;= r festgestellt wird, sollte die Schleife sofort verlassen werden, ohne weitere Tauschoperationen durchzuführen. Andernfalls kann nicht garantiert werden, dass die Elemente auf der linken Seite nicht größer als pivot und die Elemente auf der rechten Seite nicht kleiner als pivot sind. Nach jedem Tausch sollten l++ und r-- ausgeführt werden. pivot nimmt tatsächlich die Zahl in der Mitte links. Wenn das Array also mit $l - 1$ und $l$ geteilt wird, führt dies bei einem Array wie [1, 2] zu einer Endlosschleife, da das Array immer wieder in zwei Teile der Größe 0 und 2 aufgeteilt wird. Ähnlich verhält es sich, wenn das Array mit $r$ und $l$ geteilt wird. Wenn die Schleife jedoch beendet ist, ist $r$ immer kleiner als $right$, sodass das Array mit $r$ und $r+1$ geteilt werden kann. Der Leser kann den Algorithmus simulieren, um zu sehen, warum. Eine andere einfache Möglichkeit, Endlosschleifen zu vermeiden, ist die zufällige Auswahl von pivot oder die Sonderbehandlung von Arrays mit nur zwei Elementen. Außerdem ist die Verwendung von $l$, $l+1$ nicht möglich, da diese Aufteilung nicht der Definition entspricht. Wenn $r$ links von $l$ liegt, kann das Array mit $l$, $l+1$ nicht korrekt in zwei Teile aufgeteilt werden, wobei der linke Teil kleiner oder gleich pivot und der rechte Teil größer oder gleich pivot ist. In dieser Aufgabe wird davon ausgegangen, dass das Array nicht leer ist, sodass der Fall \u0026gt; nicht existiert. Es wird jedoch empfohlen, \u0026gt;= zu verwenden, da dies sicherer ist. Ergänzung # Quicksort kann auch zu \u0026ldquo;Quickselect\u0026rdquo; weiterentwickelt werden, um das $k$-kleinste Element in einem unsortierten Array in einer erwarteten Zeit von $O(n)$ zu finden. Die Idee ist ähnlich wie bei Quicksort, nur dass die Rekursion jedes Mal nur in einem Teilintervall fortgesetzt wird, wodurch die Zeitkomplexität reduziert wird.\n","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse der wichtigsten Punkte für die korrekte Implementierung des Quicksort-Algorithmus.","title":"Quicksort","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Problem # Es gibt $N$ Gegenstände. Das Volumen des $i$-ten Gegenstands ist $s_i$ und sein Wert ist $v_i$. Jeder Gegenstand kann nur einmal genommen werden. Finde unter der Voraussetzung, dass das maximale Gesamtvolumen $S$ nicht überschritten wird, den maximalen Gesamtwert $V$, der erzielt werden kann.\nEingabeformat # Die erste Zeile enthält zwei ganze Zahlen, $N$ und $S$, getrennt durch ein Leerzeichen, die die Anzahl der Gegenstände bzw. das maximale Gesamtvolumen darstellen. Die folgenden $N$ Zeilen enthalten jeweils zwei ganze Zahlen, $s_i$ und $v_i$, getrennt durch ein Leerzeichen, die das Volumen bzw. den Wert des $i$-ten Gegenstands darstellen.\nAusgabeformat # Gib eine ganze Zahl aus, die den maximalen Wert darstellt.\nDatenbereich # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Eingabebeispiel # 4 5 1 2 2 4 3 4 4 5 Ausgabebeispiel # 8 Lösung # Definiere den Zustand: f[i][j] repräsentiert den maximalen Wert, der mit den ersten $i$ Gegenständen bei einem Volumenlimit von $j$ erzielt werden kann. Wenn der $i$-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der $i$-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - s[i]] + v[i] Achte bei der Implementierung des Zustandsübergangs auf den Definitionsbereich. Wenn $j \u003c s_i$, dann betrachte den Fall der Entnahme des $i$-ten Gegenstands nicht. Denn wenn $j - s_i$ negativ ist, ist der Array-Index ungültig. Es kann auch so erklärt werden: Das Volumen des $i$-ten Gegenstands ist größer als das Volumenlimit, daher ist es unmöglich. Definiere die Anfangsbedingung: Für die ersten $0$ Gegenstände ergibt jedes Volumenlimit einen Wert von $0$, d.h. f[0][j] = 0, j $\\in [0, S]$. Zeitkomplexität: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimierung # Das Komprimieren des zweidimensionalen Arrays in ein eindimensionales Array kann erheblich Speicherplatz sparen und die Laufgeschwindigkeit bis zu einem gewissen Grad verbessern (der Nachteil ist, dass es die speziellen Anforderungen einiger Problemtypen nicht erfüllen kann). Beachte, dass im Zustandsübergang f[i][j] nur mit f[i - 1][j] und f[i - 1][j - s[i]] zusammenhängt. Mit anderen Worten, im zweidimensionalen Array f im Code, f[i][j] hängt nur mit den Elementen in der vorherigen Zeile zusammen, die sich links davon oder in derselben Spalte befinden. Daher kann das zweidimensionale Array in ein eindimensionales Array oder ein Rolling Array komprimiert werden. Beachte, dass in dem folgenden Code die zweite Schleife in umgekehrter Reihenfolge iteriert. Dies liegt daran, dass wir sicherstellen wollen, dass bei der Berechnung von f[i][j] f[i - 1][j - s[i]] noch nicht aktualisiert wurde. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Wenn die Anzahl der Schemata erforderlich ist # Es sollte nicht nur der maximale Gesamtwert ausgegeben werden, der erzielt werden kann, sondern auch \u0026ldquo;wie viele verschiedene Auswahlmethoden diesen maximalen Gesamtwert erreichen können\u0026rdquo;. Im Folgenden wird beschrieben, wie man die Anzahl der Schemata im 01-Rucksackproblem zählt.\n2D DP zum Zählen von Schemata # Das Folgende verwendet 2D DP als Beispiel zur Erläuterung.\nDefiniere den Zustand:\ndp[i][j] repräsentiert \u0026ldquo;den maximalen Wert, der erzielt werden kann, wenn man die ersten i Gegenstände mit einer Kapazität (Volumenlimit) von j betrachtet\u0026rdquo;. ways[i][j] repräsentiert \u0026ldquo;die Anzahl der Schemata, die dem maximalen Wert entsprechen, der erzielt wird, wenn man die ersten i Gegenstände mit einer Kapazität von j betrachtet\u0026rdquo;. Zustandsübergang:\nWenn der i-te Gegenstand nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Wenn der i-te Gegenstand ausgewählt wird (vorausgesetzt, dass $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Ob ausgewählt wird oder nicht, das endgültige dp[i][j] sollte das größere der beiden annehmen: Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ dann bedeutet dies, dass \u0026ldquo;die Auswahl des i-ten Gegenstands\u0026rdquo; einen größeren Wert hat: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ bedeutet dies, dass der maximale Wert, der durch die beiden Methoden erzielt wird, derselbe ist, dann sollte die Anzahl der Schemata addiert werden: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ dann bedeutet dies, dass \u0026ldquo;die Nichtauswahl des i-ten Gegenstands\u0026rdquo; einen größeren Wert hat, und die Anzahl der Schemata erbt die Anzahl der Schemata, wenn nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Anfangsbedingungen:\ndp[0][j] = 0 bedeutet, dass, wenn es 0 Gegenstände gibt, der maximale Wert, der für jede Kapazität erzielt wird, 0 ist. ways[0][0] = 1 bedeutet, dass der Fall \u0026ldquo;0 Gegenstände, Kapazität 0\u0026rdquo; ein machbares Schema ist (d.h. nichts auswählen), und die Anzahl der Schemata auf 1 gesetzt wird. Für j \u0026gt; 0, wenn es keine Gegenstände zur Auswahl gibt und die Kapazität größer als 0 ist, ist es unmöglich, einen positiven Wert zu erhalten, und die entsprechende Anzahl von Schemata ist 0, d.h. ways[0][j] = 0. Endgültige Antwort:\ndp[N][S] ist der maximale Wert. ways[N][S] ist die Anzahl der Schemata, um diesen maximalen Wert zu erreichen. Zeitkomplexität: $O(NS)$. Dieses Problem kann auch mit 1D DP optimiert werden. Wenn die Anforderung darin besteht, das Volumenlimit genau zu erreichen # Definiere den Zustand: f[i][j] repräsentiert den maximalen Wert, wenn die ersten i Gegenstände genau ein Volumen von $j$ haben. Wenn der i-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - s[i]] + v[i] Es ist zu beachten, dass es keinen Unterschied im Zustandsübergang zum ursprünglichen Problem gibt. Die Anfangsbedingungen sind jedoch unterschiedlich. Mit Ausnahme von f[0][0] = 0 ist der Rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ repräsentiert einen unmöglichen Zustand. Wenn das Volumenlimit $S$ sehr groß ist (1e9), während die Anzahl der Gegenstände $N$ und der maximale Gesamtwert $V$ relativ klein sind # Für solche Probleme gibt es eine Lösung mit einer Komplexität von $O(NV)$. Definiere den Zustand: f[i][j] repräsentiert das minimale Volumen, wenn man mehrere Gegenstände aus den ersten i Gegenständen auswählt und der Gesamtwert genau j ist. Wenn der i-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - v[i]] + s[i] Nimm den kleineren der beiden. Anfangsbedingungen: f[0][0] = 0, der Rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ repräsentiert einen unmöglichen Zustand. Beachte, dass es nicht $-\\infty$ ist. Die endgültige Antwort ist das größte j in f[N][j], so dass f[N][j] \u0026lt;= S. Wenn das Volumenlimit $S$ und der Wert eines einzelnen Gegenstands $v_i$ beide sehr groß sind (in der Größenordnung von 1e9), während die Anzahl der Gegenstände $N$ sehr klein ist (nicht mehr als 40) # Wenn $N \\leq 20$, können alle Teilmengen direkt durch Brute Force aufgezählt werden (Zeitkomplexität $O(2^N)$). Wenn $N \\leq 40$, da $2^{40}$ in der Größenordnung von $10^{12}$ liegt, wird auch die direkte Brute Force relativ groß sein, daher kann Meet-in-the-Middle-Suche verwendet werden, um die Komplexität auf ungefähr $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ zu reduzieren, was in einer akzeptablen Zeit abgeschlossen werden kann. ","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Das grundlegendste klassische Rucksackproblem.","title":"01 Rucksackproblem","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"Wenn ein sortierter Lösungsraum in zwei Teile geteilt wird, wobei ein Teil die Bedingung erfüllt und der andere Teil nicht, dann kann die binäre Suche verwendet werden, um den kritischen Punkt im sortierten Lösungsraum zu finden.\nDie Grundidee der binären Suche ist es, das Suchintervall kontinuierlich zu halbieren. Bei jeder Überprüfung wird das mittlere Element untersucht. Wenn das mittlere Element die Bedingung nicht erfüllt, kann die Hälfte des Intervalls ausgeschlossen werden; andernfalls wird die Suche in der anderen Hälfte des Intervalls fortgesetzt. Da bei jeder Suche die Hälfte des Suchintervalls verworfen wird, kann die Suchzeitkomplexität $O(\\log n)$ erreichen.\nBeispielaufgabe # Aufgabenbeschreibung: Gegeben ist ein aufsteigend sortiertes Array von ganzen Zahlen der Länge $n$ sowie $q$ Abfragen. Jede Abfrage gibt eine ganze Zahl $k$ an, und wir müssen die \u0026ldquo;Startposition\u0026rdquo; und \u0026ldquo;Endposition\u0026rdquo; von $k$ im Array finden (Indizes beginnen bei 0). Wenn die Zahl nicht im Array vorhanden ist, wird -1 -1 zurückgegeben.\nEingabeformat # Erste Zeile: Zwei ganze Zahlen $n$ und $q$, die die Länge des Arrays bzw. die Anzahl der Abfragen angeben. Zweite Zeile: $n$ ganze Zahlen, die das vollständige Array darstellen, das bereits aufsteigend sortiert ist. Die nächsten $q$ Zeilen: Jede Zeile enthält eine ganze Zahl $k$, die ein Abfrageelement darstellt. Datenbereich # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nAusgabeformat # Geben Sie für jede Abfrage die Start- und Endposition des Elements im Array in einer Zeile aus. Wenn das Element nicht im Array vorhanden ist, geben Sie -1 -1 aus.\nBeispiel:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element $3$ vorkommt, ist $[3, 4]$; Das Element $4$ kommt nur einmal an Position $5$ vor; Das Element $5$ ist nicht im Array vorhanden, daher wird $-1$ $-1$ zurückgegeben. Lösung # Suche nach der \u0026ldquo;Startposition\u0026rdquo;: Das heißt, die erste Position zu finden, die größer oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner\u0026rdquo; als $k$ Alle Zahlen rechts sind \u0026ldquo;größer oder gleich\u0026rdquo; $k$ Die Antwort ist die erste Position auf der rechten Seite Suche nach der \u0026ldquo;Endposition\u0026rdquo;: Das heißt, die letzte Position zu finden, die kleiner oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner oder gleich\u0026rdquo; $k$ Alle Zahlen rechts sind \u0026ldquo;größer\u0026rdquo; als $k$ Die Antwort ist die letzte Position auf der linken Seite Empfohlene Vorlage # Im Folgenden finden Sie eine elegante und fehlerfreie binäre Suchvorlage.\nDefinieren Sie zwei Zeiger $l, r$ mit der Invariante: Das geschlossene Intervall $[0, l]$ gehört zum linken Teil, und das geschlossene Intervall $[r, n - 1]$ gehört zum rechten Teil. $l$ und $r$ werden mit $-1$ bzw. $n$ initialisiert.\nWenn der Algorithmus beendet ist, sind $l$ und $r$ benachbart und zeigen auf das letzte Element des linken Teils bzw. das erste Element des rechten Teils.\nDa die gewünschte Lösung möglicherweise nicht existiert, müssen wir, wenn die Aufgabe nicht angibt, dass eine Lösung existiert, überprüfen, ob l oder r außerhalb des Bereichs liegen oder auf den richtigen Wert zeigen.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Suche nach der Startposition von k 15 // Teile das Array in zwei Teile, links alle \u0026lt; k, rechts alle \u0026gt;= k. 16 // Die Antwort ist der kleinste Index des rechten Teils. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Wenn r außerhalb des Bereichs liegt oder nums[r] != k, existiert k nicht 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Suche nach der Endposition von k 33 // Teile das Array in zwei Teile, links alle \u0026lt;= k, rechts alle \u0026gt; k. 34 // Die Antwort ist der größte Index des linken Teils. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Vorteile # Diese Schreibweise hat streng definierte Invarianten. Sie ist sowohl für die Suche nach der \u0026ldquo;Startposition\u0026rdquo; als auch nach der \u0026ldquo;Endposition\u0026rdquo; geeignet, ohne dass zusätzliche Verarbeitung oder Änderungen erforderlich sind. Einige Schreibweisen verwenden l == r als Abbruchbedingung. Wenn $l$ und $r$ um $1$ differieren, wird $mid$ gleich $l$ oder $r$ berechnet. Wenn dies nicht korrekt behandelt wird, wird die Aktualisierung von $l$ oder $r$ auf $mid$ dazu führen, dass sich das Suchintervall nicht verkleinert und eine Endlosschleife entsteht. Im Gegensatz dazu wird die Suche hier beendet, wenn $l$ und $r$ benachbart sind, wodurch sichergestellt wird, dass $mid$ kleiner als $l$ und größer als $r$ ist, und das Suchintervall bei der Aktualisierung von $l$ oder $r$ definitiv verkleinert wird. STL # Wenn Sie die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwenden, können Sie dasselbe erreichen:\nlower_bound(first, last, val) gibt die \u0026ldquo;erste Position größer oder gleich val\u0026rdquo; zurück upper_bound(first, last, val) gibt die \u0026ldquo;erste Position größer als val\u0026rdquo; zurück Nehmen wir zum Beispiel an, nums = {1,2,3,4,4,4,4,4,5,5,6}, und wir möchten den Bereich wissen, in dem 4 vorkommt:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 kommt 0 mal vor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;Die erste 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;Die letzte 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 kommt \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; mal vor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 zeigt auf die erste Position, deren Wert größer oder gleich $4$ ist. it2 zeigt auf die erste Position, deren Wert größer als $4$ ist. Daher ist it2 - it1 die Anzahl, wie oft $4$ im Array vorkommt; it2 - nums.begin() - 1 ist die Position der rechten Grenze von $4$. Ergänzung # Die binäre Suche kann auch auf die Suche im Bereich von Gleitkommazahlen (z. B. zum Finden von Wurzeln von Gleichungen) und auf die ternäre Suche zur Bestimmung des Maximums einer unimodalen Funktion erweitert werden.\nÜbung # LeetCode 33. Search in Rotated Sorted Array\nHinweis: Verwenden Sie im ersten Schritt die binäre Suche, um den Rotationspunkt zu finden, und verwenden Sie im zweiten Schritt die binäre Suche, um den Zielwert zu finden.\n","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Wie man den binären Suchalgorithmus elegant implementiert.","title":"Binäre Suche","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"}]