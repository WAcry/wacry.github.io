[{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-dividir-para-conquistar/","section":"Tags","summary":"","title":"Algoritmo Dividir Para Conquistar","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Diviser Pour Régner","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":" Schnellsortierung # Schnellsortierung ist ein vergleichsbasierter, instabiler Sortieralgorithmus, der das Teile-und-Herrsche-Prinzip verwendet. Die durchschnittliche Zeitkomplexität beträgt $O(n\\log n)$, im schlechtesten Fall $O(n^2)$, und die Raumkomplexität ist $O(1)$. Im Folgenden wird anhand des Beispiels einer aufsteigenden Sortierung einer Integer-Zahlenfolge die Implementierungsdetails und häufige Fehler vorgestellt.\nAufgabenbeschreibung # Gegeben sei eine Integer-Zahlenfolge der Länge $n$. Verwende Schnellsortierung, um diese aufsteigend zu sortieren, und gib das Ergebnis aus.\nEingabeformat # Die erste Zeile enthält die ganze Zahl $n$. Die zweite Zeile enthält $n$ ganze Zahlen, alle im Bereich $[1,10^9]$. Ausgabeformat # Gib die sortierte Zahlenfolge in einer Zeile aus. Datenbereich # $1 \\leq n \\leq 100000$\nEingabebeispiel # 5 3 1 2 4 5 Ausgabebeispiel # 1 2 3 4 5 Konzept der Schnellsortierung # Bei jeder Teilung der Schnellsortierung wird eine beliebige Zahl als Bezugszahl pivot ausgewählt (im Folgenden wird die Zahl an der mittleren Position gewählt).\nEs werden linke und rechte Zeiger verwendet, die sich aufeinander zu bewegen. Der linke Zeiger L sucht von links nach rechts nach der ersten Zahl, die größer oder gleich pivot ist, und der rechte Zeiger R sucht von rechts nach links nach der ersten Zahl, die kleiner oder gleich pivot ist. Dann werden diese beiden Zahlen ausgetauscht.\nDieser Prozess wird so lange wiederholt, bis der linke und der rechte Zeiger überlappen oder der linke Zeiger eine Position größer ist als der rechte Zeiger. Dies wird als eine Iteration bezeichnet.\nNach jeder Zeigerbewegung und jedem Austausch wird sichergestellt, dass die Struktur \u0026ldquo;linker Teil ≤ pivot, rechter Teil ≥ pivot\u0026rdquo; nicht beschädigt wird, d. h. es gilt die Invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIm folgenden Beispielcode sind left und right die Grenzen des aktuell verarbeiteten abgeschlossenen Intervalls, und pivot wird als das Element in der Mitte des Intervalls genommen.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Komplexität und pivot-Auswahl # Da die Schnellsortierung im schlechtesten Fall eine Komplexität von $O(n^2)$ aufweist, ist die Auswahl von pivot entscheidend. Wenn immer das erste oder letzte Element ausgewählt wird, ist es bei nahezu sortierten Arrays wahrscheinlich, dass der schlechteste Fall eintritt.\nZusätzlich zur Auswahl des Elements an der mittleren Position kann auch ein zufälliges Element als pivot ausgewählt oder der Median aus den drei Elementen links, in der Mitte und rechts als pivot genommen werden.\nHäufige Fehlerbeispiele # Der folgende Code enthält mehrere häufige Fehler.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Fehleranalyse:\npivot sollte eine Zahl im Array sein, nicht ein Index. Es sollten \u0026lt; und \u0026gt; statt \u0026lt;= und \u0026gt;= verwendet werden, da sonst der linke Zeiger möglicherweise mehr als eine Position am rechten Zeiger vorbeizieht, was die Aufteilung des Arrays in zwei Teile verhindert. Wenn l \u0026gt;= r gefunden wird, sollte die Schleife sofort verlassen werden, ohne weitere Austausche vorzunehmen. Andernfalls kann nicht garantiert werden, dass die Elemente auf der linken Seite nicht größer als pivot und die Elemente auf der rechten Seite nicht kleiner als pivot sind. Nach jedem Austausch sollten l++ und r-- ausgeführt werden. pivot nimmt tatsächlich die Zahl in der linken Mitte ein. Wenn das Array mit $l - 1$ und $l$ geteilt wird, wird bei einem Array [1, 2] leicht eine Endlosschleife entdeckt, da das Array immer wieder in zwei Teile der Größe 0 und 2 aufgeteilt wird. Umgekehrt muss $r$ am Ende der Schleife kleiner als $right$ sein, daher kann das Array mit $r$ und $r+1$ aufgeteilt werden. Die Leser können den Algorithmus simulieren, um zu sehen, warum das so ist. Eine andere einfache Möglichkeit, Endlosschleifen zu vermeiden, ist die zufällige Auswahl von pivot oder die Sonderbehandlung des Falls mit nur zwei Elementen. Analog dazu ist die Verwendung von $r$ und $l$ zur Unterscheidung des Arrays nicht möglich. Außerdem ist die Verwendung von $l$, $l+1$ nicht möglich, da diese Aufteilung nicht der Definition entspricht. Wenn sich $r$ links von $l$ befindet, kann das Array mit $l$, $l+1$ nicht korrekt in zwei Teile geteilt werden, wobei die linke Seite kleiner oder gleich pivot und die rechte Seite größer oder gleich pivot ist. In dieser Aufgabe wird davon ausgegangen, dass das Array nicht leer ist, sodass der Fall mit \u0026gt; nicht existiert. Es wird jedoch empfohlen, \u0026gt;= zu verwenden, da dies sicherer ist. Ergänzung # Schnellsortierung kann auch zu \u0026ldquo;Schnellauswahl\u0026rdquo; weiterentwickelt werden, um die $k$-kleinste Zahl in einem unsortierten Array in einer erwarteten Zeit von $O(n)$ zu finden. Das spezifische Konzept ist ähnlich wie bei der Schnellsortierung, wobei jedoch jedes Mal nur in einem Teilintervall weiter rekursiv aufgerufen wird, wodurch die Zeitkomplexität reduziert wird.\n","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse der Schlüsselpunkte für die korrekte Implementierung des Schnellsortierungsalgorithmus.","title":"Schnellsortierung","type":"posts"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A4%E0%A5%8D%E0%A4%B5%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"त्वरित सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Aufgabe # Es gibt $N$ Gegenstände. Der Platzbedarf des $i$-ten Gegenstands ist $s_i$, sein Wert ist $v_i$. Jeder Gegenstand kann nur einmal mitgenommen werden. Ermittle den maximalen Gesamtwert $V$, der erzielt werden kann, ohne die maximale Gesamtvolumenbeschränkung $S$ zu überschreiten.\nEingabeformat # Die erste Zeile enthält zwei durch Leerzeichen getrennte ganze Zahlen $N$ und $S$, die die Anzahl der Gegenstände und die maximale Gesamtvolumenbeschränkung darstellen. Die nächsten $N$ Zeilen enthalten jeweils zwei durch Leerzeichen getrennte ganze Zahlen $s_i$ und $v_i$, die den Platzbedarf und den Wert des $i$-ten Gegenstands darstellen.\nAusgabeformat # Gib eine ganze Zahl aus, die den maximalen Wert darstellt.\nDatenbereich # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Eingabebeispiel # 4 5 1 2 2 4 3 4 4 5 Ausgabebeispiel # 8 Lösungsansatz # Definiere den Zustand: f[i][j] stellt den maximalen Wert dar, der mit den ersten $i$ Gegenständen bei einer Volumenbeschränkung von $j$ erzielt werden kann. Wenn der $i$-te Gegenstand nicht genommen wird, dann ist f[i][j] = f[i - 1][j]. Wenn der $i$-te Gegenstand genommen wird, dann ist f[i][j] = f[i - 1][j - s[i]] + v[i]. Bei der Implementierung des Zustandsübergangs ist auf den Definitionsbereich zu achten. Wenn $j \u003c s_i$, dann kommt die Mitnahme des $i$-ten Gegenstands nicht in Frage, da der Array-Index ungültig wird, wenn $j-s_i$ negativ ist. Man kann es auch so erklären: Das Volumen des $i$-ten Gegenstands ist größer als die Volumenbeschränkung, daher ist es nicht möglich. Definiere die Anfangsbedingungen: Mit den ersten 0 Gegenständen ist der erzielte Wert bei jeder Volumenbeschränkung 0, d.h. f[0][j] = 0, j $\\in [0, S]$. Zeitkomplexität: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Optimierung mit 1D-DP # Durch Komprimierung des zweidimensionalen Arrays zu einem eindimensionalen Array kann der Speicherverbrauch erheblich reduziert und die Laufzeit leicht erhöht werden (Nachteil ist, dass spezielle Anforderungen bestimmter Aufgabentypen nicht erfüllt werden können) Es ist zu beachten, dass im Zustandsübergang f[i][j] nur mit f[i - 1][j] und f[i - 1][j - s[i]] zusammenhängt. Mit anderen Worten, im zweidimensionalen Array f im Code hängt f[i][j] nur mit Elementen in seiner vorherigen Zeile zusammen, die weiter links oder in derselben Spalte liegen, daher kann das zweidimensionale Array zu einem eindimensionalen Array oder einem Rolling Array komprimiert werden. Beachte, dass in dem folgenden Code die zweite Schleife in umgekehrter Reihenfolge iteriert, da wir sicherstellen müssen, dass beim Berechnen von f[i][j] f[i - 1][j - s[i]] noch nicht aktualisiert wurde. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Wenn die Anzahl der Lösungen erforderlich ist # Neben der Ausgabe des maximalen Gesamtwerts, der erzielt werden kann, muss auch ausgegeben werden, \u0026ldquo;wie viele verschiedene Auswahlmöglichkeiten es gibt, um diesen maximalen Gesamtwert zu erreichen\u0026rdquo;. Im Folgenden wird erläutert, wie die Anzahl der Lösungen im 01-Rucksackproblem statistisch erfasst wird.\nStatistische Erfassung von Lösungen mit 2D-DP # Im Folgenden wird dies anhand von 2D-DP erläutert.\nDefiniere den Zustand:\ndp[i][j] stellt den „maximalen Wert dar, der erzielt werden kann, wenn die ersten i Elemente verwendet werden und die Kapazität (Volumenbegrenzung) j beträgt“. ways[i][j] stellt die „Anzahl der Lösungen dar, die den maximalen Wert ergeben, wenn die ersten i Elemente verwendet werden und die Kapazität j beträgt“. Zustandsübergang:\nWenn das i-te Element nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Wenn das i-te Element ausgewählt wird (vorausgesetzt, dass $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Ob ausgewählt oder nicht, am Ende sollte dp[i][j] den größeren der beiden Werte annehmen: Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ bedeutet dies, dass der Wert des \u0026ldquo;Auswählens des i-ten Elements\u0026rdquo; größer ist: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ bedeutet dies, dass die beiden Methoden denselben Maximalwert ergeben, und die Anzahl der Lösungen sollte addiert werden: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ bedeutet dies, dass der Wert des \u0026ldquo;Nichtauswählens des i-ten Elements\u0026rdquo; größer ist, und die Anzahl der Lösungen erbt die Anzahl der Lösungen des Nichtauswählens: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Anfangsbedingungen:\ndp[0][j] = 0 bedeutet, dass der maximale Wert, der mit den ersten 0 Elementen bei jeder Kapazität erzielt werden kann, 0 ist. ways[0][0] = 1 bedeutet, dass die Situation \u0026ldquo;die ersten 0 Elemente, Kapazität 0\u0026rdquo; eine mögliche Lösung ist (d.h. nichts wird ausgewählt), und die Anzahl der Lösungen wird auf 1 gesetzt. Für j \u0026gt; 0 ist es nicht möglich, einen positiven Wert zu erzielen, wenn keine Elemente ausgewählt werden können und die Kapazität größer als 0 ist, daher ist die entsprechende Anzahl der Lösungen 0, d.h. ways[0][j] = 0. Endgültige Lösung:\ndp[N][S] ist der Maximalwert. ways[N][S] ist die Anzahl der Lösungen, die diesen Maximalwert erreichen. Zeitkomplexität: $O(NS)$. Dieses Problem kann auch mit einer 1D-DP optimiert werden. Wenn die Situation erforderlich ist, dass die Volumengrenze genau erreicht wird # Definiere den Zustand: f[i][j] stellt den maximalen Wert dar, bei dem die ersten i Elemente genau das Volumen $j$ haben. Wenn das i-te Element nicht mitgenommen wird, ist f[i][j] = f[i - 1][j]. Wenn das i-te Element mitgenommen wird, ist f[i][j] = f[i - 1][j - s[i]] + v[i]. Es ist zu beachten, dass es keinen Unterschied zum Zustandsübergang des ursprünglichen Problems gibt. Die Anfangsbedingungen sind jedoch unterschiedlich. Außer f[0][0] = 0 ist der Rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ stellt einen unmöglichen Zustand dar. Wenn die Volumenbeschränkung $S$ besonders groß (1e9) ist, gleichzeitig die Anzahl der Elemente $N$ und der maximale Gesamtwert $V$ relativ klein sind # Für ein solches Problem gibt es eine Lösung mit einer Komplexität von $O(NV)$. Definiere den Zustand: f[i][j] stellt das minimale Volumen dar, bei dem einige der ersten i Elemente ausgewählt werden und die Summe der Werte genau j ist. Wenn das i-te Element nicht mitgenommen wird, ist f[i][j] = f[i - 1][j]. Wenn das i-te Element mitgenommen wird, ist f[i][j] = f[i - 1][j - v[i]] + s[i]. Nimm den kleineren der beiden Werte. Anfangsbedingung: f[0][0] = 0, der Rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ stellt einen unmöglichen Zustand dar. Beachte, dass es nicht $-\\infty$ ist. Die endgültige Lösung ist das größte j in f[N][j] mit f[N][j] \u0026lt;= S. Wenn die Volumenbeschränkung $S$ und der Wert eines einzelnen Elements $v_i$ besonders groß sind (in der Größenordnung von 1e9), während die Anzahl der Elemente $N$ besonders klein ist (maximal 40) # Wenn $N \\leq 20$ ist, können alle Teilmengen direkt aufgezählt werden (Zeitkomplexität $O(2^N)$). Wenn $N \\leq 40$ ist, ist $2^{40}$ in der Größenordnung von $10^{12}$, so dass eine direkte Brute-Force-Methode auch relativ groß wäre, daher kann Split-Half-Search verwendet werden, um die Komplexität grob auf $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ zu reduzieren. Dies kann in einer akzeptablen Zeit abgeschlossen werden. ","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Das grundlegendste klassische Rucksackproblem.","title":"01-Rucksackproblem","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"Wenn ein sortierter Lösungsraum in zwei Teile unterteilt wird, von denen einer die Bedingung erfüllt und der andere nicht, kann die binäre Suche verwendet werden, um den kritischen Punkt im sortierten Lösungsraum zu finden.\nDie Grundidee der binären Suche besteht darin, das Suchintervall wiederholt zu halbieren. Bei jeder Überprüfung wird das Element in der Mitte geprüft. Wenn das mittlere Element die Bedingung nicht erfüllt, kann die Hälfte des Intervalls verworfen werden. Andernfalls wird die Suche in der anderen Hälfte des Intervalls fortgesetzt. Da bei jeder Operation die Hälfte des Suchintervalls verworfen wird, kann die Zeitkomplexität der Suche $O(\\log n)$ erreichen.\nBeispielaufgabe # Aufgabenbeschreibung: Gegeben ist ein aufsteigend sortiertes Array von Ganzzahlen der Länge $n$ und $q$ Abfragen. Jede Abfrage gibt eine Ganzzahl $k$ an. Wir müssen die „Startposition“ und die „Endposition“ von $k$ im Array finden (Indizes beginnen bei 0). Wenn die Zahl nicht im Array vorhanden ist, wird -1 -1 zurückgegeben.\nEingabeformat # Erste Zeile: Zwei Ganzzahlen $n$ und $q$, die die Länge des Arrays und die Anzahl der Abfragen darstellen. Zweite Zeile: $n$ Ganzzahlen, die das vollständige, aufsteigend sortierte Array darstellen. Nächste $q$ Zeilen: Jede Zeile enthält eine Ganzzahl $k$, die ein Such-Element darstellt. Datenbereich # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nAusgabeformat # Geben Sie für jede Abfrage die Start- und Endposition des Elements im Array in einer Zeile aus. Wenn das Element nicht im Array vorhanden ist, geben Sie -1 -1 aus.\nBeispiel:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element $3$ vorkommt, ist $[3, 4]$. Das Element $4$ kommt nur einmal an Position $5$ vor. Das Element $5$ ist nicht im Array vorhanden, daher wird $-1$ $-1$ zurückgegeben. Lösung # Finde die \u0026ldquo;Startposition\u0026rdquo;: Das ist die Position des ersten Elements, das größer oder gleich $k$ ist. Das Array kann in zwei Teile unterteilt werden:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner\u0026rdquo; als $k$. Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer oder gleich\u0026rdquo; $k$. Die Antwort ist die erste Position auf der rechten Seite. Finde die \u0026ldquo;Endposition\u0026rdquo;: Das ist die Position des letzten Elements, das kleiner oder gleich $k$ ist. Das Array kann in zwei Teile unterteilt werden:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner oder gleich\u0026rdquo; $k$. Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer\u0026rdquo; als $k$. Die Antwort ist die letzte Position auf der linken Seite. Empfohlene Vorlage # Im Folgenden ist eine elegante und fehleranfällige Binärsuchvorlage dargestellt. Sie stellt sicher, dass die Schleife endet, wenn $l$ und $r$ benachbart sind, indem sie $l$ und $r$ schrittweise zusammenführt:\nDefiniere zwei Zeiger $l, r$ mit der Invariante: das geschlossene Intervall $[0, l]$ gehört zum linken Teil, und das geschlossene Intervall $[r, n - 1]$ gehört zum rechten Teil. $l$ und $r$ werden mit $-1$ und $n$ initialisiert.\nWenn der Algorithmus endet, sind $l$ und $r$ benachbart und zeigen auf das letzte Element des linken Teils bzw. auf das erste Element des rechten Teils.\nDa die von uns gesuchte Lösung möglicherweise nicht existiert, müssen wir, wenn die Aufgabe nicht angibt, dass eine Lösung existiert, prüfen, ob l oder r außerhalb der Grenzen liegt und ob sie auf den richtigen Wert zeigen.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Finde die Startposition von k 15 // Teile das Array in zwei Teile, links \u0026lt; k, rechts \u0026gt;= k. 16 // Die Antwort ist der kleinste Index des rechten Teils. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Wenn r außerhalb der Grenzen liegt oder nums[r] != k, existiert k nicht 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Finde die Endposition von k 33 // Teile das Array in zwei Teile, links \u0026lt;= k, rechts \u0026gt; k. 34 // Die Antwort ist der größte Index des linken Teils. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Warum diese Schreibweise # Diese Schreibweise hat eine streng definierte Invariante. Sie gilt sowohl für das Finden der \u0026ldquo;Startposition\u0026rdquo; als auch der \u0026ldquo;Endposition\u0026rdquo;, ohne dass zusätzliche Verarbeitung oder Änderungen erforderlich sind. Einige Schreibweisen verwenden l == r als Abbruchbedingung. Wenn $l$ und $r$ um $1$ unterschiedlich sind, ergibt sich ein $mid$, der gleich $l$ oder $r$ ist. Wenn dies nicht korrekt behandelt wird und $l$ oder $r$ auf $mid$ aktualisiert wird, wird sich das Suchintervall nicht verkleinern, was zu einer Endlosschleife führen kann. Im Gegensatz dazu bricht diese Schreibweise ab, wenn $l$ und $r$ benachbart sind, wodurch sichergestellt ist, dass $mid$ kleiner als $l$ und größer als $r$ ist, und das Suchintervall bei der Aktualisierung von $l$ oder $r$ immer verkleinert wird. STL # Wenn die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwendet werden, kann das gleiche Ergebnis erzielt werden:\nlower_bound(first, last, val) gibt die \u0026ldquo;Position des ersten Elements, das größer oder gleich val ist\u0026rdquo; zurück. upper_bound(first, last, val) gibt die \u0026ldquo;Position des ersten Elements, das größer als val ist\u0026rdquo; zurück. Nehmen wir beispielsweise an, nums = {1,2,3,4,4,4,4,4,5,5,6} und wir möchten den Bereich ermitteln, in dem 4 vorkommt:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 zeigt auf die Position des ersten Wertes, der größer oder gleich $4$ ist. it2 zeigt auf die Position des ersten Wertes, der größer als $4$ ist. Daher ist it2 - it1 die Anzahl der Vorkommen von $4$ im Array; it2 - nums.begin() - 1 ist die rechte Grenze von $4$. Zusätzliche Informationen # Die binäre Suche kann auch auf die Suche nach Fließkommazahlenbereichen erweitert werden (z. B. das Finden von Gleichungswurzeln) sowie die ternäre Suche nach den Extremwerten unipolarer Funktionen. Solange Sie das Kernprinzip \u0026ldquo;in einem sortierten Intervall ist es möglich, jedes Mal die Hälfte zu eliminieren\u0026rdquo; verstehen, werden Sie feststellen, dass die binäre Suche Ihnen helfen kann, Probleme in vielen Szenarien effizient zu lösen.\nÜbung # LeetCode 33. Search in Rotated Sorted Array\nHinweis: Finden Sie im ersten Schritt mit binärer Suche den Drehpunkt, und finden Sie im zweiten Schritt mit binärer Suche den Zielwert.\n","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Wie man den binären Suchalgorithmus elegant implementiert.","title":"Binäre Suche","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]