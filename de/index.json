[{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":" Schnellsortierung # Die Schnellsortierung ist ein vergleichsbasierter, nicht stabiler Sortieralgorithmus, der das Teile-und-Herrsche-Prinzip verwendet. Die durchschnittliche Zeitkomplexität beträgt $O(n\\log n)$, im schlechtesten Fall $O(n^2)$, und die Raumkomplexität ist $O(1)$. Im Folgenden werden die Implementierungsdetails und häufige Fehler anhand eines Beispiels zum Sortieren einer Integer-Sequenz in aufsteigender Reihenfolge erläutert.\nAufgabenbeschreibung # Gegeben sei eine Integer-Sequenz der Länge $n$. Sortiere diese mit Hilfe der Schnellsortierung in aufsteigender Reihenfolge und gib das Ergebnis aus.\nEingabeformat # Die erste Zeile enthält die ganze Zahl $n$. Die zweite Zeile enthält $n$ ganze Zahlen, die alle im Bereich $[1,10^9]$ liegen. Ausgabeformat # Eine Zeile mit der sortierten Zahlenfolge. Datenbereich # $1 \\leq n \\leq 100000$\nEingabebeispiel # 5 3 1 2 4 5 Ausgabebeispiel # 1 2 3 4 5 Vorgehensweise bei der Schnellsortierung # Bei der Schnellsortierung wird bei jeder Teilung eine beliebige Zahl als Bezugszahl pivot gewählt (im Folgenden wird die Zahl in der Mitte gewählt).\nEs werden zwei Zeiger verwendet, die sich aufeinander zu bewegen: Der linke Zeiger L sucht von links nach rechts die erste Zahl, die größer oder gleich pivot ist, und der rechte Zeiger R sucht von rechts nach links die erste Zahl, die kleiner oder gleich pivot ist. Dann werden diese beiden Zahlen vertauscht.\nDieser Vorgang wird so lange wiederholt, bis sich der linke und der rechte Zeiger überlappen oder der linke Zeiger um eine Position größer ist als der rechte Zeiger. Dies wird als ein Durchlauf bezeichnet.\nNach jeder Zeigerbewegung und jedem Tausch wird sichergestellt, dass die Struktur \u0026ldquo;linker Teil ≤ pivot, rechter Teil ≥ pivot\u0026rdquo; nicht beschädigt wird, d. h. es gilt die Invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIm folgenden Beispielcode sind left und right die Grenzen des aktuellen geschlossenen Intervalls, und pivot ist das Element in der Mitte des Intervalls.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Komplexität und Wahl des pivot # Da die Schnellsortierung im schlechtesten Fall eine Komplexität von $O(n^2)$ aufweist, ist die Wahl des pivot entscheidend. Wenn immer das erste oder letzte Element gewählt wird, tritt bei fast sortierten Arrays mit hoher Wahrscheinlichkeit der schlechteste Fall ein.\nNeben der Wahl des Elements in der Mitte kann auch ein zufälliges Element als pivot gewählt werden, oder der Median aus dem linken, mittleren und rechten Element.\nHäufige Fehlerbeispiele # Der folgende Code enthält mehrere häufige Fehler.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Fehleranalyse:\npivot sollte eine Zahl im Array sein, nicht ein Index. Verwende \u0026lt; und \u0026gt; anstelle von \u0026lt;= und \u0026gt;=, da sonst der linke Zeiger mehr als eine Position über den rechten Zeiger hinausgehen kann, wodurch das Array nicht in zwei Teile geteilt werden kann. Wenn l \u0026gt;= r festgestellt wird, sollte die Schleife sofort verlassen werden, ohne weitere Tauschvorgänge durchzuführen. Andernfalls kann nicht garantiert werden, dass die Elemente auf der linken Seite nicht größer als pivot und die Elemente auf der rechten Seite nicht kleiner als pivot sind. Nach jedem Tausch sollten l++ und r-- ausgeführt werden. pivot nimmt tatsächlich die Zahl in der Mitte links. Wenn also das Array mit $l - 1$ und $l$ geteilt wird, führt dies bei einem Array wie [1, 2] zu einer Endlosschleife, da das Array immer wieder in zwei Teile der Größe 0 und 2 aufgeteilt wird. Ähnlich verhält es sich, wenn das Array mit $r$ und $l$ geteilt wird. Umgekehrt ist $r$ am Ende eines Durchlaufs immer kleiner als $right$, sodass das Array mit $r$ und $r+1$ geteilt werden kann. Der Leser kann den Algorithmus simulieren, um zu sehen, warum. Eine andere einfache Möglichkeit, Endlosschleifen zu vermeiden, ist die zufällige Wahl von pivot oder die Sonderbehandlung von Arrays mit nur zwei Elementen. Außerdem ist die Verwendung von $l$, $l+1$ nicht möglich, da diese Aufteilung nicht der Definition entspricht. Wenn $r$ links von $l$ liegt, kann das Array mit $l$, $l+1$ nicht korrekt in zwei Teile aufgeteilt werden, wobei der linke Teil kleiner oder gleich pivot und der rechte Teil größer oder gleich pivot ist. In dieser Aufgabe wird davon ausgegangen, dass das Array nicht leer ist, sodass es keine \u0026gt;-Situation gibt. Es wird jedoch empfohlen, \u0026gt;= zu verwenden, da dies sicherer ist. Ergänzung # Die Schnellsortierung kann auch zu einer \u0026ldquo;schnellen Auswahl\u0026rdquo; weiterentwickelt werden, um das $k$-kleinste Element in einem unsortierten Array in einer erwarteten Zeit von $O(n)$ zu finden. Die Idee ist ähnlich wie bei der Schnellsortierung, nur dass die Rekursion jedes Mal nur in einem Teilintervall fortgesetzt wird, wodurch die Zeitkomplexität reduziert wird.\n","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse der wichtigsten Punkte für die korrekte Implementierung des Schnellsortierungsalgorithmus.","title":"Schnellsortierung","type":"posts"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Aufgabe # Es gibt $N$ Gegenstände. Das Volumen des $i$-ten Gegenstands ist $s_i$, der Wert ist $v_i$. Jeder Gegenstand kann nur einmal genommen werden. Unter der Voraussetzung, dass das maximale Gesamtvolumen $S$ nicht überschritten wird, finde den maximalen Gesamtwert $V$, der erreicht werden kann.\nEingabeformat # Die erste Zeile enthält zwei ganze Zahlen, $N, S$, getrennt durch ein Leerzeichen, die die Anzahl der Gegenstände bzw. die maximale Gesamtvolumenbegrenzung angeben. Die nächsten $N$ Zeilen enthalten jeweils zwei ganze Zahlen $s_i, v_i$, getrennt durch ein Leerzeichen, die das Volumen bzw. den Wert des $i$-ten Gegenstands angeben.\nAusgabeformat # Geben Sie eine ganze Zahl aus, die den maximalen Wert darstellt.\nDatenbereich # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Eingabebeispiel # 4 5 1 2 2 4 3 4 4 5 Ausgabebeispiel # 8 Lösungsansatz # Definition des Zustands: f[i][j] stellt den maximalen Wert dar, der mit den ersten $i$ Gegenständen und einer Volumenbegrenzung von $j$ erzielt werden kann. Wenn der $i$-te Gegenstand nicht genommen wird, dann f[i][j] = f[i - 1][j] Wenn der $i$-te Gegenstand genommen wird, dann f[i][j] = f[i - 1][j - s[i]] + v[i] Bei der Implementierung des Zustandsübergangs ist auf den Definitionsbereich zu achten. Wenn $j \u003c s_i$, dann wird der Fall, dass der $i$-te Gegenstand genommen wird, nicht berücksichtigt. Denn wenn $j-s_i$ negativ ist, ist der Array-Index ungültig. Man kann es auch so erklären: Das Volumen des $i$-ten Gegenstands ist größer als die Volumenbegrenzung, daher ist es unmöglich. Definition der Anfangsbedingungen: Mit den ersten $0$ Gegenständen wird bei jeder Volumenbegrenzung ein Wert von $0$ erzielt, d.h. f[0][j] = 0, j $\\in [0, S]$. Zeitkomplexität: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D-DP-Optimierung # Durch das Komprimieren des zweidimensionalen Arrays in ein eindimensionales Array kann erheblich Speicherplatz gespart und die Laufgeschwindigkeit bis zu einem gewissen Grad erhöht werden (der Nachteil ist, dass bestimmte spezielle Anforderungen von Aufgabentypen nicht erfüllt werden können). Es ist zu beachten, dass im Zustandsübergang f[i][j] nur von f[i - 1][j] und f[i - 1][j - s[i]] abhängt. Mit anderen Worten, im zweidimensionalen Array f im Code hängt f[i][j] nur von den Elementen in der vorherigen Zeile ab, die sich weiter links oder in derselben Spalte befinden. Daher kann das zweidimensionale Array in ein eindimensionales Array oder ein Rolling Array komprimiert werden. Beachten Sie, dass in dem folgenden Code die zweite Schleife in umgekehrter Reihenfolge durchlaufen wird, da wir sicherstellen müssen, dass f[i - 1][j - s[i]] noch nicht aktualisiert wurde, wenn f[i][j] berechnet wird. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Wenn die Anzahl der Lösungen erforderlich ist # Es soll nicht nur der maximal erreichbare Gesamtwert ausgegeben werden, sondern auch \u0026ldquo;wie viele verschiedene Auswahlmethoden es gibt, um diesen maximalen Gesamtwert zu erreichen\u0026rdquo;. Im Folgenden wird erläutert, wie man die Anzahl der Lösungen im 01-Rucksackproblem zählt.\n2D-DP zum Zählen der Anzahl der Lösungen # Im Folgenden wird dies am Beispiel von 2D-DP erläutert.\nDefinition des Zustands:\ndp[i][j] stellt den \u0026ldquo;maximalen Wert dar, der mit den ersten i Gegenständen und einer Kapazität (Volumenbegrenzung) von j erzielt werden kann\u0026rdquo;. ways[i][j] stellt die \u0026ldquo;Anzahl der Lösungen dar, die dem maximalen Wert entsprechen, wenn die ersten i Gegenstände eine Kapazität von j haben\u0026rdquo;. Zustandsübergang:\nWenn der i-te Gegenstand nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Wenn der i-te Gegenstand ausgewählt wird (vorausgesetzt $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Ob ausgewählt oder nicht, dp[i][j] sollte schließlich den größeren der beiden Werte annehmen: Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ dann bedeutet dies, dass der Wert \u0026ldquo;Auswählen des i-ten Gegenstands\u0026rdquo; größer ist: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ dann bedeutet dies, dass die beiden Methoden den gleichen maximalen Wert erzielen, und die Anzahl der Lösungen sollte addiert werden: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ dann bedeutet dies, dass der Wert \u0026ldquo;Auswählen des i-ten Gegenstands nicht\u0026rdquo; größer ist, und die Anzahl der Lösungen erbt die Anzahl der Lösungen, wenn nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Anfangsbedingungen:\ndp[0][j] = 0 bedeutet, dass der maximale Wert, der mit den ersten 0 Gegenständen bei jeder Kapazität erzielt wird, 0 ist. ways[0][0] = 1 bedeutet, dass der Fall \u0026ldquo;erste 0 Gegenstände, Kapazität 0\u0026rdquo; eine mögliche Lösung ist (d. h. nichts auswählen), und die Anzahl der Lösungen wird auf 1 gesetzt. Für j \u0026gt; 0 ist es unmöglich, einen positiven Wert zu erzielen, wenn keine Gegenstände ausgewählt werden können und die Kapazität größer als 0 ist, und die entsprechende Anzahl der Lösungen ist 0, d. h. ways[0][j] = 0. Endgültige Antwort:\ndp[N][S] ist der maximale Wert. ways[N][S] ist die Anzahl der Lösungen, die diesen maximalen Wert erreichen. Zeitkomplexität: $O(NS)$. Diese Aufgabe kann auch mit 1D-DP optimiert werden. Wenn genau die Volumenbegrenzung erreicht werden muss # Definition des Zustands: f[i][j] stellt den maximalen Wert dar, wenn die ersten i Gegenstände genau das Volumen $j$ haben. Wenn der i-te Gegenstand nicht genommen wird, dann f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann f[i][j] = f[i - 1][j - s[i]] + v[i] Es ist zu beachten, dass es keinen Unterschied zum Zustandsübergang des ursprünglichen Problems gibt. Die Anfangsbedingungen sind jedoch unterschiedlich. Außer f[0][0] = 0 ist der Rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ stellt einen unmöglichen Zustand dar. Wenn die Volumenbegrenzung $S$ besonders groß ist (1e9), während die Anzahl der Gegenstände $N$ und der maximale Gesamtwert $V$ relativ klein sind # Für solche Aufgaben gibt es eine Lösung mit einer Komplexität von $O(NV)$. Definition des Zustands: f[i][j] stellt das minimale Volumen dar, wenn aus den ersten i Gegenständen einige ausgewählt werden und die Summe der Werte genau j beträgt. Wenn der i-te Gegenstand nicht genommen wird, dann f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann f[i][j] = f[i - 1][j - v[i]] + s[i] Nehmen Sie den kleineren der beiden Werte. Anfangsbedingungen: f[0][0] = 0, der Rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ stellt einen unmöglichen Zustand dar. Beachten Sie, dass es nicht $-\\infty$ ist. Die endgültige Antwort ist das größte j in f[N][j], so dass f[N][j] \u0026lt;= S. Wenn die Volumenbegrenzung $S$ und der Wert eines einzelnen Gegenstands $v_i$ beide besonders groß sind (Größenordnung 1e9), während die Anzahl der Gegenstände $N$ besonders klein ist (maximal nicht mehr als 40) # Wenn $N \\leq 20$ ist, können alle Teilmengen direkt mit Brute-Force aufgezählt werden (Zeitkomplexität $O(2^N)$). Wenn $N \\leq 40$ ist, ist $2^{40}$ in der Größenordnung von $10^{12}$, und die direkte Brute-Force-Methode ist ebenfalls relativ groß, daher kann Halbierungssuche verwendet werden, um die Komplexität grob auf $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ zu reduzieren, was in einer akzeptablen Zeit abgeschlossen werden kann. ","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Das grundlegendste klassische Rucksackproblem.","title":"01背包problem","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":" markdown # title: \u0026ldquo;Binäre Suche\u0026rdquo; date: 2024-12-24 draft: false description: \u0026ldquo;Wie man den binären Suchalgorithmus elegant implementiert.\u0026rdquo; summary: \u0026ldquo;Wie man den binären Suchalgorithmus elegant implementiert.\u0026rdquo; tags: [ \u0026ldquo;Algorithmus\u0026rdquo;, \u0026ldquo;Binäre Suche\u0026rdquo;, \u0026ldquo;Algorithmusvorlage\u0026rdquo; ] categories: [ \u0026ldquo;Algorithmen und Datenstrukturen\u0026rdquo; ] # Wenn ein geordneter Lösungsraum in zwei Teile geteilt wird, wobei ein Teil eine Bedingung erfüllt und der andere nicht, dann kann die binäre Suche verwendet werden, um den kritischen Punkt im geordneten Lösungsraum zu finden.\nDie Grundidee der binären Suche ist es, das Suchintervall wiederholt zu halbieren. Jedes Mal wird das mittlere Element überprüft. Wenn das mittlere Element die Bedingung nicht erfüllt, kann die Hälfte des Intervalls eliminiert werden; andernfalls wird die Suche in der anderen Hälfte fortgesetzt. Da jedes Mal die Hälfte des Suchintervalls verworfen wird, kann die Suchzeitkomplexität $O(\\log n)$ erreichen.\nBeispielproblem # Problembeschreibung: Gegeben ist ein aufsteigend sortiertes Integer-Array der Länge $n$ und $q$ Abfragen. Jede Abfrage gibt eine ganze Zahl $k$ an, und wir müssen die \u0026ldquo;Startposition\u0026rdquo; und \u0026ldquo;Endposition\u0026rdquo; von $k$ im Array finden (Indizes beginnen bei 0). Wenn die Zahl nicht im Array existiert, gib -1 -1 zurück.\nEingabeformat # Erste Zeile: zwei ganze Zahlen $n$ und $q$, die die Länge des Arrays bzw. die Anzahl der Abfragen darstellen. Zweite Zeile: $n$ ganze Zahlen, die das vollständige Array darstellen, bereits aufsteigend sortiert. Nächste $q$ Zeilen: jede Zeile enthält eine ganze Zahl $k$, die ein Abfrageelement darstellt. Datenbereich # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nAusgabeformat # Gib für jede Abfrage die Start- und Endpositionen des Elements im Array in einer einzigen Zeile aus. Wenn das Element nicht im Array existiert, gib -1 -1 aus.\nBeispiel:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element $3$ vorkommt, ist $[3, 4]$; Element $4$ kommt nur einmal vor, an Position $5$; Element $5$ existiert nicht im Array, also gib $-1$ $-1$ zurück. Lösung # Finden der \u0026ldquo;Startposition\u0026rdquo;: Das heißt, die erste Position zu finden, die größer oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner als\u0026rdquo; $k$ Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer oder gleich\u0026rdquo; $k$ Die Antwort ist die erste Position auf der rechten Seite Finden der \u0026ldquo;Endposition\u0026rdquo;: Das heißt, die letzte Position zu finden, die kleiner oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner oder gleich\u0026rdquo; $k$ Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer als\u0026rdquo; $k$ Die Antwort ist die letzte Position auf der linken Seite Empfohlene Vorlage # Nachfolgend ist eine elegante und weniger fehleranfällige Vorlage für die binäre Suche.\nDefiniere zwei Zeiger $l, r$, mit der Invariante: Das geschlossene Intervall $[0, l]$ gehört zum linken Teil, und das geschlossene Intervall $[r, n - 1]$ gehört zum rechten Teil. $l$ und $r$ werden mit $-1$ bzw. $n$ initialisiert.\nWenn der Algorithmus terminiert, sind $l$ und $r$ benachbart und zeigen auf das letzte Element des linken Teils bzw. das erste Element des rechten Teils.\nDa die Lösung, die wir suchen, möglicherweise nicht existiert, müssen wir, wenn das Problem nicht angibt, dass eine Lösung definitiv existiert, überprüfen, ob l oder r außerhalb der Grenzen liegt und ob es auf den richtigen Wert zeigt.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Finde die Startposition von k 15 // Teile das Array in zwei Teile, der linke Teil ist alles \u0026lt; k, und der rechte Teil ist alles \u0026gt;= k. 16 // Die Antwort ist der kleinste Index des rechten Teils. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Wenn r außerhalb der Grenzen liegt oder nums[r] != k, bedeutet das, dass k nicht existiert 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Finde die Endposition von k 33 // Teile das Array in zwei Teile, der linke Teil ist alles \u0026lt;= k, und der rechte Teil ist alles \u0026gt; k. 34 // Die Antwort ist der größte Index des linken Teils. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Vorteile # Dieser Ansatz hat streng definierte Invarianten. Er gilt sowohl für das Finden der \u0026ldquo;Startposition\u0026rdquo; als auch der \u0026ldquo;Endposition\u0026rdquo; ohne zusätzliche Behandlung oder Änderungen. Einige Ansätze verwenden l == r als Abbruchbedingung. Wenn $l$ und $r$ sich um $1$ unterscheiden, wird $mid$ so berechnet, dass es gleich $l$ oder $r$ ist. Wenn dies nicht korrekt behandelt wird, wird das Aktualisieren von $l$ oder $r$ auf $mid$ das Suchintervall nicht verkleinern, was zu einer Endlosschleife führt. Im Gegensatz dazu terminiert dieser Ansatz, wenn $l$ und $r$ benachbart sind, wodurch sichergestellt wird, dass $mid$ kleiner als $l$ und größer als $r$ ist, und das Aktualisieren von $l$ oder $r$ das Suchintervall immer verkleinert. STL # Wenn Sie die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwenden, können Sie dasselbe erreichen:\nlower_bound(first, last, val) gibt \u0026ldquo;die erste Position zurück, die größer oder gleich val ist\u0026rdquo; upper_bound(first, last, val) gibt \u0026ldquo;die erste Position zurück, die größer als val ist\u0026rdquo; Nehmen wir zum Beispiel an, nums = {1,2,3,4,4,4,4,4,5,5,6}, und wir wollen den Bereich wissen, in dem 4 vorkommt:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 kommt 0 mal vor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;erste 4 ist bei \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;letzte 4 ist bei \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 kommt \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; mal vor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 zeigt auf die erste Position, an der der Wert größer oder gleich $4$ ist. it2 zeigt auf die erste Position, an der der Wert größer als $4$ ist. Daher ist it2 - it1 die Anzahl, wie oft $4$ im Array vorkommt; it2 - nums.begin() - 1 ist die Position der rechten Grenze von $4$. Zusätzliche Hinweise # Die binäre Suche kann auch auf die Suche in Gleitkomma-Bereichen erweitert werden (z. B. das Finden der Wurzeln einer Gleichung) und die ternäre Suche zum Finden der Extrema unimodaler Funktionen.\nÜbung # LeetCode 33. Suche in einem rotierten sortierten Array\nHinweis: Verwenden Sie zuerst die binäre Suche, um den Rotationspunkt zu finden, und verwenden Sie dann die binäre Suche, um den Zielwert zu finden.\n","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"","type":"posts"}]