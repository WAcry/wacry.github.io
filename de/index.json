[{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":" Binäre Suche # In einer sortierten Sequenz kann man mit der binären Suche schnell ein bestimmtes Element finden. Im Vergleich zur linearen Suche mit einer Zeitkomplexität von $O(n)$ benötigt die binäre Suche nur $O(\\log n)$ Zeit, was sie bei großen Datenmengen sehr effizient macht.\nDas Kernkonzept der binären Suche # Die Grundidee der binären Suche besteht darin, den Suchbereich kontinuierlich zu halbieren. Bei jedem Vergleich wird das Element in der Mitte mit dem Zielwert verglichen. Wenn das Element in der Mitte die Bedingung nicht erfüllt, kann die Hälfte des Bereichs ausgeschlossen werden; andernfalls wird die Suche in der anderen Hälfte fortgesetzt. Da bei jedem Schritt die Hälfte des Suchbereichs verworfen wird, kann eine Zeitkomplexität von $O(\\log n)$ erreicht werden.\nDie binäre Suche ist sehr nützlich für Probleme, bei denen \u0026quot; die möglichen Lösungen in einen sortierten Bereich (der Bedingung erfüllt) und einen anderen sortierten Bereich (der Bedingung nicht erfüllt) unterteilt werden können \u0026ldquo;. Zum Beispiel:\nFinden, ob ein bestimmtes Element in einem sortierten Array existiert Finden der \u0026ldquo;ersten Position\u0026rdquo; oder \u0026ldquo;letzten Position\u0026rdquo;, an der eine Zahl auftritt Beispielaufgabe: Finden der Start- und Endpositionen von Elementen # Aufgabenbeschreibung: Gegeben sei ein aufsteigend sortiertes Array von ganzen Zahlen der Länge $n$, sowie $q$ Abfragen. Jede Abfrage gibt eine ganze Zahl $k$ an, und wir müssen die \u0026ldquo;Startposition\u0026rdquo; und die \u0026ldquo;Endposition\u0026rdquo; von $k$ im Array finden (Indizes beginnen bei 0). Wenn die Zahl im Array nicht existiert, wird $-1$ $-1$ zurückgegeben.\nEingabeformat:\nErste Zeile: Zwei ganze Zahlen $n$ und $q$, die die Länge des Arrays und die Anzahl der Abfragen angeben. Zweite Zeile: $n$ ganze Zahlen (im Bereich von 1 ~ 10000), die das vollständige Array darstellen, das bereits aufsteigend sortiert ist. Nächste $q$ Zeilen: Jede Zeile enthält eine ganze Zahl $k$, die ein abzufragendes Element darstellt. Ausgabeformat: Für jede Abfrage soll die Start- und Endposition des Elements im Array in einer Zeile ausgegeben werden. Wenn das Element im Array nicht vorhanden ist, soll $-1$ $-1$ ausgegeben werden.\nBeispiele:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element 3 vorkommt, ist [3, 4]; Das Element 4 kommt nur einmal an Position 5 vor; Das Element 5 ist im Array nicht vorhanden, daher wird -1 -1 zurückgegeben. Die Anwendungsstrategie der binären Suche # In diesem Problem können wir uns bei der Suche nach der \u0026ldquo;linken Grenze\u0026rdquo; und der \u0026ldquo;rechten Grenze\u0026rdquo; eines bestimmten Wertes auf die binäre Suche verlassen. Der Schlüssel ist zu verstehen, wie man den Suchbereich definiert und wie man die Zeiger entsprechend dem Vergleichsergebnis verschiebt.\nSuche nach der \u0026ldquo;linken Grenze\u0026rdquo;: Das heißt, die erste Position zu finden, die größer oder gleich $k$ ist. Wir können das Array in zwei Teile aufteilen:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner\u0026rdquo; als $k$ Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer oder gleich\u0026rdquo; $k$ Suche nach der \u0026ldquo;rechten Grenze\u0026rdquo;: Das heißt, die letzte Position zu finden, die kleiner oder gleich $k$ ist. Wir können das Array in zwei Teile aufteilen:\nAlle Zahlen auf der linken Seite sind \u0026ldquo;kleiner oder gleich\u0026rdquo; $k$ Alle Zahlen auf der rechten Seite sind \u0026ldquo;größer\u0026rdquo; als $k$ Solange diese beiden Bereiche korrekt verwaltet werden, können wir mit der binären Suche schnell zu einem Ergebnis kommen.\nEmpfohlene Vorlage: Vermeiden von Endlosschleifen bei der binären Suche # Im Folgenden wird eine elegante und fehlerfreie Vorlage für die binäre Suche vorgestellt. Sie stellt sicher, dass die Schleife immer dann endet, wenn die Zeiger $l$ und $r$ benachbart sind, indem sie diese schrittweise einander annähern:\nDefinieren Sie zwei Zeiger $l, r$, die die Invariante erfüllen: Das geschlossene Intervall $[0, l]$ gehört zum linken Teil und das geschlossene Intervall $[r, n - 1]$ gehört zum rechten Teil. $l$ und $r$ werden mit $-1$ bzw. $n$ initialisiert.\nWenn der Algorithmus beendet ist, sind $l$ und $r$ benachbart und zeigen auf den größten Wert des linken Teils bzw. den kleinsten Wert des rechten Teils.\nDa die gewünschte Lösung möglicherweise nicht existiert, muss bei der Rückgabe von $l$ oder $r$ geprüft werden, ob der entsprechende Wert der gewünschte Wert ist und ob er außerhalb des Bereichs liegt. Zum Beispiel steht $l$ für den größten Wert $\\leq k$, und wir müssen l != -1 \u0026amp;\u0026amp; nums[l] == k prüfen.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Finde die Startposition von k (linke Grenze) // Teile das Array in zwei Teile auf, links alle \u0026lt; k, rechts alle \u0026gt;= k. // Die linke Grenze ist der kleinste Index des rechten Teils. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Wenn r außerhalb des Bereichs liegt oder nums[r] != k, dann existiert k nicht if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Speichere die linke Grenze von k // 2. Finde die Endposition von k (rechte Grenze) // Teile das Array in zwei Teile auf, links alle \u0026lt;= k, rechts alle \u0026gt; k. // Die rechte Grenze ist der größte Index des linken Teils. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Da wir bereits überprüft haben, dass k existiert, muss hier nicht erneut geprüft werden int rightPos = l; // Rechte Grenze cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Warum ist es weniger fehleranfällig, so zu schreiben? # Diese Schreibweise hat eine streng definierte Invariante. Sie kann sowohl die linke als auch die rechte Grenze finden und ist somit in allen Szenarien anwendbar. Einige Schreibweisen verwenden $l == r$ als Abbruchbedingung. Wenn $l$ und $r$ sich um 1 unterscheiden, berechnet man $mid$ mit l oder r gleich. Wenn die Aktualisierung von l oder r nicht korrekt behandelt wird, wird der Suchbereich nicht verkleinert und es kommt zu einer Endlosschleife. Im Gegensatz dazu endet die hier gezeigte Schreibweise, wenn $l$ und $r$ benachbart sind, wodurch dieses Problem vermieden wird. STL-Lösung: lower_bound und upper_bound # Wenn Sie die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwenden, können Sie die gleichen Dinge problemlos erledigen:\nlower_bound(first, last, val) gibt die \u0026ldquo;erste Position größer oder gleich val\u0026rdquo; zurück upper_bound(first, last, val) gibt die \u0026ldquo;erste Position größer als val\u0026rdquo; zurück Nehmen wir zum Beispiel an, dass nums = {1,2,3,4,4,4,4,4,5,5,6} und wir wollen das Intervall finden, in dem 4 vorkommt:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Zeigt an, dass 4 nicht im Array existiert cout \u0026lt;\u0026lt; \u0026#34;4 kommt 0 mal vor\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Erste 4 befindet sich an \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Letzte 4 befindet sich an \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 kommt \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; mal vor\u0026#34; \u0026lt;\u0026lt; endl; } it1 zeigt auf die erste Position, deren Wert größer oder gleich 4 ist. it2 zeigt auf die erste Position, deren Wert größer als 4 ist. Daher ist it2 - it1 die Häufigkeit, mit der 4 im Array vorkommt; it2 - nums.begin() - 1 ist die rechte Grenze von 4. Diese beiden Funktionen sind besonders nützlich, wenn man Bereiche sucht oder die Häufigkeit des Auftretens zählt.\nErgänzung # Die binäre Suche kann auch auf die Suche nach Floating-Point-Bereichen erweitert werden (z. B. zur Suche nach den Wurzeln von Gleichungen) sowie auf die ternäre Suche zur Suche nach dem Maximalwert einer unimodalen Funktion. Solange Sie das Kernprinzip \u0026quot; bei jedem Schritt kann in einem sortierten Bereich die Hälfte ausgeschlossen werden\u0026rdquo; verstehen, werden Sie feststellen, dass die binäre Suche Ihnen helfen kann, Probleme in vielen Szenarien effizient zu lösen.\nÜbungsaufgaben # LeetCode 33. Search in Rotated Sorted Array\nHinweis: Verwenden Sie im ersten Schritt die binäre Suche, um den Drehpunkt zu finden, und verwenden Sie im zweiten Schritt erneut die binäre Suche, um den Zielwert zu finden.\n","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"Binäre Suche","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"}]