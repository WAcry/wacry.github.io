[{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmos De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer-algorithm/","section":"Tags","summary":"","title":"Divide and Conquer Algorithm","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":" Quicksort # Quicksort ist ein vergleichsbasierter, nicht stabiler Sortieralgorithmus, der auf dem Divide-and-Conquer-Prinzip basiert. Die durchschnittliche Zeitkomplexität beträgt $O(n\\log n)$, im schlechtesten Fall $O(n^2)$, und die Raumkomplexität ist $O(1)$. Im Folgenden wird die Implementierung anhand eines Beispiels zum Sortieren einer Integer-Sequenz in aufsteigender Reihenfolge erläutert, einschließlich Details und häufiger Fehler.\nAufgabenbeschreibung # Gegeben ist eine Integer-Sequenz der Länge $n$. Sortiere diese mit Quicksort in aufsteigender Reihenfolge und gib das Ergebnis aus.\nEingabeformat # Die erste Zeile enthält die ganze Zahl $n$. Die zweite Zeile enthält $n$ ganze Zahlen im Bereich $[1,10^9]$. Ausgabeformat # Eine Zeile mit der sortierten Sequenz. Datenbereich # $1 \\leq n \\leq 100000$\nEingabebeispiel # 5 3 1 2 4 5 Ausgabebeispiel # 1 2 3 4 5 Quicksort-Ansatz # Bei jeder Divide-and-Conquer-Operation in Quicksort wird eine beliebige Zahl als Pivot-Element pivot ausgewählt (im Folgenden wird die Zahl in der Mitte gewählt).\nZwei Zeiger, ein linker Zeiger L und ein rechter Zeiger R, bewegen sich aufeinander zu. Der linke Zeiger L sucht von links nach rechts die erste Zahl, die größer oder gleich pivot ist, und der rechte Zeiger R sucht von rechts nach links die erste Zahl, die kleiner oder gleich pivot ist. Dann werden diese beiden Zahlen vertauscht.\nDieser Vorgang wird so lange wiederholt, bis sich der linke und der rechte Zeiger überlappen oder der linke Zeiger um eine Position größer ist als der rechte Zeiger. Dies wird als eine Iteration bezeichnet.\nNach jeder Zeigerbewegung und jedem Tausch wird sichergestellt, dass die Struktur \u0026ldquo;linker Teil ≤ pivot, rechter Teil ≥ pivot\u0026rdquo; nicht verletzt wird, d. h. es gibt die Invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIm folgenden Beispielcode sind left und right die Grenzen des aktuellen geschlossenen Intervalls, und pivot ist das Element in der Mitte des Intervalls.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Komplexität und Auswahl des pivot # Da Quicksort im schlechtesten Fall eine Komplexität von $O(n^2)$ hat, ist die Wahl des pivot entscheidend. Wenn immer das erste oder letzte Element gewählt wird, tritt bei fast sortierten Arrays mit hoher Wahrscheinlichkeit der schlechteste Fall ein.\nNeben der Wahl des Elements in der Mitte kann auch ein zufälliges Element als pivot gewählt werden, oder der Median aus dem linken, mittleren und rechten Element.\nHäufige Fehlerbeispiele # Der folgende Code enthält mehrere häufige Fehler.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Fehleranalyse:\npivot sollte eine Zahl im Array sein, nicht ein Index. Verwende \u0026lt; und \u0026gt; anstelle von \u0026lt;= und \u0026gt;=, da sonst der linke Zeiger möglicherweise mehr als eine Position über den rechten Zeiger hinausgeht, wodurch das Array nicht in zwei Teile geteilt werden kann. Wenn l \u0026gt;= r gefunden wird, sollte die Schleife sofort verlassen werden, ohne weitere Tauschoperationen durchzuführen. Andernfalls kann nicht garantiert werden, dass die Elemente auf der linken Seite nicht größer als pivot und die Elemente auf der rechten Seite nicht kleiner als pivot sind. Nach jedem Tausch sollten l++ und r-- ausgeführt werden. pivot ist eigentlich die Zahl in der Mitte, die nach links verschoben ist. Wenn das Array also mit $l - 1$ und $l$ geteilt wird, führt dies bei einem Array wie [1, 2] zu einer Endlosschleife, da das Array immer wieder in zwei Teile der Größe 0 und 2 aufgeteilt wird. Ähnlich verhält es sich, wenn das Array mit $r$ und $l$ geteilt wird. Wenn die Schleife jedoch beendet ist, ist $r$ immer kleiner als $right$, sodass das Array mit $r$ und $r+1$ geteilt werden kann. Der Leser kann den Algorithmus simulieren, um zu sehen, warum. Eine andere einfache Möglichkeit, Endlosschleifen zu vermeiden, ist die zufällige Auswahl von pivot oder die Sonderbehandlung von Arrays mit nur zwei Elementen. Außerdem ist die Verwendung von $l$, $l+1$ nicht möglich, da diese Aufteilung nicht der Definition entspricht. Wenn $r$ links von $l$ liegt, kann das Array mit $l$, $l+1$ nicht korrekt in zwei Teile aufgeteilt werden, wobei der linke Teil kleiner oder gleich pivot und der rechte Teil größer oder gleich pivot ist. In dieser Aufgabe wird davon ausgegangen, dass das Array nicht leer ist, sodass der Fall \u0026gt; nicht existiert. Es wird jedoch empfohlen, \u0026gt;= zu verwenden, da dies sicherer ist. Ergänzung # Quicksort kann auch zu \u0026ldquo;Quickselect\u0026rdquo; weiterentwickelt werden, um das $k$-kleinste Element in einem unsortierten Array in einer erwarteten Zeit von $O(n)$ zu finden. Die Idee ist ähnlich wie bei Quicksort, nur dass die Rekursion jedes Mal nur in einem Teilintervall fortgesetzt wird, wodurch die Zeitkomplexität reduziert wird.\n","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse der wichtigsten Punkte für die korrekte Implementierung des Quicksort-Algorithmus.","title":"Quicksort","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 Dezember 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B9%A0%EB%A5%B8-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"빠른 정렬","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Problem # Es gibt $N$ Gegenstände. Das Volumen des $i$-ten Gegenstands ist $s_i$ und sein Wert ist $v_i$. Jeder Gegenstand kann nur einmal genommen werden. Finde unter der Voraussetzung, dass das maximale Gesamtvolumen $S$ nicht überschritten wird, den maximalen Gesamtwert $V$, der erzielt werden kann.\nEingabeformat # Die erste Zeile enthält zwei ganze Zahlen, $N$ und $S$, getrennt durch ein Leerzeichen, die die Anzahl der Gegenstände bzw. das maximale Gesamtvolumen darstellen. Die folgenden $N$ Zeilen enthalten jeweils zwei ganze Zahlen, $s_i$ und $v_i$, getrennt durch ein Leerzeichen, die das Volumen bzw. den Wert des $i$-ten Gegenstands darstellen.\nAusgabeformat # Gib eine ganze Zahl aus, die den maximalen Wert darstellt.\nDatenbereich # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Eingabebeispiel # 4 5 1 2 2 4 3 4 4 5 Ausgabebeispiel # 8 Lösung # Definiere den Zustand: f[i][j] repräsentiert den maximalen Wert, der mit den ersten $i$ Gegenständen bei einem Volumenlimit von $j$ erzielt werden kann. Wenn der $i$-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der $i$-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - s[i]] + v[i] Achte bei der Implementierung des Zustandsübergangs auf den Definitionsbereich. Wenn $j \u003c s_i$, dann betrachte den Fall der Entnahme des $i$-ten Gegenstands nicht. Denn wenn $j - s_i$ negativ ist, ist der Array-Index ungültig. Es kann auch so erklärt werden: Das Volumen des $i$-ten Gegenstands ist größer als das Volumenlimit, daher ist es unmöglich. Definiere die Anfangsbedingung: Für die ersten $0$ Gegenstände ergibt jedes Volumenlimit einen Wert von $0$, d.h. f[0][j] = 0, j $\\in [0, S]$. Zeitkomplexität: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimierung # Das Komprimieren des zweidimensionalen Arrays in ein eindimensionales Array kann erheblich Speicherplatz sparen und die Laufgeschwindigkeit bis zu einem gewissen Grad verbessern (der Nachteil ist, dass es die speziellen Anforderungen einiger Problemtypen nicht erfüllen kann). Beachte, dass im Zustandsübergang f[i][j] nur mit f[i - 1][j] und f[i - 1][j - s[i]] zusammenhängt. Mit anderen Worten, im zweidimensionalen Array f im Code, f[i][j] hängt nur mit den Elementen in der vorherigen Zeile zusammen, die sich links davon oder in derselben Spalte befinden. Daher kann das zweidimensionale Array in ein eindimensionales Array oder ein Rolling Array komprimiert werden. Beachte, dass in dem folgenden Code die zweite Schleife in umgekehrter Reihenfolge iteriert. Dies liegt daran, dass wir sicherstellen wollen, dass bei der Berechnung von f[i][j] f[i - 1][j - s[i]] noch nicht aktualisiert wurde. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Wenn die Anzahl der Schemata erforderlich ist # Es sollte nicht nur der maximale Gesamtwert ausgegeben werden, der erzielt werden kann, sondern auch \u0026ldquo;wie viele verschiedene Auswahlmethoden diesen maximalen Gesamtwert erreichen können\u0026rdquo;. Im Folgenden wird beschrieben, wie man die Anzahl der Schemata im 01-Rucksackproblem zählt.\n2D DP zum Zählen von Schemata # Das Folgende verwendet 2D DP als Beispiel zur Erläuterung.\nDefiniere den Zustand:\ndp[i][j] repräsentiert \u0026ldquo;den maximalen Wert, der erzielt werden kann, wenn man die ersten i Gegenstände mit einer Kapazität (Volumenlimit) von j betrachtet\u0026rdquo;. ways[i][j] repräsentiert \u0026ldquo;die Anzahl der Schemata, die dem maximalen Wert entsprechen, der erzielt wird, wenn man die ersten i Gegenstände mit einer Kapazität von j betrachtet\u0026rdquo;. Zustandsübergang:\nWenn der i-te Gegenstand nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Wenn der i-te Gegenstand ausgewählt wird (vorausgesetzt, dass $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Ob ausgewählt wird oder nicht, das endgültige dp[i][j] sollte das größere der beiden annehmen: Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ dann bedeutet dies, dass \u0026ldquo;die Auswahl des i-ten Gegenstands\u0026rdquo; einen größeren Wert hat: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ bedeutet dies, dass der maximale Wert, der durch die beiden Methoden erzielt wird, derselbe ist, dann sollte die Anzahl der Schemata addiert werden: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Wenn $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ dann bedeutet dies, dass \u0026ldquo;die Nichtauswahl des i-ten Gegenstands\u0026rdquo; einen größeren Wert hat, und die Anzahl der Schemata erbt die Anzahl der Schemata, wenn nicht ausgewählt wird: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Anfangsbedingungen:\ndp[0][j] = 0 bedeutet, dass, wenn es 0 Gegenstände gibt, der maximale Wert, der für jede Kapazität erzielt wird, 0 ist. ways[0][0] = 1 bedeutet, dass der Fall \u0026ldquo;0 Gegenstände, Kapazität 0\u0026rdquo; ein machbares Schema ist (d.h. nichts auswählen), und die Anzahl der Schemata auf 1 gesetzt wird. Für j \u0026gt; 0, wenn es keine Gegenstände zur Auswahl gibt und die Kapazität größer als 0 ist, ist es unmöglich, einen positiven Wert zu erhalten, und die entsprechende Anzahl von Schemata ist 0, d.h. ways[0][j] = 0. Endgültige Antwort:\ndp[N][S] ist der maximale Wert. ways[N][S] ist die Anzahl der Schemata, um diesen maximalen Wert zu erreichen. Zeitkomplexität: $O(NS)$. Dieses Problem kann auch mit 1D DP optimiert werden. Wenn die Anforderung darin besteht, das Volumenlimit genau zu erreichen # Definiere den Zustand: f[i][j] repräsentiert den maximalen Wert, wenn die ersten i Gegenstände genau ein Volumen von $j$ haben. Wenn der i-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - s[i]] + v[i] Es ist zu beachten, dass es keinen Unterschied im Zustandsübergang zum ursprünglichen Problem gibt. Die Anfangsbedingungen sind jedoch unterschiedlich. Mit Ausnahme von f[0][0] = 0 ist der Rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ repräsentiert einen unmöglichen Zustand. Wenn das Volumenlimit $S$ sehr groß ist (1e9), während die Anzahl der Gegenstände $N$ und der maximale Gesamtwert $V$ relativ klein sind # Für solche Probleme gibt es eine Lösung mit einer Komplexität von $O(NV)$. Definiere den Zustand: f[i][j] repräsentiert das minimale Volumen, wenn man mehrere Gegenstände aus den ersten i Gegenständen auswählt und der Gesamtwert genau j ist. Wenn der i-te Gegenstand nicht genommen wird, dann gilt f[i][j] = f[i - 1][j] Wenn der i-te Gegenstand genommen wird, dann gilt f[i][j] = f[i - 1][j - v[i]] + s[i] Nimm den kleineren der beiden. Anfangsbedingungen: f[0][0] = 0, der Rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ repräsentiert einen unmöglichen Zustand. Beachte, dass es nicht $-\\infty$ ist. Die endgültige Antwort ist das größte j in f[N][j], so dass f[N][j] \u0026lt;= S. Wenn das Volumenlimit $S$ und der Wert eines einzelnen Gegenstands $v_i$ beide sehr groß sind (in der Größenordnung von 1e9), während die Anzahl der Gegenstände $N$ sehr klein ist (nicht mehr als 40) # Wenn $N \\leq 20$, können alle Teilmengen direkt durch Brute Force aufgezählt werden (Zeitkomplexität $O(2^N)$). Wenn $N \\leq 40$, da $2^{40}$ in der Größenordnung von $10^{12}$ liegt, wird auch die direkte Brute Force relativ groß sein, daher kann Meet-in-the-Middle-Suche verwendet werden, um die Komplexität auf ungefähr $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ zu reduzieren, was in einer akzeptablen Zeit abgeschlossen werden kann. ","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Das grundlegendste klassische Rucksackproblem.","title":"01 Rucksackproblem","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"Wenn ein sortierter Lösungsraum in zwei Teile geteilt wird, wobei ein Teil die Bedingung erfüllt und der andere Teil nicht, dann kann die binäre Suche verwendet werden, um den kritischen Punkt im sortierten Lösungsraum zu finden.\nDie Grundidee der binären Suche ist es, das Suchintervall kontinuierlich zu halbieren. Bei jeder Überprüfung wird das mittlere Element untersucht. Wenn das mittlere Element die Bedingung nicht erfüllt, kann die Hälfte des Intervalls ausgeschlossen werden; andernfalls wird die Suche in der anderen Hälfte des Intervalls fortgesetzt. Da bei jeder Suche die Hälfte des Suchintervalls verworfen wird, kann die Suchzeitkomplexität $O(\\log n)$ erreichen.\nBeispielaufgabe # Aufgabenbeschreibung: Gegeben ist ein aufsteigend sortiertes Array von ganzen Zahlen der Länge $n$ sowie $q$ Abfragen. Jede Abfrage gibt eine ganze Zahl $k$ an, und wir müssen die \u0026ldquo;Startposition\u0026rdquo; und \u0026ldquo;Endposition\u0026rdquo; von $k$ im Array finden (Indizes beginnen bei 0). Wenn die Zahl nicht im Array vorhanden ist, wird -1 -1 zurückgegeben.\nEingabeformat # Erste Zeile: Zwei ganze Zahlen $n$ und $q$, die die Länge des Arrays bzw. die Anzahl der Abfragen angeben. Zweite Zeile: $n$ ganze Zahlen, die das vollständige Array darstellen, das bereits aufsteigend sortiert ist. Die nächsten $q$ Zeilen: Jede Zeile enthält eine ganze Zahl $k$, die ein Abfrageelement darstellt. Datenbereich # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nAusgabeformat # Geben Sie für jede Abfrage die Start- und Endposition des Elements im Array in einer Zeile aus. Wenn das Element nicht im Array vorhanden ist, geben Sie -1 -1 aus.\nBeispiel:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element $3$ vorkommt, ist $[3, 4]$; Das Element $4$ kommt nur einmal an Position $5$ vor; Das Element $5$ ist nicht im Array vorhanden, daher wird $-1$ $-1$ zurückgegeben. Lösung # Suche nach der \u0026ldquo;Startposition\u0026rdquo;: Das heißt, die erste Position zu finden, die größer oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner\u0026rdquo; als $k$ Alle Zahlen rechts sind \u0026ldquo;größer oder gleich\u0026rdquo; $k$ Die Antwort ist die erste Position auf der rechten Seite Suche nach der \u0026ldquo;Endposition\u0026rdquo;: Das heißt, die letzte Position zu finden, die kleiner oder gleich $k$ ist. Das Array kann in zwei Teile geteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner oder gleich\u0026rdquo; $k$ Alle Zahlen rechts sind \u0026ldquo;größer\u0026rdquo; als $k$ Die Antwort ist die letzte Position auf der linken Seite Empfohlene Vorlage # Im Folgenden finden Sie eine elegante und fehlerfreie binäre Suchvorlage.\nDefinieren Sie zwei Zeiger $l, r$ mit der Invariante: Das geschlossene Intervall $[0, l]$ gehört zum linken Teil, und das geschlossene Intervall $[r, n - 1]$ gehört zum rechten Teil. $l$ und $r$ werden mit $-1$ bzw. $n$ initialisiert.\nWenn der Algorithmus beendet ist, sind $l$ und $r$ benachbart und zeigen auf das letzte Element des linken Teils bzw. das erste Element des rechten Teils.\nDa die gewünschte Lösung möglicherweise nicht existiert, müssen wir, wenn die Aufgabe nicht angibt, dass eine Lösung existiert, überprüfen, ob l oder r außerhalb des Bereichs liegen oder auf den richtigen Wert zeigen.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Suche nach der Startposition von k 15 // Teile das Array in zwei Teile, links alle \u0026lt; k, rechts alle \u0026gt;= k. 16 // Die Antwort ist der kleinste Index des rechten Teils. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Wenn r außerhalb des Bereichs liegt oder nums[r] != k, existiert k nicht 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Suche nach der Endposition von k 33 // Teile das Array in zwei Teile, links alle \u0026lt;= k, rechts alle \u0026gt; k. 34 // Die Antwort ist der größte Index des linken Teils. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Vorteile # Diese Schreibweise hat streng definierte Invarianten. Sie ist sowohl für die Suche nach der \u0026ldquo;Startposition\u0026rdquo; als auch nach der \u0026ldquo;Endposition\u0026rdquo; geeignet, ohne dass zusätzliche Verarbeitung oder Änderungen erforderlich sind. Einige Schreibweisen verwenden l == r als Abbruchbedingung. Wenn $l$ und $r$ um $1$ differieren, wird $mid$ gleich $l$ oder $r$ berechnet. Wenn dies nicht korrekt behandelt wird, wird die Aktualisierung von $l$ oder $r$ auf $mid$ dazu führen, dass sich das Suchintervall nicht verkleinert und eine Endlosschleife entsteht. Im Gegensatz dazu wird die Suche hier beendet, wenn $l$ und $r$ benachbart sind, wodurch sichergestellt wird, dass $mid$ kleiner als $l$ und größer als $r$ ist, und das Suchintervall bei der Aktualisierung von $l$ oder $r$ definitiv verkleinert wird. STL # Wenn Sie die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwenden, können Sie dasselbe erreichen:\nlower_bound(first, last, val) gibt die \u0026ldquo;erste Position größer oder gleich val\u0026rdquo; zurück upper_bound(first, last, val) gibt die \u0026ldquo;erste Position größer als val\u0026rdquo; zurück Nehmen wir zum Beispiel an, nums = {1,2,3,4,4,4,4,4,5,5,6}, und wir möchten den Bereich wissen, in dem 4 vorkommt:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 kommt 0 mal vor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;Die erste 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;Die letzte 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 kommt \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; mal vor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 zeigt auf die erste Position, deren Wert größer oder gleich $4$ ist. it2 zeigt auf die erste Position, deren Wert größer als $4$ ist. Daher ist it2 - it1 die Anzahl, wie oft $4$ im Array vorkommt; it2 - nums.begin() - 1 ist die Position der rechten Grenze von $4$. Ergänzung # Die binäre Suche kann auch auf die Suche im Bereich von Gleitkommazahlen (z. B. zum Finden von Wurzeln von Gleichungen) und auf die ternäre Suche zur Bestimmung des Maximums einer unimodalen Funktion erweitert werden.\nÜbung # LeetCode 33. Search in Rotated Sorted Array\nHinweis: Verwenden Sie im ersten Schritt die binäre Suche, um den Rotationspunkt zu finden, und verwenden Sie im zweiten Schritt die binäre Suche, um den Zielwert zu finden.\n","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Wie man den binären Suchalgorithmus elegant implementiert.","title":"Binäre Suche","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"}]