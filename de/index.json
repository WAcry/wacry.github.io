[{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":" Binäre Suche # Wenn ein sortierter Lösungsraum in zwei Teile aufgeteilt wird, wobei ein Teil die Bedingung erfüllt und der andere Teil die Bedingung nicht erfüllt, dann kann die binäre Suche verwendet werden, um den kritischen Punkt im sortierten Lösungsraum zu finden.\nDie Grundidee der binären Suche besteht darin, den Suchbereich kontinuierlich zu halbieren. Bei jeder Überprüfung wird das mittlere Element überprüft. Wenn das mittlere Element die Bedingung nicht erfüllt, kann die Hälfte des Bereichs ausgeschlossen werden; andernfalls wird die Suche im anderen Teil des Bereichs fortgesetzt. Da bei jeder Suche die Hälfte des Suchbereichs verworfen wird, kann die Suchzeitkomplexität \\(O(\\log n)\\) erreichen.\nBeispielaufgabe # Aufgabenbeschreibung: Gegeben ist ein aufsteigend sortiertes Array von ganzen Zahlen der Länge \\(n\\) sowie \\(q\\) Abfragen. Jede Abfrage gibt eine ganze Zahl \\(k\\) an, und wir müssen die \u0026ldquo;Startposition\u0026rdquo; und \u0026ldquo;Endposition\u0026rdquo; von \\(k\\) im Array finden (Indizes beginnen bei 0). Wenn die Zahl nicht im Array existiert, gib \\(-1\\) \\(-1\\) zurück.\nEingabeformat # Erste Zeile: Zwei ganze Zahlen \\(n\\) und \\(q\\), die die Länge des Arrays und die Anzahl der Abfragen angeben. Zweite Zeile: \\(n\\) ganze Zahlen, die das vollständige Array darstellen und bereits aufsteigend sortiert sind. Die nächsten \\(q\\) Zeilen: Jede Zeile enthält eine ganze Zahl \\(k\\), die ein Abfrageelement darstellt. Datenbereich # \\(1 \\leq n \\leq 100000\\)\n\\(1 \\leq q \\leq 10000\\)\n\\(1 \\leq k \\leq 10000\\)\nAusgabeformat # Für jede Abfrage geben Sie in einer Zeile die Start- und Endposition des Elements im Array aus. Wenn das Element nicht im Array existiert, geben Sie -1 -1 aus.\nBeispiel:\nEingabe: 6 3 1 2 2 3 3 4 3 4 5 Ausgabe: 3 4 5 5 -1 -1 Erläuterung:\nDer Bereich, in dem das Element \\(3\\) vorkommt, ist \\([3, 4]\\); Das Element \\(4\\) kommt nur einmal vor, an Position \\(5\\); Das Element \\(5\\) existiert nicht im Array, daher wird \\(-1\\) \\(-1\\) zurückgegeben. Lösung # Finden der \u0026ldquo;Startposition\u0026rdquo;: Das heißt, die erste Position zu finden, die größer oder gleich \\(k\\) ist. Das Array kann in zwei Teile aufgeteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner als\u0026rdquo; \\(k\\) Alle Zahlen rechts sind \u0026ldquo;größer oder gleich\u0026rdquo; \\(k\\) Die Antwort ist die erste Position auf der rechten Seite. Finden der \u0026ldquo;Endposition\u0026rdquo;: Das heißt, die letzte Position zu finden, die kleiner oder gleich \\(k\\) ist. Das Array kann in zwei Teile aufgeteilt werden:\nAlle Zahlen links sind \u0026ldquo;kleiner oder gleich\u0026rdquo; \\(k\\) Alle Zahlen rechts sind \u0026ldquo;größer als\u0026rdquo; \\(k\\) Die Antwort ist die letzte Position auf der linken Seite. Empfohlene Vorlage # Nachfolgend finden Sie eine elegante und fehlerfreie Binärsuchvorlage. Sie sorgt dafür, dass die Schleife aufhört, sobald \\(l\\) und \\(r\\) nebeneinander liegen, indem \\(l\\) und \\(r\\) schrittweise angenähert werden:\nDefinieren Sie zwei Zeiger \\(l, r\\) mit der Invariante: Das geschlossene Intervall \\([0, l]\\) gehört zum linken Teil, das geschlossene Intervall \\([r, n - 1]\\) gehört zum rechten Teil. \\(l\\) und \\(r\\) werden mit \\(-1\\) bzw. \\(n\\) initialisiert.\nWenn der Algorithmus terminiert, sind \\(l\\) und \\(r\\) benachbart und zeigen auf das letzte Element des linken Teils bzw. das erste Element des rechten Teils.\nDa die gewünschte Lösung möglicherweise nicht existiert, müssen wir, wenn die Aufgabe nicht angibt, dass eine Lösung existiert, prüfen, ob l oder r außerhalb des Bereichs liegen oder ob sie auf den richtigen Wert zeigen.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Finde die Startposition von k 15 // Teile das Array in zwei Teile auf, links alle \u0026lt; k, rechts alle \u0026gt;= k. 16 // Die Antwort ist der kleinste Index des rechten Teils. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Wenn r außerhalb des Bereichs liegt oder nums[r] != k, existiert k nicht 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Finde die Endposition von k 33 // Teile das Array in zwei Teile auf, links alle \u0026lt;= k, rechts alle \u0026gt; k. 34 // Die Antwort ist der größte Index des linken Teils. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Warum diese Schreibweise? # Diese Schreibweise hat streng definierte Invarianten. Sie ist gleichzeitig geeignet, um die \u0026ldquo;Startposition\u0026rdquo; und die \u0026ldquo;Endposition\u0026rdquo; zu finden, ohne dass zusätzliche Verarbeitung oder Änderungen erforderlich sind. Einige Schreibweisen verwenden l == r als Abbruchbedingung. Wenn \\(l\\) und \\(r\\) einen Abstand von \\(1\\) haben, wird \\(mid\\) gleich \\(l\\) oder \\(r\\) berechnet. Wenn dies nicht korrekt verarbeitet wird, indem \\(l\\) oder \\(r\\) auf \\(mid\\) aktualisiert wird, verkleinert sich der Suchbereich nicht und es kommt zu einer Endlosschleife. Im Gegenteil, diese Schreibweise beendet sich, wenn \\(l\\) und \\(r\\) benachbart sind, wodurch sichergestellt wird, dass \\(mid\\) kleiner als \\(l\\) und größer als \\(r\\) ist, und der Suchbereich wird bei der Aktualisierung von \\(l\\) oder \\(r\\) garantiert verkleinert. STL # Wenn Sie die von C++ STL bereitgestellten Funktionen lower_bound und upper_bound verwenden, können Sie das gleiche Ergebnis erzielen:\nlower_bound(first, last, val) gibt die \u0026ldquo;erste Position zurück, die größer oder gleich val ist\u0026rdquo; upper_bound(first, last, val) gibt die \u0026ldquo;erste Position zurück, die größer als val ist\u0026rdquo; Nehmen wir zum Beispiel an, nums = {1,2,3,4,4,4,4,4,5,5,6}, und wir möchten den Bereich wissen, in dem 4 vorkommt:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 kommt 0 Mal vor\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;Die erste 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;Die letzte 4 ist an Position \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 kommt \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; Mal vor\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 zeigt auf die erste Position, deren Wert größer oder gleich \\(4\\) ist. it2 zeigt auf die erste Position, deren Wert größer als \\(4\\) ist.\nAlso ist it2 - it1 die Anzahl, wie oft \\(4\\) im Array vorkommt; it2 - nums.begin() - 1 ist die rechte Grenze von \\(4\\). Ergänzung # Die binäre Suche kann auch auf die Suche nach Gleitkommazahlenbereichen (z. B. zum Finden von Wurzeln von Gleichungen) und auf die ternäre Suche zum Finden von Maximalwerten einer unimodalen Funktion erweitert werden. Sobald Sie das Kernprinzip \u0026quot; In einem sortierten Intervall kann bei jedem Schritt die Hälfte ausgeschlossen werden\u0026quot; verstanden haben, werden Sie feststellen, dass die binäre Suche Ihnen in vielen Szenarien helfen kann, Probleme effizient zu lösen.\nÜbung # LeetCode 33. Suche in einem rotierten sortierten Array\nHinweis: Verwenden Sie im ersten Schritt die binäre Suche, um den Rotationspunkt zu finden, und verwenden Sie im zweiten Schritt die binäre Suche, um den Zielwert zu finden.\n","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Wie man den binären Suchalgorithmus für ganze Zahlen elegant implementiert.","title":"Binäre Suche","type":"posts"},{"content":"","date":"24 Dezember 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-dalgorithmes/","section":"Tags","summary":"","title":"Modèles D'algorithmes","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmi/","section":"Tags","summary":"","title":"Template Algoritmi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथ्म","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%81/","section":"Categories","summary":"","title":"एल्गोरिथ्म और डेटा संरचनाएँ","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथ्म टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/de/series/","section":"Series","summary":"","title":"Series","type":"series"}]