[{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":" Tri Rapide # Le tri rapide est un algorithme de tri non stable basé sur la comparaison, qui utilise le principe \u0026ldquo;diviser pour régner\u0026rdquo;. Sa complexité temporelle moyenne est de $O(n\\log n)$, et de $O(n^2)$ dans le pire des cas, avec une complexité spatiale de $O(1)$. Nous allons prendre l\u0026rsquo;exemple du tri d\u0026rsquo;une suite d\u0026rsquo;entiers par ordre croissant pour illustrer les détails de son implémentation et les erreurs courantes.\nDescription du Problème # Étant donnée une suite d\u0026rsquo;entiers de longueur $n$, utilisez le tri rapide pour la trier par ordre croissant et affichez le résultat.\nFormat d\u0026rsquo;entrée # La première ligne contient l\u0026rsquo;entier $n$. La deuxième ligne contient $n$ entiers, tous dans l\u0026rsquo;intervalle $[1,10^9]$. Format de sortie # Une ligne contenant la suite triée. Plage de données # $1 \\leq n \\leq 100000$\nExemple d\u0026rsquo;entrée # 5 3 1 2 4 5 Exemple de sortie # 1 2 3 4 5 Idée du Tri Rapide # À chaque étape de division du tri rapide, un nombre est choisi comme pivot (ici, nous choisissons le nombre au milieu).\nDeux pointeurs, gauche L et droit R, se déplacent l\u0026rsquo;un vers l\u0026rsquo;autre. Le pointeur gauche L cherche de gauche à droite le premier nombre supérieur ou égal au pivot, et le pointeur droit R cherche de droite à gauche le premier nombre inférieur ou égal au pivot. Ensuite, ces deux nombres sont échangés.\nCe processus est répété jusqu\u0026rsquo;à ce que les pointeurs gauche et droit se chevauchent ou que le pointeur gauche dépasse le pointeur droit d\u0026rsquo;une position. Ceci est appelé une itération.\nAprès chaque déplacement et échange de pointeurs, la structure \u0026ldquo;partie gauche ≤ pivot, partie droite ≥ pivot\u0026rdquo; est maintenue, c\u0026rsquo;est-à-dire qu\u0026rsquo;il y a un invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nDans l\u0026rsquo;exemple de code ci-dessous, left et right sont les limites de l\u0026rsquo;intervalle fermé en cours de traitement, et pivot est l\u0026rsquo;élément au milieu de l\u0026rsquo;intervalle.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexité et Choix du pivot # Étant donné que le tri rapide a une complexité de $O(n^2)$ dans le pire des cas, le choix du pivot est crucial. Si l\u0026rsquo;on choisit toujours le premier ou le dernier élément, le pire des cas se produira probablement dans un tableau presque trié.\nEn plus de choisir l\u0026rsquo;élément au milieu, on peut également choisir un élément aléatoire comme pivot, ou prendre la médiane des trois éléments de gauche, du milieu et de droite comme pivot.\nExemples d\u0026rsquo;Erreurs Courantes # Le code suivant contient plusieurs erreurs courantes.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Analyse des erreurs :\npivot doit être un nombre du tableau, et non un indice. Utiliser respectivement \u0026lt; et \u0026gt; au lieu de \u0026lt;= et \u0026gt;=, sinon le pointeur gauche pourrait dépasser le pointeur droit de plus d\u0026rsquo;une position, ce qui empêcherait de diviser le tableau en deux parties. Après avoir constaté que l \u0026gt;= r, il faut immédiatement sortir de la boucle et ne plus effectuer d\u0026rsquo;échange. Sinon, on ne peut pas garantir que les éléments de gauche ne sont pas supérieurs à pivot et que les éléments de droite ne sont pas inférieurs à pivot. Après chaque échange, il faut exécuter l++ et r--. pivot prend en fait le nombre du milieu gauche. Par conséquent, si l\u0026rsquo;on utilise $l - 1$ et $l$ pour diviser le tableau, il est facile de constater qu\u0026rsquo;un tableau comme [1, 2] conduira à une boucle infinie, divisant continuellement le tableau en deux parties de taille 0 et 2. De même, utiliser $r$ et $l$ pour diviser le tableau ne fonctionne pas non plus. Au contraire, à la fin d\u0026rsquo;une itération, $r$ est nécessairement inférieur à $right$, on peut donc utiliser $r$ et $r+1$ pour diviser le tableau. Le lecteur peut simuler le processus de l\u0026rsquo;algorithme pour voir pourquoi. Une autre façon simple d\u0026rsquo;éviter les boucles infinies est de choisir un pivot aléatoire ou de traiter spécialement le cas où il n\u0026rsquo;y a que deux éléments. De plus, utiliser $l$, $l+1$ ne fonctionne pas non plus, car cette division ne correspond pas à la définition. Lorsque $r$ est à gauche de $l$, utiliser $l$, $l+1$ ne permet pas de diviser correctement le tableau en deux parties : une partie gauche inférieure ou égale à pivot et une partie droite supérieure ou égale à pivot. Ce problème suppose que le tableau n\u0026rsquo;est pas vide, il n\u0026rsquo;y a donc pas de cas où \u0026gt; est utilisé. Cependant, il est recommandé d\u0026rsquo;utiliser \u0026gt;=, ce qui est plus sûr. Complément # Le tri rapide peut également être transformé en \u0026ldquo;sélection rapide\u0026rdquo;, qui permet de trouver le $k$-ième plus petit nombre dans un tableau non trié en un temps espéré de $O(n)$. L\u0026rsquo;idée est similaire à celle du tri rapide, sauf qu\u0026rsquo;à chaque étape, on ne continue la récursion que dans un seul sous-intervalle, ce qui réduit la complexité temporelle.\n","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse des points clés pour implémenter correctement l\u0026rsquo;algorithme de tri rapide.","title":"Tri Rapide","type":"posts"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":" Problème # Il y a $N$ objets. Le volume du $i$-ème objet est $s_i$, et sa valeur est $v_i$. Chaque objet ne peut être pris qu\u0026rsquo;une seule fois. Sous la condition de ne pas dépasser la limite de volume total maximal $S$, trouvez la valeur totale maximale $V$ qui peut être obtenue.\nFormat d\u0026rsquo;entrée # La première ligne contient deux entiers, $N$ et $S$, séparés par un espace, représentant respectivement le nombre d\u0026rsquo;objets et la limite de volume total maximal. Les $N$ lignes suivantes contiennent chacune deux entiers, $s_i$ et $v_i$, séparés par un espace, représentant respectivement le volume et la valeur du $i$-ème objet.\nFormat de sortie # Affichez un entier représentant la valeur maximale.\nPlage de données # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Exemple d\u0026rsquo;entrée # 4 5 1 2 2 4 3 4 4 5 Exemple de sortie # 8 Solution # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale qui peut être obtenue à partir des $i$ premiers objets avec une limite de volume de $j$. Si le $i$-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le $i$-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] Lors de l\u0026rsquo;implémentation de la transition d\u0026rsquo;état, faites attention à la plage du domaine. Si $j \u003c s_i$, alors ne considérez pas le cas de la prise du $i$-ème objet. Car si $j - s_i$ est négatif, l\u0026rsquo;index du tableau est illégal. Cela peut aussi être expliqué de cette façon : le volume du $i$-ème objet est supérieur à la limite de volume, donc c\u0026rsquo;est impossible. Définir la condition initiale : Pour les $0$ premiers objets, toute limite de volume donne une valeur de $0$, c\u0026rsquo;est-à-dire f[0][j] = 0, j $\\in [0, S]$. Complexité temporelle : $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Optimisation DP 1D # La compression du tableau bidimensionnel en un tableau unidimensionnel peut considérablement économiser de l\u0026rsquo;espace et améliorer la vitesse d\u0026rsquo;exécution dans une certaine mesure (l\u0026rsquo;inconvénient est qu\u0026rsquo;il ne peut pas répondre aux exigences particulières de certains types de problèmes). Notez que dans la transition d\u0026rsquo;état, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;à f[i - 1][j] et f[i - 1][j - s[i]]. En d\u0026rsquo;autres termes, dans le tableau bidimensionnel f du code, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;aux éléments de la ligne précédente qui sont à sa gauche ou dans la même colonne. Par conséquent, le tableau bidimensionnel peut être compressé en un tableau unidimensionnel ou un tableau roulant. Notez que dans le code ci-dessous, la deuxième boucle itère dans l\u0026rsquo;ordre inverse. C\u0026rsquo;est parce que nous voulons nous assurer que lors du calcul de f[i][j], f[i - 1][j - s[i]] n\u0026rsquo;a pas encore été mis à jour. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Si le nombre de schémas est requis # Non seulement la valeur totale maximale qui peut être obtenue doit être affichée, mais aussi \u0026ldquo;combien de méthodes de sélection différentes peuvent atteindre cette valeur totale maximale\u0026rdquo;. Ce qui suit décrit comment compter le nombre de schémas dans le problème du sac à dos 0/1.\nDP 2D pour compter les schémas # Ce qui suit utilise la DP 2D comme exemple pour expliquer.\nDéfinir l\u0026rsquo;état :\ndp[i][j] représente \u0026ldquo;la valeur maximale qui peut être obtenue en considérant les i premiers objets avec une capacité (limite de volume) de j\u0026rdquo;. ways[i][j] représente \u0026ldquo;le nombre de schémas correspondant à la valeur maximale obtenue en considérant les i premiers objets avec une capacité de j\u0026rdquo;. Transition d\u0026rsquo;état :\nSi le i-ème objet n\u0026rsquo;est pas sélectionné : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Si le i-ème objet est sélectionné (à condition que $ j \\ge s_i $) : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Qu\u0026rsquo;il faille sélectionner ou non, le dp[i][j] final doit prendre le plus grand des deux : Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ alors cela signifie que \u0026ldquo;la sélection du i-ème objet\u0026rdquo; a une plus grande valeur : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ cela signifie que la valeur maximale obtenue par les deux méthodes est la même, alors le nombre de schémas doit être ajouté : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ alors cela signifie que \u0026ldquo;ne pas sélectionner le i-ème objet\u0026rdquo; a une plus grande valeur, et le nombre de schémas hérite du nombre de schémas lors de la non-sélection : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Conditions initiales :\ndp[0][j] = 0 signifie que lorsqu\u0026rsquo;il y a 0 objet, la valeur maximale obtenue pour toute capacité est 0. ways[0][0] = 1 signifie que le cas de \u0026ldquo;0 objet, capacité 0\u0026rdquo; est un schéma réalisable (c\u0026rsquo;est-à-dire ne rien sélectionner), et le nombre de schémas est défini sur 1. Pour j \u0026gt; 0, lorsqu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;objet à choisir et que la capacité est supérieure à 0, il est impossible d\u0026rsquo;obtenir une valeur positive, et le nombre de schémas correspondant est 0, c\u0026rsquo;est-à-dire ways[0][j] = 0. Réponse finale :\ndp[N][S] est la valeur maximale. ways[N][S] est le nombre de schémas pour atteindre cette valeur maximale. Complexité temporelle : $O(NS)$. Ce problème peut également être optimisé en utilisant la DP 1D. Si l\u0026rsquo;exigence est d\u0026rsquo;atteindre exactement la limite de volume # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale lorsque les i premiers objets ont exactement un volume de $j$. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] On peut noter qu\u0026rsquo;il n\u0026rsquo;y a pas de différence dans la transition d\u0026rsquo;état par rapport au problème d\u0026rsquo;origine. Cependant, les conditions initiales sont différentes. À l\u0026rsquo;exception de f[0][0] = 0, le reste f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ représente un état impossible. Si la limite de volume $S$ est très grande (1e9), tandis que le nombre d\u0026rsquo;objets $N$ et la valeur totale maximale $V$ sont relativement petits # Pour de tels problèmes, il existe une solution avec une complexité de $O(NV)$. Définir l\u0026rsquo;état : f[i][j] représente le volume minimal lors de la sélection de plusieurs objets parmi les i premiers objets, et la valeur totale est exactement j. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - v[i]] + s[i] Prendre le plus petit des deux. Conditions initiales : f[0][0] = 0, le reste f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ représente un état impossible. Notez que ce n\u0026rsquo;est pas $-\\infty$. La réponse finale est le plus grand j dans f[N][j] tel que f[N][j] \u0026lt;= S. Si la limite de volume $S$ et la valeur d\u0026rsquo;un seul objet $v_i$ sont toutes deux très grandes (de l\u0026rsquo;ordre de 1e9), tandis que le nombre d\u0026rsquo;objets $N$ est très petit (pas plus de 40) # Lorsque $N \\leq 20$, tous les sous-ensembles peuvent être directement énumérés par force brute (complexité temporelle $O(2^N)$). Lorsque $N \\leq 40$, puisque $2^{40}$ est de l\u0026rsquo;ordre de $10^{12}$, la force brute directe sera également relativement importante, donc la recherche par rencontre au milieu peut être utilisée pour réduire la complexité à environ $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, ce qui peut être réalisé dans un temps acceptable. ","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Le problème du sac à dos classique le plus basique.","title":"Problème du sac à dos 0/1","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"Si un espace de solutions ordonné est divisé en deux parties, où une partie satisfait une condition et l\u0026rsquo;autre non, alors la recherche binaire peut être utilisée pour trouver le point critique dans l\u0026rsquo;espace de solutions ordonné.\nL\u0026rsquo;idée de base de la recherche binaire est de diviser répétitivement l\u0026rsquo;intervalle de recherche par deux. À chaque fois, l\u0026rsquo;élément du milieu est vérifié. Si l\u0026rsquo;élément du milieu ne satisfait pas la condition, la moitié de l\u0026rsquo;intervalle peut être éliminée ; sinon, la recherche continue dans l\u0026rsquo;autre moitié. Puisque la moitié de l\u0026rsquo;intervalle de recherche est écartée à chaque fois, la complexité temporelle de la recherche peut atteindre $O(\\log n)$.\nExemple de Problème # Description du Problème : Étant donné un tableau d\u0026rsquo;entiers trié par ordre croissant de longueur $n$, et $q$ requêtes. Chaque requête donne un entier $k$, et nous devons trouver la \u0026ldquo;position de départ\u0026rdquo; et la \u0026ldquo;position de fin\u0026rdquo; de $k$ dans le tableau (les indices commencent à 0). Si le nombre n\u0026rsquo;existe pas dans le tableau, retourner -1 -1.\nFormat d\u0026rsquo;Entrée # Première ligne : deux entiers $n$ et $q$, représentant respectivement la longueur du tableau et le nombre de requêtes. Deuxième ligne : $n$ entiers, représentant le tableau complet, déjà trié par ordre croissant. Les $q$ lignes suivantes : chaque ligne contient un entier $k$, représentant un élément de requête. Plage de Données # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormat de Sortie # Pour chaque requête, afficher les positions de début et de fin de l\u0026rsquo;élément dans le tableau sur une seule ligne. Si l\u0026rsquo;élément n\u0026rsquo;existe pas dans le tableau, afficher -1 -1.\nExemple :\nEntrée : 6 3 1 2 2 3 3 4 3 4 5 Sortie : 3 4 5 5 -1 -1 Explication :\nLa plage où l\u0026rsquo;élément $3$ apparaît est $[3, 4]$ ; L\u0026rsquo;élément $4$ n\u0026rsquo;apparaît qu\u0026rsquo;une seule fois, à la position $5$ ; L\u0026rsquo;élément $5$ n\u0026rsquo;existe pas dans le tableau, donc retourner $-1$ $-1$. Solution # Trouver la \u0026ldquo;Position de Départ\u0026rdquo; : C\u0026rsquo;est-à-dire, trouver la première position qui est supérieure ou égale à $k$. Le tableau peut être divisé en deux parties :\nTous les nombres à gauche sont \u0026ldquo;inférieurs à\u0026rdquo; $k$ Tous les nombres à droite sont \u0026ldquo;supérieurs ou égaux à\u0026rdquo; $k$ La réponse est la première position à droite Trouver la \u0026ldquo;Position de Fin\u0026rdquo; : C\u0026rsquo;est-à-dire, trouver la dernière position qui est inférieure ou égale à $k$. Le tableau peut être divisé en deux parties :\nTous les nombres à gauche sont \u0026ldquo;inférieurs ou égaux à\u0026rdquo; $k$ Tous les nombres à droite sont \u0026ldquo;supérieurs à\u0026rdquo; $k$ La réponse est la dernière position à gauche Modèle Recommandé # Voici un modèle de recherche binaire élégant et moins sujet aux erreurs.\nDéfinissez deux pointeurs $l, r$, avec l\u0026rsquo;invariant : l\u0026rsquo;intervalle fermé $[0, l]$ appartient à la partie gauche, et l\u0026rsquo;intervalle fermé $[r, n - 1]$ appartient à la partie droite. $l$ et $r$ sont initialisés à $-1$ et $n$, respectivement.\nLorsque l\u0026rsquo;algorithme se termine, $l$ et $r$ sont adjacents, pointant respectivement vers le dernier élément de la partie gauche et le premier élément de la partie droite.\nComme la solution que nous voulons peut ne pas exister, si le problème n\u0026rsquo;indique pas qu\u0026rsquo;une solution existe forcément, nous devons vérifier si l ou r est hors limites et s\u0026rsquo;il pointe vers la bonne valeur.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Trouver la position de départ de k 15 // Diviser le tableau en deux parties, la partie gauche est toute \u0026lt; k, et la partie droite est toute \u0026gt;= k. 16 // La réponse est le plus petit indice de la partie droite. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Si r est hors limites ou nums[r] != k, cela signifie que k n\u0026#39;existe pas 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Trouver la position de fin de k 33 // Diviser le tableau en deux parties, la partie gauche est toute \u0026lt;= k, et la partie droite est toute \u0026gt; k. 34 // La réponse est le plus grand indice de la partie gauche. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Avantages # Cette approche a des invariants strictement définis. Elle s\u0026rsquo;applique à la fois pour trouver la \u0026ldquo;position de départ\u0026rdquo; et la \u0026ldquo;position de fin\u0026rdquo; sans traitement ou modifications supplémentaires. Certaines approches utilisent l == r comme condition de terminaison. Lorsque $l$ et $r$ diffèrent de $1$, $mid$ sera calculé comme étant égal à $l$ ou $r$. S\u0026rsquo;il n\u0026rsquo;est pas géré correctement, la mise à jour de $l$ ou $r$ à $mid$ ne réduira pas l\u0026rsquo;intervalle de recherche, ce qui entraînera une boucle infinie. En revanche, cette approche se termine lorsque $l$ et $r$ sont adjacents, garantissant que $mid$ est inférieur à $l$ et supérieur à $r$, et la mise à jour de $l$ ou $r$ réduira toujours l\u0026rsquo;intervalle de recherche. STL # Si vous utilisez les fonctions lower_bound et upper_bound fournies par la STL de C++, vous pouvez obtenir le même résultat :\nlower_bound(first, last, val) retournera \u0026ldquo;la première position qui est supérieure ou égale à val\u0026rdquo; upper_bound(first, last, val) retournera \u0026ldquo;la première position qui est supérieure à val\u0026rdquo; Par exemple, supposons que nums = {1,2,3,4,4,4,4,4,5,5,6}, et nous voulons connaître la plage où 4 apparaît :\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît 0 fois\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;le premier 4 est à \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;le dernier 4 est à \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; fois\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 pointe vers la première position où la valeur est supérieure ou égale à $4$. it2 pointe vers la première position où la valeur est supérieure à $4$. Par conséquent, it2 - it1 est le nombre de fois que $4$ apparaît dans le tableau ; it2 - nums.begin() - 1 est la position de la limite droite de $4$. Notes Additionnelles # La recherche binaire peut également être étendue pour rechercher dans des plages de nombres à virgule flottante (comme la recherche des racines d\u0026rsquo;une équation) et la recherche ternaire pour trouver les extrema de fonctions unimodales.\nPratique # LeetCode 33. Recherche dans un tableau trié pivoté\nIndice : Utilisez d\u0026rsquo;abord la recherche binaire pour trouver le point de rotation, puis utilisez la recherche binaire pour trouver la valeur cible.\n","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Comment implémenter élégamment l\u0026rsquo;algorithme de recherche binaire.","title":"Recherche Binaire","type":"posts"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/fr/series/","section":"Series","summary":"","title":"Series","type":"series"}]