[{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-dividir-para-conquistar/","section":"Tags","summary":"","title":"Algoritmo Dividir Para Conquistar","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Diviser Pour Régner","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":" Tri Rapide # Le tri rapide est un algorithme de tri non stable basé sur la comparaison, qui utilise le principe diviser pour régner. Sa complexité temporelle moyenne est de $O(n\\log n)$, dans le pire des cas de $O(n^2)$, et sa complexité spatiale est de $O(1)$. Nous allons présenter ci-dessous les détails de son implémentation et les erreurs fréquentes, en prenant l\u0026rsquo;exemple du tri d\u0026rsquo;une séquence d\u0026rsquo;entiers par ordre croissant.\nDescription du Problème # Étant donné une séquence de $n$ entiers, triez-la par ordre croissant en utilisant le tri rapide et affichez le résultat.\nFormat d\u0026rsquo;Entrée # La première ligne contient l\u0026rsquo;entier $n$. La deuxième ligne contient $n$ entiers, tous dans la plage $[1, 10^9]$. Format de Sortie # Affichez une ligne contenant la séquence triée. Plage de Données # $1 \\leq n \\leq 100000$\nExemple d\u0026rsquo;Entrée # 5 3 1 2 4 5 Exemple de Sortie # 1 2 3 4 5 Idée du Tri Rapide # À chaque étape de la division, le tri rapide sélectionne un nombre comme pivot (pivot ci-dessous est le nombre situé au milieu).\nDeux pointeurs, un gauche L et un droit R, se déplacent respectivement de gauche à droite et de droite à gauche. Le pointeur gauche L cherche le premier nombre supérieur ou égal au pivot, et le pointeur droit R cherche le premier nombre inférieur ou égal au pivot. Ensuite, ces deux nombres sont échangés.\nCe processus est répété jusqu\u0026rsquo;à ce que le pointeur gauche et le pointeur droit se chevauchent, ou que le pointeur gauche dépasse le pointeur droit d\u0026rsquo;une position. C\u0026rsquo;est ce qu\u0026rsquo;on appelle une itération.\nAprès chaque déplacement de pointeur et chaque échange, on garantit que la structure \u0026ldquo;partie gauche ≤ pivot, partie droite ≥ pivot\u0026rdquo; est maintenue, c\u0026rsquo;est-à-dire l\u0026rsquo;invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nDans l\u0026rsquo;exemple de code ci-dessous, left et right sont les limites de l\u0026rsquo;intervalle fermé en cours de traitement, et pivot est l\u0026rsquo;élément situé au milieu de l\u0026rsquo;intervalle.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexité et Choix du pivot # Comme le tri rapide a une complexité de $O(n^2)$ dans le pire des cas, le choix du pivot est crucial. Si l\u0026rsquo;on choisit toujours le premier ou le dernier élément, on risque de rencontrer le pire des cas dans un tableau presque trié.\nEn plus de choisir l\u0026rsquo;élément du milieu, on peut également choisir un élément aléatoire comme pivot, ou prendre la médiane des trois éléments (gauche, milieu, droit) comme pivot.\nExemples d\u0026rsquo;Erreurs Fréquentes # Le code suivant contient plusieurs erreurs courantes.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Analyse des erreurs :\npivot doit être un nombre du tableau, et non un indice. L\u0026rsquo;utilisation de \u0026lt;= et \u0026gt;= au lieu de \u0026lt; et \u0026gt; peut faire dépasser le pointeur gauche le pointeur droit de plus d\u0026rsquo;une position, ce qui empêche de diviser correctement le tableau en deux parties. Après avoir constaté que l \u0026gt;= r, il faut sortir immédiatement de la boucle sans effectuer d\u0026rsquo;échange. Sinon, on ne peut pas garantir que les éléments à gauche soient inférieurs ou égaux à pivot et que les éléments à droite soient supérieurs ou égaux à pivot. Après chaque échange, il faut exécuter l++ et r--. pivot prend en fait le nombre du milieu gauche. Si l\u0026rsquo;on divise le tableau en utilisant $l - 1$ et $l$, en considérant le tableau [1, 2], on observe facilement que cela conduit à une boucle infinie, divisant continuellement le tableau en deux parties de taille 0 et 2. Inversement, à la fin de la boucle, $r$ est nécessairement inférieur à $right$, on peut donc utiliser $r$ et $r + 1$ pour diviser le tableau. Le lecteur peut simuler le processus de l\u0026rsquo;algorithme pour comprendre pourquoi. Une autre façon simple d\u0026rsquo;éviter la boucle infinie est de choisir un pivot aléatoire ou de gérer spécialement le cas où il n\u0026rsquo;y a que deux éléments. De même, l\u0026rsquo;utilisation de $r$ et $l$ pour distinguer le tableau est également incorrecte. De plus, utiliser $l$, $l+1$ ne fonctionne pas non plus, car cette division ne correspond pas à la définition. Lorsque $r$ est à gauche de $l$, utiliser $l$, $l+1$ ne permet pas de diviser correctement le tableau en deux parties : une partie gauche inférieure ou égale à pivot, et une partie droite supérieure ou égale à pivot. Ce problème suppose que le tableau n\u0026rsquo;est pas vide, donc il n\u0026rsquo;y a pas de cas où left \u0026gt; right. Cependant, il est recommandé d\u0026rsquo;utiliser \u0026gt;=, pour plus de sécurité. Compléments # Le tri rapide peut également être transformé en \u0026ldquo;sélection rapide\u0026rdquo;, qui permet de trouver le $k$-ième plus petit nombre d\u0026rsquo;un tableau non trié en $O(n)$ en temps espéré. L\u0026rsquo;idée est similaire à celle du tri rapide, mais à chaque étape, on ne continue la récursion que sur un seul sous-intervalle, ce qui réduit la complexité temporelle.\n","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse des points clés pour une implémentation correcte de l\u0026rsquo;algorithme de tri rapide.","title":"Tri Rapide","type":"posts"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A4%E0%A5%8D%E0%A4%B5%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"त्वरित सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":" Énoncé du problème # Il y a $N$ objets. Le volume du $i$-ème objet est $s_i$, et sa valeur est $v_i$. Chaque objet ne peut être pris qu\u0026rsquo;une seule fois. Sous la contrainte que le volume total ne dépasse pas $S$, trouvez la valeur totale maximale $V$ qui peut être obtenue.\nFormat d\u0026rsquo;entrée # La première ligne contient deux entiers, $N$ et $S$, séparés par un espace, représentant respectivement le nombre d\u0026rsquo;objets et la contrainte maximale de volume total. Les $N$ lignes suivantes contiennent deux entiers, $s_i$ et $v_i$, séparés par un espace, représentant respectivement le volume et la valeur du $i$-ème objet.\nFormat de sortie # Affichez un entier, représentant la valeur maximale.\nIntervalle de données # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Exemple d\u0026rsquo;entrée # 4 5 1 2 2 4 3 4 4 5 Exemple de sortie # 8 Solution # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale qui peut être obtenue avec les $i$ premiers objets, avec une limite de volume de $j$. Si le $i$-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le $i$-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] Lors de l\u0026rsquo;implémentation de la transition d\u0026rsquo;état, il faut faire attention au domaine de définition. Si $j \u003c s_i$, on ne considère pas le cas où le $i$-ème objet est pris. Parce que si $j-s_i$ est négatif, l\u0026rsquo;indice du tableau n\u0026rsquo;est pas valide. On peut aussi l\u0026rsquo;expliquer ainsi : le volume du $i$-ème objet est supérieur à la limite de volume, donc il est impossible de le prendre. Définir les conditions initiales : avec 0 objet, la valeur obtenue est 0 quelle que soit la limite de volume, c\u0026rsquo;est-à-dire f[0][j] = 0, j $\\in [0, S]$. Complexité temporelle : $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Optimisation DP unidimensionnelle # La compression du tableau bidimensionnel en un tableau unidimensionnel peut économiser considérablement de l\u0026rsquo;espace et améliorer la vitesse d\u0026rsquo;exécution dans une certaine mesure (l\u0026rsquo;inconvénient est qu\u0026rsquo;il est impossible de répondre aux exigences spécifiques de certains types de problèmes). Il est à noter que dans la transition d\u0026rsquo;état, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;à f[i - 1][j] et f[i - 1][j - s[i]]. En d\u0026rsquo;autres termes, dans le tableau bidimensionnel f du code, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;aux éléments de sa ligne précédente qui sont plus à gauche ou dans la même colonne. Par conséquent, le tableau bidimensionnel peut être compressé en un tableau unidimensionnel ou en un tableau déroulant. Notez que dans le code ci-dessous, la deuxième boucle est une itération inverse, car nous devons nous assurer que lors du calcul de f[i][j], f[i - 1][j - s[i]] n\u0026rsquo;a pas encore été mis à jour. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Si le nombre de schémas est requis # Il faut non seulement afficher la valeur totale maximale qui peut être obtenue, mais aussi afficher \u0026ldquo;combien de méthodes de sélection différentes permettent d\u0026rsquo;atteindre cette valeur totale maximale\u0026rdquo;. Voici une introduction à la façon de calculer le nombre de schémas dans le problème du sac à dos 0/1.\nCalcul du nombre de schémas avec la programmation dynamique bidimensionnelle # L\u0026rsquo;exemple suivant prend la programmation dynamique bidimensionnelle comme exemple pour l\u0026rsquo;expliquer.\nDéfinition des états :\ndp[i][j] représente « la valeur maximale qui peut être obtenue avec les i premiers objets, lorsque la capacité (limite de volume) est j ». ways[i][j] représente « le nombre de schémas correspondant pour obtenir la valeur maximale, avec les i premiers objets et une capacité de j ». Transition d\u0026rsquo;état :\nSi le i-ème objet n\u0026rsquo;est pas sélectionné : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Si le i-ème objet est sélectionné (à condition que $j \\ge s_i$) : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Sélectionner ou ne pas sélectionner, la valeur finale de dp[i][j] doit prendre la plus grande des deux : Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ alors cela indique que « la sélection du i-ème objet » donne une plus grande valeur : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ alors cela indique que les deux méthodes obtiennent la même valeur maximale, le nombre de schémas doit être additionné : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ alors cela indique que « la non-sélection du i-ème objet » donne une plus grande valeur, le nombre de schémas hérite du nombre de schémas en cas de non-sélection : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Condition initiale :\ndp[0][j] = 0 signifie que lorsqu\u0026rsquo;il n\u0026rsquo;y a aucun objet, la valeur maximale obtenue avec une capacité quelconque est 0. ways[0][0] = 1 signifie que le cas « 0 objet sélectionné, capacité 0 » est un schéma réalisable (c\u0026rsquo;est-à-dire ne rien sélectionner), et le nombre de schémas est défini sur 1. Pour j \u0026gt; 0, lorsque aucun objet n\u0026rsquo;est sélectionnable et que la capacité est supérieure à 0, il est impossible d\u0026rsquo;obtenir une valeur positive. Le nombre de schémas correspondant est 0, c\u0026rsquo;est-à-dire ways[0][j] = 0. Réponse finale :\ndp[N][S] est la valeur maximale. ways[N][S] est le nombre de schémas pour atteindre cette valeur maximale. Complexité temporelle : $O(NS)$. Ce problème peut également être optimisé avec la programmation dynamique unidimensionnelle. Si la limite de volume exacte est requise # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale avec les i premiers objets avec un volume exactement égal à j. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] On peut noter qu\u0026rsquo;il n\u0026rsquo;y a pas de différence avec la transition d\u0026rsquo;état du problème initial. Cependant, les conditions initiales sont différentes. À l\u0026rsquo;exception de f[0][0] = 0, le reste f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ représente un état impossible. Si la limite de volume $S$ est très grande (1e9), alors que le nombre d\u0026rsquo;objets $N$ et la valeur totale maximale $V$ sont relativement petits # Pour ce type de problème, il existe une solution avec une complexité de $O(NV)$. Définir l\u0026rsquo;état : f[i][j] représente le volume minimal lorsque l\u0026rsquo;on choisit plusieurs objets parmi les i premiers objets dont la somme de valeur est exactement j. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - v[i]] + s[i] Prendre la plus petite des deux valeurs. Condition initiale : f[0][0] = 0, le reste f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ représente un état impossible. Attention, ce n\u0026rsquo;est pas $-\\infty$. La réponse finale est le plus grand j parmi les f[N][j] tels que f[N][j] \u0026lt;= S. Si la limite de volume $S$ et la valeur de chaque objet $v_i$ sont toutes deux très grandes (à l\u0026rsquo;ordre de 1e9), alors que le nombre d\u0026rsquo;objets $N$ est très petit (au plus 40) # Lorsque $N \\leq 20$, on peut énumérer directement tous les sous-ensembles de manière exhaustive (complexité temporelle $O(2^N)$). Lorsque $N \\leq 40$, comme $2^{40}$ est de l\u0026rsquo;ordre de $10^{12}$, l\u0026rsquo;énumération exhaustive directe serait également très importante. On peut alors utiliser la recherche de milieu pour réduire grossièrement la complexité à $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, qui peut être complétée dans un temps acceptable. ","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Le problème de sac à dos classique le plus fondamental.","title":"Problème du sac à dos 0/1","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"Si un espace de solution ordonné peut être divisé en deux parties, où une partie satisfait la condition et l\u0026rsquo;autre partie ne la satisfait pas, alors on peut utiliser la recherche binaire pour trouver le point critique dans l\u0026rsquo;espace de solution ordonné.\nL\u0026rsquo;idée de base de la recherche binaire est de diviser continuellement l\u0026rsquo;intervalle de recherche en deux. À chaque vérification, on examine l\u0026rsquo;élément du milieu. Si l\u0026rsquo;élément du milieu ne satisfait pas la condition, on peut éliminer la moitié de l\u0026rsquo;intervalle. Sinon, on continue la recherche dans l\u0026rsquo;autre moitié de l\u0026rsquo;intervalle. Comme à chaque fois, la moitié de l\u0026rsquo;intervalle de recherche est supprimée, la complexité temporelle de la recherche peut atteindre $O(\\log n)$.\nExemple de problème # Description du problème :\nÉtant donné un tableau d\u0026rsquo;entiers de longueur $n$ trié par ordre croissant, ainsi que $q$ requêtes. Chaque requête donne un entier $k$, et nous devons trouver la « position de début » et la « position de fin » de $k$ dans le tableau (les indices commencent à 0). Si le nombre n\u0026rsquo;existe pas dans le tableau, on retourne -1 -1.\nFormat d\u0026rsquo;entrée # Première ligne : deux entiers $n$ et $q$, indiquant respectivement la longueur du tableau et le nombre de requêtes. Deuxième ligne : $n$ entiers, représentant le tableau complet, déjà trié par ordre croissant. Les $q$ lignes suivantes : chaque ligne contient un entier $k$, représentant un élément de requête. Plage de données # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormat de sortie # Pour chaque requête, affichez sur une ligne la position de début et de fin de l\u0026rsquo;élément dans le tableau. Si l\u0026rsquo;élément n\u0026rsquo;existe pas dans le tableau, affichez -1 -1.\nExemple :\nEntrée : 6 3 1 2 2 3 3 4 3 4 5 Sortie : 3 4 5 5 -1 -1 Explication :\nLa plage d\u0026rsquo;apparition de l\u0026rsquo;élément $3$ est $[3, 4]$ ; L\u0026rsquo;élément $4$ n\u0026rsquo;apparaît qu\u0026rsquo;une seule fois, à la position $5$ ; L\u0026rsquo;élément $5$ n\u0026rsquo;existe pas dans le tableau, donc on retourne $-1$ $-1$. Solution # Recherche de la « position de début » : C\u0026rsquo;est-à-dire, trouver la première position supérieure ou égale à $k$. On peut diviser le tableau en deux parties :\nTous les nombres à gauche sont « inférieurs » à $k$ Tous les nombres à droite sont « supérieurs ou égaux » à $k$ La réponse est la première position à droite. Recherche de la « position de fin » : C\u0026rsquo;est-à-dire, trouver la dernière position inférieure ou égale à $k$. On peut diviser le tableau en deux parties :\nTous les nombres à gauche sont « inférieurs ou égaux » à $k$ Tous les nombres à droite sont « supérieurs » à $k$ La réponse est la dernière position à gauche. Modèle recommandé # Voici un modèle de recherche binaire élégant et peu sujet aux erreurs. Il assure que la boucle se termine lorsque $l$ et $r$ sont adjacents en les faisant progressivement se rapprocher :\nDéfinissez deux pointeurs $l, r$, avec l\u0026rsquo;invariant : l\u0026rsquo;intervalle fermé $[0, l]$ appartient à la partie gauche, l\u0026rsquo;intervalle fermé $[r, n - 1]$ appartient à la partie droite. $l$ et $r$ sont initialisés à $-1$ et $n$.\nLorsque l\u0026rsquo;algorithme se termine, $l$ et $r$ sont adjacents, pointant respectivement vers le dernier élément de la partie gauche et le premier élément de la partie droite.\nComme la solution que nous recherchons peut ne pas exister, si le problème n\u0026rsquo;indique pas qu\u0026rsquo;une solution existe nécessairement, nous devons vérifier si l ou r sont hors limites, et s\u0026rsquo;ils pointent vers la bonne valeur.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Recherche de la position de début de k 15 // Diviser le tableau en deux parties, gauche \u0026lt; k, droite \u0026gt;= k. 16 // La réponse est le plus petit indice de la partie droite. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Si r est hors limites ou nums[r] != k, cela signifie que k n\u0026#39;existe pas 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Recherche de la position de fin de k 33 // Diviser le tableau en deux parties, gauche \u0026lt;= k, droite \u0026gt; k. 34 // La réponse est le plus grand indice de la partie gauche. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Pourquoi écrire comme ça ? # Cette méthode a un invariant strictement défini. Elle s\u0026rsquo;applique simultanément pour trouver à la fois la « position de début » et la « position de fin », sans nécessiter de traitement ou de changement supplémentaires. Certaines méthodes utilisent l == r comme condition d\u0026rsquo;arrêt. Lorsque $l$ et $r$ diffèrent de $1$, cela calculera $mid$ qui sera égal à $l$ ou $r$. Si cela n\u0026rsquo;est pas traité correctement, la mise à jour de $l$ ou $r$ avec $mid$ ne réduira pas l\u0026rsquo;intervalle de recherche, ce qui conduira à une boucle infinie. Inversement, la méthode ici se termine lorsque $l$ et $r$ sont adjacents, garantissant que $mid$ est inférieur à $l$ et supérieur à $r$, et que la mise à jour de $l$ ou $r$ réduira certainement l\u0026rsquo;intervalle de recherche. STL # Si vous utilisez les fonctions lower_bound et upper_bound fournies par C++ STL, vous pouvez également réaliser la même chose :\nlower_bound(first, last, val) retourne « la première position supérieure ou égale à val » upper_bound(first, last, val) retourne « la première position supérieure à val » Par exemple, supposons que nums = {1,2,3,4,4,4,4,4,5,5,6}, et que nous voulions connaître l\u0026rsquo;intervalle d\u0026rsquo;apparition de 4 :\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît 0 fois\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;le premier 4 est à \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;le dernier 4 est à \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; fois\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 pointe vers la première position dont la valeur est supérieure ou égale à $4$. it2 pointe vers la première position dont la valeur est supérieure à $4$. Donc it2 - it1 est le nombre de fois que $4$ apparaît dans le tableau ; it2 - nums.begin() - 1 est la limite droite de $4$. Compléments # La recherche binaire peut également être étendue à la recherche dans une plage de nombres à virgule flottante (comme trouver la racine d\u0026rsquo;une équation), ainsi qu\u0026rsquo;à la recherche ternaire pour trouver l\u0026rsquo;optimum d\u0026rsquo;une fonction unimodale. Tant que vous comprenez le principe central de « dans un intervalle ordonné, vous pouvez à chaque fois éliminer la moitié », vous constaterez que la recherche binaire peut vous aider à résoudre efficacement des problèmes dans de nombreux scénarios.\nExercice # LeetCode 33. Recherche dans un tableau trié pivoté\nConseil : La première étape consiste à utiliser la recherche binaire pour trouver le point de rotation, la deuxième étape consiste à utiliser à nouveau la recherche binaire pour trouver la valeur cible.\n","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Comment implémenter élégamment l\u0026rsquo;algorithme de recherche binaire.","title":"Recherche binaire","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]