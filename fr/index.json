[{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Recherche binaire # Dans une séquence ordonnée, la recherche binaire peut être utilisée pour trouver rapidement un élément spécifique. Comparée à la complexité temporelle de la recherche linéaire $O(n)$, la recherche binaire ne nécessite que $O(\\log n)$ de temps, elle est donc très efficace pour les grandes échelles de données.\nIdée centrale de la recherche binaire # L\u0026rsquo;idée de base de la recherche binaire est de diviser continuellement l\u0026rsquo;intervalle de recherche en deux. À chaque comparaison, l\u0026rsquo;élément du milieu est comparé à la valeur cible. Si l\u0026rsquo;élément du milieu ne satisfait pas la condition, la moitié de l\u0026rsquo;intervalle peut être éliminée ; sinon, la recherche se poursuit dans l\u0026rsquo;autre moitié de l\u0026rsquo;intervalle. Comme la moitié de l\u0026rsquo;intervalle de recherche est rejetée à chaque fois, la complexité temporelle de la recherche peut atteindre $O(\\log n)$.\nLa recherche binaire est très utile pour les problèmes où « les solutions possibles peuvent être divisées en un intervalle ordonné (qui satisfait la condition) et un autre intervalle ordonné (qui ne satisfait pas la condition) ». Par exemple :\nTrouver si un certain élément existe dans un tableau trié Trouver la « première position » ou la « dernière position » où un nombre apparaît Exemple de problème : trouver la position de début et de fin d\u0026rsquo;un élément # Description du problème :\nÉtant donné un tableau d\u0026rsquo;entiers de longueur $n$ trié par ordre croissant, ainsi que $q$ requêtes. Chaque requête donne un entier $k$, et nous devons trouver la « position de début » et la « position de fin » de $k$ dans le tableau (indices commençant à 0). Si le nombre n\u0026rsquo;existe pas dans le tableau, retourner $-1$ $-1$.\nFormat d\u0026rsquo;entrée :\nPremière ligne : deux entiers $n$ et $q$, représentant respectivement la longueur du tableau et le nombre de requêtes. Deuxième ligne : $n$ entiers (dans la plage 1 à 10 000), représentant le tableau complet, déjà trié par ordre croissant. Les $q$ lignes suivantes : chaque ligne contient un entier $k$, représentant un élément de requête. Format de sortie :\nPour chaque requête, afficher sur une ligne les positions de début et de fin de l\u0026rsquo;élément dans le tableau. Si l\u0026rsquo;élément n\u0026rsquo;existe pas dans le tableau, afficher $-1$ $-1$.\nExemple :\nEntrée : 6 3 1 2 2 3 3 4 3 4 5 Sortie : 3 4 5 5 -1 -1 Explication :\nL\u0026rsquo;intervalle où l\u0026rsquo;élément 3 apparaît est [3, 4] ; L\u0026rsquo;élément 4 n\u0026rsquo;apparaît qu\u0026rsquo;une seule fois, à la position 5 ; L\u0026rsquo;élément 5 n\u0026rsquo;existe pas dans le tableau, donc on retourne -1 -1. Idées d\u0026rsquo;application de la recherche binaire # Dans ce problème, afin de trouver la « limite gauche » et la « limite droite » d\u0026rsquo;une certaine valeur, nous pouvons nous appuyer sur la recherche binaire. L\u0026rsquo;essentiel est de comprendre comment définir l\u0026rsquo;intervalle de recherche et comment déplacer les pointeurs en fonction du résultat de la comparaison.\nTrouver la « limite gauche » :\nC\u0026rsquo;est-à-dire, trouver la première position supérieure ou égale à $k$. On peut diviser le tableau en deux parties :\nTous les nombres à gauche sont « inférieurs » à $k$ Tous les nombres à droite sont « supérieurs ou égaux » à $k$ Trouver la « limite droite » :\nC\u0026rsquo;est-à-dire, trouver la dernière position inférieure ou égale à $k$. On peut diviser le tableau en deux parties :\nTous les nombres à gauche sont « inférieurs ou égaux » à $k$ Tous les nombres à droite sont « supérieurs » à $k$ Tant que ces deux intervalles peuvent être correctement maintenus, les résultats peuvent être obtenus rapidement grâce à la recherche binaire.\nModèle recommandé : écrire une recherche binaire qui évite les boucles infinies # Voici un modèle de recherche binaire élégant et peu susceptible d\u0026rsquo;erreurs. En faisant converger progressivement $l$ et $r$, il garantit que la boucle se termine lorsque les deux sont adjacents :\nDéfinir deux pointeurs $l, r$, il existe un invariant : l\u0026rsquo;intervalle fermé $[0, l]$ appartient à la partie gauche, et l\u0026rsquo;intervalle fermé $[r, n - 1]$ appartient à la partie droite. $l$ et $r$ sont tous deux initialisés à $-1$ et $n$.\nLorsque l\u0026rsquo;algorithme se termine, $l$ et $r$ sont adjacents, pointant respectivement vers la valeur maximale de la partie gauche et la valeur minimale de la partie droite.\nÉtant donné que la solution que nous voulons pourrait ne pas exister, lors du retour de $l$ ou de $r$, il est nécessaire de vérifier si la valeur correspondante est bien la valeur que nous voulons, et si elle est hors limites. Par exemple, $l$ représente la valeur maximale de $\\leq k$, et nous devons vérifier si l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Trouver la position de début de k (limite gauche) // Diviser le tableau en deux parties, à gauche tous \u0026lt; k, à droite tous \u0026gt;= k. // La limite gauche est l\u0026#39;indice minimal de la partie droite. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Si r est hors limites ou nums[r] != k, cela signifie que k n\u0026#39;existe pas if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Enregistrer la limite gauche de k // 2. Trouver la position de fin de k (limite droite) // Diviser le tableau en deux parties, à gauche tous \u0026lt;= k, à droite tous \u0026gt; k. // La limite droite est l\u0026#39;indice maximal de la partie gauche. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Comme nous avons déjà vérifié que k existe, nous n\u0026#39;avons pas besoin de vérifier à nouveau ici int rightPos = l; // Limite droite cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Pourquoi cette façon d\u0026rsquo;écrire est-elle moins susceptible d\u0026rsquo;erreurs ? # Cette façon d\u0026rsquo;écrire a des invariants strictement définis. Elle peut trouver à la fois la limite gauche et la limite droite, ce qui peut être appliqué à tous les scénarios. Certaines façons d\u0026rsquo;écrire utilisent $l == r$ comme condition de terminaison. Lorsque $l$ et $r$ sont distants de 1, il en résultera que $mid$ est égal à l ou r. S\u0026rsquo;il n\u0026rsquo;est pas traité correctement, la mise à jour de l ou r en mid, et l\u0026rsquo;intervalle de recherche ne se rétrécissant pas, cela entraînera une boucle infinie. Au contraire, cette façon d\u0026rsquo;écrire se termine lorsque $l$ et $r$ sont adjacents, ce qui évite ce problème. Solution STL : lower_bound et upper_bound # Si l\u0026rsquo;on utilise les fonctions lower_bound et upper_bound fournies par C++ STL, on peut facilement faire la même chose :\nlower_bound(first, last, val) retourne « la première position supérieure ou égale à val » upper_bound(first, last, val) retourne « la première position supérieure à val » Par exemple, supposons que nums = {1,2,3,4,4,4,4,4,5,5,6}, nous voulons connaître l\u0026rsquo;intervalle où apparaît 4 :\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Cela indique que 4 n\u0026#39;existe pas dans le tableau cout \u0026lt;\u0026lt; \u0026#34;4 apparaît 0 fois\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;le premier 4 est à \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;le dernier 4 est à \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 apparaît \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; fois\u0026#34; \u0026lt;\u0026lt; endl; } it1 pointe vers la première position dont la valeur est supérieure ou égale à 4. it2 pointe vers la première position dont la valeur est supérieure à 4.\nPar conséquent, it2 - it1 est le nombre de fois que 4 apparaît dans le tableau ; it2 - nums.begin() - 1 est la limite droite de 4. Ces deux fonctions sont particulièrement pratiques pour rechercher des intervalles ou compter le nombre d\u0026rsquo;occurrences.\nSupplément # La recherche binaire peut également être étendue à la recherche d\u0026rsquo;une plage de nombres à virgule flottante (telle que la recherche de la racine d\u0026rsquo;une équation), ainsi qu\u0026rsquo;à la recherche ternaire pour rechercher le maximum d\u0026rsquo;une fonction unimodale. Tant que vous comprenez le principe central de « dans un intervalle ordonné, chaque fois que l\u0026rsquo;on peut éliminer la moitié », vous constaterez que la recherche binaire peut vous aider à résoudre efficacement des problèmes dans de nombreux scénarios.\nExercices après cours # LeetCode 33. Search in Rotated Sorted Array\nAstuce : utilisez d\u0026rsquo;abord la recherche binaire pour trouver le point de rotation, puis utilisez la recherche binaire pour trouver la valeur cible.\n","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"Recherche binaire","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/fr/series/","section":"Series","summary":"","title":"Series","type":"series"}]