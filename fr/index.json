[{"content":" I. Le théorème CAP # 1.1 Qu\u0026rsquo;est-ce que le théorème CAP ? # Le théorème CAP a été proposé par Eric Brewer en 2000. Son idée centrale est la suivante :\nC (Cohérence) : Tous les nœuds du système voient les mêmes données au même moment. Plus précisément, lorsqu\u0026rsquo;un client lit des données, quel que soit le réplica à partir duquel il lit, le résultat doit être cohérent avec les données les plus récemment validées (généralement, cela fait référence à une cohérence forte/linéaire). A (Disponibilité) : Le système peut toujours fournir des services normaux même en cas de panne partielle. Chaque requête peut obtenir une « réponse valide » dans un délai raisonnable (cela n\u0026rsquo;implique pas nécessairement une réussite, mais aussi une réponse d\u0026rsquo;échec correcte). P (Tolérance au partitionnement) : Le système peut tolérer les partitions réseau (communication inaccessible entre les nœuds). Même si le réseau est divisé, le système peut fournir un certain degré de disponibilité ou de cohérence. Dans un environnement distribué réel, les partitions réseau sont inévitables, donc P est fondamentalement considéré comme une « option obligatoire ». Lorsqu\u0026rsquo;une partition réseau se produit, le système ne peut pas prendre en charge simultanément la forte cohérence et la haute disponibilité des données sur tous les nœuds. Il doit faire un compromis entre C et A, ce qui donne naissance aux deux principaux types : CP et AP.\n1.2 Les limites du théorème CAP # Il convient de souligner que le théorème CAP lui-même est une théorie de niveau relativement élevé, utilisée pour guider les concepts. Il ne faut pas simplement le comprendre comme « soit choisir C, soit choisir A ». Il existe des malentendus courants :\nC n\u0026rsquo;est pas nécessairement une forte cohérence Le C du théorème CAP fait souvent référence à la cohérence au sens le plus strict (c\u0026rsquo;est-à-dire la cohérence linéaire). Cependant, dans les systèmes réels, nous avons de nombreux modèles plus précis à choisir, tels que la cohérence faible, la lecture validée (Read Committed), la cohérence causale (Causal Consistency), etc. La disponibilité n\u0026rsquo;est pas 0 ou 1 Ce n\u0026rsquo;est pas parce que vous choisissez CP que la disponibilité est complètement sacrifiée ; ou que vous choisissez AP que la cohérence n\u0026rsquo;est pas du tout garantie. La disponibilité et la cohérence ont toutes deux différentes marges de compromis et de stratégies de dégradation. La cohérence éventuelle ne viole pas le CAP Il s\u0026rsquo;agit d\u0026rsquo;un compromis très courant, qui échange une cohérence d\u0026rsquo;écriture plus faible contre une disponibilité et un débit plus élevés, et qui converge les données en arrière-plan de manière asynchrone. Par conséquent, le théorème CAP doit être combiné avec divers modèles de cohérence et modèles d\u0026rsquo;architecture à haute disponibilité dans des scénarios spécifiques pour générer une véritable valeur de guidage pratique.\nII. Modèles de cohérence des systèmes distribués # La classification des modèles de cohérence est très riche, mais les modèles courants peuvent être divisés en : forte cohérence et faible cohérence (qui comprend la cohérence éventuelle, la cohérence causale, etc.). Cet article présente principalement la forte cohérence et la cohérence éventuelle, et explique leurs applications courantes dans les modes CP ou AP.\n2.1 Forte cohérence # La forte cohérence (Strong Consistency), également appelée linéarisabilité (Linearizability), fait référence au fait qu\u0026rsquo;une fois qu\u0026rsquo;une opération d\u0026rsquo;écriture est terminée et renvoie un succès, toute opération de lecture ultérieure peut lire le contenu mis à jour. En d\u0026rsquo;autres termes, le système se comporte comme s\u0026rsquo;il avait exécuté toutes les opérations en série.\nImplémentation courante : Elle repose sur la réplication synchrone et un mécanisme de quorum (majorité), et utilise des protocoles (tels que Paxos/Raft) pour garantir qu\u0026rsquo;il n\u0026rsquo;y a qu\u0026rsquo;un seul leader (Leader) valide dans le système. Toutes les opérations sont écrites dans le journal dans l\u0026rsquo;ordre et répliquées sur la plupart des nœuds. Avantages et inconvénients : Avantages : Garantit la correction des données la plus stricte, et les données lues à tout moment ne « reviennent » pas en arrière. Inconvénients : En cas de gigue du réseau, de partitionnement ou de panne du leader, afin de maintenir la cohérence, les opérations d\u0026rsquo;écriture sont souvent bloquées, ce qui entraîne une baisse de la disponibilité globale ; les performances et le débit sont également relativement faibles. 2.2 Cohérence éventuelle # La cohérence éventuelle (Eventual Consistency) est une forme typique de faible cohérence. Elle exige seulement que si le système n\u0026rsquo;a plus de nouvelles opérations de mise à jour, les données de tous les réplicas convergent progressivement vers le même état au fil du temps. Pendant cette période, les utilisateurs qui lisent les données du réplica peuvent voir des valeurs obsolètes, mais elles finiront par devenir cohérentes.\nImplémentation courante : Protocole Gossip, réplication asynchrone multi-réplicas, CRDT (Conflict-free Replicated Data Type), etc. Avantages et inconvénients : Avantages : Haute disponibilité, haut débit, faible latence d\u0026rsquo;écriture et haute tolérance aux partitions réseau. Inconvénients : Nécessite de tolérer une incohérence des données à court terme, une logique d\u0026rsquo;application plus complexe et peut nécessiter une détection et une fusion des conflits. III. Protocoles et algorithmes de cohérence courants # Afin de maintenir la cohérence entre les réplicas du système distribué, l\u0026rsquo;industrie a proposé de nombreux algorithmes et protocoles classiques. Voici une brève introduction à plusieurs d\u0026rsquo;entre eux :\n3.1 Paxos # Paxos est un algorithme de cohérence distribuée proposé par Leslie Lamport dans les années 1990, principalement utilisé pour mettre en œuvre une forte cohérence ou une cohérence linéaire.\nPrincipe de base : Il utilise la division des rôles (Proposeur, Accepteur, Apprenant) pour effectuer plusieurs tours de vote afin de déterminer si une opération ou une valeur est acceptée par la majorité des nœuds. Avantages et inconvénients : Avantages : Il peut toujours parvenir à un consensus en cas de partitionnement du réseau ou de panne de nœud, et présente une grande sécurité. Inconvénients : La mise en œuvre est complexe, le débogage et le dépannage sont difficiles, et plusieurs tours de vote entraînent des performances limitées. L\u0026rsquo;industrie utilise principalement ses variantes (Multi-Paxos, etc.). 3.2 Raft # Raft a été officiellement proposé en 2013. Son objectif est de simplifier la mise en œuvre et la difficulté de compréhension tout en garantissant la même sécurité que Paxos. Il établit un rôle de leader (Leader) stable pour effectuer de manière centralisée la réplication des journaux et la récupération des pannes :\nÉtapes clés : Élection du leader (Leader Election), réplication des journaux (Log Replication), sécurité (Safety), etc. Applications courantes : Etcd, Consul, TiKV, LogCabin, etc. sont tous basés sur Raft pour mettre en œuvre une forte réplication cohérente. Avantages et inconvénients : Avantages : Relativement facile à comprendre, moins de code à mettre en œuvre ; bonnes performances pour les clusters de petite et moyenne taille. Inconvénients : Dépend du nœud principal (Leader), et une panne ou un partitionnement du nœud principal entraînera un blocage temporaire de l\u0026rsquo;écriture ; dans les clusters à grande échelle ou les déploiements interrégionaux, la latence et la disponibilité seront affectées. 3.3 Protocole Gossip # Le protocole Gossip (commérage) n\u0026rsquo;est pas un protocole de consensus traditionnel. Il est principalement utilisé dans des scénarios décentralisés pour échanger des métadonnées ou des informations d\u0026rsquo;état par le biais d\u0026rsquo;interactions aléatoires entre les nœuds, afin de se propager et de converger sur l\u0026rsquo;ensemble du réseau.\nCaractéristiques : Décentralisé, faible coût, échange périodique et aléatoire de messages entre les nœuds. Applications courantes : Cassandra, Riak, gestion des membres distribués (tels que Serf), etc., utilisés pour mettre en œuvre la cohérence éventuelle, la synchronisation de l\u0026rsquo;état des réplicas, etc. Avantages et inconvénients : Avantages : Bonne évolutivité, simple à mettre en œuvre, adapté aux scénarios qui n\u0026rsquo;ont pas d\u0026rsquo;exigences élevées en matière de cohérence et qui ont des exigences élevées en matière d\u0026rsquo;évolutivité. Inconvénients : La garantie de cohérence est faible et des moyens de traitement des conflits de niveau supérieur (tels que CRDT, fusion de numéros de version, etc.) sont nécessaires pour résoudre les conflits. 3.4 2PC / 3PC # Dans les scénarios de transactions distribuées, les protocoles de validation courants sont 2PC (Two-phase Commit) et 3PC (Three-phase Commit) :\n2PC : Le coordinateur informe tous les participants de la « préparation (prepare) ». S\u0026rsquo;ils réussissent tous, il diffuse la « validation (commit) », sinon il diffuse l\u0026rsquo;« annulation (abort) ». 3PC : Une étape est ajoutée sur la base de 2PC pour réduire le blocage causé par une panne unique, mais la mise en œuvre est plus complexe et il existe toujours des problèmes d\u0026rsquo;indisponibilité dans des scénarios extrêmes de partitionnement ou de panne du réseau. Avantages et inconvénients : Avantages : Facile à comprendre, sémantique de transaction claire, largement utilisé dans les bases de données distribuées, les files d\u0026rsquo;attente de messages, etc. Inconvénients : Forte dépendance au coordinateur, risque de blocage ; il peut être impossible de faire avancer la transaction lorsque le réseau est partitionné pendant une longue période. IV. Les deux principaux choix du CAP : CP et AP # Une fois que nous avons déterminé que P est un attribut « obligatoire », si un système distribué veut continuer à fournir des services lors d\u0026rsquo;un partitionnement du réseau, il doit faire un choix entre C et A. La conception courante du système est donc divisée en deux camps principaux : CP et AP.\n4.1 Système CP # CP (Cohérence + Tolérance au partitionnement) : En cas de partitionnement du réseau, le système choisira de donner la priorité à la garantie de la cohérence et de sacrifier la disponibilité si nécessaire.\nImplémentation typique : Consensus majoritaire (Paxos, Raft, etc.), qui nécessite que plus de la moitié des nœuds soient actifs et parviennent à un consensus pour autoriser l\u0026rsquo;écriture. Si le quorum (quorum légal) ne peut pas être atteint ou si le nœud principal tombe en panne, le système bloquera ou rejettera les opérations d\u0026rsquo;écriture afin d\u0026rsquo;éviter une incohérence des données due à une division cérébrale. Applications courantes : Zookeeper, Etcd, Consul, services de verrouillage distribués, gestion des métadonnées distribuées, etc. Processus centraux de transactions financières, systèmes de comptabilité bancaire et autres scénarios qui nécessitent une forte cohérence. Caractéristiques : Possède une garantie de données stricte : il préfère s\u0026rsquo;arrêter plutôt que d\u0026rsquo;avoir un double maître ou une confusion de données. Sacrifie une certaine disponibilité : En cas de partitionnement du réseau ou de basculement, il y aura une fenêtre pendant laquelle le service sera indisponible ou les opérations d\u0026rsquo;écriture seront rejetées. 4.2 Système AP # AP (Disponibilité + Tolérance au partitionnement) : En cas de partitionnement du réseau, le système choisira de donner la priorité à la garantie de la disponibilité et d\u0026rsquo;assouplir la cohérence en même temps.\nImplémentation typique : Cohérence éventuelle, réplication multi-maîtres, protocole Gossip, stratégie de cohérence réglable de style Dynamo, etc. Applications courantes : Bases de données NoSQL (Cassandra, Riak, DynamoDB, etc.), systèmes de mise en cache distribués (Redis Cluster), etc. Réseaux sociaux, collecte de journaux, systèmes de recommandation et autres entreprises qui nécessitent une haute disponibilité, un haut débit et des exigences relativement souples en matière de cohérence des données. Caractéristiques : Même en cas de partitionnement, tous les nœuds continuent de recevoir les requêtes de lecture et d\u0026rsquo;écriture, ce qui garantit que le système est « aussi disponible que possible ». Les données peuvent être temporairement incohérentes, mais elles convergeront progressivement en arrière-plan par le biais d\u0026rsquo;une synchronisation asynchrone et d\u0026rsquo;une fusion des conflits. V. Comment choisir entre CP et AP ? # Dans les systèmes distribués à grande échelle réels, il est rare de ne dépendre que d\u0026rsquo;un seul modèle. Au lieu de cela, différents niveaux de traitement sont effectués pour différentes données ou scénarios commerciaux afin d\u0026rsquo;obtenir l\u0026rsquo;équilibre optimal entre cohérence et disponibilité.\nChoisir CP pour les données essentielles Tels que le solde du compte utilisateur, le paiement des commandes, le flux des transactions financières, etc., qui ont des exigences très élevées en matière de cohérence. Tolérer une indisponibilité temporaire de l\u0026rsquo;écriture causée par une gigue du réseau, mais ne pas tolérer les erreurs de solde ou de montant de transaction. Choisir AP pour les données périphériques ou mises en cache Tels que le cache de la page de détails du produit, les journaux de comportement de l\u0026rsquo;utilisateur, les listes de candidats recommandés, etc., qui ont des exigences de cohérence plus faibles. Accorder plus d\u0026rsquo;importance à la haute concurrence et à la haute disponibilité, et être en mesure de tolérer un certain temps de mise à jour différée ou de lecture erronée. De nombreuses entreprises Internet adopteront une architecture hybride : les processus de transaction centraux utilisent un stockage de type CP (tel qu\u0026rsquo;une base de données relationnelle distribuée ou un stockage distribué avec une forte cohérence) ; les entreprises périphériques ou les scénarios « lecture intensive et écriture rare » utilisent un stockage de type AP ou des solutions de mise en cache.\nVI. Comment CP et AP atteignent-ils une haute concurrence et une cohérence éventuelle ? # 6.1 Comment les systèmes CP gèrent-ils la haute concurrence ? # Bien que les protocoles de consensus soient confrontés à une latence élevée et à un faible débit lorsque la taille d\u0026rsquo;un seul nœud de cluster et le volume de requêtes d\u0026rsquo;écriture sont importants, la concurrence et l\u0026rsquo;évolutivité peuvent toujours être améliorées par les moyens suivants :\nLecture et écriture par lots Regrouper plusieurs opérations d\u0026rsquo;écriture côté client ou dans la couche intermédiaire, et les écrire sur le nœud leader en une seule fois, ce qui réduit les allers-retours sur le réseau et les tours de protocole. Division de la base de données et des tables et multi-clusters Diviser les données en plusieurs clusters (sharding) par logique ou par hachage. Chaque cluster exécute toujours le protocole CP ; les requêtes sont dispersées vers différentes partitions par le biais d\u0026rsquo;une couche de routage ou de proxy. Améliorer la capacité de concurrence globale et limiter l\u0026rsquo;impact des pannes à une seule partition. Le débit d\u0026rsquo;un seul cluster de partition d\u0026rsquo;un système CP est souvent 2 à 10 fois inférieur à celui d\u0026rsquo;un système AP.\n6.2 Comment les systèmes AP garantissent-ils la cohérence éventuelle ? # Les systèmes AP peuvent généralement fournir un débit d\u0026rsquo;écriture et une disponibilité de lecture élevés, mais ils relâchent la cohérence. Par conséquent, il est nécessaire de mettre en œuvre une garantie de convergence de la cohérence en arrière-plan ou dans la couche de logique métier :\nNuméro de version (Vector Clock) ou horodatage logique Attribuer un numéro de version (ou basé sur Lamport Clock / Hybrid Clock) à chaque opération de mise à jour, et effectuer une fusion ou une stratégie de victoire basée sur l\u0026rsquo;horodatage (Last Write Wins) dans les scénarios de conflit. Protocole Gossip / mécanisme d\u0026rsquo;anti-entropie Les nœuds échangent périodiquement les dernières données ou métadonnées, et fusionnent les conflits lorsqu\u0026rsquo;ils sont détectés. Stratégie de cohérence réglable Représentée par le modèle Dynamo, le client peut configurer des paramètres tels que R et W (tels que l\u0026rsquo;écriture de la majorité, la confirmation du réplica), afin d\u0026rsquo;ajuster de manière flexible la cohérence et la disponibilité. Stratégie personnalisée de résolution des conflits Combiner la sémantique métier pour la fusion, par exemple, le panier d\u0026rsquo;achat est fusionné par « union », et le compteur utilise CRDT (G-counter, PN-counter, etc.) pour garantir la monotonie des données. VII. Mise en œuvre d\u0026rsquo;une forte cohérence inter-partitions de CP # Comme mentionné au chapitre VII, la division de la base de données et des tables (Sharding) peut « diviser » la pression d\u0026rsquo;un seul cluster CP en plusieurs sous-clusters afin de prendre en charge une concurrence plus élevée. Cependant, lorsque l\u0026rsquo;entreprise doit effectuer des transactions inter-partitions (c\u0026rsquo;est-à-dire impliquant des mises à jour de plusieurs bases de données ou tables), elle est toujours confrontée au défi de la cohérence multi-partitions. Il existe généralement les idées suivantes :\nTransactions distribuées : 2PC / 3PC Si l\u0026rsquo;application doit effectuer des mises à jour atomiques sur plusieurs partitions, les protocoles de transactions distribuées (tels que 2PC, 3PC) sont généralement utilisés pour coordonner la validation ou l\u0026rsquo;annulation de chaque partition. Problèmes et contre-mesures : 2PC/3PC dépendent tous d\u0026rsquo;un nœud coordinateur, qui peut devenir un goulot d\u0026rsquo;étranglement unique. Dans des situations extrêmes de partitionnement grave du réseau ou de panne du coordinateur, un blocage peut se produire. Généralement, le basculement maître-esclave, la détection de battement de cœur et le mécanisme de délai d\u0026rsquo;attente, la nouvelle tentative idempotente, MVCC, etc. sont utilisés pour réduire l\u0026rsquo;impact du blocage et le risque d\u0026rsquo;incohérence des données. Architecture basée sur les cellules Diviser l\u0026rsquo;entreprise en plusieurs unités autonomes. Les données de chaque unité se trouvent dans le même ensemble de partitions, ce qui garantit que la plupart des transactions ne sont effectuées que dans une seule unité, ce qui réduit les opérations inter-partitions. Utiliser des mécanismes asynchrones ou de cohérence éventuelle à la limite de l\u0026rsquo;unité pour l\u0026rsquo;échange de données, en tenant compte de la haute disponibilité et de la cohérence globales. Base de données distribuée mondiale + protocole de consensus global Par exemple, Google Spanner utilise Paxos sur chaque partition (Shard) pour mettre en œuvre une forte réplication cohérente, puis utilise l\u0026rsquo;API TrueTime pour fournir un horodatage global afin de garantir la cohérence inter-partitions. Cette solution est extrêmement complexe à mettre en œuvre, mais elle peut fournir des capacités de transactions distribuées quasi fortement cohérentes à l\u0026rsquo;échelle mondiale. Résumé : Pour les transactions inter-partitions qui nécessitent strictement une forte cohérence, 2PC/3PC + coordinateur est toujours une solution courante, et la haute disponibilité du coordinateur est améliorée autant que possible pour réduire la possibilité de pannes. Cependant, dans la pratique de l\u0026rsquo;ingénierie, il est nécessaire de réduire autant que possible les opérations d\u0026rsquo;écriture inter-partitions, ou d\u0026rsquo;utiliser l\u0026rsquo;idée de l\u0026rsquo;unité pour limiter la plupart des transactions à une seule partition, ce qui réduit la complexité du système.\nVIII. Discussion sur des cas célèbres # Voici une brève discussion sur plusieurs systèmes distribués qui sont souvent mentionnés dans l\u0026rsquo;industrie, afin de voir leurs compromis et leurs méthodes de mise en œuvre sur CAP :\nGoogle Spanner Un système CP typique (il peut même réaliser l\u0026rsquo;illusion « CA » que le monde extérieur mentionne souvent, mais en substance, il doit toujours sacrifier une partie de la disponibilité). Utiliser l\u0026rsquo;horodatage externe précis fourni par TrueTime + la réplication Paxos à l\u0026rsquo;intérieur de chaque partition pour garantir une forte cohérence entre les centres de données. Convient aux transactions financières mondiales ou aux scénarios qui nécessitent une forte cohérence, mais le coût de l\u0026rsquo;infrastructure est extrêmement élevé. BigTable / HBase En apparence, il est plus orienté CP. La cohérence des métadonnées est garantie par la coordination distribuée entre RegionServer et Master. Cependant, dans le chemin de lecture et d\u0026rsquo;écriture réel, une certaine haute disponibilité peut également être fournie par la réplication asynchrone multi-réplicas, et la cohérence de lecture peut être ajustée en fonction des besoins de l\u0026rsquo;application. AWS DynamoDB Tendance AP. La conception initiale s\u0026rsquo;inspire de l\u0026rsquo;article Dynamo. Le niveau de cohérence peut être ajusté par des paramètres tels que R et W. Le mode par défaut offre une très haute disponibilité et une cohérence éventuelle. La « lecture fortement cohérente » peut également être activée (mais seule la forte cohérence d\u0026rsquo;une seule partition est garantie, pas nécessairement entre les partitions). Cassandra Également une tendance AP. Le protocole Gossip sous-jacent est utilisé pour maintenir l\u0026rsquo;état de la topologie des nœuds. La cohérence de lecture et d\u0026rsquo;écriture peut être configurée avec le nombre de réplicas de lecture et d\u0026rsquo;écriture R / W pour réaliser une transition en douceur de la cohérence éventuelle à une cohérence plus forte. Comparaison visible : Il n\u0026rsquo;existe pas de « AP ou CP » absolu en ingénierie. Il s\u0026rsquo;agit plutôt d\u0026rsquo;un mélange de plusieurs stratégies de cohérence ; la plupart des systèmes offrent un certain degré de cohérence réglable pour s\u0026rsquo;adapter à différents scénarios d\u0026rsquo;application.\nIX. Résumé # Le théorème CAP n\u0026rsquo;est pas une solution unique Les systèmes distribués réels ne peuvent pas simplement dire « Je choisis C et j\u0026rsquo;abandonne A » ou « Je choisis A et j\u0026rsquo;abandonne C ». Il est plus courant dans l\u0026rsquo;industrie de choisir de manière flexible les modes CP ou AP pour différentes dimensions de données et différents types d\u0026rsquo;opérations. Même au sein d\u0026rsquo;un même système, différentes stratégies de tolérance aux pannes et de cohérence sont utilisées pour différentes tables/fonctions. AP n\u0026rsquo;est pas absolument disponible à 100 % Par exemple, Cassandra, DynamoDB, etc. peuvent également ne pas être en mesure de répondre aux requêtes en cas de partitionnement extrême du réseau ou de défaillance à grande échelle des nœuds. Les systèmes AP sont simplement conçus pour avoir tendance à « écrire d\u0026rsquo;abord tant que le réplica est accessible en écriture », sacrifiant une partie de la garantie de cohérence en échange d\u0026rsquo;une disponibilité et d\u0026rsquo;un débit relativement plus élevés. CP peut également essayer d\u0026rsquo;atteindre une haute disponibilité Paxos/Raft peut également fournir une disponibilité de 99,99 % ou même plus dans des circonstances normales, mais il faut investir davantage dans le réseau, le matériel et les coûts d\u0026rsquo;ingénierie, et un blocage de l\u0026rsquo;écriture se produira toujours en cas de partitionnement extrême du réseau, sacrifiant la disponibilité pour maintenir la cohérence. L\u0026rsquo;architecture hybride est le courant dominant Les scénarios de transactions centrales insistent sur une forte cohérence (CP), et les scénarios auxiliaires périphériques ou les canaux de mise en cache utilisent une faible cohérence (AP), et les deux coopèrent. Il est nécessaire de combiner la tolérance de l\u0026rsquo;entreprise, l\u0026rsquo;environnement réseau, l\u0026rsquo;investissement en coûts et les réserves techniques de l\u0026rsquo;équipe pour faire des compromis globaux. Le théorème CAP fournit un cadre de réflexion de haut niveau pour la conception de systèmes distribués, ce qui nous aide à prendre des décisions rationnelles face à la réalité inévitable du partitionnement du réseau. Dans les systèmes réels, il est nécessaire d\u0026rsquo;utiliser des modèles de cohérence, des protocoles de consensus, des mécanismes de réplication multi-réplicas plus riches, ainsi que des pratiques d\u0026rsquo;ingénierie (récupération après sinistre, dégradation, idempotence, fusion des conflits, etc.) pour équilibrer la cohérence et la disponibilité.\n","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735350760948-cap/","section":"Posts","summary":"Discussion de l\u0026rsquo;application du théorème CAP dans les systèmes distribués, de la théorie à la pratique.","title":"Analyse approfondie du théorème CAP : Créer des systèmes distribués à haute concurrence et haute disponibilité","type":"posts"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 décembre 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 décembre 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"Le tri rapide est un algorithme de tri non stable basé sur la comparaison, qui utilise le principe diviser pour régner. Sa complexité temporelle moyenne est de $O(n\\log n)$, et dans le pire des cas, elle est de $O(n^2)$. Sa complexité spatiale est de $O(1)$. L\u0026rsquo;exemple ci-dessous utilise le tri d\u0026rsquo;une séquence d\u0026rsquo;entiers par ordre croissant pour illustrer les détails de son implémentation et les erreurs courantes.\nDescription du problème # Étant donnée une séquence d\u0026rsquo;entiers de longueur $n$, utilisez le tri rapide pour la trier par ordre croissant et affichez le résultat.\nFormat d\u0026rsquo;entrée # La première ligne contient l\u0026rsquo;entier $n$. La deuxième ligne contient $n$ entiers, tous dans l\u0026rsquo;intervalle $[1,10^9]$. Format de sortie # Une ligne contenant la séquence triée. Plage de données # $1 \\leq n \\leq 100000$\nExemple d\u0026rsquo;entrée # 5 3 1 2 4 5 Exemple de sortie # 1 2 3 4 5 Idée du tri rapide # À chaque étape de division du tri rapide, un nombre est choisi arbitrairement comme pivot (ci-dessous, nous choisissons le nombre au milieu).\nDeux pointeurs, gauche L et droit R, se déplacent l\u0026rsquo;un vers l\u0026rsquo;autre. Le pointeur gauche L se déplace de gauche à droite pour trouver le premier nombre supérieur ou égal au pivot, et le pointeur droit R se déplace de droite à gauche pour trouver le premier nombre inférieur ou égal au pivot. Ensuite, ces deux nombres sont échangés.\nCe processus est répété jusqu\u0026rsquo;à ce que les pointeurs gauche et droit se chevauchent ou que le pointeur gauche soit d\u0026rsquo;une position au-delà du pointeur droit. Ceci est appelé une itération.\nAprès chaque déplacement et échange de pointeurs, la structure \u0026ldquo;partie gauche ≤ pivot, partie droite ≥ pivot\u0026rdquo; est garantie de ne pas être violée, c\u0026rsquo;est-à-dire qu\u0026rsquo;il existe un invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nDans l\u0026rsquo;exemple de code ci-dessous, left et right sont les limites de l\u0026rsquo;intervalle fermé en cours de traitement, et pivot est l\u0026rsquo;élément au milieu de l\u0026rsquo;intervalle.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexité et choix du pivot # Étant donné que le tri rapide a une complexité de $O(n^2)$ dans le pire des cas, le choix du pivot est crucial. Si le premier ou le dernier élément est toujours choisi, le pire des cas se produira probablement dans un tableau presque trié.\nEn plus de choisir l\u0026rsquo;élément au milieu, un élément peut être choisi aléatoirement comme pivot, ou la médiane des trois éléments gauche, milieu et droit peut être choisie comme pivot.\nExemples d\u0026rsquo;erreurs courantes # Le code suivant contient plusieurs erreurs courantes.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Analyse des erreurs :\npivot doit être un nombre dans le tableau, pas un indice. Utilisez respectivement \u0026lt; et \u0026gt; au lieu de \u0026lt;= et \u0026gt;=, sinon le pointeur gauche peut dépasser le pointeur droit de plus d\u0026rsquo;une position, ce qui empêche de diviser le tableau en deux parties. Après avoir constaté que l \u0026gt;= r, la boucle doit être immédiatement quittée et l\u0026rsquo;échange ne doit plus être effectué. Sinon, il n\u0026rsquo;est pas garanti que les éléments de gauche ne soient pas supérieurs à pivot et que les éléments de droite ne soient pas inférieurs à pivot. Après chaque échange, l++ et r-- doivent être exécutés. pivot prend en fait le nombre au milieu gauche. Par conséquent, si le tableau est divisé en utilisant $l - 1$ et $l$, il n\u0026rsquo;est pas difficile de constater qu\u0026rsquo;une boucle infinie se produira en divisant continuellement le tableau en deux parties de taille 0 et 2, en considérant le tableau [1, 2]. De même, il n\u0026rsquo;est pas possible de distinguer le tableau en utilisant $r$ et $l$. Au contraire, à la fin d\u0026rsquo;une itération, $r$ est nécessairement inférieur à $right$, donc le tableau peut être divisé en utilisant $r$ et $r+1$. Le lecteur peut simuler le processus de l\u0026rsquo;algorithme pour voir pourquoi. Une autre façon simple d\u0026rsquo;éviter les boucles infinies est de choisir un pivot aléatoire ou de traiter spécialement le cas où il n\u0026rsquo;y a que deux éléments. De plus, utiliser $l$, $l+1$ ne fonctionne pas non plus, car cette division n\u0026rsquo;est pas conforme à la définition. Lorsque $r$ est à gauche de $l$, utiliser $l$, $l+1$ ne peut pas diviser correctement le tableau en deux parties où la partie gauche est inférieure ou égale à pivot et la partie droite est supérieure ou égale à pivot. Ce problème suppose que le tableau n\u0026rsquo;est pas vide, il n\u0026rsquo;y a donc pas de cas où \u0026gt; se produit. Cependant, il est recommandé d\u0026rsquo;utiliser \u0026gt;=, ce qui est plus sûr. Supplément # Le tri rapide peut également être transformé en \u0026ldquo;sélection rapide\u0026rdquo;, qui permet de trouver le $k$-ième plus petit nombre dans un tableau non trié en un temps d\u0026rsquo;exécution attendu de $O(n)$. L\u0026rsquo;idée est similaire à celle du tri rapide, sauf que la récursion ne continue que dans un seul sous-intervalle à chaque fois, ce qui réduit la complexité temporelle.\n","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analyse des points clés pour implémenter correctement l\u0026rsquo;algorithme de tri rapide.","title":"Tri rapide","type":"posts"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 décembre 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":" Problème # Il y a $N$ objets. Le volume du $i$-ème objet est $s_i$, et sa valeur est $v_i$. Chaque objet ne peut être pris qu\u0026rsquo;une seule fois. Sous la condition de ne pas dépasser la limite de volume total maximal $S$, trouvez la valeur totale maximale $V$ qui peut être obtenue.\nFormat d\u0026rsquo;entrée # La première ligne contient deux entiers, $N$ et $S$, séparés par un espace, représentant respectivement le nombre d\u0026rsquo;objets et la limite de volume total maximal. Les $N$ lignes suivantes contiennent chacune deux entiers, $s_i$ et $v_i$, séparés par un espace, représentant respectivement le volume et la valeur du $i$-ème objet.\nFormat de sortie # Affichez un entier représentant la valeur maximale.\nPlage de données # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Exemple d\u0026rsquo;entrée # 4 5 1 2 2 4 3 4 4 5 Exemple de sortie # 8 Solution # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale qui peut être obtenue à partir des $i$ premiers objets avec une limite de volume de $j$. Si le $i$-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le $i$-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] Lors de l\u0026rsquo;implémentation de la transition d\u0026rsquo;état, faites attention à la plage du domaine. Si $j \u003c s_i$, alors ne considérez pas le cas de la prise du $i$-ème objet. Car si $j - s_i$ est négatif, l\u0026rsquo;index du tableau est illégal. Cela peut aussi être expliqué de cette façon : le volume du $i$-ème objet est supérieur à la limite de volume, donc c\u0026rsquo;est impossible. Définir la condition initiale : Pour les $0$ premiers objets, toute limite de volume donne une valeur de $0$, c\u0026rsquo;est-à-dire f[0][j] = 0, j $\\in [0, S]$. Complexité temporelle : $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Optimisation DP 1D # La compression du tableau bidimensionnel en un tableau unidimensionnel peut considérablement économiser de l\u0026rsquo;espace et améliorer la vitesse d\u0026rsquo;exécution dans une certaine mesure (l\u0026rsquo;inconvénient est qu\u0026rsquo;il ne peut pas répondre aux exigences particulières de certains types de problèmes). Notez que dans la transition d\u0026rsquo;état, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;à f[i - 1][j] et f[i - 1][j - s[i]]. En d\u0026rsquo;autres termes, dans le tableau bidimensionnel f du code, f[i][j] n\u0026rsquo;est lié qu\u0026rsquo;aux éléments de la ligne précédente qui sont à sa gauche ou dans la même colonne. Par conséquent, le tableau bidimensionnel peut être compressé en un tableau unidimensionnel ou un tableau roulant. Notez que dans le code ci-dessous, la deuxième boucle itère dans l\u0026rsquo;ordre inverse. C\u0026rsquo;est parce que nous voulons nous assurer que lors du calcul de f[i][j], f[i - 1][j - s[i]] n\u0026rsquo;a pas encore été mis à jour. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Si le nombre de schémas est requis # Non seulement la valeur totale maximale qui peut être obtenue doit être affichée, mais aussi \u0026ldquo;combien de méthodes de sélection différentes peuvent atteindre cette valeur totale maximale\u0026rdquo;. Ce qui suit décrit comment compter le nombre de schémas dans le problème du sac à dos 0/1.\nDP 2D pour compter les schémas # Ce qui suit utilise la DP 2D comme exemple pour expliquer.\nDéfinir l\u0026rsquo;état :\ndp[i][j] représente \u0026ldquo;la valeur maximale qui peut être obtenue en considérant les i premiers objets avec une capacité (limite de volume) de j\u0026rdquo;. ways[i][j] représente \u0026ldquo;le nombre de schémas correspondant à la valeur maximale obtenue en considérant les i premiers objets avec une capacité de j\u0026rdquo;. Transition d\u0026rsquo;état :\nSi le i-ème objet n\u0026rsquo;est pas sélectionné : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Si le i-ème objet est sélectionné (à condition que $ j \\ge s_i $) : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Qu\u0026rsquo;il faille sélectionner ou non, le dp[i][j] final doit prendre le plus grand des deux : Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ alors cela signifie que \u0026ldquo;la sélection du i-ème objet\u0026rdquo; a une plus grande valeur : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ cela signifie que la valeur maximale obtenue par les deux méthodes est la même, alors le nombre de schémas doit être ajouté : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Si $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ alors cela signifie que \u0026ldquo;ne pas sélectionner le i-ème objet\u0026rdquo; a une plus grande valeur, et le nombre de schémas hérite du nombre de schémas lors de la non-sélection : $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Conditions initiales :\ndp[0][j] = 0 signifie que lorsqu\u0026rsquo;il y a 0 objet, la valeur maximale obtenue pour toute capacité est 0. ways[0][0] = 1 signifie que le cas de \u0026ldquo;0 objet, capacité 0\u0026rdquo; est un schéma réalisable (c\u0026rsquo;est-à-dire ne rien sélectionner), et le nombre de schémas est défini sur 1. Pour j \u0026gt; 0, lorsqu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;objet à choisir et que la capacité est supérieure à 0, il est impossible d\u0026rsquo;obtenir une valeur positive, et le nombre de schémas correspondant est 0, c\u0026rsquo;est-à-dire ways[0][j] = 0. Réponse finale :\ndp[N][S] est la valeur maximale. ways[N][S] est le nombre de schémas pour atteindre cette valeur maximale. Complexité temporelle : $O(NS)$. Ce problème peut également être optimisé en utilisant la DP 1D. Si l\u0026rsquo;exigence est d\u0026rsquo;atteindre exactement la limite de volume # Définir l\u0026rsquo;état : f[i][j] représente la valeur maximale lorsque les i premiers objets ont exactement un volume de $j$. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - s[i]] + v[i] On peut noter qu\u0026rsquo;il n\u0026rsquo;y a pas de différence dans la transition d\u0026rsquo;état par rapport au problème d\u0026rsquo;origine. Cependant, les conditions initiales sont différentes. À l\u0026rsquo;exception de f[0][0] = 0, le reste f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ représente un état impossible. Si la limite de volume $S$ est très grande (1e9), tandis que le nombre d\u0026rsquo;objets $N$ et la valeur totale maximale $V$ sont relativement petits # Pour de tels problèmes, il existe une solution avec une complexité de $O(NV)$. Définir l\u0026rsquo;état : f[i][j] représente le volume minimal lors de la sélection de plusieurs objets parmi les i premiers objets, et la valeur totale est exactement j. Si le i-ème objet n\u0026rsquo;est pas pris, alors f[i][j] = f[i - 1][j] Si le i-ème objet est pris, alors f[i][j] = f[i - 1][j - v[i]] + s[i] Prendre le plus petit des deux. Conditions initiales : f[0][0] = 0, le reste f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ représente un état impossible. Notez que ce n\u0026rsquo;est pas $-\\infty$. La réponse finale est le plus grand j dans f[N][j] tel que f[N][j] \u0026lt;= S. Si la limite de volume $S$ et la valeur d\u0026rsquo;un seul objet $v_i$ sont toutes deux très grandes (de l\u0026rsquo;ordre de 1e9), tandis que le nombre d\u0026rsquo;objets $N$ est très petit (pas plus de 40) # Lorsque $N \\leq 20$, tous les sous-ensembles peuvent être directement énumérés par force brute (complexité temporelle $O(2^N)$). Lorsque $N \\leq 40$, puisque $2^{40}$ est de l\u0026rsquo;ordre de $10^{12}$, la force brute directe sera également relativement importante, donc la recherche par rencontre au milieu peut être utilisée pour réduire la complexité à environ $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, ce qui peut être réalisé dans un temps acceptable. ","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Le problème du sac à dos classique le plus basique.","title":"Problème du sac à dos 0/1","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"Si un espace de solution ordonné est divisé en deux parties, où une partie satisfait la condition et l\u0026rsquo;autre partie ne la satisfait pas, alors une recherche binaire peut être utilisée pour trouver le point critique dans l\u0026rsquo;espace de solution ordonné.\nL\u0026rsquo;idée de base de la recherche binaire est de diviser continuellement l\u0026rsquo;intervalle de recherche en deux. À chaque vérification, l\u0026rsquo;élément du milieu est examiné. Si l\u0026rsquo;élément du milieu ne satisfait pas la condition, la moitié de l\u0026rsquo;intervalle peut être éliminée ; sinon, la recherche continue dans l\u0026rsquo;autre moitié de l\u0026rsquo;intervalle. Puisque la moitié de l\u0026rsquo;intervalle de recherche est abandonnée à chaque fois, la complexité temporelle de la recherche peut atteindre $O(\\log n)$.\nExemple de problème # Description du problème : Étant donné un tableau d\u0026rsquo;entiers de longueur $n$ trié par ordre croissant, ainsi que $q$ requêtes. Chaque requête donne un entier $k$, et nous devons trouver la « position de départ » et la « position de fin » de $k$ dans le tableau (les indices commencent à 0). Si le nombre n\u0026rsquo;existe pas dans le tableau, renvoyez -1 -1.\nFormat d\u0026rsquo;entrée # Première ligne : deux entiers $n$ et $q$, représentant respectivement la longueur du tableau et le nombre de requêtes. Deuxième ligne : $n$ entiers, représentant le tableau complet, déjà trié par ordre croissant. Les $q$ lignes suivantes : chaque ligne contient un entier $k$, représentant un élément de requête. Plage de données # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormat de sortie # Pour chaque requête, affichez la position de départ et de fin de l\u0026rsquo;élément dans le tableau sur une seule ligne. Si l\u0026rsquo;élément n\u0026rsquo;existe pas dans le tableau, affichez -1 -1.\nExemple :\nEntrée : 6 3 1 2 2 3 3 4 3 4 5 Sortie : 3 4 5 5 -1 -1 Explication :\nLa plage d\u0026rsquo;apparition de l\u0026rsquo;élément $3$ est $[3, 4]$ ; L\u0026rsquo;élément $4$ n\u0026rsquo;apparaît qu\u0026rsquo;une seule fois, à la position $5$ ; L\u0026rsquo;élément $5$ n\u0026rsquo;existe pas dans le tableau, donc on renvoie $-1$ $-1$. Solution # Trouver la « position de départ » : C\u0026rsquo;est-à-dire trouver la première position supérieure ou égale à $k$. Le tableau peut être divisé en deux parties :\nTous les nombres à gauche sont « inférieurs » à $k$ Tous les nombres à droite sont « supérieurs ou égaux » à $k$ La réponse est la première position à droite Trouver la « position de fin » : C\u0026rsquo;est-à-dire trouver la dernière position inférieure ou égale à $k$. Le tableau peut être divisé en deux parties :\nTous les nombres à gauche sont « inférieurs ou égaux » à $k$ Tous les nombres à droite sont « supérieurs » à $k$ La réponse est la dernière position à gauche Modèle recommandé # Voici un modèle de recherche binaire élégant et peu susceptible de provoquer des erreurs.\nDéfinissez deux pointeurs $l, r$, avec l\u0026rsquo;invariant : l\u0026rsquo;intervalle fermé $[0, l]$ appartient à la partie gauche, l\u0026rsquo;intervalle fermé $[r, n - 1]$ appartient à la partie droite. $l$ et $r$ sont initialisés à $-1$ et $n$.\nLorsque l\u0026rsquo;algorithme se termine, $l$ et $r$ sont adjacents, pointant respectivement vers le dernier élément de la partie gauche et le premier élément de la partie droite.\nÉtant donné que la solution que nous recherchons peut ne pas exister, si le problème n\u0026rsquo;indique pas qu\u0026rsquo;une solution existe nécessairement, nous devons vérifier si l ou r est hors limites et s\u0026rsquo;il pointe vers la bonne valeur.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Trouver la position de départ de k 15 // Diviser le tableau en deux parties, la gauche \u0026lt; k, la droite \u0026gt;= k. 16 // La réponse est l\u0026#39;indice minimum de la partie droite. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Si r est hors limites ou nums[r] != k, cela signifie que k n\u0026#39;existe pas 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Trouver la position de fin de k 33 // Diviser le tableau en deux parties, la gauche \u0026lt;= k, la droite \u0026gt; k. 34 // La réponse est l\u0026#39;indice maximum de la partie gauche. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Avantages # Cette écriture a des invariants strictement définis. Elle s\u0026rsquo;applique à la fois à la recherche de la « position de départ » et de la « position de fin », sans nécessiter de traitement ou de changement supplémentaire. Certaines écritures utilisent l == r comme condition d\u0026rsquo;arrêt. Lorsque $l$ et $r$ diffèrent de $1$, $mid$ sera calculé comme étant égal à $l$ ou $r$. Si cela n\u0026rsquo;est pas traité correctement, la mise à jour de $l$ ou $r$ à $mid$ ne réduira pas l\u0026rsquo;intervalle de recherche, ce qui entraînera une boucle infinie. Au contraire, cette écriture s\u0026rsquo;arrête lorsque $l$ et $r$ sont adjacents, garantissant que $mid$ est inférieur à $l$ et supérieur à $r$, et que l\u0026rsquo;intervalle de recherche sera réduit lors de la mise à jour de $l$ ou $r$. STL # Si vous utilisez les fonctions lower_bound et upper_bound fournies par C++ STL, vous pouvez également faire la même chose :\nlower_bound(first, last, val) renvoie « la première position supérieure ou égale à val » upper_bound(first, last, val) renvoie « la première position supérieure à val » Par exemple, supposons que nums = {1,2,3,4,4,4,4,4,5,5,6}, et que nous voulions connaître l\u0026rsquo;intervalle où apparaît 4 :\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît 0 fois\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;le premier 4 est à \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;le dernier 4 est à \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 apparaît \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; fois\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 pointe vers la première position dont la valeur est supérieure ou égale à $4$. it2 pointe vers la première position dont la valeur est supérieure à $4$. Donc it2 - it1 est le nombre de fois que $4$ apparaît dans le tableau ; it2 - nums.begin() - 1 est la position de la limite droite de $4$. Complément # La recherche binaire peut également être étendue à la recherche dans des plages de nombres à virgule flottante (comme la recherche de racines d\u0026rsquo;équations), ainsi qu\u0026rsquo;à la recherche ternaire pour trouver les valeurs maximales des fonctions unimodales.\nExercice # LeetCode 33. Search in Rotated Sorted Array\nIndice : utilisez la recherche binaire pour trouver le point de rotation dans la première étape, puis utilisez la recherche binaire pour trouver la valeur cible dans la deuxième étape.\n","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Comment implémenter élégamment l\u0026rsquo;algorithme de recherche binaire.","title":"Recherche binaire","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/fr/series/","section":"Series","summary":"","title":"Series","type":"series"}]