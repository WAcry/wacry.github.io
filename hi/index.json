[{"content":" प्रश्न # $N$ वस्तुएँ हैं। $i$वीं वस्तु का आयतन $s_i$ है और मान $v_i$ है। प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त के तहत, प्राप्त किया जा सकने वाला अधिकतम कुल मान $V$ ज्ञात कीजिए।\nइनपुट प्रारूप # पहली पंक्ति में दो पूर्णांक हैं, $N, S$, जो स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा को दर्शाते हैं। इसके बाद $N$ पंक्तियाँ हैं, प्रत्येक पंक्ति में दो पूर्णांक $s_i, v_i$ हैं, जो स्थान से अलग किए गए हैं, जो क्रमशः $i$वीं वस्तु के आयतन और मान को दर्शाते हैं।\nआउटपुट प्रारूप # एक पूर्णांक आउटपुट करें, जो अधिकतम मान को दर्शाता है।\nडेटा सीमा # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ इनपुट नमूना # 4 5 1 2 2 4 3 4 4 5 आउटपुट नमूना # 8 समाधान # स्थिति को परिभाषित करें: f[i][j] पहले $i$ वस्तुओं के लिए अधिकतम मान को दर्शाता है, जहां आयतन सीमा $j$ है। यदि $i$वीं वस्तु को नहीं लिया जाता है, तो f[i][j] = f[i - 1][j] यदि $i$वीं वस्तु को लिया जाता है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] स्थिति स्थानांतरण को लागू करते समय, परिभाषा डोमेन रेंज पर ध्यान दें। यदि $j \u003c s_i$, तो $i$वीं वस्तु को लेने की स्थिति पर विचार न करें। क्योंकि यदि $j-s_i$ एक ऋणात्मक संख्या है, तो सरणी सूचकांक अवैध है। इसे इस प्रकार भी समझा जा सकता है: $i$वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है। प्रारंभिक स्थितियों को परिभाषित करें: पहले $0$ वस्तुओं के लिए, किसी भी आयतन सीमा पर $0$ का मान प्राप्त होता है, अर्थात् f[0][j] = 0, j $\\in [0, S]$। समय जटिलता: $O(NS)$। कोड # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} एक आयामी DP अनुकूलन # दो आयामी सरणी को एक आयामी सरणी में संकुचित करके, आप अंतरिक्ष को काफी हद तक बचा सकते हैं और संचालन की गति को एक निश्चित सीमा तक बढ़ा सकते हैं (नुकसान यह है कि यह कुछ प्रश्न प्रकारों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है)। ध्यान दें कि स्थिति स्थानांतरण में, f[i][j] केवल f[i - 1][j] और f[i - 1][j - s[i]] से संबंधित है। दूसरे शब्दों में, कोड में दो आयामी सरणी f में, f[i][j] केवल अपनी पिछली पंक्ति के उन तत्वों से संबंधित है जो इसके बाईं ओर या उसी कॉलम में हैं, इसलिए दो आयामी सरणी को एक आयामी सरणी या रोलिंग सरणी में संकुचित किया जा सकता है। ध्यान दें कि निम्न कोड में, दूसरी लूप व्युत्क्रम क्रम में पुनरावृति करती है, इसका कारण यह है कि हम यह सुनिश्चित करना चाहते हैं कि f[i][j] की गणना करते समय, f[i - 1][j - s[i]] को अभी तक अपडेट नहीं किया गया है। 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} यदि योजना संख्याओं की आवश्यकता है # न केवल प्राप्त किए जा सकने वाले अधिकतम कुल मान को आउटपुट करें, बल्कि यह भी आउटपुट करें कि \u0026ldquo;कितने अलग-अलग चयन विधियों से यह अधिकतम कुल मान प्राप्त किया जा सकता है\u0026rdquo;। अब 01 बैग समस्या में योजना संख्याओं को कैसे गिना जाए इसका परिचय देते हैं।\nदो-आयामी DP के साथ योजना संख्याओं की गणना करना # अब दो-आयामी DP का उदाहरण लेकर समझाते हैं।\nस्थिति को परिभाषित करें:\ndp[i][j] का अर्थ है \u0026ldquo;पहली i वस्तुओं के लिए, क्षमता (आयतन सीमा) j होने पर प्राप्त किया जा सकने वाला अधिकतम मान\u0026rdquo;। ways[i][j] का अर्थ है \u0026ldquo;पहली i वस्तुओं के लिए, क्षमता j होने पर अधिकतम मान प्राप्त होने पर संबंधित योजना संख्याओं की संख्या\u0026rdquo;। स्थिति स्थानांतरण:\nयदि iवीं वस्तु का चयन नहीं किया जाता है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ यदि iवीं वस्तु का चयन किया जाता है (इस शर्त के साथ कि $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ चयन करें या न करें, अंततः dp[i][j] को दोनों में से बड़ा मान लेना चाहिए: यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;iवीं वस्तु को चुनने\u0026rdquo; का मान बड़ा है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ तो इसका मतलब है कि दोनों तरीकों से प्राप्त अधिकतम मान समान है, इसलिए योजना संख्याओं को जोड़ना चाहिए: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;iवीं वस्तु का चयन न करने\u0026rdquo; का मान बड़ा है, योजना संख्याएं चयन न करने की योजना संख्याओं को प्राप्त करती हैं: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ प्रारंभिक स्थितियां:\ndp[0][j] = 0 का अर्थ है कि पहले 0 वस्तुओं के लिए, किसी भी क्षमता से प्राप्त अधिकतम मान 0 है। ways[0][0] = 1 का अर्थ है कि \u0026ldquo;पहले 0 वस्तुओं, क्षमता 0\u0026rdquo; की यह स्थिति एक व्यवहार्य योजना है (अर्थात, कुछ भी न चुनें), योजना संख्याओं को 1 पर सेट किया गया है। j \u0026gt; 0 के लिए, जब कोई वस्तु चुनने के लिए नहीं है, लेकिन क्षमता 0 से अधिक है, तो कोई भी सकारात्मक मान प्राप्त करना संभव नहीं है, संबंधित योजना संख्या 0 है, अर्थात ways[0][j] = 0। अंतिम उत्तर:\ndp[N][S] अधिकतम मान है। ways[N][S] वह योजना संख्या है जो इस अधिकतम मान को प्राप्त करती है। समय जटिलता: $O(NS)$। इस समस्या को एक आयामी DP के साथ भी अनुकूलित किया जा सकता है। यदि आयतन सीमा को ठीक से प्राप्त करने की आवश्यकता हो # स्थिति को परिभाषित करें: f[i][j] पहली i वस्तुओं के ठीक आयतन $j$ के अधिकतम मान को दर्शाता है। यदि iवीं वस्तु को नहीं लिया जाता है, तो f[i][j] = f[i - 1][j] यदि iवीं वस्तु को लिया जाता है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] आप ध्यान दे सकते हैं कि मूल समस्या के साथ स्थिति स्थानांतरण में कोई अंतर नहीं है। लेकिन प्रारंभिक स्थितियां अलग हैं। f[0][0] = 0 के अलावा, शेष f[0][j] = $-\\infty$, j $\\in [1, S]$। $-\\infty$ एक असंभव स्थिति को दर्शाता है। यदि आयतन सीमा $S$ विशेष रूप से बड़ी (1e9) है, जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मान $V$ अपेक्षाकृत छोटे हैं # ऐसी समस्याओं के लिए, $O(NV)$ की जटिलता वाला समाधान है। स्थिति को परिभाषित करें: f[i][j] का अर्थ है कि पहले i वस्तुओं में से कुछ को चुना गया है, और मानों का योग ठीक j होने पर न्यूनतम आयतन। यदि iवीं वस्तु को नहीं लिया जाता है, तो f[i][j] = f[i - 1][j] यदि iवीं वस्तु को लिया जाता है, तो f[i][j] = f[i - 1][j - v[i]] + s[i] दोनों में से छोटे मान को लें। प्रारंभिक स्थितियां: f[0][0] = 0, शेष f[0][j] = $\\infty$, j $\\in [1, V]$। $\\infty$ एक असंभव स्थिति को दर्शाता है। ध्यान दें कि यह $-\\infty$ नहीं है। अंतिम उत्तर f[N][j] में अधिकतम j है जिससे f[N][j] \u0026lt;= S हो। यदि आयतन सीमा $S$ और एकल वस्तु मान $v_i$ दोनों विशेष रूप से बड़े ($1e9$ के क्रम में) हैं, जबकि वस्तुओं की संख्या $N$ विशेष रूप से छोटी है (अधिकतम 40 से अधिक नहीं) # जब $N \\leq 20$ हो, तो सभी उपसमुच्चयों को सीधे क्रूर बल से गिना जा सकता है (समय जटिलता $O(2^N)$)। जब $N \\leq 40$ हो, तो $2^{40}$ $10^{12}$ के क्रम में होने के कारण, प्रत्यक्ष क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए आधे में विभाजित खोज का उपयोग किया जा सकता है, जिससे जटिलता लगभग $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ तक कम हो जाती है, जिसे स्वीकार्य समय के भीतर पूरा किया जा सकता है। ","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"सबसे बुनियादी क्लासिक बैग समस्या।","title":"01背包 समस्या","type":"posts"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"यदि एक क्रमबद्ध समाधान स्थान को दो भागों में विभाजित किया जाता है, जिनमें से एक भाग शर्त को संतुष्ट करता है, और दूसरा भाग नहीं करता है। तो द्विआधारी खोज का उपयोग क्रमबद्ध समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए किया जा सकता है।\nद्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक जांच में मध्य तत्व की जाँच की जाती है। यदि मध्य तत्व शर्त को पूरा नहीं करता है, तो आधे अंतराल को समाप्त किया जा सकता है; अन्यथा, अन्य आधे अंतराल में खोज जारी रखी जाती है। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग हटा दिया जाता है, इसलिए खोज की समय जटिलता $O(\\log n)$ तक पहुँच सकती है।\nउदाहरण प्रश्न # प्रश्न विवरण: एक आरोही क्रम में व्यवस्थित $n$ लंबाई की पूर्णांक सरणी दी गई है, और $q$ प्रश्न हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ के \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; और \u0026ldquo;अंतिम स्थान\u0026rdquo; (अनुक्रमणिका 0 से शुरू) को खोजने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो -1 -1 लौटाएँ।\nइनपुट प्रारूप # पहली पंक्ति: दो पूर्णांक $n$ और $q$, जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं। दूसरी पंक्ति: $n$ पूर्णांक, जो पूर्ण सरणी को दर्शाते हैं, आरोही क्रम में व्यवस्थित हैं। अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व का प्रतिनिधित्व करता है। डेटा रेंज # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nआउटपुट प्रारूप # प्रत्येक प्रश्न के लिए, सरणी में तत्व का प्रारंभिक और अंतिम स्थान एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो -1 -1 आउटपुट करें।\nउदाहरण:\nइनपुट: 6 3 1 2 2 3 3 4 3 4 5 आउटपुट: 3 4 5 5 -1 -1 स्पष्टीकरण:\nतत्व $3$ की सीमा $[3, 4]$ है; तत्व $4$ केवल एक बार, स्थान $5$ पर दिखाई देता है; तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ। उत्तर # \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; खोजना: अर्थात, $k$ से पहले या उसके बराबर पहली स्थिति खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;कम\u0026rdquo; हैं दाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;अधिक या उसके बराबर\u0026rdquo; हैं उत्तर दाईं ओर का पहला स्थान है \u0026ldquo;अंतिम स्थान\u0026rdquo; खोजना: अर्थात, $k$ से कम या उसके बराबर अंतिम स्थिति खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;कम या उसके बराबर\u0026rdquo; हैं दाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;अधिक\u0026rdquo; हैं उत्तर बाईं ओर का अंतिम स्थान है अनुशंसित टेम्पलेट # नीचे एक सुरुचिपूर्ण और त्रुटि-रहित द्विआधारी टेम्पलेट है। यह $l$ और $r$ को धीरे-धीरे एक-दूसरे के करीब लाकर सुनिश्चित करता है कि लूप दोनों के आसन्न होने पर समाप्त हो जाए:\nदो पॉइंटर्स $l$ और $r$ को परिभाषित करें, जिनमें अपरिवर्तनीय हैं: बंद अंतराल $[0, l]$ सभी बाएं भाग से संबंधित हैं, और बंद अंतराल $[r, n - 1]$ सभी दाएं भाग से संबंधित हैं। $l$ और $r$ दोनों को $-1$ और $n$ पर प्रारंभ किया जाता है।\nएल्गोरिथ्म समाप्त होने पर, $l$ और $r$ आसन्न होते हैं, क्रमशः बाएं भाग के अंतिम तत्व और दाएं भाग के पहले तत्व की ओर इशारा करते हैं।\nक्योंकि वांछित समाधान मौजूद नहीं हो सकता है, इसलिए यदि प्रश्न में यह नहीं बताया गया है कि कोई समाधान निश्चित रूप से मौजूद है, तो हमें यह जांचने की आवश्यकता है कि क्या l या r सीमा से बाहर है, और क्या वह सही मान की ओर इशारा कर रहा है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k का प्रारंभिक स्थान खोजें 15 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt; k, दाईं ओर सभी \u0026gt;= k। 16 // उत्तर दाईं ओर का न्यूनतम सूचकांक है। 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // यदि r सीमा से बाहर है या nums[r] != k है, तो इसका मतलब है कि k मौजूद नहीं है 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k का अंतिम स्थान खोजें 33 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt;= k, दाईं ओर सभी \u0026gt; k। 34 // उत्तर बाएं भाग का अधिकतम सूचकांक है। 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} इस तरह क्यों लिखें # इस लेखन में अपरिवर्तनीयों की सख्त परिभाषा है। यह \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; और \u0026ldquo;अंतिम स्थान\u0026rdquo; दोनों स्थितियों को खोजने के लिए एक साथ लागू होता है, बिना किसी अतिरिक्त प्रसंस्करण और परिवर्तन की आवश्यकता के। कुछ लेखन l == r का उपयोग समापन स्थिति के रूप में करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो यह $mid$ और $l$ या $r$ के बराबर की गणना करेगा। यदि सही ढंग से संसाधित नहीं किया गया, तो $l$ या $r$ को $mid$ के रूप में अपडेट करने पर, खोज अंतराल कम नहीं होगा, जिससे एक अनंत लूप हो सकता है। इसके विपरीत, यहां लिखने की शैली $l$ और $r$ के आसन्न होने पर समाप्त हो जाती है, यह सुनिश्चित करते हुए कि $mid$, $l$ से छोटा और $r$ से बड़ा है। $l$ या $r$ को अपडेट करते समय खोज अंतराल निश्चित रूप से कम हो जाएगा। STL # यदि C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound फ़ंक्शंस का उपयोग करते हैं, तो वही काम पूरा किया जा सकता है:\nlower_bound(first, last, val) \u0026ldquo;val से पहले या उसके बराबर पहले स्थान\u0026rdquo; को लौटाएगा। upper_bound(first, last, val) \u0026ldquo;val से पहले स्थान\u0026rdquo; को लौटाएगा। उदाहरण के लिए, मान लें कि nums = {1,2,3,4,4,4,4,4,5,5,6} है, और हम जानना चाहते हैं कि 4 किस सीमा में है:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 पहले मान को इंगित करता है जो $4$ से अधिक या उसके बराबर है। it2 पहले मान को इंगित करता है जो $4$ से अधिक है।\nइसलिए it2 - it1 सरणी में $4$ की उपस्थिति की संख्या है; it2 - nums.begin() - 1 $4$ की दाईं सीमा है। अतिरिक्त # द्विआधारी खोज को फ़्लोटिंग-पॉइंट संख्या श्रेणी (जैसे समीकरण के मूल की खोज) और त्रिकोणीय खोज को एकल-शिखर वाले फ़ंक्शन के चरम मान को खोजने के लिए भी बढ़ाया जा सकता है। जब तक आप \u0026ldquo;क्रमबद्ध अंतराल में, आप हर बार आधे भाग को बाहर निकाल सकते हैं\u0026rdquo; के मूल सिद्धांत को समझते हैं, तो आप पाएंगे कि द्विआधारी खोज कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकती है।\nअभ्यास # LeetCode 33. Rotated Sorted Array में खोजें\nसंकेत: पहला चरण घुमाव बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"द्विआधारी खोज एल्गोरिथ्म को सुरुचिपूर्ण ढंग से कैसे लागू करें।","title":"द्विआधारी खोज","type":"posts"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]