[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":" एक, CAP प्रमेय # 1.1 CAP प्रमेय क्या है # CAP प्रमेय एरिक ब्रेवर द्वारा 2000 में प्रस्तावित की गई थी, जिसका मूल विचार है:\nC (संगति): सिस्टम में सभी नोड्स एक ही समय में समान डेटा देखते हैं। अधिक सख्ती से कहें तो, जब कोई क्लाइंट डेटा पढ़ता है, तो परिणाम नवीनतम सबमिट किए गए डेटा के अनुरूप होना चाहिए, चाहे वह किसी भी प्रतिलिपि से पढ़ा जाए (आमतौर पर मजबूत संगति/रेखीय संगति को संदर्भित करता है)। A (उपलब्धता): सिस्टम आंशिक विफलताओं के मामले में भी सामान्य सेवाएं प्रदान कर सकता है, और प्रत्येक अनुरोध को उचित समय के भीतर \u0026ldquo;मान्य प्रतिक्रिया\u0026rdquo; मिल सकती है (यह आवश्यक नहीं है कि सभी सफल हों, इसमें सही विफलता प्रतिक्रियाएं भी शामिल हैं)। P (विभाजन सहिष्णुता): सिस्टम नेटवर्क विभाजन (नोड्स के बीच संचार दुर्गम हो जाता है) को सहन कर सकता है, और यहां तक कि अगर नेटवर्क विभाजित हो जाता है, तो सिस्टम कुछ हद तक उपलब्धता या संगति प्रदान कर सकता है। वास्तविक वितरित वातावरण में, नेटवर्क विभाजन अपरिहार्य है, इसलिए P को मूल रूप से \u0026ldquo;अनिवार्य विकल्प\u0026rdquo; माना जाता है। जब नेटवर्क विभाजन होता है, तो सिस्टम सभी नोड्स के डेटा की मजबूत संगति और उच्च उपलब्धता दोनों को एक साथ नहीं रख सकता है, और केवल C और A के बीच चयन कर सकता है, जिसके परिणामस्वरूप CP और AP दो मुख्य प्रकार उत्पन्न होते हैं।\n1.2 CAP प्रमेय की सीमाएँ # यह ध्यान दिया जाना चाहिए कि CAP प्रमेय स्वयं एक अपेक्षाकृत उच्च-स्तरीय सिद्धांत है, जिसका उपयोग वैचारिक मार्गदर्शन के लिए किया जाता है, और इसे \u0026ldquo;या तो C चुनें या A चुनें\u0026rdquo; के रूप में आसानी से नहीं समझा जा सकता है। कुछ सामान्य गलतफहमियाँ हैं:\nC आवश्यक रूप से मजबूत संगति नहीं है CAP प्रमेय में C अक्सर संगति के सबसे सख्त अर्थ (यानी, रैखिक संगति) को संदर्भित करता है। लेकिन वास्तविक प्रणालियों में, हमारे पास कमजोर संगति, पढ़ी गई प्रतिबद्धता (Read Committed), कारण संगति (Causal Consistency) और कई अन्य बारीक मॉडल हैं जिन्हें चुना जा सकता है। उपलब्धता 0 या 1 नहीं है यह नहीं कहा जा सकता है कि CP चुनने का मतलब है कि उपलब्धता पूरी तरह से त्याग दी गई है; या AP चुनने का मतलब है कि संगति की कोई गारंटी नहीं है। उपलब्धता और संगति दोनों में विभिन्न स्तरों के ट्रेड-ऑफ और डिग्रेडेशन रणनीतियाँ हैं। अंतिम संगति CAP का उल्लंघन नहीं करती है यह एक बहुत ही सामान्य समझौता समाधान है, जो उच्च उपलब्धता और थ्रूपुट के लिए कम लेखन संगति का उपयोग करता है, और पृष्ठभूमि में डेटा को अभिसरित करने के लिए अतुल्यकालिक तरीकों का उपयोग करता है। इसलिए, CAP प्रमेय को विभिन्न संगति मॉडल और उच्च उपलब्धता वास्तुकला पैटर्न के साथ विशिष्ट परिदृश्यों में जोड़ा जाना चाहिए ताकि वास्तविक कार्यान्वयन मार्गदर्शन मूल्य उत्पन्न हो सके।\nदो, वितरित प्रणालियों का संगति मॉडल # संगति मॉडल का वर्गीकरण बहुत समृद्ध है, लेकिन सामान्य मुख्यधारा के मॉडल को मोटे तौर पर मजबूत संगति और कमजोर संगति (जिसमें अंतिम संगति, कारण संगति आदि शामिल हैं) में विभाजित किया जा सकता है। यह लेख मुख्य रूप से मजबूत संगति और अंतिम संगति का परिचय देता है, और CP या AP मोड के तहत उनके सामान्य अनुप्रयोगों का वर्णन करता है।\n2.1 मजबूत संगति # मजबूत संगति (Strong Consistency), जिसे रेखीय संगति (Linearizability) भी कहा जाता है, का अर्थ है कि एक बार जब कोई लेखन ऑपरेशन सफलतापूर्वक पूरा हो जाता है, तो कोई भी बाद का पठन ऑपरेशन उस अद्यतन सामग्री को पढ़ सकता है। दूसरे शब्दों में, सिस्टम सभी कार्यों को क्रमिक रूप से निष्पादित करने जैसा दिखता है।\nसामान्य कार्यान्वयन: सिंक्रोनस प्रतिकृति और एक मध्यस्थता (बहुमत) तंत्र पर निर्भर करता है, और यह सुनिश्चित करने के लिए प्रोटोकॉल (जैसे Paxos/Raft) का उपयोग करता है कि सिस्टम में केवल एक प्रभावी नेता (Leader) है, और सभी संचालन क्रम में लॉग में लिखे जाते हैं और अधिकांश नोड्स में दोहराए जाते हैं। फायदे और नुकसान: फायदे: सबसे सख्त डेटा शुद्धता की गारंटी देता है, और किसी भी समय पढ़ा गया डेटा \u0026ldquo;रोलबैक\u0026rdquo; नहीं होता है। नुकसान: नेटवर्क झटकों, विभाजन या नेता की विफलता के मामले में, संगति बनाए रखने के लिए अक्सर लेखन संचालन को अवरुद्ध किया जाएगा, जिससे समग्र उपलब्धता में गिरावट आएगी; प्रदर्शन और थ्रूपुट भी अपेक्षाकृत कम हैं। 2.2 अंतिम संगति # अंतिम संगति (Eventual Consistency) कमजोर संगति का एक विशिष्ट रूप है, जिसके लिए केवल यह आवश्यक है कि यदि सिस्टम में कोई नया अद्यतन ऑपरेशन नहीं है, तो समय के साथ, सभी प्रतियों का डेटा धीरे-धीरे एक ही स्थिति में अभिसरित हो जाएगा। इस दौरान, उपयोगकर्ता प्रतिलिपि डेटा पढ़ सकते हैं, और पुराने मान देख सकते हैं, लेकिन अंततः यह सुसंगत हो जाएगा।\nसामान्य कार्यान्वयन: गॉसिप प्रोटोकॉल, मल्टी-रेप्लिका एसिंक्रोनस रेप्लिकेशन, CRDT (Conflict-free Replicated Data Type), आदि। फायदे और नुकसान: फायदे: उच्च उपलब्धता, उच्च थ्रूपुट, कम लेखन संचालन विलंबता, और नेटवर्क विभाजन के लिए उच्च सहिष्णुता। नुकसान: थोड़े समय के लिए डेटा असंगति को सहन करने की आवश्यकता है, एप्लिकेशन तर्क अधिक जटिल है, और संघर्ष का पता लगाने और विलय करने की आवश्यकता हो सकती है। तीन, सामान्य संगति प्रोटोकॉल और एल्गोरिदम # वितरित सिस्टम प्रतियों के बीच संगति बनाए रखने के लिए, उद्योग ने कई क्लासिक एल्गोरिदम और प्रोटोकॉल प्रस्तावित किए हैं। यहां कुछ का संक्षिप्त परिचय दिया गया है:\n3.1 Paxos # Paxos एक वितरित संगति एल्गोरिथम है जिसे लेस्ली लैम्पपोर्ट ने 1990 के दशक में प्रस्तावित किया था, जिसका उपयोग मुख्य रूप से मजबूत संगति या रैखिक संगति को प्राप्त करने के लिए किया जाता है।\nमूल सिद्धांत: भूमिका विभाजन (प्रस्तावक Proposer, स्वीकर्ता Acceptor, शिक्षार्थी Learner) के माध्यम से कई दौर के मतदान के माध्यम से, यह तय करने के लिए कि क्या किसी ऑपरेशन या मान को अधिकांश नोड्स द्वारा स्वीकार किया जाता है। फायदे और नुकसान: फायदे: नेटवर्क विभाजन और नोड विफलताओं के तहत भी संगति प्राप्त कर सकता है, और इसमें उच्च सुरक्षा है। नुकसान: कार्यान्वयन जटिल है, डिबगिंग और समस्या निवारण मुश्किल है, और कई दौर के मतदान के कारण प्रदर्शन सीमित है। उद्योग में इसके अधिक प्रकार (मल्टी-Paxos, आदि) का उपयोग किया जाता है। 3.2 Raft # Raft को आधिकारिक तौर पर 2013 में प्रस्तावित किया गया था, जिसका लक्ष्य Paxos के समान सुरक्षा सुनिश्चित करते हुए कार्यान्वयन और समझने की कठिनाई को सरल बनाना था। यह एक स्थिर नेता (Leader) भूमिका स्थापित करके, केंद्रीकृत रूप से लॉग प्रतिकृति और विफलता पुनर्प्राप्ति करता है:\nमहत्वपूर्ण चरण: नेता चुनाव (Leader Election), लॉग प्रतिकृति (Log Replication), सुरक्षा (Safety), आदि। सामान्य अनुप्रयोग: Etcd, Consul, TiKV, LogCabin, आदि सभी मजबूत संगति प्रतिकृति को लागू करने के लिए Raft पर आधारित हैं। फायदे और नुकसान: फायदे: अपेक्षाकृत समझने में आसान, कम कार्यान्वयन कोड; छोटे और मध्यम आकार के क्लस्टर के लिए बेहतर प्रदर्शन। नुकसान: मुख्य नोड (नेता) पर निर्भर करता है, और मुख्य नोड की विफलता या विभाजन से थोड़े समय के लिए लेखन अवरुद्ध हो जाएगा; बड़े पैमाने पर क्लस्टर या क्रॉस-क्षेत्रीय परिनियोजन में, विलंबता और उपलब्धता प्रभावित होगी। 3.3 गॉसिप प्रोटोकॉल # गॉसिप (गपशप) प्रोटोकॉल पारंपरिक सहमति प्रोटोकॉल नहीं है, इसका उपयोग मुख्य रूप से विकेन्द्रीकृत परिदृश्यों में नोड्स के बीच यादृच्छिक बातचीत के माध्यम से मेटाडेटा या स्थिति जानकारी का आदान-प्रदान करने के लिए किया जाता है, ताकि पूरे नेटवर्क में प्रसार और अभिसरण हो सके।\nविशेषताएं: विकेन्द्रीकृत, कम ओवरहेड, और नोड्स के बीच आवधिक और यादृच्छिक संदेशों का आदान-प्रदान। सामान्य अनुप्रयोग: कैसेंड्रा, रियाक, वितरित सदस्य प्रबंधन (जैसे सर्फ), आदि, का उपयोग अंतिम संगति, प्रतिलिपि स्थिति सिंक्रनाइज़ेशन आदि को लागू करने के लिए किया जाता है। फायदे और नुकसान: फायदे: अच्छी स्केलेबिलिटी, लागू करने में आसान, उन परिदृश्यों के लिए उपयुक्त है जिनमें संगति की आवश्यकताएं अधिक नहीं हैं और स्केलेबिलिटी की आवश्यकताएं अधिक हैं। नुकसान: संगति की गारंटी कमजोर है, और संघर्षों को अंततः हल करने के लिए उच्च-स्तरीय संघर्ष समाधान विधियों (जैसे CRDT, संस्करण संख्या विलय, आदि) की आवश्यकता है। 3.4 2PC / 3PC # वितरित लेनदेन परिदृश्यों में, सामान्य प्रतिबद्धता प्रोटोकॉल 2PC (दो-चरण प्रतिबद्धता) और 3PC (तीन-चरण प्रतिबद्धता) हैं:\n2PC: समन्वयक सभी प्रतिभागियों को \u0026ldquo;तैयार (prepare)\u0026rdquo; करने के लिए सूचित करता है, और यदि सभी सफल होते हैं, तो \u0026ldquo;प्रतिबद्ध (commit)\u0026rdquo; प्रसारित करता है, अन्यथा \u0026ldquo;रोलबैक (abort)\u0026rdquo; करता है। 3PC: 2PC के आधार पर एक चरण जोड़ा जाता है, जो एकल बिंदु विफलता के कारण होने वाले अवरोध को कम करता है, लेकिन कार्यान्वयन अधिक जटिल है, और अभी भी चरम नेटवर्क विभाजन या विफलता परिदृश्यों के तहत अनुपलब्धता की समस्या है। फायदे और नुकसान: फायदे: समझने में आसान, लेनदेन शब्दार्थ स्पष्ट हैं, और वितरित डेटाबेस, संदेश कतारों आदि में व्यापक रूप से उपयोग किए जाते हैं। नुकसान: समन्वयक पर मजबूत निर्भरता, अवरोध का जोखिम; जब नेटवर्क लंबे समय तक विभाजित होता है, तो लेनदेन को आगे बढ़ाना संभव नहीं हो सकता है। चार, CAP के दो मुख्यधारा के विकल्प: CP और AP # जब हम मानते हैं कि P एक \u0026ldquo;अनिवार्य\u0026rdquo; विशेषता है, तो यदि वितरित सिस्टम नेटवर्क विभाजन के दौरान सेवाएं प्रदान करना जारी रखना चाहता है, तो उसे C और A के बीच चयन करना होगा। इसलिए, सामान्य सिस्टम डिज़ाइन CP और AP के दो प्रमुख शिविरों में विभाजित हो गया है।\n4.1 CP सिस्टम # CP (संगति + विभाजन सहिष्णुता): जब नेटवर्क विभाजन का सामना करना पड़ता है, तो सिस्टम संगति को प्राथमिकता देना चुनता है, और आवश्यकता पड़ने पर उपलब्धता का त्याग करता है।\nविशिष्ट कार्यान्वयन: बहुमत सहमति (Paxos, Raft, आदि), जिसके लिए आधे से अधिक नोड्स को जीवित रहने और एक समझौते पर पहुंचने की आवश्यकता होती है ताकि लेखन की अनुमति दी जा सके। यदि वर्तमान में कोरम (कानूनी संख्या) तक नहीं पहुंचा जा सकता है या मुख्य नोड विफल हो जाता है, तो सिस्टम मस्तिष्क विभाजन के कारण डेटा असंगति को रोकने के लिए लेखन संचालन को अवरुद्ध या अस्वीकार कर देगा। सामान्य अनुप्रयोग: ज़ूकीपर, एटसीडी, कंसुल, वितरित लॉक सेवाएं, वितरित मेटाडेटा प्रबंधन, आदि। वित्तीय लेनदेन मुख्य प्रक्रियाएं, बैंक लेखा प्रणाली और अन्य उच्च संगति आवश्यकताओं वाले परिदृश्य। विशेषताएं: सख्त डेटा गारंटी है: दोहरे मुख्य या डेटा भ्रम से बचने के लिए शटडाउन करना बेहतर है। कुछ उपलब्धता का त्याग करें: नेटवर्क विभाजन या विफलता स्विचओवर के मामले में, एक सेवा अनुपलब्ध होगी या लेखन संचालन को अस्वीकार करने की अवधि होगी। 4.2 AP सिस्टम # AP (उपलब्धता + विभाजन सहिष्णुता): जब नेटवर्क विभाजन का सामना करना पड़ता है, तो सिस्टम उपलब्धता को प्राथमिकता देना चुनता है, और साथ ही संगति को कम करता है।\nविशिष्ट कार्यान्वयन: अंतिम संगति, मल्टी-मास्टर प्रतिकृति, गॉसिप प्रोटोकॉल, डायनेमो-शैली समायोज्य संगति नीतियां, आदि। सामान्य अनुप्रयोग: NoSQL डेटाबेस (कैसेंड्रा, रियाक, डायनेमोडीबी, आदि), वितरित कैशिंग सिस्टम (रेडिस क्लस्टर), आदि। सोशल नेटवर्क, लॉग संग्रह, अनुशंसा प्रणाली और अन्य व्यवसाय जिन्हें उच्च उपलब्धता और उच्च थ्रूपुट की आवश्यकता होती है, और डेटा संगति के लिए अपेक्षाकृत कम आवश्यकताएं होती हैं। विशेषताएं: विभाजन होने पर भी, सभी नोड्स अभी भी पढ़ने और लिखने के अनुरोधों को स्वीकार करते हैं, यह सुनिश्चित करते हुए कि सिस्टम \u0026ldquo;जहां तक संभव हो उपलब्ध\u0026rdquo; है। डेटा में थोड़े समय के लिए असंगति हो सकती है, लेकिन यह पृष्ठभूमि में अतुल्यकालिक सिंक्रनाइज़ेशन और संघर्ष विलय जैसे तरीकों से धीरे-धीरे अभिसरित हो जाएगा। पांच, CP और AP में कैसे चयन करें? # वास्तविक बड़े पैमाने पर वितरित प्रणालियों में, यह अक्सर केवल एक मॉडल पर निर्भर नहीं होता है, बल्कि विभिन्न डेटा या व्यावसायिक परिदृश्यों को स्तरित तरीके से संसाधित करता है, ताकि संगति और उपलब्धता का इष्टतम संतुलन प्राप्त किया जा सके।\nमुख्य डेटा CP चुनें जैसे उपयोगकर्ता खाता शेष, ऑर्डर भुगतान, वित्तीय लेनदेन प्रवाह, आदि, जिनकी संगति के लिए बहुत अधिक आवश्यकताएं हैं। नेटवर्क झटकों के कारण होने वाले थोड़े समय के लिए गैर-लेखन को सहन करें, लेकिन शेष राशि या लेनदेन राशि में त्रुटियों को सहन न करें। परिधीय या कैश डेटा AP चुनें जैसे उत्पाद विवरण पृष्ठ का कैश, उपयोगकर्ता व्यवहार लॉग, अनुशंसा उम्मीदवार सूची, आदि, जिनकी संगति के लिए कम आवश्यकताएं हैं। उच्च समवर्तीता और उच्च उपलब्धता पर अधिक ध्यान दें, और कुछ समय के लिए विलंबित अपडेट या गंदे पढ़ने को सहन करने में सक्षम हों। कई इंटरनेट कंपनियां मिश्रित वास्तुकला को अपनाएंगी: मुख्य लेनदेन प्रक्रियाएं CP-शैली भंडारण (जैसे वितरित संबंधपरक डेटाबेस या मजबूत संगति के साथ वितरित भंडारण) का उपयोग करती हैं; परिधीय व्यवसाय या \u0026ldquo;अधिक पढ़ें और कम लिखें\u0026rdquo; परिदृश्य AP-शैली भंडारण या कैशिंग समाधान का उपयोग करते हैं।\nछह, CP और AP उच्च समवर्तीता और अंतिम संगति को कैसे प्राप्त करते हैं # 6.1 CP सिस्टम उच्च समवर्तीता से कैसे निपटते हैं # हालांकि सहमति प्रोटोकॉल को एकल क्लस्टर नोड आकार और उच्च लेखन अनुरोध मात्रा के मामले में उच्च विलंबता और कम थ्रूपुट का सामना करना पड़ेगा, फिर भी समवर्तीता और स्केलेबिलिटी को निम्नलिखित तरीकों से बढ़ाया जा सकता है:\nबैच पढ़ना और लिखना कई लेखन संचालन को क्लाइंट या मध्य परत में पैकेज करें, और उन्हें एक बार में नेता नोड पर लिखें, जिससे नेटवर्क राउंड ट्रिप और प्रोटोकॉल राउंड कम हो जाएं। डेटाबेस और टेबल का विभाजन और बहु-क्लस्टर डेटा को तार्किक या हैश द्वारा कई क्लस्टर (शार्डिंग) में विभाजित करें, और प्रत्येक क्लस्टर के अंदर CP प्रोटोकॉल चलाएं; अनुरोधों को रूटिंग या प्रॉक्सी परत के माध्यम से विभिन्न शार्ड में फैलाएं। समग्र समवर्ती क्षमता में सुधार करें, और विफलता के प्रभाव को एकल शार्ड तक सीमित करें। CP सिस्टम का एकल शार्ड क्लस्टर थ्रूपुट अक्सर AP सिस्टम की तुलना में 2 से 10 गुना कम होता है।\n6.2 AP सिस्टम अंतिम संगति की गारंटी कैसे देते हैं # AP सिस्टम आमतौर पर उच्च लेखन थ्रूपुट और पढ़ने की उपलब्धता प्रदान करने में सक्षम होते हैं, लेकिन संगति में ढील देते हैं, इसलिए पृष्ठभूमि या व्यावसायिक तर्क परत में संगति अभिसरण की गारंटी को लागू करने की आवश्यकता होती है:\nसंस्करण संख्या (वेक्टर क्लॉक) या तार्किक टाइमस्टैम्प प्रत्येक अद्यतन ऑपरेशन को एक संस्करण संख्या (या लैम्पपोर्ट क्लॉक / हाइब्रिड क्लॉक पर आधारित) असाइन करें, और संघर्ष परिदृश्यों में विलय करें या टाइमस्टैम्प-आधारित जीत रणनीति (अंतिम लेखन जीत) का उपयोग करें। गॉसिप प्रोटोकॉल / एंटी-एंट्रॉपी तंत्र नोड्स समय-समय पर नवीनतम डेटा या मेटाडेटा का आदान-प्रदान करते हैं, और यदि संघर्ष पाए जाते हैं तो उन्हें मर्ज करते हैं। समायोज्य संगति नीतियां डायनेमो मॉडल द्वारा दर्शाए गए, क्लाइंट R, W और अन्य मापदंडों (जैसे बहुमत लिखना, प्रतिलिपि पुष्टिकरण) को कॉन्फ़िगर कर सकते हैं, ताकि संगति और उपलब्धता के बीच लचीले ढंग से समायोजित किया जा सके। कस्टम संघर्ष समाधान नीतियां व्यावसायिक शब्दार्थ के साथ विलय करें, जैसे कि शॉपिंग कार्ट को \u0026ldquo;संघ\u0026rdquo; के साथ विलय करना, और काउंटर को CRDT (G-काउंटर, PN-काउंटर, आदि) के साथ डेटा की एकरसता की गारंटी देना। सात, CP का क्रॉस-शार्ड मजबूत संगति कार्यान्वयन # अध्याय सात में, यह उल्लेख किया गया था कि डेटाबेस और टेबल (शार्डिंग) को विभाजित करके, एकल CP क्लस्टर के दबाव को उच्च समवर्तीता का समर्थन करने के लिए कई उप-क्लस्टर में \u0026ldquo;विभाजित\u0026rdquo; किया जा सकता है। हालांकि, जब व्यवसाय को शार्ड में लेनदेन करने की आवश्यकता होती है (यानी, कई डेटाबेस या टेबल के अपडेट शामिल होते हैं), तो अभी भी बहु-शार्ड संगति की चुनौती का सामना करना पड़ता है। आमतौर पर निम्नलिखित विचार होते हैं:\nवितरित लेनदेन: 2PC / 3PC यदि एप्लिकेशन को कई शार्ड में परमाणु अपडेट करने की आवश्यकता है, तो आमतौर पर प्रत्येक शार्ड की प्रतिबद्धता या रोलबैक को समन्वयित करने के लिए वितरित लेनदेन प्रोटोकॉल (जैसे 2PC, 3PC) का उपयोग किया जाता है। समस्याएँ और उपाय: 2PC/3PC दोनों एक समन्वयक नोड पर निर्भर करते हैं, जो एक एकल बिंदु बाधा बन सकता है। गंभीर नेटवर्क विभाजन या समन्वयक विफलता के चरम मामलों में, अवरोध हो सकता है। सामान्य तौर पर, अवरोध प्रभाव और डेटा असंगति जोखिम को कम करने के लिए मास्टर-स्लेव स्विचिंग, हार्टबीट डिटेक्शन और टाइमआउट तंत्र, आइडमपोटेंट रीट्राय, MVCC आदि का उपयोग किया जाएगा। सेल-आधारित वास्तुकला व्यवसाय को कई स्वायत्त इकाइयों में विभाजित करें, और प्रत्येक इकाई में डेटा एक ही शार्ड सेट में है, यह सुनिश्चित करते हुए कि अधिकांश लेनदेन केवल एक इकाई में पूरे होते हैं, जिससे क्रॉस-शार्ड संचालन कम हो जाते हैं। इकाई सीमाओं पर डेटा का आदान-प्रदान करने के लिए अतुल्यकालिक या अंतिम संगति तंत्र का उपयोग करें, समग्र उच्च उपलब्धता और संगति दोनों को ध्यान में रखते हुए। वैश्विक वितरित डेटाबेस + वैश्विक सहमति प्रोटोकॉल उदाहरण के लिए, Google स्पैनर प्रत्येक शार्ड पर Paxos के माध्यम से प्रतिलिपि की मजबूत संगति प्रतिकृति को लागू करता है, और फिर क्रॉस-शार्ड संगति सुनिश्चित करने के लिए वैश्विक टाइमस्टैम्प प्रदान करने के लिए TrueTime API का उपयोग करता है। इस योजना में कार्यान्वयन की जटिलता बहुत अधिक है, लेकिन यह वैश्विक स्तर पर मजबूत संगति के करीब वितरित लेनदेन क्षमता प्रदान कर सकती है। सारांश: मजबूत संगति की सख्त आवश्यकता वाले क्रॉस-शार्ड लेनदेन के लिए, 2PC/3PC + समन्वयक अभी भी एक सामान्य समाधान है, और समन्वयक की उच्च उपलब्धता को यथासंभव बढ़ाकर विफलता की संभावना को कम किया जाता है। लेकिन इंजीनियरिंग अभ्यास में, क्रॉस-शार्ड लेखन संचालन को कम करने या सिस्टम की जटिलता को कम करने के लिए यूनिटाइजेशन विचारों के माध्यम से अधिकांश लेनदेन को एकल शार्ड सीमा तक सीमित करने की आवश्यकता है।\nआठ, प्रसिद्ध केस स्टडी # आइए संक्षेप में कुछ वितरित प्रणालियों पर चर्चा करें जिनका उद्योग में अक्सर उल्लेख किया जाता है, और देखें कि वे CAP पर कैसे चयन और कार्यान्वयन करती हैं:\nGoogle स्पैनर एक विशिष्ट CP सिस्टम (यहां तक कि \u0026ldquo;CA\u0026rdquo; भ्रम भी पैदा कर सकता है जिसे बाहरी दुनिया अक्सर कहती है, लेकिन सार में, इसे अभी भी कुछ उपलब्धता का त्याग करने की आवश्यकता है)। TrueTime द्वारा प्रदान किए गए बाहरी सटीक टाइमस्टैम्प + प्रत्येक शार्ड के अंदर Paxos प्रतिकृति का उपयोग करके, यह क्रॉस-डेटा सेंटर मजबूत संगति की गारंटी देता है। वैश्विक वित्तीय लेनदेन या उच्च संगति आवश्यकताओं वाले परिदृश्यों के लिए उपयुक्त, लेकिन बुनियादी ढांचे की लागत बहुत अधिक है। बिगटेबल / एचबेस सतह पर CP की ओर अधिक झुकाव, रीजनसर्वर और मास्टर के बीच वितरित समन्वय के माध्यम से मेटाडेटा की संगति सुनिश्चित करना। लेकिन वास्तविक पढ़ने और लिखने के पथ में, यह बहु-प्रतिलिपि अतुल्यकालिक प्रतिकृति के माध्यम से उच्च उपलब्धता के कुछ साधन भी प्रदान कर सकता है, और पढ़ने की संगति को एप्लिकेशन आवश्यकताओं के अनुसार समायोजित किया जा सकता है। AWS डायनेमोडीबी AP की ओर झुकाव, प्रारंभिक डिज़ाइन प्रेरणा डायनेमो पेपर से आई है, और R, W और अन्य मापदंडों के माध्यम से संगति स्तर को समायोजित किया जा सकता है। डिफ़ॉल्ट मोड के तहत, यह बहुत उच्च उपलब्धता और अंतिम संगति प्रदान करता है, और \u0026ldquo;मजबूत संगति पढ़ना\u0026rdquo; भी चालू किया जा सकता है (लेकिन यह केवल एकल विभाजन की मजबूत संगति की गारंटी देता है, आवश्यक नहीं कि क्रॉस-विभाजन)। कैसेंड्रा यह भी AP की ओर झुकाव है, और अंतर्निहित गॉसिप प्रोटोकॉल का उपयोग नोड टोपोलॉजी स्थिति को बनाए रखने के लिए किया जाता है। पढ़ने और लिखने की संगति को पढ़ने और लिखने की प्रतिलिपि संख्या R / W को कॉन्फ़िगर किया जा सकता है, ताकि अंतिम संगति से मजबूत संगति में एक सहज संक्रमण प्राप्त किया जा सके। तुलना से देखा जा सकता है: इंजीनियरिंग में कोई पूर्ण \u0026ldquo;AP या CP\u0026rdquo; नहीं है, बल्कि विभिन्न संगति रणनीतियों का मिश्रण है; अधिकांश सिस्टम विभिन्न अनुप्रयोग परिदृश्यों के अनुकूल होने के लिए कुछ हद तक समायोज्य संगति प्रदान करते हैं।\nनौ, निष्कर्ष # CAP प्रमेय एक आकार-फिट-सभी नहीं है वास्तविक वितरित प्रणालियाँ यह नहीं कह सकती हैं कि \u0026ldquo;मैं C चुनता हूँ और A छोड़ देता हूँ\u0026rdquo; या \u0026ldquo;मैं A चुनता हूँ और C छोड़ देता हूँ\u0026rdquo;। उद्योग में अधिक सामान्य बात यह है कि विभिन्न डेटा आयामों और विभिन्न प्रकार के संचालन के लिए, लचीले ढंग से CP या AP मोड का चयन करें, और यहां तक कि एक ही सिस्टम के भीतर, विभिन्न तालिकाओं/विभिन्न कार्यों के लिए विभिन्न दोष सहिष्णुता और संगति रणनीतियों को अपनाएं। AP बिल्कुल 100% उपलब्ध नहीं है उदाहरण के लिए, कैसेंड्रा, डायनेमोडीबी, आदि भी चरम नेटवर्क विभाजन या नोड के बड़े पैमाने पर विफल होने पर अनुरोधों को पूरा करने में विफल रहेंगे। AP सिस्टम केवल डिज़ाइन में \u0026ldquo;जब तक प्रतिलिपि लिखने योग्य है, तब तक पहले लिखें\u0026rdquo; की ओर झुकाव रखते हैं, और अपेक्षाकृत उच्च उपलब्धता और थ्रूपुट के बदले में संगति की कुछ गारंटी का त्याग करते हैं। CP भी उच्च उपलब्धता प्राप्त करने की पूरी कोशिश कर सकता है Paxos/Raft सामान्य परिस्थितियों में 99.99% या उससे भी अधिक उपलब्धता प्रदान कर सकते हैं, लेकिन इसके लिए अधिक नेटवर्क, हार्डवेयर और इंजीनियरिंग लागतों का निवेश करने की आवश्यकता होती है, और चरम नेटवर्क विभाजन के मामले में, यह अभी भी लेखन को अवरुद्ध करेगा और संगति बनाए रखने के लिए उपलब्धता का त्याग करेगा। मिश्रित वास्तुकला मुख्यधारा है मुख्य लेनदेन परिदृश्य मजबूत संगति (CP) पर जोर देते हैं, और परिधीय सहायक परिदृश्य या कैशिंग चैनल कमजोर संगति (AP) को अपनाते हैं, और दोनों एक दूसरे के साथ सहयोग करते हैं। व्यावसायिक सहिष्णुता, नेटवर्क वातावरण, लागत निवेश और टीम के तकनीकी भंडार के साथ मिलकर व्यापक रूप से चयन करना आवश्यक है। CAP प्रमेय वितरित प्रणालियों के डिजाइन के लिए एक उच्च-स्तरीय सोच ढांचा प्रदान करता है, जो हमें नेटवर्क विभाजन की अपरिहार्य वास्तविकता का सामना करने पर तर्कसंगत निर्णय लेने में मदद करता है। वास्तविक प्रणालियों में, संगति और उपलब्धता को संतुलित करने के लिए अधिक समृद्ध संगति मॉडल, सहमति प्रोटोकॉल, बहु-प्रतिलिपि प्रतिकृति तंत्र और इंजीनियरिंग अभ्यास (विपत्ति रिकवरी, डिग्रेडेशन, आइडमपोटेंस, संघर्ष विलय, आदि) की आवश्यकता होती है।\n","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735350760948-cap/","section":"Posts","summary":"वितरित प्रणालियों में CAP प्रमेय के अनुप्रयोग पर सिद्धांत से अभ्यास तक चर्चा।","title":"CAP प्रमेय का गहन विश्लेषण: उच्च समवर्ती और उच्च उपलब्धता वाली वितरित प्रणालियों का निर्माण","type":"posts"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 दिसंबर 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"क्विक सॉर्ट एक तुलना-आधारित अस्थिर सॉर्टिंग एल्गोरिथम है, जो विभाजन और जीत की विचारधारा का उपयोग करता है, जिसकी औसत समय जटिलता $O(n\\log n)$ है, सबसे खराब स्थिति में $O(n^2)$ है, और स्थान जटिलता $O(1)$ है। नीचे, एक पूर्णांक अनुक्रम को छोटे से बड़े क्रम में सॉर्ट करने का एक उदाहरण लेते हुए, इसके कार्यान्वयन विवरण और सामान्य त्रुटियों का परिचय दिया गया है।\nसमस्या विवरण # एक लंबाई $n$ के पूर्णांक अनुक्रम को देखते हुए, इसे छोटे से बड़े क्रम में सॉर्ट करने के लिए क्विक सॉर्ट का उपयोग करें और परिणाम आउटपुट करें।\nइनपुट प्रारूप # पहली पंक्ति में पूर्णांक $n$ इनपुट करें दूसरी पंक्ति में $n$ पूर्णांक इनपुट करें, सभी $[1,10^9]$ सीमा में आउटपुट प्रारूप # एक पंक्ति में सॉर्ट किए गए अनुक्रम को आउटपुट करें डेटा सीमा # $1 \\leq n \\leq 100000$\nइनपुट नमूना # 5 3 1 2 4 5 आउटपुट नमूना # 1 2 3 4 5 क्विक सॉर्ट विचार # क्विक सॉर्ट प्रत्येक विभाजन के समय, एक संख्या को आधार संख्या pivot के रूप में चुनता है (नीचे मध्य स्थिति की संख्या का चयन करें)।\nबाएं और दाएं पॉइंटर्स का उपयोग विपरीत दिशाओं में जाने के लिए करें, बाएं पॉइंटर L बाएं से दाएं पहले pivot से अधिक या उसके बराबर संख्या की तलाश करता है, दाएं पॉइंटर R दाएं से बाएं पहले pivot से कम या उसके बराबर संख्या की तलाश करता है, और फिर इन दो संख्याओं का आदान-प्रदान करें।\nइस प्रक्रिया को तब तक दोहराते रहें जब तक कि बाएं पॉइंटर और दाएं पॉइंटर ओवरलैप न हो जाएं या बाएं पॉइंटर दाएं पॉइंटर से एक स्थान बड़ा न हो जाए। इसे एक चक्र कहा जाता है।\nप्रत्येक पॉइंटर मूवमेंट और स्वैप के बाद, यह सुनिश्चित किया जाता है कि \u0026ldquo;बायां भाग ≤ pivot, दायां भाग ≥ pivot\u0026rdquo; की संरचना को तोड़ा न जाए, अर्थात, एक अपरिवर्तनीय [left, L) \u0026lt;= pivot है, (R, right] \u0026gt;= pivot।\nनिम्नलिखित उदाहरण कोड में, left और right वर्तमान में संसाधित बंद अंतराल की सीमाएँ हैं, और pivot अंतराल के मध्य बिंदु पर तत्व लेता है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} जटिलता और pivot का चयन # चूंकि सबसे खराब स्थिति में क्विक सॉर्ट की जटिलता $O(n^2)$ है, इसलिए pivot का चयन बहुत महत्वपूर्ण है। यदि हमेशा पहले या अंतिम तत्व का चयन किया जाता है, तो लगभग क्रमबद्ध सरणी में सबसे खराब स्थिति होने की संभावना अधिक होती है।\nमध्य स्थिति के तत्व को लेने के अलावा, pivot के रूप में एक तत्व को यादृच्छिक रूप से चुना जा सकता है, या बाएं, मध्य और दाएं तीन तत्वों के माध्यिका को pivot के रूप में लिया जा सकता है।\nसामान्य त्रुटि उदाहरण # नीचे दिए गए कोड में कई सामान्य त्रुटियां हैं।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} त्रुटि विश्लेषण:\npivot सरणी में एक संख्या होनी चाहिए, न कि एक सूचकांक। क्रमशः \u0026lt;= और \u0026gt;= के बजाय \u0026lt; और \u0026gt; का उपयोग करें, अन्यथा बाएं पॉइंटर दाएं पॉइंटर से एक स्थान से अधिक हो सकता है, ताकि सरणी को दो भागों में विभाजित न किया जा सके। l \u0026gt;= r पाए जाने के बाद, लूप से तुरंत बाहर निकल जाना चाहिए, और अब स्वैप नहीं करना चाहिए। अन्यथा, यह गारंटी नहीं दी जा सकती है कि बाईं ओर के तत्व pivot से अधिक नहीं हैं, और दाईं ओर के तत्व pivot से कम नहीं हैं। प्रत्येक स्वैप के बाद, l++ और r-- को निष्पादित किया जाना चाहिए। pivot वास्तव में मध्य-बाएं संख्या लेता है। इसलिए, यदि सरणी को विभाजित करने के लिए $l - 1$ और $l$ का उपयोग किया जाता है, तो सरणी [1, 2] पर विचार करें, यह पता लगाना मुश्किल नहीं है कि इससे एक अनंत लूप होगा, सरणी को लगातार 0 और 2 आकार के दो भागों में विभाजित किया जाएगा। इसी तरह, सरणी को अलग करने के लिए $r$ और $l$ का उपयोग करना भी काम नहीं करता है। इसके विपरीत, एक चक्र के अंत में, $r$ निश्चित रूप से $right$ से कम होगा, इसलिए सरणी को विभाजित करने के लिए $r$ और $r+1$ का उपयोग किया जा सकता है। पाठक यह देखने के लिए एल्गोरिथम प्रक्रिया का अनुकरण कर सकते हैं कि ऐसा क्यों है। अनंत लूप से बचने का एक और सरल तरीका है कि pivot को यादृच्छिक रूप से चुना जाए या केवल दो तत्वों की स्थिति को विशेष रूप से संभाला जाए। इसके अलावा, $l$, $l+1$ का उपयोग करना भी काम नहीं करता है, क्योंकि यह विभाजन परिभाषा के अनुरूप नहीं है। जब $r$, $l$ के बाईं ओर होता है, तो $l$, $l+1$ का उपयोग सरणी को बाईं ओर pivot से कम या उसके बराबर और दाईं ओर pivot से अधिक या उसके बराबर दो भागों में सही ढंग से विभाजित नहीं कर सकता है। यह प्रश्न मानता है कि सरणी खाली नहीं है, इसलिए \u0026gt; की स्थिति मौजूद नहीं है। लेकिन \u0026gt;= का उपयोग करने की अनुशंसा की जाती है, यह अधिक सुरक्षित है। पूरक # क्विक सॉर्ट को \u0026ldquo;क्विक सिलेक्शन\u0026rdquo; में भी विकसित किया जा सकता है, जो $O(n)$ की अपेक्षित समय में एक अव्यवस्थित सरणी में $k$ वीं सबसे छोटी संख्या को ढूंढता है। विशिष्ट विचार क्विक सॉर्ट के समान है, सिवाय इसके कि प्रत्येक बार केवल एक तरफ के उप-अंतराल में पुनरावर्ती रूप से जारी रहता है, जिससे समय जटिलता कम हो जाती है।\n","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735252761946-quick-sort/","section":"Posts","summary":"क्विक सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।","title":"क्विक सॉर्ट","type":"posts"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" समस्या # $N$ वस्तुएँ हैं। $i$-वीं वस्तु का आयतन $s_i$ है, और इसका मान $v_i$ है। प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त के तहत, अधिकतम कुल मान $V$ ज्ञात करें जो प्राप्त किया जा सकता है।\nइनपुट प्रारूप # पहली पंक्ति में दो पूर्णांक, $N$ और $S$, एक स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा का प्रतिनिधित्व करते हैं। निम्नलिखित $N$ पंक्तियों में प्रत्येक में दो पूर्णांक, $s_i$ और $v_i$, एक स्थान से अलग किए गए हैं, जो क्रमशः $i$-वीं वस्तु के आयतन और मान का प्रतिनिधित्व करते हैं।\nआउटपुट प्रारूप # अधिकतम मान का प्रतिनिधित्व करने वाला एक पूर्णांक आउटपुट करें।\nडेटा रेंज # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ इनपुट उदाहरण # 4 5 1 2 2 4 3 4 4 5 आउटपुट उदाहरण # 8 समाधान # स्थिति को परिभाषित करें: f[i][j] पहले $i$ वस्तुओं से प्राप्त किए जा सकने वाले अधिकतम मान का प्रतिनिधित्व करता है, जिसकी आयतन सीमा $j$ है। यदि $i$-वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि $i$-वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] स्थिति संक्रमण को लागू करते समय, डोमेन रेंज पर ध्यान दें। यदि $j \u003c s_i$, तो $i$-वीं वस्तु लेने के मामले पर विचार न करें। क्योंकि यदि $j - s_i$ ऋणात्मक है, तो सरणी सूचकांक अवैध है। इसे इस तरह भी समझाया जा सकता है: $i$-वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है। प्रारंभिक स्थिति को परिभाषित करें: पहली $0$ वस्तुओं के लिए, किसी भी आयतन सीमा से $0$ का मान प्राप्त होता है, अर्थात, f[0][j] = 0, j $\\in [0, S]$। समय जटिलता: $O(NS)$। कोड # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP ऑप्टिमाइजेशन # दो-आयामी सरणी को एक-आयामी सरणी में संपीड़ित करने से काफी जगह बच सकती है और कुछ हद तक चलने की गति में सुधार हो सकता है (नुकसान यह है कि यह कुछ समस्या प्रकारों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है)। ध्यान दें कि स्थिति संक्रमण में, f[i][j] केवल f[i - 1][j] और f[i - 1][j - s[i]] से संबंधित है। दूसरे शब्दों में, कोड में दो-आयामी सरणी f में, f[i][j] केवल पिछली पंक्ति के उन तत्वों से संबंधित है जो इसके बाईं ओर या उसी कॉलम में हैं। इसलिए, दो-आयामी सरणी को एक-आयामी सरणी या एक रोलिंग सरणी में संपीड़ित किया जा सकता है। ध्यान दें कि नीचे दिए गए कोड में, दूसरा लूप उल्टे क्रम में पुनरावृति करता है। ऐसा इसलिए है क्योंकि हम यह सुनिश्चित करना चाहते हैं कि f[i][j] की गणना करते समय, f[i - 1][j - s[i]] को अभी तक अपडेट नहीं किया गया है। 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} यदि योजनाओं की संख्या आवश्यक है # न केवल अधिकतम कुल मान जो प्राप्त किया जा सकता है, उसे आउटपुट किया जाना चाहिए, बल्कि \u0026ldquo;कितनी अलग-अलग चयन विधियां इस अधिकतम कुल मान को प्राप्त कर सकती हैं\u0026rdquo;। निम्नलिखित 01 नैपसेक समस्या में योजनाओं की संख्या की गणना कैसे करें का वर्णन करता है।\nयोजनाओं की गणना करने के लिए 2D DP # निम्नलिखित 2D DP का उपयोग एक उदाहरण के रूप में समझाने के लिए करता है।\nस्थिति को परिभाषित करें:\ndp[i][j] \u0026ldquo;क्षमता (आयतन सीमा) j के साथ पहली i वस्तुओं पर विचार करते समय प्राप्त किए जा सकने वाले अधिकतम मान\u0026rdquo; का प्रतिनिधित्व करता है। ways[i][j] \u0026ldquo;क्षमता j के साथ पहली i वस्तुओं पर विचार करते समय प्राप्त अधिकतम मान के अनुरूप योजनाओं की संख्या\u0026rdquo; का प्रतिनिधित्व करता है। स्थिति संक्रमण:\nयदि i-वीं वस्तु का चयन नहीं किया जाता है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ यदि i-वीं वस्तु का चयन किया जाता है (बशर्ते कि $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ चयन करना है या नहीं, अंतिम dp[i][j] को दोनों में से बड़ा लेना चाहिए: यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;i-वीं वस्तु का चयन करने\u0026rdquo; का मान अधिक है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ तो इसका मतलब है कि दो विधियों द्वारा प्राप्त अधिकतम मान समान है, तो योजनाओं की संख्या को जोड़ा जाना चाहिए: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;i-वीं वस्तु का चयन नहीं करने\u0026rdquo; का मान अधिक है, और योजनाओं की संख्या चयन नहीं करने पर योजनाओं की संख्या को विरासत में देती है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ प्रारंभिक स्थितियाँ:\ndp[0][j] = 0 का अर्थ है कि जब 0 वस्तुएँ होती हैं, तो किसी भी क्षमता के लिए प्राप्त अधिकतम मान 0 होता है। ways[0][0] = 1 का अर्थ है कि \u0026ldquo;0 वस्तुएँ, क्षमता 0\u0026rdquo; का मामला एक व्यवहार्य योजना है (अर्थात, कुछ भी नहीं चुनना), और योजनाओं की संख्या 1 पर सेट है। j \u0026gt; 0 के लिए, जब चुनने के लिए कोई वस्तु नहीं होती है और क्षमता 0 से अधिक होती है, तो कोई भी सकारात्मक मान प्राप्त करना असंभव है, और योजनाओं की संबंधित संख्या 0 है, अर्थात, ways[0][j] = 0। अंतिम उत्तर:\ndp[N][S] अधिकतम मान है। ways[N][S] इस अधिकतम मान को प्राप्त करने के लिए योजनाओं की संख्या है। समय जटिलता: $O(NS)$। इस समस्या को 1D DP का उपयोग करके भी अनुकूलित किया जा सकता है। यदि आवश्यकता आयतन सीमा तक ठीक से पहुँचने की है # स्थिति को परिभाषित करें: f[i][j] अधिकतम मान का प्रतिनिधित्व करता है जब पहली i वस्तुओं का आयतन ठीक $j$ होता है। यदि i-वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि i-वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] यह ध्यान दिया जा सकता है कि मूल समस्या से स्थिति संक्रमण में कोई अंतर नहीं है। हालाँकि, प्रारंभिक स्थितियाँ अलग हैं। f[0][0] = 0 को छोड़कर, शेष f[0][j] = $-\\infty$, j $\\in [1, S]$। $-\\infty$ एक असंभव स्थिति का प्रतिनिधित्व करता है। यदि आयतन सीमा $S$ बहुत बड़ी है (1e9), जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मान $V$ अपेक्षाकृत छोटे हैं # ऐसी समस्याओं के लिए, $O(NV)$ की जटिलता वाला एक समाधान है। स्थिति को परिभाषित करें: f[i][j] पहली i वस्तुओं में से कई वस्तुओं का चयन करते समय न्यूनतम आयतन का प्रतिनिधित्व करता है, और कुल मान ठीक j है। यदि i-वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि i-वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - v[i]] + s[i] दोनों में से छोटा लें। प्रारंभिक स्थितियाँ: f[0][0] = 0, शेष f[0][j] = $\\infty$, j $\\in [1, V]$। $\\infty$ एक असंभव स्थिति का प्रतिनिधित्व करता है। ध्यान दें कि यह $-\\infty$ नहीं है। अंतिम उत्तर f[N][j] में सबसे बड़ा j है जैसे कि f[N][j] \u0026lt;= S। यदि आयतन सीमा $S$ और एक एकल वस्तु का मान $v_i$ दोनों बहुत बड़े हैं (1e9 के क्रम में), जबकि वस्तुओं की संख्या $N$ बहुत कम है (40 से अधिक नहीं) # जब $N \\leq 20$, तो सभी उपसमुच्चय को सीधे क्रूर बल द्वारा गिना जा सकता है (समय जटिलता $O(2^N)$)। जब $N \\leq 40$, चूंकि $2^{40}$ $10^{12}$ के क्रम में है, इसलिए प्रत्यक्ष क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए जटिलता को लगभग $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ तक कम करने के लिए बीच में मिलन खोज का उपयोग किया जा सकता है, जिसे स्वीकार्य समय में पूरा किया जा सकता है। ","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"सबसे बुनियादी क्लासिक नैपसेक समस्या।","title":"01 नैपसेक समस्या","type":"posts"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"यदि क्रमित समाधान स्थान को दो भागों में विभाजित किया जाता है, जहाँ एक भाग शर्त को पूरा करता है और दूसरा भाग शर्त को पूरा नहीं करता है, तो क्रमित समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग किया जा सकता है।\nद्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक जाँच में मध्य बिंदु तत्व की जाँच करें, यदि मध्य बिंदु तत्व शर्त को पूरा नहीं करता है, तो आधे अंतराल को समाप्त किया जा सकता है; अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूँकि प्रत्येक बार खोज अंतराल का आधा भाग छोड़ दिया जाता है, इसलिए खोज समय जटिलता $O(\\log n)$ तक पहुँच सकती है।\nउदाहरण समस्या # https://www.acwing.com/problem/content/791\nसमस्या विवरण: एक आरोही क्रम में व्यवस्थित लंबाई $n$ की पूर्णांक सरणी दी गई है, साथ ही $q$ प्रश्न भी दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, हमें सरणी में $k$ की \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; (सूचकांक 0 से शुरू) ज्ञात करने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो -1 -1 लौटाएँ।\nइनपुट प्रारूप # पहली पंक्ति: दो पूर्णांक $n$ और $q$, क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं। दूसरी पंक्ति: $n$ पूर्णांक, पूरी सरणी को दर्शाते हैं, जो आरोही क्रम में व्यवस्थित है। अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व को दर्शाता है। डेटा सीमा # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nआउटपुट प्रारूप # प्रत्येक प्रश्न के लिए, सरणी में तत्व की प्रारंभिक और अंतिम स्थिति को एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो -1 -1 आउटपुट करें।\nनमूना:\nइनपुट: 6 3 1 2 2 3 3 4 3 4 5 आउटपुट: 3 4 5 5 -1 -1 स्पष्टीकरण:\nतत्व $3$ की सीमा $[3, 4]$ है; तत्व $4$ केवल एक बार स्थिति $5$ पर दिखाई देता है; तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ। समाधान # \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; ज्ञात करना: अर्थात, $k$ से पहले या उसके बराबर पहला स्थान ज्ञात करना। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;कम\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;अधिक या बराबर\u0026rdquo; हैं उत्तर दाईं ओर का पहला स्थान है \u0026ldquo;अंतिम स्थिति\u0026rdquo; ज्ञात करना: अर्थात, $k$ से पहले या उसके बराबर अंतिम स्थान ज्ञात करना। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;कम या बराबर\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;अधिक\u0026rdquo; हैं उत्तर बाईं ओर का अंतिम स्थान है अनुशंसित टेम्पलेट # नीचे एक सुरुचिपूर्ण और त्रुटि-मुक्त द्विआधारी टेम्पलेट दिया गया है।\nदो पॉइंटर्स $l, r$ को परिभाषित करें, जिसमें अपरिवर्तनीय है: बंद अंतराल $[0, l]$ बाईं ओर के भाग से संबंधित है, बंद अंतराल $[r, n - 1]$ दाईं ओर के भाग से संबंधित है। $l$ और $r$ दोनों को $-1$ और $n$ के रूप में इनिशियलाइज़ किया गया है।\nजब एल्गोरिथम समाप्त होता है, तो $l$ और $r$ आसन्न होते हैं, क्रमशः बाईं ओर के भाग के अंतिम तत्व और दाईं ओर के भाग के पहले तत्व की ओर इशारा करते हैं।\nचूँकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए यदि समस्या में यह नहीं बताया गया है कि एक समाधान निश्चित रूप से मौजूद है, तो हमें यह जाँचने की आवश्यकता है कि क्या l या r सीमा से बाहर है, क्या यह सही मान की ओर इशारा करता है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k की प्रारंभिक स्थिति ज्ञात करें 15 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt; k, दाईं ओर सभी \u0026gt;= k। 16 // उत्तर दाईं ओर के भाग का न्यूनतम सूचकांक है। 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k की अंतिम स्थिति ज्ञात करें 33 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt;= k, दाईं ओर सभी \u0026gt; k। 34 // उत्तर बाईं ओर के भाग का अधिकतम सूचकांक है। 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} लाभ # इस लेखन में अपरिवर्तनीय की सख्त परिभाषा है। यह \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; दोनों स्थितियों को खोजने के लिए उपयुक्त है, इसके लिए अतिरिक्त प्रसंस्करण और परिवर्तन की आवश्यकता नहीं है। कुछ लेखन l == r को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो यह $mid$ और $l$ या $r$ के बराबर की गणना करेगा। यदि सही ढंग से संसाधित नहीं किया जाता है, तो $l$ या $r$ को $mid$ में अपडेट करने से, खोज अंतराल कम नहीं होता है, जिससे एक अनंत लूप हो जाएगा। इसके विपरीत, यहाँ का लेखन $l$ और $r$ के आसन्न होने पर समाप्त होता है, यह सुनिश्चित करता है कि $mid$ $l$ से छोटा है और $r$ से बड़ा है, $l$ या $r$ को अपडेट करते समय खोज अंतराल निश्चित रूप से कम हो जाएगा। STL # यदि C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound फ़ंक्शंस का उपयोग किया जाता है, तो वही काम पूरा किया जा सकता है:\nlower_bound(first, last, val) \u0026ldquo;val से पहले या उसके बराबर पहले स्थान\u0026rdquo; को लौटाएगा upper_bound(first, last, val) \u0026ldquo;val से पहले पहले स्थान\u0026rdquo; को लौटाएगा उदाहरण के लिए, मान लीजिए nums = {1,2,3,4,4,4,4,4,5,5,6}, हम जानना चाहते हैं कि 4 किस अंतराल में दिखाई देता है:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 पहले मान की ओर इशारा करता है जो $4$ से पहले या उसके बराबर है। it2 पहले मान की ओर इशारा करता है जो $4$ से अधिक है। इसलिए it2 - it1 सरणी में $4$ की संख्या है; it2 - nums.begin() - 1 $4$ की दाहिनी सीमा की स्थिति है। पूरक # द्विआधारी खोज को फ़्लोटिंग-पॉइंट संख्या सीमा (जैसे समीकरणों की जड़ों को खोजना) और एकल-शिखर फ़ंक्शन के अधिकतम मान को खोजने के लिए त्रि-आयामी खोज तक भी बढ़ाया जा सकता है।\nअभ्यास # LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें\nसंकेत: पहला चरण रोटेशन बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"द्विआधारी खोज एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।","title":"द्विआधारी खोज","type":"posts"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"}]