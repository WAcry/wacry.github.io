[{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":" बाइनरी सर्च # एक क्रमबद्ध अनुक्रम में किसी विशिष्ट तत्व को खोजने के लिए, आप इसे जल्दी से पूरा करने के लिए बाइनरी सर्च का उपयोग कर सकते हैं। रैखिक खोज की समय जटिलता $O(n)$ की तुलना में, बाइनरी सर्च को केवल $O(\\log n)$ समय की आवश्यकता होती है, इसलिए यह बड़े डेटा पैमानों में बहुत कुशल है।\nबाइनरी सर्च का मूल विचार # बाइनरी सर्च का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक तुलना में, मध्य बिंदु तत्व के आकार की तुलना लक्ष्य मान से करें। यदि मध्य बिंदु तत्व शर्त को पूरा नहीं करता है, तो आप आधे अंतराल को खत्म कर सकते हैं; अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग त्याग दिया जाता है, खोज की समय जटिलता $O(\\log n)$ तक पहुंच सकती है।\nउन समस्याओं के लिए जहां \u0026quot; व्यवहार्य समाधान को एक क्रमबद्ध अंतराल (शर्त को पूरा करना) और दूसरे क्रमबद्ध अंतराल (शर्त को पूरा नहीं करना) में विभाजित किया जा सकता है\u0026quot;, बाइनरी सर्च बहुत उपयोगी है। उदाहरण के लिए:\nयह जानने के लिए कि क्या किसी क्रमबद्ध सरणी में कोई विशेष तत्व मौजूद है। किसी संख्या का \u0026ldquo;पहला स्थान\u0026rdquo; या \u0026ldquo;अंतिम स्थान\u0026rdquo; ज्ञात करना। उदाहरण समस्या: किसी तत्व की प्रारंभिक और अंतिम स्थिति खोजना # समस्या विवरण: एक लंबाई $n$ की पूर्णांक सरणी दी गई है, जिसे आरोही क्रम में क्रमबद्ध किया गया है, साथ ही $q$ प्रश्न भी दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ का \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; और \u0026ldquo;अंतिम स्थान\u0026rdquo; (अनुक्रमणिका 0 से शुरू होती है) ज्ञात करने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो $-1$ $-1$ लौटाएं।\nइनपुट प्रारूप:\nपहली पंक्ति: दो पूर्णांक $n$ और $q$, जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं। दूसरी पंक्ति: $n$ पूर्णांक (1 ~ 10000 की सीमा में), जो पूर्ण सरणी का प्रतिनिधित्व करते हैं, और पहले से ही आरोही क्रम में क्रमबद्ध हैं। अगले $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व को दर्शाता है। आउटपुट प्रारूप: प्रत्येक प्रश्न के लिए, उसी पंक्ति में सरणी में तत्व की प्रारंभिक और अंतिम स्थिति आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो $-1$ $-1$ आउटपुट करें।\nनमूना:\nइनपुट: 6 3 1 2 2 3 3 4 3 4 5 आउटपुट: 3 4 5 5 -1 -1 स्पष्टीकरण:\nतत्व 3 की सीमा [3, 4] है; तत्व 4 केवल एक बार दिखाई देता है, स्थिति 5 पर; तत्व 5 सरणी में मौजूद नहीं है, इसलिए -1 -1 लौटाएं। बाइनरी सर्च के लिए अनुप्रयोग विचार # इस समस्या में, किसी मान की \u0026ldquo;बाईं सीमा\u0026rdquo; और \u0026ldquo;दाईं सीमा\u0026rdquo; ज्ञात करने के लिए, हम बाइनरी सर्च पर निर्भर हो सकते हैं। महत्वपूर्ण बात यह है कि खोज अंतराल को कैसे परिभाषित किया जाए, और तुलना परिणाम के आधार पर पॉइंटर्स को कैसे स्थानांतरित किया जाए, इसे समझना।\n\u0026ldquo;बाईं सीमा\u0026rdquo; ज्ञात करना: अर्थात, $k$ से पहले स्थित पहले सबसे बड़े या $k$ के बराबर स्थान को खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;छोटी\u0026rdquo; हैं। दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;बड़ी या बराबर\u0026rdquo; हैं। \u0026ldquo;दाईं सीमा\u0026rdquo; ज्ञात करना: अर्थात, $k$ से पहले स्थित अंतिम सबसे छोटे या $k$ के बराबर स्थान को खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;छोटी या बराबर\u0026rdquo; हैं। दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;बड़ी\u0026rdquo; हैं। जब तक आप इन दो अंतरालों को सही ढंग से बनाए रख सकते हैं, तब तक आप बाइनरी सर्च के माध्यम से जल्दी से परिणाम प्राप्त कर सकते हैं।\nअनुशंसित टेम्पलेट: मृत लूप से बचने के लिए बाइनरी लेखन # यहां एक सुरुचिपूर्ण और गैर-गलती-प्रवण बाइनरी टेम्पलेट है। यह $l$ और $r$ को धीरे-धीरे एक-दूसरे के करीब लाने से, यह सुनिश्चित करता है कि लूप हमेशा दोनों के आसन्न होने पर समाप्त होता है:\nदो पॉइंटर्स $l$, $r$ को परिभाषित करें, एक अपरिवर्तनीय के साथ: बंद अंतराल $[0, l]$ सभी बाईं ओर के भाग से संबंधित है, और बंद अंतराल $[r, n - 1]$ सभी दाईं ओर के भाग से संबंधित है। $l$ और $r$ दोनों को $-1$ और $n$ पर इनिशियलाइज़ किया गया है।\nएल्गोरिथम के समाप्त होने पर, $l$ और $r$ आसन्न होते हैं, जो क्रमशः बाईं ओर के अधिकतम मान और दाईं ओर के न्यूनतम मान को इंगित करते हैं।\nचूंकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए $l$ या $r$ लौटाते समय, हमें यह जांचने की आवश्यकता होती है कि संबंधित मान वह मान है जो हम चाहते हैं, और यह आउट ऑफ़ बाउंड है या नहीं। उदाहरण के लिए, $l$ $\\leq k$ के अधिकतम मान को दर्शाता है, और हमें l != -1 \u0026amp;\u0026amp; nums[l] == k की जांच करने की आवश्यकता है\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. k की शुरुआती स्थिति (बाईं सीमा) खोजें // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt; k हैं, और दाईं ओर सभी \u0026gt;= k हैं। // बाईं सीमा दाईं ओर के भाग का न्यूनतम अनुक्रमणिका है। int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // यदि r सीमा से बाहर है या nums[r] != k है, तो इसका मतलब है कि k मौजूद नहीं है। if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // k की बाईं सीमा रिकॉर्ड करें // 2. k की समाप्ति स्थिति (दाईं सीमा) खोजें // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt;= k हैं, और दाईं ओर सभी \u0026gt; k हैं। // दाईं सीमा बाईं ओर के भाग का अधिकतम अनुक्रमणिका है। l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // चूंकि हमने पहले ही सत्यापित कर लिया है कि k मौजूद है, इसलिए यहां फिर से सत्यापित करने की कोई आवश्यकता नहीं है। int rightPos = l; // दाईं सीमा cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } इस तरह लिखने में गलती करना इतना मुश्किल क्यों है? # इस लेखन में अपरिवर्तनीय की एक सख्त परिभाषा है। यह बाईं सीमा और दाईं सीमा दोनों को खोज सकता है, और सभी परिदृश्यों पर लागू किया जा सकता है। कुछ लेखन $l == r$ को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ 1 से भिन्न होते हैं, तो $mid$ और l या r समान होने की गणना की जाएगी। यदि इसे सही ढंग से संभाला नहीं जाता है, तो l या r को mid पर अपडेट करने से खोज अंतराल कम नहीं होगा, जिससे एक डेड लूप हो जाएगा। इसके विपरीत, यहाँ का लेखन $l$ और $r$ के आसन्न होने पर समाप्त होता है, इस समस्या से बचाता है। STL समाधान: lower_bound और upper_bound # यदि आप C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound फ़ंक्शन का उपयोग करते हैं, तो आप आसानी से उसी काम को पूरा कर सकते हैं:\nlower_bound(first, last, val) \u0026ldquo;मान के पहले से बड़े या बराबर स्थान\u0026rdquo; को लौटाएगा। upper_bound(first, last, val) \u0026ldquo;मान से पहले बड़े स्थान\u0026rdquo; को लौटाएगा। एक उदाहरण के रूप में, मान लें कि nums = {1,2,3,4,4,4,4,4,5,5,6}, और हम जानना चाहते हैं कि 4 का अंतराल कहाँ है:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // इसका मतलब है कि सरणी में 4 मौजूद नहीं है cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; } it1 पहले मान से बड़े या 4 के बराबर स्थान को इंगित करता है। it2 पहले मान से बड़े 4 के स्थान को इंगित करता है। इसलिए it2 - it1 सरणी में 4 की संख्या है; it2 - nums.begin() - 1 4 की दाईं सीमा है। ये दोनों फ़ंक्शन किसी अंतराल की खोज करते समय या होने की संख्या की गणना करते समय विशेष रूप से सुविधाजनक हैं।\nपूरक # बाइनरी सर्च को फ्लोटिंग-पॉइंट नंबर की सीमा में खोज (जैसे समीकरणों की जड़ों को खोजना), और एकल-शिखर फ़ंक्शन के अधिकतम मान के लिए त्रि-बिंदु खोज तक भी बढ़ाया जा सकता है। जब तक आप \u0026quot; एक क्रमबद्ध अंतराल में, प्रत्येक बार आप आधे हिस्से को समाप्त कर सकते हैं\u0026quot; के इस मूल सिद्धांत को समझते हैं, तो आप पाएंगे कि बाइनरी सर्च कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकता है।\nकक्षा के बाद अभ्यास # LeetCode 33. घुमाई हुई क्रमबद्ध सरणी में खोजें\nसंकेत: पहले चरण में रोटेशन बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग करें, और दूसरे चरण में लक्ष्य मान को खोजने के लिए बाइनरी सर्च का उपयोग करें।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"बाइनरी सर्च","type":"posts"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"}]