[{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"यदि एक क्रमबद्ध समाधान स्थान को दो भागों में विभाजित किया जाता है, जिनमें से एक भाग शर्त को संतुष्ट करता है, और दूसरा भाग नहीं करता है। तो द्विआधारी खोज का उपयोग क्रमबद्ध समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए किया जा सकता है।\nद्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक जांच में मध्य तत्व की जाँच की जाती है। यदि मध्य तत्व शर्त को पूरा नहीं करता है, तो आधे अंतराल को समाप्त किया जा सकता है; अन्यथा, अन्य आधे अंतराल में खोज जारी रखी जाती है। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग हटा दिया जाता है, इसलिए खोज की समय जटिलता $O(\\log n)$ तक पहुँच सकती है।\nउदाहरण प्रश्न # प्रश्न विवरण: एक आरोही क्रम में व्यवस्थित $n$ लंबाई की पूर्णांक सरणी दी गई है, और $q$ प्रश्न हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ के \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; और \u0026ldquo;अंतिम स्थान\u0026rdquo; (अनुक्रमणिका 0 से शुरू) को खोजने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो -1 -1 लौटाएँ।\nइनपुट प्रारूप # पहली पंक्ति: दो पूर्णांक $n$ और $q$, जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं। दूसरी पंक्ति: $n$ पूर्णांक, जो पूर्ण सरणी को दर्शाते हैं, आरोही क्रम में व्यवस्थित हैं। अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व का प्रतिनिधित्व करता है। डेटा रेंज # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nआउटपुट प्रारूप # प्रत्येक प्रश्न के लिए, सरणी में तत्व का प्रारंभिक और अंतिम स्थान एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो -1 -1 आउटपुट करें।\nउदाहरण:\nइनपुट: 6 3 1 2 2 3 3 4 3 4 5 आउटपुट: 3 4 5 5 -1 -1 स्पष्टीकरण:\nतत्व $3$ की सीमा $[3, 4]$ है; तत्व $4$ केवल एक बार, स्थान $5$ पर दिखाई देता है; तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ। उत्तर # \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; खोजना: अर्थात, $k$ से पहले या उसके बराबर पहली स्थिति खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;कम\u0026rdquo; हैं दाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;अधिक या उसके बराबर\u0026rdquo; हैं उत्तर दाईं ओर का पहला स्थान है \u0026ldquo;अंतिम स्थान\u0026rdquo; खोजना: अर्थात, $k$ से कम या उसके बराबर अंतिम स्थिति खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;कम या उसके बराबर\u0026rdquo; हैं दाईं ओर सभी संख्याएँ $k$ से \u0026ldquo;अधिक\u0026rdquo; हैं उत्तर बाईं ओर का अंतिम स्थान है अनुशंसित टेम्पलेट # नीचे एक सुरुचिपूर्ण और त्रुटि-रहित द्विआधारी टेम्पलेट है। यह $l$ और $r$ को धीरे-धीरे एक-दूसरे के करीब लाकर सुनिश्चित करता है कि लूप दोनों के आसन्न होने पर समाप्त हो जाए:\nदो पॉइंटर्स $l$ और $r$ को परिभाषित करें, जिनमें अपरिवर्तनीय हैं: बंद अंतराल $[0, l]$ सभी बाएं भाग से संबंधित हैं, और बंद अंतराल $[r, n - 1]$ सभी दाएं भाग से संबंधित हैं। $l$ और $r$ दोनों को $-1$ और $n$ पर प्रारंभ किया जाता है।\nएल्गोरिथ्म समाप्त होने पर, $l$ और $r$ आसन्न होते हैं, क्रमशः बाएं भाग के अंतिम तत्व और दाएं भाग के पहले तत्व की ओर इशारा करते हैं।\nक्योंकि वांछित समाधान मौजूद नहीं हो सकता है, इसलिए यदि प्रश्न में यह नहीं बताया गया है कि कोई समाधान निश्चित रूप से मौजूद है, तो हमें यह जांचने की आवश्यकता है कि क्या l या r सीमा से बाहर है, और क्या वह सही मान की ओर इशारा कर रहा है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k का प्रारंभिक स्थान खोजें 15 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt; k, दाईं ओर सभी \u0026gt;= k। 16 // उत्तर दाईं ओर का न्यूनतम सूचकांक है। 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // यदि r सीमा से बाहर है या nums[r] != k है, तो इसका मतलब है कि k मौजूद नहीं है 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k का अंतिम स्थान खोजें 33 // सरणी को दो भागों में विभाजित करें, बाईं ओर सभी \u0026lt;= k, दाईं ओर सभी \u0026gt; k। 34 // उत्तर बाएं भाग का अधिकतम सूचकांक है। 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} इस तरह क्यों लिखें # इस लेखन में अपरिवर्तनीयों की सख्त परिभाषा है। यह \u0026ldquo;प्रारंभिक स्थान\u0026rdquo; और \u0026ldquo;अंतिम स्थान\u0026rdquo; दोनों स्थितियों को खोजने के लिए एक साथ लागू होता है, बिना किसी अतिरिक्त प्रसंस्करण और परिवर्तन की आवश्यकता के। कुछ लेखन l == r का उपयोग समापन स्थिति के रूप में करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो यह $mid$ और $l$ या $r$ के बराबर की गणना करेगा। यदि सही ढंग से संसाधित नहीं किया गया, तो $l$ या $r$ को $mid$ के रूप में अपडेट करने पर, खोज अंतराल कम नहीं होगा, जिससे एक अनंत लूप हो सकता है। इसके विपरीत, यहां लिखने की शैली $l$ और $r$ के आसन्न होने पर समाप्त हो जाती है, यह सुनिश्चित करते हुए कि $mid$, $l$ से छोटा और $r$ से बड़ा है। $l$ या $r$ को अपडेट करते समय खोज अंतराल निश्चित रूप से कम हो जाएगा। STL # यदि C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound फ़ंक्शंस का उपयोग करते हैं, तो वही काम पूरा किया जा सकता है:\nlower_bound(first, last, val) \u0026ldquo;val से पहले या उसके बराबर पहले स्थान\u0026rdquo; को लौटाएगा। upper_bound(first, last, val) \u0026ldquo;val से पहले स्थान\u0026rdquo; को लौटाएगा। उदाहरण के लिए, मान लें कि nums = {1,2,3,4,4,4,4,4,5,5,6} है, और हम जानना चाहते हैं कि 4 किस सीमा में है:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 पहले मान को इंगित करता है जो $4$ से अधिक या उसके बराबर है। it2 पहले मान को इंगित करता है जो $4$ से अधिक है।\nइसलिए it2 - it1 सरणी में $4$ की उपस्थिति की संख्या है; it2 - nums.begin() - 1 $4$ की दाईं सीमा है। अतिरिक्त # द्विआधारी खोज को फ़्लोटिंग-पॉइंट संख्या श्रेणी (जैसे समीकरण के मूल की खोज) और त्रिकोणीय खोज को एकल-शिखर वाले फ़ंक्शन के चरम मान को खोजने के लिए भी बढ़ाया जा सकता है। जब तक आप \u0026ldquo;क्रमबद्ध अंतराल में, आप हर बार आधे भाग को बाहर निकाल सकते हैं\u0026rdquo; के मूल सिद्धांत को समझते हैं, तो आप पाएंगे कि द्विआधारी खोज कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकती है।\nअभ्यास # LeetCode 33. Rotated Sorted Array में खोजें\nसंकेत: पहला चरण घुमाव बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"द्विआधारी खोज एल्गोरिथ्म को सुरुचिपूर्ण ढंग से कैसे लागू करें।","title":"द्विआधारी खोज","type":"posts"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"}]