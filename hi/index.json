[{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 दिसंबर 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":" क्विक सॉर्ट # क्विक सॉर्ट एक तुलना-आधारित अस्थिर सॉर्टिंग एल्गोरिथम है, जो विभाजन और जीत की विचारधारा का उपयोग करता है। इसकी औसत समय जटिलता $O(n\\log n)$ है, सबसे खराब स्थिति में $O(n^2)$ है, और स्थान जटिलता $O(1)$ है। यहां, एक पूर्णांक अनुक्रम को छोटे से बड़े क्रम में सॉर्ट करने के उदाहरण के साथ, इसके कार्यान्वयन विवरण और सामान्य त्रुटियों का परिचय दिया गया है।\nसमस्या विवरण # एक लंबाई $n$ के पूर्णांक अनुक्रम को देखते हुए, इसे क्विक सॉर्ट का उपयोग करके छोटे से बड़े क्रम में सॉर्ट करें और परिणाम आउटपुट करें।\nइनपुट प्रारूप # पहली पंक्ति में पूर्णांक $n$ इनपुट करें दूसरी पंक्ति में $n$ पूर्णांक इनपुट करें, सभी $[1,10^9]$ सीमा में आउटपुट प्रारूप # एक पंक्ति में सॉर्ट किया गया अनुक्रम आउटपुट करें डेटा रेंज # $1 \\leq n \\leq 100000$\nइनपुट नमूना # 5 3 1 2 4 5 आउटपुट नमूना # 1 2 3 4 5 क्विक सॉर्ट विचार # क्विक सॉर्ट प्रत्येक विभाजन के समय, एक संख्या को आधार संख्या pivot के रूप में चुनता है (नीचे मध्य स्थिति की संख्या का चयन किया गया है)।\nबाएं और दाएं पॉइंटर्स का उपयोग विपरीत दिशाओं में जाने के लिए करें। बाएं पॉइंटर L बाएं से दाएं पहले pivot से बड़े या बराबर संख्या की तलाश करता है, और दाएं पॉइंटर R दाएं से बाएं पहले pivot से छोटे या बराबर संख्या की तलाश करता है, और फिर इन दो संख्याओं को स्वैप करता है।\nइस प्रक्रिया को तब तक दोहराते रहें जब तक कि बाएं पॉइंटर और दाएं पॉइंटर ओवरलैप न हो जाएं या बाएं पॉइंटर दाएं पॉइंटर से एक स्थान बड़ा न हो जाए। इसे एक चक्र कहा जाता है।\nप्रत्येक पॉइंटर मूवमेंट और स्वैप के बाद, यह सुनिश्चित किया जाता है कि \u0026ldquo;बायां भाग ≤ pivot, दायां भाग ≥ pivot\u0026rdquo; की संरचना को तोड़ा नहीं गया है, यानी, अपरिवर्तनीय [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot है।\nनिम्नलिखित उदाहरण कोड में, left और right वर्तमान में संसाधित बंद अंतराल की सीमाएं हैं, और pivot अंतराल के मध्य बिंदु पर तत्व लेता है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} जटिलता और pivot का चयन # चूंकि सबसे खराब स्थिति में क्विक सॉर्ट की जटिलता $O(n^2)$ है, इसलिए pivot का चयन बहुत महत्वपूर्ण है। यदि हमेशा पहले या अंतिम तत्व का चयन किया जाता है, तो लगभग क्रमबद्ध सरणी में सबसे खराब स्थिति होने की संभावना अधिक होती है।\nमध्य स्थिति के तत्व को लेने के अलावा, pivot के रूप में एक तत्व को यादृच्छिक रूप से चुना जा सकता है, या बाएं, मध्य और दाएं तीन तत्वों के माध्यिका को pivot के रूप में लिया जा सकता है।\nसामान्य त्रुटि उदाहरण # नीचे दिए गए कोड में कई सामान्य त्रुटियां हैं।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} त्रुटि विश्लेषण:\npivot सरणी में एक संख्या होनी चाहिए, न कि एक सूचकांक। क्रमशः \u0026lt;= और \u0026gt;= के बजाय \u0026lt; और \u0026gt; का उपयोग करें, अन्यथा बाएं पॉइंटर दाएं पॉइंटर से एक से अधिक स्थान आगे बढ़ सकता है, ताकि सरणी को दो भागों में विभाजित न किया जा सके। l \u0026gt;= r पाए जाने के बाद, लूप से तुरंत बाहर निकल जाना चाहिए, और अब स्वैप नहीं करना चाहिए। अन्यथा, यह गारंटी नहीं दी जा सकती है कि बाईं ओर के तत्व pivot से बड़े नहीं हैं, और दाईं ओर के तत्व pivot से छोटे नहीं हैं। प्रत्येक स्वैप के बाद, l++ और r-- को निष्पादित किया जाना चाहिए। pivot वास्तव में मध्य-बाएं संख्या लेता है। इसलिए, यदि सरणी को विभाजित करने के लिए $l - 1$ और $l$ का उपयोग किया जाता है, तो सरणी [1, 2] पर विचार करें, यह पता लगाना मुश्किल नहीं है कि इससे एक अनंत लूप होगा, लगातार सरणी को 0 और 2 आकार के दो भागों में विभाजित किया जाएगा। इसी तरह, सरणी को अलग करने के लिए $r$ और $l$ का उपयोग करना भी काम नहीं करता है। इसके विपरीत, एक चक्र के अंत में, $r$ निश्चित रूप से $right$ से छोटा होगा, इसलिए सरणी को विभाजित करने के लिए $r$ और $r+1$ का उपयोग किया जा सकता है। पाठक यह देखने के लिए एल्गोरिथम प्रक्रिया का अनुकरण कर सकते हैं कि ऐसा क्यों है। अनंत लूप से बचने का एक और सरल तरीका है कि pivot को यादृच्छिक रूप से चुना जाए या केवल दो तत्वों की स्थिति को विशेष रूप से संभाला जाए। इसके अलावा, $l$, $l+1$ का उपयोग करना भी काम नहीं करता है, क्योंकि यह विभाजन परिभाषा के अनुरूप नहीं है। जब $r$, $l$ के बाईं ओर होता है, तो $l$, $l+1$ का उपयोग सरणी को बाईं ओर pivot से कम या बराबर और दाईं ओर pivot से अधिक या बराबर के दो भागों में सही ढंग से विभाजित नहीं कर सकता है। यह प्रश्न मानता है कि सरणी खाली नहीं है, इसलिए \u0026gt; की स्थिति मौजूद नहीं है। लेकिन \u0026gt;= का उपयोग करने की सलाह दी जाती है, यह अधिक सुरक्षित है। पूरक # क्विक सॉर्ट को \u0026ldquo;क्विक चयन\u0026rdquo; में भी विकसित किया जा सकता है, जो $O(n)$ की अपेक्षित समय में एक अव्यवस्थित सरणी में $k$ वीं सबसे छोटी संख्या को ढूंढता है। विशिष्ट विचार क्विक सॉर्ट के समान है, सिवाय इसके कि प्रत्येक बार केवल एक तरफ के उप-अंतराल में पुनरावर्ती रूप से जारी रहता है, जिससे समय जटिलता कम हो जाती है।\n","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735252761946-quick-sort/","section":"Posts","summary":"क्विक सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।","title":"क्विक सॉर्ट","type":"posts"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" प्रश्न # https://www.acwing.com/problem/content/2/\n$N$ वस्तुएँ हैं। $i$वीं वस्तु का आयतन $s_i$ है, और मूल्य $v_i$ है। प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त पर, प्राप्त किए जा सकने वाले अधिकतम कुल मूल्य $V$ की गणना करें।\nइनपुट प्रारूप # पहली पंक्ति में दो पूर्णांक, $N, S$, रिक्त स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा को दर्शाते हैं। अगली $N$ पंक्तियों में, प्रत्येक पंक्ति में दो पूर्णांक $s_i, v_i$, रिक्त स्थान से अलग किए गए हैं, जो क्रमशः $i$वीं वस्तु के आयतन और मूल्य को दर्शाते हैं।\nआउटपुट प्रारूप # एक पूर्णांक आउटपुट करें, जो अधिकतम मूल्य को दर्शाता है।\nडेटा रेंज # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ इनपुट नमूना # 4 5 1 2 2 4 3 4 4 5 आउटपुट नमूना # 8 समाधान # स्थिति को परिभाषित करें: f[i][j] पहले $i$ वस्तुओं के लिए, आयतन सीमा $j$ के साथ प्राप्त किए जा सकने वाले अधिकतम मूल्य को दर्शाता है। यदि $i$वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि $i$वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] स्थिति संक्रमण को लागू करते समय, परिभाषा क्षेत्र की सीमा पर ध्यान दें। यदि $j \u003c s_i$, तो $i$वीं वस्तु लेने की स्थिति पर विचार न करें। क्योंकि यदि $j-s_i$ ऋणात्मक है, तो सरणी सूचकांक अवैध है। इसे इस प्रकार भी समझाया जा सकता है: $i$वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है। प्रारंभिक स्थिति को परिभाषित करें: पहले $0$ वस्तुओं के लिए, किसी भी आयतन सीमा पर $0$ मूल्य प्राप्त होता है, अर्थात f[0][j] = 0, j $\\in [0, S]$। समय जटिलता: $O(NS)$। कोड # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} एक-आयामी DP अनुकूलन # दो-आयामी सरणी को एक-आयामी सरणी में संपीड़ित करने से, स्थान की काफी बचत हो सकती है और एक निश्चित सीमा तक चलने की गति में सुधार हो सकता है (नुकसान यह है कि यह कुछ प्रकार के प्रश्नों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है) ध्यान दें कि स्थिति संक्रमण में, f[i][j] केवल f[i - 1][j] और f[i - 1][j - s[i]] से संबंधित है। दूसरे शब्दों में, कोड में दो-आयामी सरणी f में, f[i][j] केवल अपनी पिछली पंक्ति में इसके बाईं ओर या उसी कॉलम के तत्वों से संबंधित है, इसलिए दो-आयामी सरणी को एक-आयामी सरणी या रोलिंग सरणी में संपीड़ित किया जा सकता है। ध्यान दें कि नीचे दिए गए कोड में, दूसरी लूप विपरीत क्रम में पुनरावृति करती है, ऐसा इसलिए है क्योंकि हमें यह सुनिश्चित करना है कि f[i][j] की गणना करते समय, f[i - 1][j - s[i]] को अभी तक अपडेट नहीं किया गया है। 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} यदि योजनाओं की संख्या की आवश्यकता हो # न केवल प्राप्त किए जा सकने वाले अधिकतम कुल मूल्य को आउटपुट करना है, बल्कि यह भी आउटपुट करना है कि \u0026ldquo;इस अधिकतम कुल मूल्य को प्राप्त करने के लिए कितने अलग-अलग चयन विधियाँ हैं\u0026rdquo;। नीचे 01 बैग समस्या में योजनाओं की संख्या को कैसे गिनें इसका परिचय दिया गया है।\nhttps://www.acwing.com/problem/content/11/\nदो-आयामी DP योजनाओं की संख्या की गणना # नीचे दो-आयामी DP का उपयोग करके एक उदाहरण दिया गया है।\nस्थिति को परिभाषित करें:\ndp[i][j] \u0026ldquo;पहले i वस्तुओं के लिए, क्षमता (आयतन सीमा) j होने पर, प्राप्त किए जा सकने वाले अधिकतम मूल्य\u0026rdquo; को दर्शाता है। ways[i][j] \u0026ldquo;पहले i वस्तुओं के लिए, क्षमता j होने पर, अधिकतम मूल्य प्राप्त करते समय संबंधित योजनाओं की संख्या\u0026rdquo; को दर्शाता है। स्थिति संक्रमण:\nयदि $i$वीं वस्तु का चयन नहीं किया जाता है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ यदि $i$वीं वस्तु का चयन किया जाता है (यह मानते हुए कि $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ चयन करें या न करें, अंततः dp[i][j] को दोनों में से बड़ा मान लेना चाहिए: यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;iवीं वस्तु का चयन करने\u0026rdquo; का मूल्य अधिक है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ तो इसका मतलब है कि दोनों तरीकों से प्राप्त अधिकतम मूल्य समान है, तो योजनाओं की संख्या को जोड़ा जाना चाहिए: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ यदि $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ तो इसका मतलब है कि \u0026ldquo;iवीं वस्तु का चयन न करने\u0026rdquo; का मूल्य अधिक है, योजनाओं की संख्या चयन न करने की योजनाओं की संख्या को विरासत में देती है: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ प्रारंभिक स्थिति:\ndp[0][j] = 0 का अर्थ है कि पहले 0 वस्तुओं के लिए, किसी भी क्षमता पर प्राप्त अधिकतम मूल्य 0 है। ways[0][0] = 1 का अर्थ है कि \u0026ldquo;पहले 0 वस्तुओं, क्षमता 0\u0026rdquo; की स्थिति एक व्यवहार्य योजना है (अर्थात कुछ भी न चुनें), योजनाओं की संख्या 1 पर सेट है। j \u0026gt; 0 के लिए, जब चुनने के लिए कोई वस्तु नहीं है और क्षमता 0 से अधिक है, तो कोई सकारात्मक मूल्य प्राप्त करना संभव नहीं है, संबंधित योजनाओं की संख्या 0 है, अर्थात ways[0][j] = 0। अंतिम उत्तर:\ndp[N][S] अधिकतम मूल्य है। ways[N][S] उस अधिकतम मूल्य को प्राप्त करने के लिए योजनाओं की संख्या है। समय जटिलता: $O(NS)$। इस प्रश्न को एक-आयामी DP का उपयोग करके भी अनुकूलित किया जा सकता है। यदि आयतन सीमा को ठीक से प्राप्त करने की आवश्यकता हो # स्थिति को परिभाषित करें: f[i][j] पहले i वस्तुओं के लिए ठीक आयतन $j$ के अधिकतम मूल्य को दर्शाता है। यदि $i$वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि $i$वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - s[i]] + v[i] ध्यान दें कि मूल समस्या के स्थिति संक्रमण में कोई अंतर नहीं है। लेकिन प्रारंभिक स्थिति अलग है। f[0][0] = 0 के अलावा, शेष f[0][j] = $-\\infty$, j $\\in [1, S]$। $-\\infty$ एक असंभव स्थिति को दर्शाता है। यदि आयतन सीमा $S$ विशेष रूप से बड़ी (1e9) है, जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मूल्य $V$ अपेक्षाकृत छोटे हैं # इस तरह के प्रश्न के लिए, $O(NV)$ की जटिलता वाला एक समाधान है। स्थिति को परिभाषित करें: f[i][j] पहले i वस्तुओं में से कुछ का चयन करने पर, मूल्य का कुल योग ठीक j होने पर न्यूनतम आयतन को दर्शाता है। यदि $i$वीं वस्तु नहीं ली जाती है, तो f[i][j] = f[i - 1][j] यदि $i$वीं वस्तु ली जाती है, तो f[i][j] = f[i - 1][j - v[i]] + s[i] दोनों में से छोटा मान लें। प्रारंभिक स्थिति: f[0][0] = 0, शेष f[0][j] = $\\infty$, j $\\in [1, V]$। $\\infty$ एक असंभव स्थिति को दर्शाता है। ध्यान दें कि यह $-\\infty$ नहीं है। अंतिम उत्तर f[N][j] में सबसे बड़ा j है जिससे f[N][j] \u0026lt;= S हो। यदि आयतन सीमा $S$ और एकल वस्तु का मूल्य $v_i$ दोनों विशेष रूप से बड़े हैं (1e9 के क्रम में), जबकि वस्तुओं की संख्या $N$ विशेष रूप से छोटी है (अधिकतम 40 से अधिक नहीं) # https://www.acwing.com/solution/content/38250/\nजब $N \\leq 20$ होता है, तो सभी उपसमुच्चयों को सीधे क्रूर बल से गिना जा सकता है (समय जटिलता $O(2^N)$)। जब $N \\leq 40$ होता है, तो $2^{40}$ $10^{12}$ के क्रम में होने के कारण, क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए मध्य-खोज का उपयोग किया जा सकता है, जटिलता को मोटे तौर पर $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ तक कम किया जा सकता है, जिसे स्वीकार्य समय में पूरा किया जा सकता है। ","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"सबसे बुनियादी क्लासिक बैग समस्या।","title":"01背包 समस्या","type":"posts"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/las-nueve-lecciones-de-la-mochila/","section":"Series","summary":"","title":"Las Nueve Lecciones De La Mochila","type":"series"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/series/nine-lectures-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Lectures on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"यदि किसी क्रमित समाधान स्थान को दो भागों में विभाजित किया जाता है, जहाँ एक भाग एक शर्त को संतुष्ट करता है और दूसरा नहीं, तो क्रमित समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग किया जा सकता है।\nबाइनरी सर्च का मूल विचार खोज अंतराल को बार-बार आधा करना है। प्रत्येक बार, मध्य तत्व की जाँच की जाती है। यदि मध्य तत्व शर्त को संतुष्ट नहीं करता है, तो अंतराल का आधा भाग समाप्त किया जा सकता है; अन्यथा, खोज दूसरे आधे भाग में जारी रहती है। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग छोड़ दिया जाता है, इसलिए खोज समय जटिलता $O(\\log n)$ तक पहुँच सकती है।\nउदाहरण समस्या # समस्या विवरण: $n$ लंबाई की एक आरोही क्रम में सॉर्ट की गई पूर्णांक सरणी दी गई है, और $q$ प्रश्न दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ की \u0026ldquo;शुरुआती स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; (सूचकांक 0 से शुरू होते हैं) खोजने की आवश्यकता है। यदि संख्या सरणी में मौजूद नहीं है, तो -1 -1 लौटाएँ।\nइनपुट प्रारूप # पहली पंक्ति: दो पूर्णांक $n$ और $q$, क्रमशः सरणी की लंबाई और प्रश्नों की संख्या का प्रतिनिधित्व करते हैं। दूसरी पंक्ति: $n$ पूर्णांक, पूरी सरणी का प्रतिनिधित्व करते हैं, जो पहले से ही आरोही क्रम में सॉर्ट की गई है। अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व का प्रतिनिधित्व करता है। डेटा रेंज # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nआउटपुट प्रारूप # प्रत्येक प्रश्न के लिए, सरणी में तत्व की शुरुआती और अंतिम स्थिति को एक ही पंक्ति में आउटपुट करें। यदि तत्व सरणी में मौजूद नहीं है, तो -1 -1 आउटपुट करें।\nउदाहरण:\nइनपुट: 6 3 1 2 2 3 3 4 3 4 5 आउटपुट: 3 4 5 5 -1 -1 स्पष्टीकरण:\nवह सीमा जहाँ तत्व $3$ दिखाई देता है, $[3, 4]$ है; तत्व $4$ केवल एक बार, स्थिति $5$ पर दिखाई देता है; तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ। समाधान # \u0026ldquo;शुरुआती स्थिति\u0026rdquo; खोजना: अर्थात, पहली स्थिति खोजना जो $k$ से अधिक या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;कम\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;अधिक या बराबर\u0026rdquo; हैं उत्तर दाईं ओर की पहली स्थिति है \u0026ldquo;अंतिम स्थिति\u0026rdquo; खोजना: अर्थात, अंतिम स्थिति खोजना जो $k$ से कम या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;कम या बराबर\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ $k$ से \u0026ldquo;अधिक\u0026rdquo; हैं उत्तर बाईं ओर की अंतिम स्थिति है अनुशंसित टेम्पलेट # नीचे एक सुरुचिपूर्ण और कम त्रुटि-प्रवण बाइनरी सर्च टेम्पलेट दिया गया है।\nदो पॉइंटर्स $l, r$ को परिभाषित करें, जिसमें अपरिवर्तनीय है: बंद अंतराल $[0, l]$ बाएं भाग से संबंधित है, और बंद अंतराल $[r, n - 1]$ दाएं भाग से संबंधित है। $l$ और $r$ को क्रमशः $-1$ और $n$ पर इनिशियलाइज़ किया गया है।\nजब एल्गोरिथम समाप्त हो जाता है, तो $l$ और $r$ आसन्न होते हैं, जो क्रमशः बाएं भाग के अंतिम तत्व और दाएं भाग के पहले तत्व की ओर इशारा करते हैं।\nक्योंकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, यदि समस्या यह नहीं बताती है कि एक समाधान निश्चित रूप से मौजूद है, तो हमें यह जांचने की आवश्यकता है कि क्या l या r सीमा से बाहर है और क्या यह सही मान की ओर इशारा करता है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k की शुरुआती स्थिति ज्ञात करें 15 // सरणी को दो भागों में विभाजित करें, बायां भाग सभी \u0026lt; k है, और दायां भाग सभी \u0026gt;= k है। 16 // उत्तर दाएं भाग का सबसे छोटा सूचकांक है। 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k की अंतिम स्थिति ज्ञात करें 33 // सरणी को दो भागों में विभाजित करें, बायां भाग सभी \u0026lt;= k है, और दायां भाग सभी \u0026gt; k है। 34 // उत्तर बाएं भाग का सबसे बड़ा सूचकांक है। 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} फायदे # इस दृष्टिकोण में सख्ती से परिभाषित अपरिवर्तनीय हैं। यह अतिरिक्त हैंडलिंग या परिवर्तनों के बिना \u0026ldquo;शुरुआती स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; दोनों को खोजने पर लागू होता है। कुछ दृष्टिकोण l == r को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो $mid$ की गणना $l$ या $r$ के बराबर होने के लिए की जाएगी। यदि सही ढंग से हैंडल नहीं किया जाता है, तो $l$ या $r$ को $mid$ में अपडेट करने से खोज अंतराल कम नहीं होगा, जिससे एक अनंत लूप हो जाएगा। इसके विपरीत, यह दृष्टिकोण तब समाप्त होता है जब $l$ और $r$ आसन्न होते हैं, यह सुनिश्चित करते हुए कि $mid$ $l$ से कम और $r$ से अधिक है, और $l$ या $r$ को अपडेट करने से हमेशा खोज अंतराल कम हो जाएगा। STL # यदि आप C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound फ़ंक्शंस का उपयोग करते हैं, तो आप वही चीज़ प्राप्त कर सकते हैं:\nlower_bound(first, last, val) \u0026ldquo;पहली स्थिति लौटाएगा जो val से अधिक या उसके बराबर है\u0026rdquo; upper_bound(first, last, val) \u0026ldquo;पहली स्थिति लौटाएगा जो val से अधिक है\u0026rdquo; उदाहरण के लिए, मान लीजिए nums = {1,2,3,4,4,4,4,4,5,5,6}, और हम वह सीमा जानना चाहते हैं जहाँ 4 दिखाई देता है:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 0 बार दिखाई देता है\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;पहला 4 \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; \u0026#34; पर है\u0026#34; \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;अंतिम 4 \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; \u0026#34; पर है\u0026#34; \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; बार दिखाई देता है\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 उस पहली स्थिति की ओर इशारा करता है जहाँ मान $4$ से अधिक या उसके बराबर है। it2 उस पहली स्थिति की ओर इशारा करता है जहाँ मान $4$ से अधिक है। इसलिए, it2 - it1 सरणी में $4$ के दिखाई देने की संख्या है; it2 - nums.begin() - 1 $4$ की दाईं सीमा की स्थिति है। अतिरिक्त नोट्स # बाइनरी सर्च को फ्लोटिंग-पॉइंट रेंज में खोजने के लिए भी बढ़ाया जा सकता है (जैसे किसी समीकरण की जड़ें खोजना) और यूनिमोडल फ़ंक्शंस के एक्सट्रीमा को खोजने के लिए टर्नरी सर्च।\nअभ्यास # LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें\nसंकेत: सबसे पहले, रोटेशन बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग करें, और फिर लक्ष्य मान को खोजने के लिए बाइनरी सर्च का उपयोग करें।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"बाइनरी सर्च एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।","title":"बाइनरी सर्च","type":"posts"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]