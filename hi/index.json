[{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 दिसंबर 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-dalgorithmes/","section":"Tags","summary":"","title":"Modèles D'algorithmes","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmi/","section":"Tags","summary":"","title":"Template Algoritmi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथ्म","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%81/","section":"Categories","summary":"","title":"एल्गोरिथ्म और डेटा संरचनाएँ","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A5%8D%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथ्म टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":" द्विआधारी खोज # यदि क्रमित समाधान स्थान को दो भागों, बाएं और दाएं में विभाजित किया जाता है, जहां एक भाग शर्त को पूरा करता है और दूसरा भाग शर्त को पूरा नहीं करता है। फिर एक महत्वपूर्ण बिंदु को खोजने के लिए क्रमित समाधान स्थान में द्विआधारी खोज का उपयोग किया जा सकता है।\nद्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधे में विभाजित करना है। प्रत्येक बार मध्य बिंदु तत्व की जाँच करें, यदि मध्य बिंदु तत्व स्थिति को पूरा नहीं करता है, तो आधे अंतराल को हटाया जा सकता है; अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूँकि प्रत्येक बार खोज अंतराल का आधा हिस्सा छोड़ा जाता है, खोज का समय जटिलता \\(O(\\log n)\\) तक पहुँच सकता है।\nउदाहरण प्रश्न # प्रश्न विवरणः एक आरोही क्रमबद्ध लंबाई \\(n\\) पूर्णांक सरणी दी गई है, साथ ही \\(q\\) क्वेरी दी गई हैं। प्रत्येक क्वेरी एक पूर्णांक \\(k\\) देती है, हमें सरणी में \\( k\\) के \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; (इंडेक्स 0 से शुरू) को खोजने की आवश्यकता है। यदि संख्या सरणी में मौजूद नहीं है, तो \\(-1\\) \\(-1\\) वापस करें।\nइनपुट प्रारूप # पहली पंक्ति: दो पूर्णांक \\(n\\) और \\(q\\), जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या को दर्शाते हैं। दूसरी पंक्ति: \\(n\\) पूर्णांक, जो पूर्ण सरणी को दर्शाते हैं, जिन्हें आरोही क्रम में क्रमबद्ध किया गया है। अगली \\(q\\) पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक \\(k\\) होता है, जो एक क्वेरी तत्व को दर्शाता है। डेटा रेंज # \\(1 \\leq n \\leq 100000\\)\n\\(1 \\leq q \\leq 10000\\)\n\\(1 \\leq k \\leq 10000\\)\nआउटपुट प्रारूप # प्रत्येक क्वेरी के लिए, सरणी में तत्व की प्रारंभिक और अंतिम स्थिति को एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो -1 -1 आउटपुट करें।\nनमूनाः\nइनपुटः 6 3 1 2 2 3 3 4 3 4 5 आउटपुटः 3 4 5 5 -1 -1 व्याख्या:\nतत्व \\(3\\) की सीमा \\([3, 4]\\) है; तत्व \\(4\\) केवल एक बार स्थिति \\(5\\) पर प्रकट होता है; तत्व \\(5\\) सरणी में मौजूद नहीं है, इसलिए \\(-1\\) \\(-1\\) वापस करें। उत्तर # \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; का पता लगाएं: यानी पहली स्थिति खोजें जो \\(k\\) से बड़ी या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ \\(k\\) से \u0026ldquo;छोटी\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ \\(k\\) से \u0026ldquo;बड़ी या बराबर\u0026rdquo; हैं उत्तर दाईं ओर की पहली स्थिति है \u0026ldquo;अंतिम स्थिति\u0026rdquo; का पता लगाएं: यानी आखिरी स्थिति खोजें जो \\(k\\) से छोटी या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:\nबाईं ओर की सभी संख्याएँ \\(k\\) से \u0026ldquo;छोटी या बराबर\u0026rdquo; हैं दाईं ओर की सभी संख्याएँ \\(k\\) से \u0026ldquo;बड़ी\u0026rdquo; हैं उत्तर बाईं ओर की अंतिम स्थिति है अनुशंसित टेम्पलेट # नीचे एक सुंदर और त्रुटि-मुक्त द्विआधारी टेम्पलेट दिया गया है। यह \\(l\\) और \\(r\\) को धीरे-धीरे एक साथ लाकर सुनिश्चित करता है कि चक्र दोनों के आसन्न होने पर समाप्त हो:\nदो पॉइंटर्स \\(l, r\\) को परिभाषित करें, एक अपरिवर्तनीय है: बंद अंतराल \\([0, l]\\) सभी बाईं ओर के भाग से संबंधित हैं, बंद अंतराल \\([r, n - 1]\\) सभी दाईं ओर के भाग से संबंधित हैं। \\(l\\) और \\(r\\) दोनों को \\(-1\\) और \\(n\\) पर इनिशियलाइज़ किया जाता है।\nजब एल्गोरिथ्म समाप्त होता है, तो \\(l\\) और \\(r\\) आसन्न होते हैं, क्रमशः बाईं ओर के अंतिम तत्व और दाईं ओर के पहले तत्व की ओर इशारा करते हैं।\nक्योंकि हम जो हल चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए यदि प्रश्न यह नहीं बताता है कि कोई समाधान निश्चित रूप से मौजूद है, तो हमें यह न्याय करने की आवश्यकता है कि l या r सीमा से बाहर है या नहीं और क्या यह सही मान की ओर इशारा करता है।\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k की शुरुआती स्थिति खोजें 15 // सरणी को दो भागों में विभाजित करें, बाईं ओर सब \u0026lt; k, दाईं ओर सब \u0026gt;= k। 16 // उत्तर दाईं ओर का न्यूनतम इंडेक्स है। 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k की अंतिम स्थिति खोजें 33 // सरणी को दो भागों में विभाजित करें, बाईं ओर सब \u0026lt;= k, दाईं ओर सब \u0026gt; k। 34 // उत्तर बाईं ओर का अधिकतम इंडेक्स है। 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} इसे इस तरह क्यों लिखें # इस लेखन में अपरिवर्तनीय की सख्त परिभाषा है। यह \u0026ldquo;प्रारंभिक स्थिति\u0026rdquo; और \u0026ldquo;अंतिम स्थिति\u0026rdquo; दोनों स्थितियों को खोजने के लिए उपयुक्त है, इसके लिए अतिरिक्त हैंडलिंग और परिवर्तन की आवश्यकता नहीं है। कुछ लेखन l == r का उपयोग समाप्ति शर्त के रूप में करते हैं। जब \\(l\\) और \\(r\\) \\(1\\) से भिन्न होते हैं, तो यह \\(mid\\) की गणना \\(l\\) या \\(r\\) के बराबर करेगा। यदि सही तरीके से हैंडल नहीं किया जाता है, तो \\(l\\) या \\(r\\) को \\(mid\\) पर अपडेट करना, खोज अंतराल को कम नहीं करता है, जिससे एक अनंत चक्र होता है। इसके विपरीत, यहां की लेखन शैली \\(l\\) में समाप्त होती है और \\(r\\) आसन्न होते हैं, यह सुनिश्चित करते हैं कि \\(mid\\) \\(l\\) से छोटा है और \\(r\\) से बड़ा है, और जब \\(l\\) या \\(r\\) अपडेट किया जाता है तो खोज अंतराल निश्चित रूप से कम हो जाएगा। STL # यदि C++ STL द्वारा प्रदान किए गए lower_bound और upper_bound कार्यों का उपयोग किया जाता है, तो भी वही किया जा सकता है:\nlower_bound(first, last, val) \u0026ldquo;पहला स्थान जो val से बड़ा या उसके बराबर है\u0026rdquo; वापस करेगा। upper_bound(first, last, val) \u0026ldquo;पहला स्थान जो val से बड़ा है\u0026rdquo; वापस करेगा। एक उदाहरण के रूप में, मान लीजिए कि nums = {1,2,3,4,4,4,4,4,5,5,6} और हम जानना चाहते हैं कि 4 किस अंतराल में दिखाई देता है:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 पहले मान से अधिक या \\(4\\) के बराबर स्थान पर इंगित करता है। it2 पहले मान से अधिक \\(4\\) के स्थान पर इंगित करता है। तो it2 - it1 सरणी में \\(4\\) की संख्या है; it2 - nums.begin() - 1 \\(4\\) की दाहिनी सीमा है। पूरक # द्विआधारी खोज को फ़्लोटिंग-पॉइंट नंबर रेंज (जैसे समीकरणों की जड़ें खोजना), साथ ही सिंगल-पीक फ़ंक्शंस के अधिकतम मानों को खोजने के लिए त्रिगुट खोज तक भी बढ़ाया जा सकता है। जब तक आप \u0026ldquo;क्रमबद्ध अंतराल में, हर बार आधे हिस्से को हटाया जा सकता है\u0026rdquo; के मूल सिद्धांत को समझते हैं, आप पाएंगे कि द्विआधारी खोज कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकती है।\nअभ्यास # LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें\nसंकेत: पहला चरण घूर्णन बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।\n","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"पूर्णांक द्विआधारी खोज एल्गोरिथ्म को सुंदरता से कैसे लागू करें।","title":"द्विआधारी खोज","type":"posts"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/hi/series/","section":"Series","summary":"","title":"Series","type":"series"}]