[{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer-algorithm/","section":"Tags","summary":"","title":"Divide and Conquer Algorithm","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"Quick sort is a comparison-based, unstable sorting algorithm that employs a divide-and-conquer strategy. Its average time complexity is $O(n\\log n)$, with a worst-case complexity of $O(n^2)$, and a space complexity of $O(1)$. The following will use sorting an integer sequence in ascending order as an example to introduce its implementation details and common mistakes.\nProblem Description # Given an integer sequence of length $n$, use quick sort to sort it in ascending order and output the result.\nInput Format # The first line inputs an integer $n$. The second line inputs $n$ integers, all within the range $[1, 10^9]$. Output Format # Output the sorted sequence on a single line. Data Range # $1 \\leq n \\leq 100000$\nInput Example # 5 3 1 2 4 5 Output Example # 1 2 3 4 5 Quick Sort Idea # Each time quick sort divides, it arbitrarily selects a number as the pivot (below, the number in the middle position is chosen).\nUse left and right pointers moving towards each other. The left pointer L searches from left to right for the first number greater than or equal to the pivot, and the right pointer R searches from right to left for the first number less than or equal to the pivot. Then, swap these two numbers.\nRepeat this process continuously until the left and right pointers overlap or the left pointer is one position to the right of the right pointer. This is called one cycle.\nAfter each pointer movement and swap, ensure that the structure \u0026ldquo;left part ≤ pivot, right part ≥ pivot\u0026rdquo; is not broken, i.e., there is an invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIn the example code below, left and right are the boundaries of the currently processed closed interval, and pivot is taken as the element at the midpoint of the interval.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexity and pivot Selection # Since quick sort has a complexity of $O(n^2)$ in the worst case, the selection of the pivot is crucial. If the first or last element is always chosen, the worst case is likely to occur in nearly sorted arrays.\nIn addition to taking the element in the middle position, a random element can be selected as the pivot, or the median of the left, middle, and right elements can be taken as the pivot.\nCommon Error Examples # The following code contains several common errors.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Error Analysis:\nThe pivot should be a number in the array, not an index. Use \u0026lt; and \u0026gt; instead of \u0026lt;= and \u0026gt;=, otherwise the left pointer may move more than one position past the right pointer, which would prevent the array from being divided into two parts. After l \u0026gt;= r is detected, the loop should be exited immediately, without performing the swap. Otherwise, it cannot be guaranteed that elements on the left are not greater than pivot and elements on the right are not less than pivot. After each swap, l++ and r-- should be executed. The pivot actually takes the number that is slightly to the left of the middle. Therefore, if the array is divided using $l - 1$ and $l$, consider the array [1, 2]. It is not difficult to see that this will cause an infinite loop, continuously dividing the array into two parts of size 0 and 2. Similarly, using $r$ and $l$ to divide the array will also not work. Conversely, at the end of a round of the loop, $r$ must be less than $right$, so $r$ and $r+1$ can be used to divide the array. The reader can simulate the algorithm process to see why. Another simple way to avoid infinite loops is to randomly select the pivot or handle the case where there are only two elements specially. Additionally, using $l$ and $l+1$ will also not work, because this division does not conform to the definition. When $r$ is to the left of $l$, using $l$ and $l+1$ cannot correctly divide the array into two parts: the left part less than or equal to pivot, and the right part greater than or equal to pivot. This problem assumes that the array is non-empty, so the case of \u0026gt; does not exist. However, it is safer to use \u0026gt;=, which is recommended. Supplement # Quick sort can also be evolved into \u0026ldquo;quick select\u0026rdquo;, which can find the $k$-th smallest number in an unordered array in $O(n)$ expected time. The specific idea is similar to quick sort, except that it only continues recursion in one sub-interval each time, thus reducing the time complexity.\n","date":"26 December 2024","externalUrl":null,"permalink":"/posts/1735252761946-quick-sort/","section":"Posts","summary":"Key Points for Correctly Implementing the Quick Sort Algorithm.","title":"Quick Sort","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Problem # There are $N$ items. The volume of the $i$-th item is $s_i$, and its value is $v_i$. Each item can only be taken once. Under the premise of not exceeding the maximum total volume limit $S$, find the maximum total value $V$ that can be obtained.\nInput Format # The first line contains two integers, $N$ and $S$, separated by a space, representing the number of items and the maximum total volume limit, respectively. The following $N$ lines each contain two integers, $s_i$ and $v_i$, separated by a space, representing the volume and value of the $i$-th item, respectively.\nOutput Format # Output an integer representing the maximum value.\nData Range # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Input Example # 4 5 1 2 2 4 3 4 4 5 Output Example # 8 Solution # Define the state: f[i][j] represents the maximum value that can be obtained from the first $i$ items with a volume limit of $j$. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j]. If the $i$-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i]. When implementing the state transition, pay attention to the domain range. If $j \u003c s_i$, then do not consider taking the $i$-th item. Because if $j - s_i$ is negative, the array index is illegal. It can also be explained this way: the volume of the $i$-th item is greater than the volume limit, so it is impossible. Define the initial condition: For the first 0 items, any volume limit yields a value of 0, i.e., f[0][j] = 0, j $\\in [0, S]$. Time complexity: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimization # Compressing a two-dimensional array into a one-dimensional array can significantly save space and improve the running speed to a certain extent (the disadvantage is that it cannot meet the special requirements of some problem types). Note that in the state transition, f[i][j] is only related to f[i - 1][j] and f[i - 1][j - s[i]]. In other words, in the two-dimensional array f in the code, f[i][j] is only related to the elements in the previous row that are to its left or in the same column. Therefore, the two-dimensional array can be compressed into a one-dimensional array or a rolling array. Note that in the code below, the second loop iterates in reverse order. This is because we need to ensure that when calculating f[i][j], f[i - 1][j - s[i]] has not been updated yet. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} If the Number of Solutions is Required # If you need to output not only the maximum total value that can be obtained, but also \u0026ldquo;how many different selection methods can achieve this maximum total value\u0026rdquo;, the following introduces how to count the number of solutions in the 01 knapsack problem.\n2D DP for Counting Solutions # The following uses 2D DP as an example for explanation.\nDefine the state:\ndp[i][j] represents \u0026ldquo;the maximum value that can be obtained when considering the first i items with a capacity (volume limit) of j\u0026rdquo;. ways[i][j] represents \u0026ldquo;the number of solutions corresponding to the maximum value obtained when considering the first i items with a capacity of j\u0026rdquo;. State transition:\nIf the $i$-th item is not selected: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ If the $i$-th item is selected (provided that $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Whether to select or not, the final dp[i][j] should take the larger of the two: If $$ \\text{dp}[i-1][j - s_i] + v_i $$ then it means that \"selecting the i-th item\" has a greater value: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$\nIf $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ it means that the maximum value obtained by the two methods is the same, then the number of solutions should be added: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] \\text{ways}[i-1][j - s_i]. $$ If $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ then it means that \u0026ldquo;not selecting the i-th item\u0026rdquo; has a greater value, and the number of solutions inherits the number of solutions when not selecting: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Initial conditions:\ndp[0][j] = 0 means that when there are 0 items, the maximum value obtained for any capacity is 0. ways[0][0] = 1 means that \u0026ldquo;0 items, capacity 0\u0026rdquo; is a feasible solution (i.e., selecting nothing), and the number of solutions is set to 1. For j \u0026gt; 0, when there are no items to choose from and the capacity is greater than 0, it is impossible to obtain any positive value, and the corresponding number of solutions is 0, i.e., ways[0][j] = 0. Final answer:\ndp[N][S] is the maximum value. ways[N][S] is the number of solutions to achieve this maximum value. Time complexity: $O(NS)$. This problem can also be optimized using 1D DP. If the Requirement is to Reach the Volume Limit Exactly # Define the state: f[i][j] represents the maximum value when the first i items have a volume of exactly $j$. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j]. If the $i$-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i]. It can be noted that there is no difference from the state transition of the original problem. However, the initial conditions are different. Besides f[0][0] = 0, the rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ represents an impossible state. If the Volume Limit $S$ is Very Large (1e9), While the Number of Items $N$ and the Maximum Total Value $V$ are Relatively Small # For such problems, there is a solution with a complexity of $O(NV)$. Define the state: f[i][j] represents the minimum volume when selecting some of the first i items with a total value of exactly j. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j]. If the $i$-th item is taken, then f[i][j] = f[i - 1][j - v[i]] + s[i]. Take the smaller of the two. Initial condition: f[0][0] = 0, the rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ represents an impossible state. Note that it is not $-\\infty$. The final answer is the largest j in f[N][j] such that f[N][j] \u0026lt;= S. If the Volume Limit $S$ and the Value of a Single Item $v_i$ are Both Very Large (on the order of $1e9$), While the Number of Items $N$ is Very Small (no more than 40) # When $N \\leq 20$, all subsets can be directly enumerated (time complexity $O(2^N)$). When $N \\leq 40$, since $2^{40}$ is on the order of $10^{12}$, direct brute force will also be relatively large. Therefore, meet-in-the-middle search can be used to reduce the complexity to approximately $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, which can be completed within an acceptable time. ","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"The most basic classic knapsack problem.","title":"0-1 knapsack problem","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"If an ordered solution space is divided into left and right parts, where one part satisfies a condition and the other does not, then binary search can be used to find the critical point in the ordered solution space.\nThe basic idea of binary search is to repeatedly halve the search interval. Each time, the middle element is checked. If the middle element does not satisfy the condition, half of the interval can be excluded; otherwise, the search continues in the other half. Since half of the search interval is discarded each time, the search time complexity can reach $O(\\log n)$.\nExample Problem # Problem Description: Given an ascending-ordered integer array of length $n$, and $q$ queries. Each query gives an integer $k$, and we need to find the \u0026ldquo;starting position\u0026rdquo; and \u0026ldquo;ending position\u0026rdquo; of $k$ in the array (indices start from 0). If the number does not exist in the array, return -1 -1.\nInput Format # First line: two integers $n$ and $q$, representing the length of the array and the number of queries, respectively. Second line: $n$ integers, representing the complete array, already sorted in ascending order. The following $q$ lines: each line contains an integer $k$, representing a query element. Data Range # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nOutput Format # For each query, output the starting and ending positions of the element in the array on one line. If the element does not exist in the array, output -1 -1.\nExample:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Explanation:\nThe range where element $3$ appears is $[3, 4]$; Element $4$ appears only once, at position $5$; Element $5$ does not exist in the array, so return $-1$ $-1$. Solution # Finding the \u0026ldquo;Starting Position\u0026rdquo;: That is, finding the first position greater than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than or equal to\u0026rdquo; $k$ The answer is the first position on the right Finding the \u0026ldquo;Ending Position\u0026rdquo;: That is, finding the last position less than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than or equal to\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than\u0026rdquo; $k$ The answer is the last position on the left Recommended Template # Below is an elegant and less error-prone binary search template.\nDefine two pointers $l, r$, with the invariant: the closed interval $[0, l]$ belongs to the left part, and the closed interval $[r, n - 1]$ belongs to the right part. $l$ and $r$ are initialized to $-1$ and $n$, respectively.\nWhen the algorithm terminates, $l$ and $r$ are adjacent, pointing to the last element of the left part and the first element of the right part, respectively.\nSince the solution we want may not exist, if the problem does not state that a solution definitely exists, we need to check if l or r is out of bounds and if it points to the correct value.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Find the starting position of k 15 // Divide the array into two parts, the left part all \u0026lt; k, the right part all \u0026gt;= k. 16 // The answer is the smallest index of the right part. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // If r is out of bounds or nums[r] != k, it means k does not exist 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Find the ending position of k 33 // Divide the array into two parts, the left part all \u0026lt;= k, the right part all \u0026gt; k. 34 // The answer is the largest index of the left part. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Advantages # This approach has strictly defined invariants. It applies to both finding the \u0026ldquo;starting position\u0026rdquo; and the \u0026ldquo;ending position\u0026rdquo; without extra handling or changes. Some approaches use l == r as the termination condition. When $l$ and $r$ differ by $1$, $mid$ will be calculated to be equal to $l$ or $r$. If not handled correctly, updating $l$ or $r$ to $mid$ will not shrink the search interval, leading to an infinite loop. In contrast, this approach terminates when $l$ and $r$ are adjacent, ensuring that $mid$ is less than $l$ and greater than $r$, and updating $l$ or $r$ will always shrink the search interval. STL # If you use the lower_bound and upper_bound functions provided by C++ STL, you can also accomplish the same thing:\nlower_bound(first, last, val) returns the \u0026ldquo;first position greater than or equal to val\u0026rdquo; upper_bound(first, last, val) returns the \u0026ldquo;first position greater than val\u0026rdquo; For example, suppose nums = {1,2,3,4,4,4,4,4,5,5,6}, and we want to know the range where 4 appears:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 points to the first position where the value is greater than or equal to $4$. it2 points to the first position where the value is greater than $4$. Therefore, it2 - it1 is the number of times $4$ appears in the array; it2 - nums.begin() - 1 is the position of the right boundary of $4$. Supplement # Binary search can also be extended to search in floating-point ranges (such as finding roots of equations) and ternary search for finding the extrema of unimodal functions.\nPractice # LeetCode 33. Search in Rotated Sorted Array\nHint: First use binary search to find the rotation point, and then use binary search to find the target value.\n","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"How to implement the binary search algorithm elegantly.","title":"Binary Search","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/series/classic-knapsack-problem-set/","section":"Series","summary":"","title":"Classic Knapsack Problem Set","type":"series"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]