[{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":" Binary Search # Binary search can be used to quickly find a specific element in an ordered sequence. Compared to the linear search with a time complexity of $O(n)$, binary search only requires $O(\\log n)$ time, making it very efficient when dealing with large data sets.\nThe Core Idea of Binary Search # The basic idea of binary search is to repeatedly halve the search interval. Each time, the middle element is compared with the target value. If the middle element does not satisfy the condition, half of the interval can be eliminated; otherwise, the search continues in the other half of the interval. Since half of the search interval is discarded each time, the search time complexity can reach $O(\\log n)$.\nBinary search is very useful for problems where \u0026ldquo;feasible solutions can be divided into one ordered interval (satisfying the condition) and another ordered interval (not satisfying the condition)\u0026rdquo;. For example:\nFinding whether an element exists in an ordered array Finding the \u0026ldquo;first position\u0026rdquo; or \u0026ldquo;last position\u0026rdquo; where a number appears Example: Finding the Start and End Positions of an Element # Problem Description: Given an ascendingly sorted integer array of length $n$, and $q$ queries. Each query gives an integer $k$, and we need to find the \u0026ldquo;starting position\u0026rdquo; and \u0026ldquo;ending position\u0026rdquo; of $k$ in the array (indexes starting from 0). If the number does not exist in the array, return $-1$ $-1$.\nInput Format:\nThe first line: two integers $n$ and $q$, representing the length of the array and the number of queries, respectively. The second line: $n$ integers (within the range of 1 ~ 10000), representing the complete array, already sorted in ascending order. The following $q$ lines: each line contains an integer $k$, representing a query element. Output Format: For each query, output the start and end positions of the element in the array on a single line. If the element does not exist in the array, output $-1$ $-1$.\nExample:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Explanation:\nThe range where element 3 appears is [3, 4]; Element 4 appears only once, at position 5; Element 5 does not exist in the array, so return -1 -1. The Application Approach of Binary Search # In this problem, we can rely on binary search to find the \u0026ldquo;left boundary\u0026rdquo; and \u0026ldquo;right boundary\u0026rdquo; of a certain value. The key is to understand how to define the search interval and how to move the pointers based on the comparison result.\nFinding the \u0026ldquo;left boundary\u0026rdquo;: That is, finding the first position that is greater than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than or equal to\u0026rdquo; $k$ Finding the \u0026ldquo;right boundary\u0026rdquo;: That is, finding the last position that is less than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than or equal to\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than\u0026rdquo; $k$ As long as these two intervals can be correctly maintained, the result can be quickly obtained through binary search.\nRecommended Template: Binary Search Code to Avoid Infinite Loops # Here\u0026rsquo;s an elegant and error-resistant binary search template. It ensures the loop terminates when $l$ and $r$ are adjacent by gradually bringing $l$ and $r$ closer:\nDefine two pointers $l, r$, with the invariants: the closed interval $[0, l]$ all belongs to the left part, the closed interval $[r, n - 1]$ all belongs to the right part. $l$ and $r$ are initialized to $-1$ and $n$, respectively.\nWhen the algorithm terminates, $l$ and $r$ are adjacent, pointing to the maximum value in the left part and the minimum value in the right part, respectively.\nBecause the desired solution may not exist, when returning $l$ or $r$, it is necessary to check if the corresponding value is the value we want and if it is out of bounds. For example, $l$ represents the maximum value $\\leq k$, and we need to check l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Find the starting position of k (left boundary) // Divide the array into two parts, the left part all \u0026lt; k, and the right part all \u0026gt;= k. // The left boundary is the smallest index of the right part. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // If r is out of bounds or nums[r] != k, it means k does not exist if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Record the left boundary of k // 2. Find the ending position of k (right boundary) // Divide the array into two parts, the left part all \u0026lt;= k, and the right part all \u0026gt; k. // The right boundary is the largest index of the left part. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Since we have already verified that k exists, there is no need to verify again here int rightPos = l; // Right boundary cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Why is this method less error-prone? # This method has strictly defined invariants. It can find both the left and right boundaries, making it applicable to all scenarios. Some methods use $l == r$ as the termination condition. When $l$ and $r$ differ by 1, the calculated $mid$ will be equal to l or r. If not handled correctly, updating l or r to mid will not shrink the search interval, leading to an infinite loop. In contrast, this method terminates when $l$ and $r$ are adjacent, avoiding this problem. STL Solution: lower_bound and upper_bound # If you use the lower_bound and upper_bound functions provided by C++ STL, you can easily accomplish the same thing:\nlower_bound(first, last, val) returns \u0026ldquo;the first position greater than or equal to val\u0026rdquo; upper_bound(first, last, val) returns \u0026ldquo;the first position greater than val\u0026rdquo; For example, suppose nums = {1,2,3,4,4,4,4,4,5,5,6}, and we want to know the interval where 4 appears:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Indicates that 4 does not exist in the array cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; } it1 points to the first position where the value is greater than or equal to 4. it2 points to the first position where the value is greater than 4. Therefore, it2 - it1 is the number of times 4 appears in the array; it2 - nums.begin() - 1 is the right boundary of 4. These two functions are particularly convenient when searching intervals or counting occurrences.\nSupplement # Binary search can also be extended to search within floating-point numbers (e.g., finding the roots of an equation), as well as ternary search to find the extreme values of unimodal functions. As long as you understand the core principle of \u0026ldquo;eliminating half in an ordered interval each time,\u0026rdquo; you will find that binary search can help you solve problems efficiently in many scenarios.\nHomework # LeetCode 33. Search in Rotated Sorted Array\nHint: Use binary search to find the rotation point first, and then use binary search to find the target value.\n","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"How to elegantly implement the integer binary search algorithm.","title":"Binary Search","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]