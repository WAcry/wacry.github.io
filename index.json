[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":" I. The CAP Theorem # 1.1 What is the CAP Theorem? # The CAP Theorem was proposed by Eric Brewer in 2000. Its core idea is:\nC (Consistency): All nodes in the system see the same data at the same time. More strictly, when a client reads data, the result should be consistent with the latest committed data, regardless of which replica is read from (usually referring to strong consistency/linearizability). A (Availability): The system can still provide normal services when partial failures occur. Each request can receive a \u0026ldquo;valid response\u0026rdquo; within a reasonable time (not necessarily successful, but also including correct failure responses). P (Partition Tolerance): The system can tolerate network partitions (unreachable communication between nodes). Even if the network is split, the system can provide a certain degree of availability or consistency. In a real distributed environment, network partitions are inevitable, so P is basically considered a \u0026ldquo;must-have\u0026rdquo;. When a network partition occurs, the system cannot simultaneously ensure strong consistency and high availability of data across all nodes. It can only make trade-offs between C and A, resulting in two main types: CP and AP.\n1.2 Limitations of the CAP Theorem # It should be noted that the CAP theorem itself is a relatively high-level theory, used for conceptual guidance, and should not be simply understood as \u0026ldquo;either choose C or choose A\u0026rdquo;. There are some common misunderstandings:\nC is not necessarily strong consistency The C in the CAP theorem often refers to consistency in the strictest sense (i.e., linearizability). However, in actual systems, we have many fine-grained models to choose from, such as weak consistency, Read Committed, and Causal Consistency. Availability is not 0 or 1 It is not that choosing CP means availability is completely sacrificed, or that choosing AP means consistency is not guaranteed at all. There is room for trade-offs and degradation strategies for both availability and consistency. Eventual consistency does not violate CAP It is a very common compromise, using lower write consistency in exchange for higher availability and throughput, and converging data in the background asynchronously. Therefore, the CAP theorem should be combined with various consistency models and high-availability architecture patterns in specific scenarios to generate real practical guidance.\nII. Consistency Models in Distributed Systems # Consistency models are classified in many ways, but the common mainstream models can be roughly divided into: strong consistency and weak consistency (which includes eventual consistency, causal consistency, etc.). This article mainly introduces strong consistency and eventual consistency, and explains their common applications in CP or AP modes.\n2.1 Strong Consistency # Strong Consistency, also known as Linearizability, means that once a write operation is completed and returns successfully, any subsequent read operation can read the updated content. That is, the system behaves as if all operations were executed serially.\nCommon Implementation: Relies on synchronous replication and a quorum (majority) mechanism, using protocols (such as Paxos/Raft) to ensure that there is only one valid leader in the system. All operations are written to the log in order and replicated to the majority of nodes. Advantages and Disadvantages: Advantages: Guarantees the strictest data correctness, and the data read at any time does not \u0026ldquo;revert\u0026rdquo;. Disadvantages: In the event of network jitter, partitions, or leader failures, write operations are often blocked to maintain consistency, leading to a decrease in overall availability; performance and throughput are also relatively lower. 2.2 Eventual Consistency # Eventual Consistency is a typical form of weak consistency. It only requires that if the system no longer has new update operations, the data of all replicas will gradually converge to the same state over time. During this period, users may see outdated values when reading replica data, but it will eventually become consistent.\nCommon Implementation: Gossip protocol, asynchronous multi-replica replication, CRDT (Conflict-free Replicated Data Type), etc. Advantages and Disadvantages: Advantages: High availability, high throughput, low write operation latency, and high tolerance for network partitions. Disadvantages: Need to tolerate short-term data inconsistencies, more complex application logic, and may require conflict detection and merging. III. Common Consistency Protocols and Algorithms # To keep distributed system replicas consistent, the industry has proposed many classic algorithms and protocols. Here are a few brief introductions:\n3.1 Paxos # Paxos is a distributed consensus algorithm proposed by Leslie Lamport in the 1990s, mainly used to achieve strong consistency or linearizability.\nBasic Principle: Through role division (Proposer, Acceptor, Learner), multiple rounds of voting are conducted to determine whether an operation or value is accepted by the majority of nodes. Advantages and Disadvantages: Advantages: Can still reach a consensus under network partitions and node failures, with high security. Disadvantages: Complex to implement, difficult to debug and troubleshoot, and performance is limited due to multiple rounds of voting. Industrial applications often use its variants (Multi-Paxos, etc.). 3.2 Raft # Raft was officially proposed in 2013, with the goal of simplifying implementation and understanding while ensuring the same level of security as Paxos. It establishes a stable Leader role to centrally perform log replication and fault recovery:\nKey Stages: Leader Election, Log Replication, Safety, etc. Common Applications: Etcd, Consul, TiKV, LogCabin, etc., are all based on Raft to achieve strong consistent replication. Advantages and Disadvantages: Advantages: Relatively easy to understand, less code to implement; good performance for small and medium-sized clusters. Disadvantages: Relies on the master node (Leader), and leader failures or partitions can cause temporary write blocking; in large-scale clusters or cross-regional deployments, latency and availability can be affected. 3.3 Gossip Protocol # The Gossip protocol is not a traditional consensus protocol. It is mainly used in decentralized scenarios to exchange metadata or status information through random interactions between nodes, thereby spreading and converging across the entire network.\nFeatures: Decentralized, low overhead, nodes periodically and randomly exchange messages. Common Applications: Cassandra, Riak, distributed membership management (such as Serf), etc., are used to achieve eventual consistency, replica state synchronization, etc. Advantages and Disadvantages: Advantages: Good scalability, simple to implement, suitable for scenarios with low consistency requirements and high scalability requirements. Disadvantages: Weak consistency guarantees, requiring higher-level conflict handling methods (such as CRDT, version number merging, etc.) to ultimately resolve conflicts. 3.4 2PC / 3PC # In distributed transaction scenarios, common commit protocols are 2PC (Two-phase Commit) and 3PC (Three-phase Commit):\n2PC: The coordinator notifies all participants to \u0026ldquo;prepare\u0026rdquo;, and if all are successful, it broadcasts \u0026ldquo;commit\u0026rdquo;, otherwise \u0026ldquo;abort\u0026rdquo;. 3PC: Adds a phase on top of 2PC to reduce blocking caused by single points of failure, but is more complex to implement and still has unavailability issues in extreme network partitions or failure scenarios. Advantages and Disadvantages: Advantages: Easy to understand, clear transaction semantics, widely used in distributed databases, message queues, etc. Disadvantages: Strong dependence on the coordinator, risk of blocking; may not be able to continue the transaction when the network is partitioned for a long time. IV. Two Main Choices of CAP: CP and AP # After we determine that P is a \u0026ldquo;must-have\u0026rdquo; attribute, if a distributed system wants to continue providing services during network partitions, it must make a choice between C and A. Common system designs are therefore divided into two major camps: CP and AP.\n4.1 CP Systems # CP (Consistency + Partition tolerance): When encountering network partitions, the system will choose to prioritize consistency and sacrifice availability when necessary.\nTypical Implementation: Majority consensus (Paxos, Raft, etc.), requiring more than half of the nodes to be alive and reach a consensus before allowing writes. If a quorum cannot be reached or the master node fails, the system will block or reject write operations to prevent data inconsistencies caused by split-brain. Common Applications: Zookeeper, Etcd, Consul, distributed lock services, distributed metadata management, etc. Core financial transaction processes, bank accounting systems, and other scenarios with high consistency requirements. Features: Has strict data guarantees: rather shut down than have dual masters or data chaos. Sacrifices some availability: during network partitions or failovers, there will be a window of service unavailability or rejection of write operations. 4.2 AP Systems # AP (Availability + Partition tolerance): When encountering network partitions, the system will choose to prioritize availability while relaxing consistency.\nTypical Implementation: Eventual consistency, multi-master replication, Gossip protocol, Dynamo-style tunable consistency strategies, etc. Common Applications: NoSQL databases (Cassandra, Riak, DynamoDB, etc.), distributed caching systems (Redis Cluster), etc. Social networks, log collection, recommendation systems, and other businesses that require high availability and high throughput, with relatively relaxed requirements for data consistency. Features: Even during partitions, all nodes still accept read and write requests, ensuring the system is \u0026ldquo;as available as possible\u0026rdquo;. Data may have short-term inconsistencies, but will gradually converge in the background through asynchronous synchronization and conflict merging. V. How to Choose Between CP and AP? # In real large-scale distributed systems, it is often rare to rely on a single model. Instead, different data or business scenarios are processed in layers to achieve the optimal balance between consistency and availability.\nChoose CP for core data Such as user account balances, order payments, financial transaction flows, etc., which have extremely high consistency requirements. Tolerate short-term unwriteability caused by network jitter, but cannot tolerate errors in balances or transaction amounts. Choose AP for edge or cached data Such as cached product detail pages, user behavior logs, recommendation candidate lists, etc., which have lower consistency requirements. More emphasis is placed on high concurrency and high availability, and it is acceptable to tolerate a certain amount of delayed updates or dirty reads. Many internet companies use hybrid architectures: core transaction processes use CP-style storage (such as distributed relational databases or distributed storage with strong consistency); peripheral businesses or \u0026ldquo;read-heavy\u0026rdquo; scenarios use AP-style storage or caching solutions.\nVI. How CP and AP Achieve High Concurrency and Eventual Consistency # 6.1 How CP Systems Handle High Concurrency # Although consensus protocols face higher latency and lower throughput when the single cluster node scale and write request volume are large, concurrency and scalability can still be improved through the following means:\nBatch Read and Write Package multiple write operations on the client or middleware layer and write them to the leader node at once, reducing network round trips and protocol rounds. Database Sharding \u0026amp; Multi-Cluster Split data by logic or hash into multiple clusters (sharding), each cluster still runs the CP protocol internally; requests are distributed to different shards through routing or proxy layers. Improve overall concurrency and limit the impact of failures to a single shard. The single-shard cluster throughput of CP systems is often 2 to 10 times lower than that of AP systems.\n6.2 How AP Systems Ensure Eventual Consistency # AP systems can usually provide high write throughput and read availability, but they relax consistency. Therefore, consistency convergence needs to be ensured in the background or business logic layer:\nVersion Numbers (Vector Clock) or Logical Timestamps Assign a version number to each update operation (or based on Lamport Clock / Hybrid Clock), and merge in conflict scenarios or use a timestamp-based winner strategy (Last Write Wins). Gossip Protocol / Anti-entropy Mechanism Nodes periodically exchange the latest data or metadata, and merge if conflicts are found. Tunable Consistency Strategies Represented by the Dynamo model, clients can configure parameters such as R and W (such as writing to a majority, replica confirmation), thereby flexibly adjusting between consistency and availability. Custom Conflict Resolution Strategies Merge based on business semantics, such as using \u0026ldquo;union\u0026rdquo; for shopping carts, and using CRDT (G-counter, PN-counter, etc.) for counters to ensure data monotonicity. VII. Cross-Shard Strong Consistency Implementation in CP # As mentioned in Chapter VII, database sharding can \u0026ldquo;split\u0026rdquo; the pressure of a single CP cluster into multiple sub-clusters to support higher concurrency. However, when a business needs to perform transactions across shards (i.e., involving updates to multiple databases or tables), it still faces the challenge of multi-shard consistency. There are usually the following approaches:\nDistributed Transactions: 2PC / 3PC If the application needs to perform atomic updates across multiple shards, distributed transaction protocols (such as 2PC, 3PC) are usually used to coordinate the commit or rollback of each shard. Problems and Countermeasures: 2PC/3PC both rely on a coordinator node, which can become a single point of failure. In extreme cases of severe network partitions or coordinator failures, blocking may occur. Generally, master-slave switching, heartbeat detection and timeout mechanisms, idempotent retries, and MVCC are used to reduce the impact of blocking and the risk of data inconsistency. Cell-based Architecture Divide the business into multiple autonomous cells, and the data in each cell is in the same shard set, ensuring that most transactions are completed in a single cell, reducing cross-shard operations. Use asynchronous or eventual consistency mechanisms for data exchange at cell boundaries, taking into account the overall high availability and consistency. Global Distributed Database + Global Consensus Protocol For example, Google Spanner uses Paxos to achieve strong consistent replication of replicas on each shard, and then uses the TrueTime API to provide global timestamps to ensure cross-shard consistency. This solution is extremely complex to implement, but it can provide near-strong consistent distributed transaction capabilities on a global scale. Summary: For cross-shard transactions that strictly require strong consistency, 2PC/3PC + coordinator is still a common solution, and the possibility of failure is reduced by improving the high availability of the coordinator as much as possible. However, in engineering practice, cross-shard write operations should be minimized, or most transactions should be limited to a single shard range through cell-based ideas to reduce system complexity.\nVIII. Discussion of Famous Cases # Let\u0026rsquo;s briefly discuss several distributed systems that are often mentioned in the industry and see their trade-offs and implementation methods on CAP:\nGoogle Spanner A typical CP system (it can even achieve the \u0026ldquo;CA\u0026rdquo; illusion often mentioned externally, but in essence, it still needs to sacrifice some availability). Uses external precise timestamps provided by TrueTime + Paxos replication within each shard to ensure strong consistency across data centers. Suitable for global financial transactions or scenarios with high consistency requirements, but the infrastructure cost is extremely high. BigTable / HBase Superficially more inclined to CP, using distributed coordination between RegionServer and Master to ensure the consistency of metadata. However, in the actual read and write paths, it can also provide certain high-availability means through asynchronous multi-replica replication, and read consistency can be adjusted according to application needs. AWS DynamoDB Inclined to AP, early design inspiration came from the Dynamo paper, and consistency levels can be adjusted through parameters such as R and W. Provides extremely high availability and eventual consistency in the default mode, and can also enable \u0026ldquo;strong consistent reads\u0026rdquo; (but only guarantees strong consistency within a single partition, not necessarily across partitions). Cassandra Also AP inclined, the underlying layer uses the Gossip protocol to maintain the node topology status. Read and write consistency can be configured with read and write replica numbers R / W to achieve a smooth transition from eventual consistency to stronger consistency. Comparison shows: There is no absolute \u0026ldquo;AP or CP\u0026rdquo; in engineering. It is more of a mixture of multiple consistency strategies; most systems provide a certain degree of tunable consistency to adapt to different application scenarios.\nIX. Summary # The CAP theorem is not a one-size-fits-all solution Real distributed systems cannot simply say \u0026ldquo;I choose C and give up A\u0026rdquo; or \u0026ldquo;I choose A and give up C\u0026rdquo;. It is more common in the industry to flexibly choose CP or AP modes for different data dimensions and different operation types. Even within the same system, different fault tolerance and consistency strategies are adopted for different tables/different functions. AP is not absolutely 100% available For example, Cassandra, DynamoDB, etc., will also have situations where requests cannot be satisfied in extreme network partitions or large-scale node failures. AP systems are only designed to prefer \u0026ldquo;write as long as the replica is writable\u0026rdquo;, sacrificing some consistency guarantees in exchange for relatively higher availability and throughput. CP can also try to achieve high availability Paxos/Raft can also provide 99.99% or even higher availability under normal circumstances, but it requires more investment in network, hardware, and engineering costs, and will still experience blocked writes and sacrifice availability to maintain consistency in extreme network partitions. Hybrid architecture is mainstream Core transaction scenarios adhere to strong consistency (CP), while peripheral auxiliary scenarios or caching channels use weak consistency (AP), and the two cooperate with each other. It is necessary to comprehensively consider business tolerance, network environment, cost investment, and team technical reserves to make trade-offs. The CAP theorem provides a high-level framework for the design of distributed systems, helping us make rational decisions in the face of the inevitable reality of network partitions. In actual systems, we need to use richer consistency models, consensus protocols, multi-replica replication mechanisms, and engineering practices (disaster recovery, degradation, idempotency, conflict merging, etc.) to balance consistency and availability.\n","date":"27 December 2024","externalUrl":null,"permalink":"/posts/1735350760948-cap/","section":"Posts","summary":"Discussing the application of the CAP theorem in distributed systems from theory to practice.","title":"In-depth Analysis of the CAP Theorem: Building High-Concurrency and Highly Available Distributed Systems","type":"posts"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"Quick sort is a comparison-based, unstable sorting algorithm that uses the divide-and-conquer approach. It has an average time complexity of $O(n\\log n)$, a worst-case time complexity of $O(n^2)$, and a space complexity of $O(1)$. The following will use sorting an integer sequence in ascending order as an example to introduce its implementation details and common mistakes.\nProblem Description # Given an integer sequence of length $n$, use quick sort to sort it in ascending order and output the result.\nInput Format # The first line inputs an integer $n$. The second line inputs $n$ integers, all within the range $[1, 10^9]$. Output Format # Output the sorted sequence on a single line. Data Range # $1 \\leq n \\leq 100000$\nInput Example # 5 3 1 2 4 5 Output Example # 1 2 3 4 5 Quick Sort Idea # In each divide step of quick sort, a number is arbitrarily chosen as the pivot (the number in the middle position is chosen below).\nUse left and right pointers moving towards each other. The left pointer L searches from left to right for the first number greater than or equal to pivot, and the right pointer R searches from right to left for the first number less than or equal to pivot. Then, swap these two numbers.\nRepeat this process until the left and right pointers overlap or the left pointer is one position to the right of the right pointer. This is called one cycle.\nAfter each pointer movement and swap, ensure that the structure \u0026ldquo;left part ≤ pivot, right part ≥ pivot\u0026rdquo; is not broken, i.e., there is an invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nIn the example code below, left and right are the boundaries of the currently processed closed interval, and pivot is the element at the midpoint of the interval.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexity and pivot Selection # Since quick sort has a complexity of $O(n^2)$ in the worst case, the selection of pivot is crucial. If the first or last element is always selected, the worst case is likely to occur in nearly sorted arrays.\nIn addition to taking the element in the middle position, a random element can also be selected as the pivot, or the median of the left, middle, and right elements can be taken as the pivot.\nCommon Error Examples # The following code contains several common errors.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Error Analysis:\npivot should be a number in the array, not an index. Use \u0026lt; and \u0026gt; instead of \u0026lt;= and \u0026gt;=, otherwise the left pointer may move more than one position past the right pointer, which would prevent the array from being divided into two parts. After finding l \u0026gt;= r, the loop should be exited immediately, and no more swaps should be performed. Otherwise, it cannot be guaranteed that the elements on the left are not greater than pivot and the elements on the right are not less than pivot. After each swap, l++ and r-- should be executed. pivot actually takes the number in the middle-left position. Therefore, if the array is divided using $l - 1$ and $l$, it is not difficult to find that a dead loop will occur when considering the array [1, 2], continuously dividing the array into two parts of size 0 and 2. Similarly, using $r$ and $l$ to divide the array will not work. Conversely, at the end of a round of the loop, $r$ must be less than $right$, so $r$ and $r+1$ can be used to divide the array. The reader can simulate the algorithm process to see why. Another simple way to avoid dead loops is to randomly select pivot or handle the case where there are only two elements specially. Also, using $l$, $l+1$ will not work, because this division does not conform to the definition. When $r$ is to the left of $l$, using $l$, $l+1$ cannot correctly divide the array into two parts: the left part less than or equal to pivot and the right part greater than or equal to pivot. This problem assumes that the array is not empty, so there is no case where \u0026gt; is used. However, it is recommended to use \u0026gt;=, which is safer. Supplement # Quick sort can also be evolved into \u0026ldquo;quick select\u0026rdquo;, which can find the $k$-th smallest number in an unordered array in $O(n)$ expected time. The specific idea is similar to quick sort, except that it only continues to recurse in one sub-interval each time, thus reducing the time complexity.\n","date":"26 December 2024","externalUrl":null,"permalink":"/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analysis of key points for correctly implementing the quick sort algorithm.","title":"Quick Sort","type":"posts"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Problem # There are $N$ items. The volume of the $i$-th item is $s_i$, and its value is $v_i$. Each item can only be taken once. Under the premise of not exceeding the maximum total volume limit $S$, find the maximum total value $V$ that can be obtained.\nInput Format # The first line contains two integers, $N$ and $S$, separated by a space, representing the number of items and the maximum total volume limit, respectively. The following $N$ lines each contain two integers, $s_i$ and $v_i$, separated by a space, representing the volume and value of the $i$-th item, respectively.\nOutput Format # Output an integer representing the maximum value.\nData Range # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Input Example # 4 5 1 2 2 4 3 4 4 5 Output Example # 8 Solution # Define the state: f[i][j] represents the maximum value that can be obtained from the first $i$ items with a volume limit of $j$. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j] If the $i$-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i] When implementing the state transition, pay attention to the domain range. If $j \u003c s_i$, then do not consider the case of taking the $i$-th item. Because if $j - s_i$ is negative, the array index is illegal. It can also be explained this way: the volume of the $i$-th item is greater than the volume limit, so it is impossible. Define the initial condition: For the first $0$ items, any volume limit yields a value of $0$, i.e., f[0][j] = 0, j $\\in [0, S]$. Time complexity: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimization # Compressing the two-dimensional array into a one-dimensional array can significantly save space and improve the running speed to a certain extent (the disadvantage is that it cannot meet the special requirements of some problem types). Note that in the state transition, f[i][j] is only related to f[i - 1][j] and f[i - 1][j - s[i]]. In other words, in the two-dimensional array f in the code, f[i][j] is only related to the elements in the previous row that are to its left or in the same column. Therefore, the two-dimensional array can be compressed into a one-dimensional array or a rolling array. Note that in the code below, the second loop iterates in reverse order. This is because we want to ensure that when calculating f[i][j], f[i - 1][j - s[i]] has not been updated yet. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} If the Number of Schemes is Required # Not only should the maximum total value that can be obtained be output, but also \u0026ldquo;how many different selection methods can achieve this maximum total value\u0026rdquo;. The following describes how to count the number of schemes in the 01 knapsack problem.\n2D DP to Count Schemes # The following uses 2D DP as an example to explain.\nDefine the state:\ndp[i][j] represents \u0026ldquo;the maximum value that can be obtained when considering the first i items with a capacity (volume limit) of j\u0026rdquo;. ways[i][j] represents \u0026ldquo;the number of schemes corresponding to the maximum value obtained when considering the first i items with a capacity of j\u0026rdquo;. State transition:\nIf the i-th item is not selected: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ If the i-th item is selected (provided that $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Whether to select or not, the final dp[i][j] should take the larger of the two: If $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ then it means that \u0026ldquo;selecting the i-th item\u0026rdquo; has a greater value: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ If $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ it means that the maximum value obtained by the two methods is the same, then the number of schemes should be added: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ If $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ then it means that \u0026ldquo;not selecting the i-th item\u0026rdquo; has a greater value, and the number of schemes inherits the number of schemes when not selecting: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Initial conditions:\ndp[0][j] = 0 means that when there are 0 items, the maximum value obtained for any capacity is 0. ways[0][0] = 1 means that the case of \u0026ldquo;0 items, capacity 0\u0026rdquo; is a feasible scheme (i.e., selecting nothing), and the number of schemes is set to 1. For j \u0026gt; 0, when there are no items to choose from and the capacity is greater than 0, it is impossible to obtain any positive value, and the corresponding number of schemes is 0, i.e., ways[0][j] = 0. Final answer:\ndp[N][S] is the maximum value. ways[N][S] is the number of schemes to achieve this maximum value. Time complexity: $O(NS)$. This problem can also be optimized using 1D DP. If the Requirement is to Exactly Reach the Volume Limit # Define the state: f[i][j] represents the maximum value when the first i items have exactly a volume of $j$. If the i-th item is not taken, then f[i][j] = f[i - 1][j] If the i-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i] It can be noted that there is no difference in the state transition from the original problem. However, the initial conditions are different. Except for f[0][0] = 0, the rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ represents an impossible state. If the Volume Limit $S$ is Very Large (1e9), While the Number of Items $N$ and the Maximum Total Value $V$ are Relatively Small # For such problems, there is a solution with a complexity of $O(NV)$. Define the state: f[i][j] represents the minimum volume when selecting several items from the first i items, and the total value is exactly j. If the i-th item is not taken, then f[i][j] = f[i - 1][j] If the i-th item is taken, then f[i][j] = f[i - 1][j - v[i]] + s[i] Take the smaller of the two. Initial conditions: f[0][0] = 0, the rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ represents an impossible state. Note that it is not $-\\infty$. The final answer is the largest j in f[N][j] such that f[N][j] \u0026lt;= S. If the Volume Limit $S$ and the Value of a Single Item $v_i$ are Both Very Large (on the order of 1e9), While the Number of Items $N$ is Very Small (no more than 40) # When $N \\leq 20$, all subsets can be directly enumerated by brute force (time complexity $O(2^N)$). When $N \\leq 40$, since $2^{40}$ is on the order of $10^{12}$, direct brute force will also be relatively large, so meet-in-the-middle search can be used to reduce the complexity to approximately $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, which can be completed in an acceptable time. ","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"The most basic classic knapsack problem.","title":"01 Knapsack Problem","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"If an ordered solution space is divided into two parts, where one part satisfies a condition and the other does not, then binary search can be used to find the critical point in the ordered solution space.\nThe basic idea of binary search is to repeatedly halve the search interval. Each time, the middle element is checked. If the middle element does not satisfy the condition, half of the interval can be excluded; otherwise, the search continues in the other half. Since half of the search interval is discarded each time, the search time complexity can reach $O(\\log n)$.\nExample Problem # Problem Description: Given an ascendingly sorted integer array of length $n$, and $q$ queries. Each query gives an integer $k$, and we need to find the \u0026ldquo;starting position\u0026rdquo; and \u0026ldquo;ending position\u0026rdquo; of $k$ in the array (indices start from 0). If the number does not exist in the array, return -1 -1.\nInput Format # First line: two integers $n$ and $q$, representing the length of the array and the number of queries, respectively. Second line: $n$ integers, representing the complete array, already sorted in ascending order. Next $q$ lines: each line contains an integer $k$, representing a query element. Data Range # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nOutput Format # For each query, output the starting and ending positions of the element in the array on one line. If the element does not exist in the array, output -1 -1.\nExample:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Explanation:\nThe range where element $3$ appears is $[3, 4]$; Element $4$ appears only once, at position $5$; Element $5$ does not exist in the array, so return $-1$ $-1$. Solution # Finding the \u0026ldquo;Starting Position\u0026rdquo;: That is, finding the first position greater than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than or equal to\u0026rdquo; $k$ The answer is the first position on the right Finding the \u0026ldquo;Ending Position\u0026rdquo;: That is, finding the last position less than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than or equal to\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than\u0026rdquo; $k$ The answer is the last position on the left Recommended Template # Below is an elegant and less error-prone binary search template.\nDefine two pointers $l, r$, with the invariant: the closed interval $[0, l]$ all belongs to the left part, and the closed interval $[r, n - 1]$ all belongs to the right part. $l$ and $r$ are initialized to $-1$ and $n$.\nWhen the algorithm terminates, $l$ and $r$ are adjacent, pointing to the last element of the left part and the first element of the right part, respectively.\nBecause the solution we want may not exist, if the problem does not state that a solution definitely exists, we need to check if l or r is out of bounds and if it points to the correct value.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Find the starting position of k 15 // Divide the array into two parts, the left part is all \u0026lt; k, and the right part is all \u0026gt;= k. 16 // The answer is the smallest index of the right part. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // If r is out of bounds or nums[r] != k, it means k does not exist 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Find the ending position of k 33 // Divide the array into two parts, the left part is all \u0026lt;= k, and the right part is all \u0026gt; k. 34 // The answer is the largest index of the left part. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Advantages # This approach has strictly defined invariants. It applies to both finding the \u0026ldquo;starting position\u0026rdquo; and the \u0026ldquo;ending position\u0026rdquo; without needing extra handling or changes. Some approaches use l == r as the termination condition. When $l$ and $r$ differ by $1$, $mid$ will be calculated to be equal to $l$ or $r$. If not handled correctly, updating $l$ or $r$ to $mid$ will not shrink the search interval, leading to an infinite loop. In contrast, this approach terminates when $l$ and $r$ are adjacent, ensuring that $mid$ is less than $l$ and greater than $r$, and updating $l$ or $r$ will always shrink the search interval. STL # If you use the lower_bound and upper_bound functions provided by C++ STL, you can achieve the same thing:\nlower_bound(first, last, val) returns \u0026ldquo;the first position greater than or equal to val\u0026rdquo; upper_bound(first, last, val) returns \u0026ldquo;the first position greater than val\u0026rdquo; For example, suppose nums = {1,2,3,4,4,4,4,4,5,5,6}, and we want to know the range where 4 appears:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 points to the first position where the value is greater than or equal to $4$. it2 points to the first position where the value is greater than $4$. Therefore, it2 - it1 is the number of times $4$ appears in the array; it2 - nums.begin() - 1 is the position of the right boundary of $4$. Supplement # Binary search can also be extended to search in floating-point ranges (such as finding the roots of an equation) and ternary search for finding the extrema of unimodal functions.\nPractice # LeetCode 33. Search in Rotated Sorted Array\nHint: First use binary search to find the rotation point, and then use binary search to find the target value.\n","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"How to elegantly implement the binary search algorithm.","title":"Binary Search","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]