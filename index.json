[{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"If an ordered solution space is divided into two parts, where one part satisfies a condition and the other does not, then binary search can be used to find the critical point in the ordered solution space.\nThe basic idea of binary search is to repeatedly halve the search interval. Each time, the middle element is checked. If the middle element does not satisfy the condition, half of the interval can be eliminated; otherwise, the search continues in the other half. Since half of the search interval is discarded each time, the search time complexity can reach $O(\\log n)$.\nExample Problem # Problem Description: Given an ascendingly sorted integer array of length $n$, and $q$ queries. Each query gives an integer $k$, and we need to find the \u0026ldquo;starting position\u0026rdquo; and \u0026ldquo;ending position\u0026rdquo; of $k$ in the array (indices start from 0). If the number does not exist in the array, return -1 -1.\nInput Format # First line: two integers $n$ and $q$, representing the length of the array and the number of queries, respectively. Second line: $n$ integers, representing the complete array, already sorted in ascending order. Next $q$ lines: each line contains an integer $k$, representing a query element. Data Range # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nOutput Format # For each query, output the starting and ending positions of the element in the array on a single line. If the element does not exist in the array, output -1 -1.\nExample:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Explanation:\nThe range where element $3$ appears is $[3, 4]$; Element $4$ appears only once, at position $5$; Element $5$ does not exist in the array, so return $-1$ $-1$. Solution # Finding the \u0026ldquo;Starting Position\u0026rdquo;: That is, finding the first position that is greater than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than or equal to\u0026rdquo; $k$ The answer is the first position on the right Finding the \u0026ldquo;Ending Position\u0026rdquo;: That is, finding the last position that is less than or equal to $k$. The array can be divided into two parts:\nAll numbers on the left are \u0026ldquo;less than or equal to\u0026rdquo; $k$ All numbers on the right are \u0026ldquo;greater than\u0026rdquo; $k$ The answer is the last position on the left Recommended Template # Below is an elegant and less error-prone binary search template.\nDefine two pointers $l, r$, with the invariant: the closed interval $[0, l]$ belongs to the left part, and the closed interval $[r, n - 1]$ belongs to the right part. $l$ and $r$ are initialized to $-1$ and $n$, respectively.\nWhen the algorithm terminates, $l$ and $r$ are adjacent, pointing to the last element of the left part and the first element of the right part, respectively.\nBecause the solution we want may not exist, if the problem does not state that a solution definitely exists, we need to check if l or r is out of bounds and if it points to the correct value.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Find the starting position of k 15 // Divide the array into two parts, the left part is all \u0026lt; k, and the right part is all \u0026gt;= k. 16 // The answer is the smallest index of the right part. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // If r is out of bounds or nums[r] != k, it means k does not exist 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Find the ending position of k 33 // Divide the array into two parts, the left part is all \u0026lt;= k, and the right part is all \u0026gt; k. 34 // The answer is the largest index of the left part. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Advantages # This approach has strictly defined invariants. It applies to both finding the \u0026ldquo;starting position\u0026rdquo; and the \u0026ldquo;ending position\u0026rdquo; without extra handling or changes. Some approaches use l == r as the termination condition. When $l$ and $r$ differ by $1$, $mid$ will be calculated to be equal to $l$ or $r$. If not handled correctly, updating $l$ or $r$ to $mid$ will not shrink the search interval, leading to an infinite loop. In contrast, this approach terminates when $l$ and $r$ are adjacent, ensuring that $mid$ is less than $l$ and greater than $r$, and updating $l$ or $r$ will always shrink the search interval. STL # If you use the lower_bound and upper_bound functions provided by C++ STL, you can achieve the same thing:\nlower_bound(first, last, val) will return \u0026ldquo;the first position that is greater than or equal to val\u0026rdquo; upper_bound(first, last, val) will return \u0026ldquo;the first position that is greater than val\u0026rdquo; For example, suppose nums = {1,2,3,4,4,4,4,4,5,5,6}, and we want to know the range where 4 appears:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 points to the first position where the value is greater than or equal to $4$. it2 points to the first position where the value is greater than $4$. Therefore, it2 - it1 is the number of times $4$ appears in the array; it2 - nums.begin() - 1 is the position of the right boundary of $4$. Additional Notes # Binary search can also be extended to search in floating-point ranges (such as finding the roots of an equation) and ternary search for finding the extrema of unimodal functions.\nPractice # LeetCode 33. Search in Rotated Sorted Array\nHint: First, use binary search to find the rotation point, and then use binary search to find the target value.\n","date":"24 December 2024","externalUrl":null,"permalink":"/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"How to elegantly implement the binary search algorithm.","title":"Binary Search","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":" 01 Knapsack Problem # Date: 2024-12-24\nDescription: The most basic classic knapsack problem.\nSummary: The most basic classic knapsack problem.\nTags: [ \u0026ldquo;Algorithm\u0026rdquo;, \u0026ldquo;Dynamic Programming\u0026rdquo;, \u0026ldquo;Knapsack Problem\u0026rdquo; ]\nCategories: [ \u0026ldquo;Algorithms and Data Structures\u0026rdquo; ]\nSeries: [ \u0026ldquo;Nine Lectures on Knapsack Problems\u0026rdquo; ]\nSeries Order: 1\nProblem # There are $N$ items. The volume of the $i$-th item is $s_i$, and its value is $v_i$. Each item can only be taken once. Under the premise of not exceeding the maximum total volume limit $S$, find the maximum total value $V$ that can be obtained.\nInput Format # The first line contains two integers, $N$ and $S$, separated by a space, representing the number of items and the maximum total volume limit, respectively. The next $N$ lines each contain two integers, $s_i$ and $v_i$, separated by a space, representing the volume and value of the $i$-th item, respectively.\nOutput Format # Output an integer representing the maximum value.\nData Range # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Input Example # 4 5 1 2 2 4 3 4 4 5 Output Example # 8 Solution # Define state: f[i][j] represents the maximum value that can be obtained from the first $i$ items with a volume limit of $j$. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j] If the $i$-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i] When implementing the state transition, pay attention to the domain range. If $j \u003c s_i$, then do not consider the case of taking the $i$-th item. Because if $j - s_i$ is negative, the array index is illegal. It can also be explained as: the volume of the $i$-th item is greater than the volume limit, so it is impossible. Define initial conditions: For the first 0 items, any volume limit obtains a value of 0, i.e., f[0][j] = 0, j $\\in [0, S]$. Time complexity: $O(NS)$. Code # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1D DP Optimization # Compressing the two-dimensional array into a one-dimensional array can significantly save space and improve the running speed to a certain extent (the disadvantage is that it cannot meet the special requirements of some problem types). Note that in the state transition, f[i][j] is only related to f[i - 1][j] and f[i - 1][j - s[i]]. In other words, in the two-dimensional array f in the code, f[i][j] is only related to the elements in the previous row that are to its left or in the same column. Therefore, the two-dimensional array can be compressed into a one-dimensional array or a rolling array. Note that in the code below, the second loop iterates in reverse order. This is because we want to ensure that when calculating f[i][j], f[i - 1][j - s[i]] has not been updated yet. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} If the Number of Solutions is Required # Not only should the maximum total value that can be obtained be output, but also \u0026ldquo;how many different selection methods can achieve this maximum total value\u0026rdquo;. The following describes how to count the number of solutions in the 01 knapsack problem.\n2D DP for Counting Solutions # The following uses 2D DP as an example for explanation.\nDefine state:\ndp[i][j] represents \u0026ldquo;the maximum value that can be obtained when considering the first i items with a capacity (volume limit) of j\u0026rdquo;. ways[i][j] represents \u0026ldquo;the number of solutions corresponding to the maximum value obtained when considering the first i items with a capacity of j\u0026rdquo;. State transition:\nIf the $i$-th item is not selected: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ If the $i$-th item is selected (provided that $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Whether to select or not, the final dp[i][j] should take the larger of the two: If $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ then it means that \u0026ldquo;selecting the i-th item\u0026rdquo; has a greater value: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ If $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ it means that the maximum value obtained by the two methods is the same, then the number of solutions should be added: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ If $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ then it means that \u0026ldquo;not selecting the i-th item\u0026rdquo; has a greater value, and the number of solutions inherits the number of solutions when not selecting: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Initial conditions:\ndp[0][j] = 0 means that when there are 0 items, the maximum value obtained for any capacity is 0. ways[0][0] = 1 means that \u0026ldquo;0 items, capacity 0\u0026rdquo; is a feasible solution (i.e., selecting nothing), and the number of solutions is set to 1. For j \u0026gt; 0, when there are no items to choose from and the capacity is greater than 0, it is impossible to obtain any positive value, and the corresponding number of solutions is 0, i.e., ways[0][j] = 0. Final answer:\ndp[N][S] is the maximum value. ways[N][S] is the number of solutions to achieve this maximum value. Time complexity: $O(NS)$. This problem can also be optimized using 1D DP. If the Requirement is to Exactly Reach the Volume Limit # Define state: f[i][j] represents the maximum value when the first i items have exactly a volume of $j$. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j] If the $i$-th item is taken, then f[i][j] = f[i - 1][j - s[i]] + v[i] It can be noted that there is no difference in the state transition from the original problem. However, the initial conditions are different. Besides f[0][0] = 0, the rest f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ represents an impossible state. If the Volume Limit $S$ is Very Large (1e9), While the Number of Items $N$ and the Maximum Total Value $V$ are Relatively Small # For such problems, there is a solution with a complexity of $O(NV)$. Define state: f[i][j] represents the minimum volume when selecting several items from the first i items, and the total value is exactly j. If the $i$-th item is not taken, then f[i][j] = f[i - 1][j] If the $i$-th item is taken, then f[i][j] = f[i - 1][j - v[i]] + s[i] Take the smaller of the two. Initial conditions: f[0][0] = 0, the rest f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ represents an impossible state. Note that it is not $-\\infty$. The final answer is the largest j in f[N][j] such that f[N][j] \u0026lt;= S. If the Volume Limit $S$ and the Value of a Single Item $v_i$ are Both Very Large (on the order of 1e9), While the Number of Items $N$ is Very Small (no more than 40) # When $N \\leq 20$, all subsets can be directly enumerated (time complexity $O(2^N)$). When $N \\leq 40$, since $2^{40}$ is on the order of $10^{12}$, direct brute force will also be relatively large, so meet-in-the-middle search can be used to reduce the complexity to approximately $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, which can be completed in an acceptable time. ","externalUrl":null,"permalink":"/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"","title":"","type":"posts"},{"content":" Quick Sort # Date: 2024-12-26 Draft: false Description: Analysis of key points for correctly implementing the quick sort algorithm. Summary: Analysis of key points for correctly implementing the quick sort algorithm. Tags: [ \u0026ldquo;Algorithm\u0026rdquo;, \u0026ldquo;Sorting Algorithm\u0026rdquo;, \u0026ldquo;Quick Sort\u0026rdquo;, \u0026ldquo;Divide and Conquer Algorithm\u0026rdquo; ] Categories: [ \u0026ldquo;Algorithms and Data Structures\u0026rdquo; ]\nQuick Sort # Quick sort is a comparison-based, unstable sorting algorithm that uses the divide-and-conquer approach. It has an average time complexity of $O(n\\log n)$, a worst-case time complexity of $O(n^2)$, and a space complexity of $O(1)$. The following will use sorting an integer sequence in ascending order as an example to introduce its implementation details and common mistakes.\nProblem Description # Given an integer sequence of length $n$, sort it in ascending order using quick sort and output the result.\nInput Format # The first line contains an integer $n$. The second line contains $n$ integers, all within the range $[1, 10^9]$. Output Format # Output the sorted sequence on a single line. Data Range # $1 \\leq n \\leq 100000$\nInput Example # 5 3 1 2 4 5 Output Example # 1 2 3 4 5 Quick Sort Approach # In each divide step of quick sort, a number is arbitrarily chosen as the pivot (the number in the middle position is chosen below).\nUse left and right pointers moving towards each other. The left pointer L searches from left to right for the first number greater than or equal to the pivot, and the right pointer R searches from right to left for the first number less than or equal to the pivot. Then, swap these two numbers.\nRepeat this process until the left and right pointers overlap or the left pointer is one position to the right of the right pointer. This is called one cycle.\nAfter each pointer movement and swap, ensure that the structure \u0026ldquo;left part ≤ pivot, right part ≥ pivot\u0026rdquo; is not broken, i.e., the invariant [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot holds.\nIn the example code below, left and right are the boundaries of the currently processed closed interval, and pivot is the element at the midpoint of the interval.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexity and pivot Selection # Since quick sort has a worst-case complexity of $O(n^2)$, the selection of the pivot is crucial. If the first or last element is always chosen, the worst case is likely to occur in nearly sorted arrays.\nIn addition to taking the element in the middle position, a random element can be selected as the pivot, or the median of the left, middle, and right elements can be taken as the pivot.\nCommon Error Examples # The following code contains several common errors.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Error Analysis:\npivot should be a number in the array, not an index. Use \u0026lt; and \u0026gt; instead of \u0026lt;= and \u0026gt;=, otherwise the left pointer may move more than one position past the right pointer, which would prevent the array from being divided into two parts. After finding l \u0026gt;= r, the loop should be exited immediately without performing the swap. Otherwise, it cannot be guaranteed that the elements on the left are not greater than pivot and the elements on the right are not less than pivot. After each swap, l++ and r-- should be executed. pivot actually takes the number in the middle-left position. Therefore, if $l - 1$ and $l$ are used to divide the array, consider the array [1, 2]. It is not difficult to see that this will lead to an infinite loop, continuously dividing the array into two parts of size 0 and 2. Similarly, using $r$ and $l$ to divide the array will not work. Instead, at the end of a cycle, $r$ must be less than $right$, so $r$ and $r+1$ can be used to divide the array. The reader can simulate the algorithm process to see why. Another simple way to avoid infinite loops is to randomly select the pivot or handle the case of only two elements specially. Also, using $l$, $l+1$ will not work, because this division does not conform to the definition. When $r$ is to the left of $l$, using $l$, $l+1$ cannot correctly divide the array into two parts: the left part less than or equal to pivot, and the right part greater than or equal to pivot. This problem assumes that the array is not empty, so there is no case where \u0026gt; is used. However, it is recommended to use \u0026gt;=, which is safer. Supplement # Quick sort can also be evolved into \u0026ldquo;quick select\u0026rdquo;, which can find the $k$-th smallest number in an unordered array in $O(n)$ expected time. The specific idea is similar to quick sort, except that it only continues to recurse in one sub-interval each time, thus reducing the time complexity.\n","externalUrl":null,"permalink":"/posts/1735252761946-quick-sort/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]