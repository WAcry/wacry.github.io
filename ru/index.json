[{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":" Быстрая сортировка # Быстрая сортировка — это алгоритм сортировки на основе сравнений, не являющийся устойчивым, использующий принцип «разделяй и властвуй». Средняя временная сложность составляет $O(n\\log n)$, в худшем случае — $O(n^2)$, а пространственная сложность — $O(1)$. Ниже на примере сортировки по возрастанию целочисленной последовательности рассмотрим детали реализации и распространенные ошибки.\nОписание задачи # Дана целочисленная последовательность длиной $n$. Используйте быструю сортировку для ее сортировки по возрастанию и выведите результат.\nФормат ввода # В первой строке вводится целое число $n$ Во второй строке вводятся $n$ целых чисел, каждое в диапазоне $[1,10^9]$ Формат вывода # В одной строке выводится отсортированная последовательность Ограничения # $1 \\leq n \\leq 100000$\nПример ввода # 5 3 1 2 4 5 Пример вывода # 1 2 3 4 5 Идея быстрой сортировки # При каждом разделении в быстрой сортировке выбирается произвольное число в качестве опорного элемента pivot (ниже выбирается число в середине).\nИспользуются левый и правый указатели, движущиеся навстречу друг другу. Левый указатель L движется слева направо, ища первое число, большее или равное pivot. Правый указатель R движется справа налево, ища первое число, меньшее или равное pivot. Затем эти два числа меняются местами.\nЭтот процесс повторяется до тех пор, пока левый и правый указатели не совпадут или левый указатель не станет на одну позицию правее правого. Это называется одной итерацией.\nПосле каждого перемещения указателей и обмена гарантируется, что структура «левая часть ≤ pivot, правая часть ≥ pivot» не нарушается, то есть существует инвариант [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nВ приведенном ниже примере кода left и right — это границы текущего обрабатываемого замкнутого интервала, а pivot берется как элемент в середине интервала.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Сложность и выбор pivot # Поскольку в худшем случае быстрая сортировка имеет сложность $O(n^2)$, выбор pivot очень важен. Если всегда выбирать первый или последний элемент, то в почти отсортированном массиве с большой вероятностью возникнет худший случай.\nПомимо выбора элемента в середине, можно также случайным образом выбрать элемент в качестве pivot или взять медиану из трех элементов: левого, среднего и правого.\nПримеры распространенных ошибок # Приведенный ниже код содержит несколько распространенных ошибок.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Анализ ошибок:\npivot должен быть числом из массива, а не индексом. Используются \u0026lt;= и \u0026gt;=, а не \u0026lt; и \u0026gt;, иначе левый указатель может уйти дальше правого более чем на одну позицию, и массив не будет разделен на две части. После обнаружения l \u0026gt;= r следует немедленно выйти из цикла, не выполняя обмен. В противном случае нельзя гарантировать, что левые элементы не больше pivot, а правые не меньше pivot. После каждого обмена следует выполнять l++ и r--. pivot фактически берется как число, расположенное ближе к левой середине. Поэтому, если использовать $l - 1$ и $l$ для разделения массива, то, рассмотрев массив [1, 2], нетрудно заметить, что это приведет к бесконечному циклу, постоянно разделяя массив на две части размером 0 и 2. Аналогично, использование $r$ и $l$ для разделения массива также не подходит. Напротив, в конце итерации $r$ обязательно меньше $right$, поэтому можно использовать $r$ и $r+1$ для разделения массива. Читатель может смоделировать процесс алгоритма, чтобы понять, почему. Другой простой способ избежать бесконечного цикла — это случайный выбор pivot или специальная обработка случая, когда есть только два элемента. Кроме того, использование $l$, $l+1$ также не подходит, поскольку такое разделение не соответствует определению. Когда $r$ находится слева от $l$, использование $l$, $l+1$ не может правильно разделить массив на две части: левую, где элементы меньше или равны pivot, и правую, где элементы больше или равны pivot. В этой задаче предполагается, что массив не пуст, поэтому случая \u0026gt; не существует. Однако рекомендуется использовать \u0026gt;=, это безопаснее. Дополнение # Быстрая сортировка также может быть преобразована в «быстрый выбор», который позволяет найти $k$-й наименьший элемент в неупорядоченном массиве за ожидаемое время $O(n)$. Основная идея аналогична быстрой сортировке, но на каждой итерации рекурсия продолжается только в одной из подпоследовательностей, что снижает временную сложность.\n","date":"26 января 2024","externalUrl":null,"permalink":"/ru/posts/1735252761946-quick-sort/","section":"Posts","summary":"Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки.","title":"Быстрая сортировка","type":"posts"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":" Задача # Есть $N$ предметов. Объем $i$-го предмета равен $s_i$, а его ценность равна $v_i$. Каждый предмет можно взять только один раз. При условии, что общий объем не превышает максимального ограничения $S$, найдите максимальную общую ценность $V$, которую можно получить.\nФормат ввода # В первой строке два целых числа $N$ и $S$, разделенные пробелом, обозначающие количество предметов и максимальное ограничение общего объема соответственно. В следующих $N$ строках по два целых числа $s_i$ и $v_i$, разделенные пробелом, обозначающие объем и ценность $i$-го предмета соответственно.\nФормат вывода # Выведите одно целое число, представляющее максимальную ценность.\nОграничения # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Пример ввода # 4 5 1 2 2 4 3 4 4 5 Пример вывода # 8 Решение # Определение состояния: f[i][j] представляет максимальную ценность, которую можно получить, используя первые $i$ предметов при ограничении объема $j$. Если не брать $i$-й предмет, то f[i][j] = f[i - 1][j] Если брать $i$-й предмет, то f[i][j] = f[i - 1][j - s[i]] + v[i] При реализации перехода состояний следует обратить внимание на область определения. Если $j \u003c s_i$, то не рассматриваем случай взятия $i$-го предмета. Потому что если $j-s_i$ отрицательное число, то индекс массива будет недействительным. Можно объяснить и так: объем $i$-го предмета больше ограничения объема, поэтому это невозможно. Определение начальных условий: для первых $0$ предметов при любом ограничении объема ценность равна $0$, то есть f[0][j] = 0, j $\\in [0, S]$. Временная сложность: $O(NS)$. Код # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Оптимизация с помощью одномерного DP # Преобразование двумерного массива в одномерный позволяет значительно сэкономить место и немного увеличить скорость выполнения (недостаток в том, что это не удовлетворяет особым требованиям некоторых типов задач) Заметим, что в переходе состояний f[i][j] зависит только от f[i - 1][j] и f[i - 1][j - s[i]]. Другими словами, в двумерном массиве f в коде, f[i][j] зависит только от элементов в предыдущей строке, которые находятся левее или в том же столбце, поэтому двумерный массив можно преобразовать в одномерный или использовать скользящий массив. Обратите внимание, что во вложенном цикле ниже, второй цикл проходит в обратном порядке, это потому, что мы хотим гарантировать, что при вычислении f[i][j], f[i - 1][j - s[i]] еще не был обновлен. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Если требуется количество решений # Нужно не только вывести максимальную общую ценность, но и \u0026ldquo;сколько различных способов выбора позволяют достичь этой максимальной общей ценности\u0026rdquo;. Ниже описано, как подсчитать количество решений в задаче о рюкзаке 0-1.\nПодсчет количества решений с помощью двумерного DP # Ниже приводится объяснение на примере двумерного DP.\nОпределение состояния:\ndp[i][j] представляет \u0026ldquo;максимальную ценность, которую можно получить, используя первые i предметов при ограничении объема (лимита) j\u0026rdquo;. ways[i][j] представляет \u0026ldquo;количество решений, соответствующих максимальной ценности, полученной при использовании первых i предметов при объеме j\u0026rdquo;. Переход состояний:\nЕсли не выбирать i-й предмет: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Если выбрать i-й предмет (при условии, что $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Выбирать или не выбирать, в конечном итоге dp[i][j] должен принимать большее из двух значений: Если $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ то это означает, что \u0026ldquo;выбор i-го предмета\u0026rdquo; имеет большую ценность: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Если $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ это означает, что максимальная ценность, полученная двумя способами, одинакова, тогда количество решений должно быть сложено: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Если $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ то это означает, что \u0026ldquo;не выбирать i-й предмет\u0026rdquo; имеет большую ценность, количество решений наследуется от количества решений, когда предмет не выбирается: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Начальные условия:\ndp[0][j] = 0 означает, что при использовании первых 0 предметов максимальная ценность, полученная при любом объеме, равна 0. ways[0][0] = 1 означает, что случай \u0026ldquo;первые 0 предметов, объем 0\u0026rdquo; является одним из возможных решений (то есть ничего не выбирать), количество решений устанавливается равным 1. Для j \u0026gt; 0, когда нет предметов для выбора, а объем больше 0, невозможно получить какую-либо положительную ценность, соответствующее количество решений равно 0, то есть ways[0][j] = 0. Окончательный ответ:\ndp[N][S] - это максимальная ценность. ways[N][S] - это количество решений, позволяющих достичь этой максимальной ценности. Временная сложность: $O(NS)$. Эту задачу также можно оптимизировать с помощью одномерного DP. Если требуется точное соответствие ограничению объема # Определение состояния: f[i][j] представляет максимальную ценность, когда первые i предметов имеют точный объем $j$. Если не брать i-й предмет, то f[i][j] = f[i - 1][j] Если брать i-й предмет, то f[i][j] = f[i - 1][j - s[i]] + v[i] Можно заметить, что переход состояний не отличается от исходной задачи. Но начальные условия отличаются. Кроме f[0][0] = 0, остальные f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ означает невозможное состояние. Если ограничение объема $S$ очень велико (1e9), а количество предметов $N$ и максимальная общая ценность $V$ относительно малы # Для такой задачи есть решение со сложностью $O(NV)$. Определение состояния: f[i][j] представляет минимальный объем, когда из первых i предметов выбрано несколько, а общая ценность равна j. Если не брать i-й предмет, то f[i][j] = f[i - 1][j] Если брать i-й предмет, то f[i][j] = f[i - 1][j - v[i]] + s[i] Берем меньшее из двух значений. Начальные условия: f[0][0] = 0, остальные f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ означает невозможное состояние. Обратите внимание, что это не $-\\infty$. Окончательный ответ - это наибольшее j из f[N][j], такое что f[N][j] \u0026lt;= S. Если ограничение объема $S$ и ценность отдельного предмета $v_i$ очень велики (порядка $1e9$), а количество предметов $N$ очень мало (не более 40) # Когда $N \\leq 20$, можно напрямую перебрать все подмножества (временная сложность $O(2^N)$). Когда $N \\leq 40$, поскольку $2^{40}$ имеет порядок $10^{12}$, прямой перебор также будет довольно большим, поэтому можно использовать поиск с разделением пополам, чтобы снизить сложность примерно до $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ , что можно выполнить за приемлемое время. ","date":"24 января 2024","externalUrl":null,"permalink":"/ru/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Самая базовая классическая задача о рюкзаке.","title":"01背包问题","type":"posts"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"Если упорядоченное пространство решений разделено на две части, где одна часть удовлетворяет условию, а другая нет, то бинарный поиск можно использовать для нахождения критической точки в упорядоченном пространстве решений.\nОсновная идея бинарного поиска заключается в многократном делении интервала поиска пополам. Каждый раз проверяется средний элемент. Если средний элемент не удовлетворяет условию, половину интервала можно отбросить; в противном случае поиск продолжается в другой половине. Поскольку каждый раз отбрасывается половина интервала поиска, временная сложность поиска может достигать $O(\\log n)$.\nПример задачи # Описание задачи: Дан отсортированный по возрастанию целочисленный массив длиной $n$ и $q$ запросов. Каждый запрос задает целое число $k$, и нам нужно найти \u0026ldquo;начальную позицию\u0026rdquo; и \u0026ldquo;конечную позицию\u0026rdquo; $k$ в массиве (индексы начинаются с 0). Если числа нет в массиве, вернуть -1 -1.\nФормат ввода # Первая строка: два целых числа $n$ и $q$, представляющие длину массива и количество запросов соответственно. Вторая строка: $n$ целых чисел, представляющих полный массив, уже отсортированный в порядке возрастания. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса. Диапазон данных # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nФормат вывода # Для каждого запроса выведите начальную и конечную позиции элемента в массиве в одной строке. Если элемента нет в массиве, выведите -1 -1.\nПример:\nВвод: 6 3 1 2 2 3 3 4 3 4 5 Вывод: 3 4 5 5 -1 -1 Пояснение:\nДиапазон, где появляется элемент $3$, равен $[3, 4]$; Элемент $4$ появляется только один раз, в позиции $5$; Элемента $5$ нет в массиве, поэтому возвращаем $-1$ $-1$. Решение # Нахождение \u0026ldquo;Начальной позиции\u0026rdquo;: То есть, нахождение первой позиции, которая больше или равна $k$. Массив можно разделить на две части:\nВсе числа слева \u0026ldquo;меньше\u0026rdquo; $k$ Все числа справа \u0026ldquo;больше или равны\u0026rdquo; $k$ Ответом является первая позиция справа Нахождение \u0026ldquo;Конечной позиции\u0026rdquo;: То есть, нахождение последней позиции, которая меньше или равна $k$. Массив можно разделить на две части:\nВсе числа слева \u0026ldquo;меньше или равны\u0026rdquo; $k$ Все числа справа \u0026ldquo;больше\u0026rdquo; $k$ Ответом является последняя позиция слева Рекомендуемый шаблон # Ниже приведен элегантный и менее подверженный ошибкам шаблон бинарного поиска.\nОпределим два указателя $l, r$, с инвариантом: замкнутый интервал $[0, l]$ принадлежит левой части, а замкнутый интервал $[r, n - 1]$ принадлежит правой части. $l$ и $r$ инициализируются значениями $-1$ и $n$ соответственно.\nКогда алгоритм завершается, $l$ и $r$ становятся соседними, указывая на последний элемент левой части и первый элемент правой части соответственно.\nПоскольку искомое решение может не существовать, если в условии задачи не указано, что решение обязательно существует, нам нужно проверить, не выходят ли l или r за границы и указывает ли он на правильное значение.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Найти начальную позицию k 15 // Разделить массив на две части, левая часть - все \u0026lt; k, а правая часть - все \u0026gt;= k. 16 // Ответом является наименьший индекс правой части. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Если r выходит за границы или nums[r] != k, это означает, что k не существует 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Найти конечную позицию k 33 // Разделить массив на две части, левая часть - все \u0026lt;= k, а правая часть - все \u0026gt; k. 34 // Ответом является наибольший индекс левой части. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Преимущества # Этот подход имеет строго определенные инварианты. Он применим как для нахождения \u0026ldquo;начальной позиции\u0026rdquo;, так и для \u0026ldquo;конечной позиции\u0026rdquo; без дополнительной обработки или изменений. Некоторые подходы используют l == r в качестве условия завершения. Когда $l$ и $r$ отличаются на $1$, $mid$ будет вычислен равным $l$ или $r$. Если не обработать это правильно, обновление $l$ или $r$ до $mid$ не сократит интервал поиска, что приведет к бесконечному циклу. В отличие от этого, этот подход завершается, когда $l$ и $r$ являются соседними, гарантируя, что $mid$ меньше $l$ и больше $r$, и обновление $l$ или $r$ всегда будет сокращать интервал поиска. STL # Если вы используете функции lower_bound и upper_bound, предоставляемые C++ STL, вы можете достичь того же самого:\nlower_bound(first, last, val) вернет \u0026ldquo;первую позицию, которая больше или равна val\u0026rdquo; upper_bound(first, last, val) вернет \u0026ldquo;первую позицию, которая больше val\u0026rdquo; Например, предположим, что nums = {1,2,3,4,4,4,4,4,5,5,6}, и мы хотим узнать диапазон, где появляется 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 появляется 0 раз\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;первая 4 находится в \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;последняя 4 находится в \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 появляется \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; раз\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 указывает на первую позицию, где значение больше или равно $4$. it2 указывает на первую позицию, где значение больше $4$. Следовательно, it2 - it1 - это количество раз, когда $4$ появляется в массиве; it2 - nums.begin() - 1 - это позиция правой границы $4$. Дополнительные замечания # Бинарный поиск также может быть расширен для поиска в диапазонах с плавающей точкой (например, для нахождения корней уравнения) и троичного поиска для нахождения экстремумов унимодальных функций.\nПрактика # LeetCode 33. Search in Rotated Sorted Array\nПодсказка: Сначала используйте бинарный поиск, чтобы найти точку поворота, а затем используйте бинарный поиск, чтобы найти целевое значение.\n","date":"24 января 2024","externalUrl":null,"permalink":"/ru/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Как элегантно реализовать алгоритм бинарного поиска.","title":"Бинарный поиск","type":"posts"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]