[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 декабря 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":" I. Теорема CAP # 1.1 Что такое теорема CAP # Теорема CAP была предложена Эриком Брюером в 2000 году, и ее основная идея заключается в следующем:\nC (Consistency, согласованность): все узлы в системе видят одни и те же данные в один и тот же момент времени. Строго говоря, когда клиент считывает данные, независимо от того, из какой реплики он их считывает, результат должен соответствовать последним отправленным данным (обычно подразумевается строгая согласованность/линейная согласованность). A (Availability, доступность): система может продолжать предоставлять нормальные услуги, даже если возникают частичные сбои, и каждый запрос может получить \u0026ldquo;действительный ответ\u0026rdquo; в разумное время (не обязательно успешный, но и правильный ответ об ошибке). P (Partition tolerance, отказоустойчивость к разделению): система может выдерживать разделение сети (недоступность связи между узлами), и даже если сеть разделяется, система может обеспечить определенную степень доступности или согласованности. В реальной распределенной среде разделение сети неизбежно, поэтому P в основном считается \u0026ldquo;обязательным вариантом\u0026rdquo;. Когда происходит разделение сети, система не может одновременно учитывать строгую согласованность данных и высокую доступность для всех узлов, поэтому приходится выбирать между C и A, что приводит к двум основным типам: CP и AP.\n1.2 Ограничения теоремы CAP # Следует отметить, что теорема CAP сама по себе является относительно высокоуровневой теорией, которая используется для концептуального руководства, и не следует ее понимать как \u0026ldquo;либо выбираем C, либо выбираем A\u0026rdquo;. Существует ряд распространенных заблуждений:\nC не обязательно означает строгую согласованность C в теореме CAP часто относится к согласованности в самом строгом смысле (т.е. линейной согласованности). Однако в реальных системах у нас есть множество моделей на выбор, таких как слабая согласованность, чтение подтвержденных данных (Read Committed), причинная согласованность (Causal Consistency) и т.д. Доступность не является 0 или 1 Нельзя сказать, что если выбран CP, то доступность полностью принесена в жертву; или если выбран AP, то согласованность ничем не гарантируется. И доступность, и согласованность имеют разные степени компромисса и стратегии снижения. Итоговая согласованность не противоречит CAP Это очень распространенный компромисс, который использует более низкую согласованность записи для получения более высокой доступности и пропускной способности, а также асинхронно сходится к данным в фоновом режиме. Таким образом, теорема CAP должна сочетаться с различными моделями согласованности и архитектурными моделями высокой доступности в конкретных сценариях, чтобы создать реальную практическую ценность.\nII. Модели согласованности в распределенных системах # Классификация моделей согласованности очень богата, но основные распространенные модели можно в целом разделить на: строгую согласованность и слабую согласованность (которая включает итоговую согласованность, причинную согласованность и т.д.). В этой статье в основном представлены строгая согласованность и итоговая согласованность, а также объясняется их распространенное применение в режимах CP или AP.\n2.1 Строгая согласованность # Строгая согласованность (Strong Consistency), также известная как линейная согласованность (Linearizability), означает, что как только операция записи завершается и возвращает успех, любая последующая операция чтения может прочитать это обновление. Другими словами, система ведет себя так, как будто все операции выполняются последовательно.\nРаспространенная реализация: зависит от синхронной репликации и механизма кворума (большинства), используя протоколы (такие как Paxos/Raft) для обеспечения наличия только одного эффективного лидера (Leader) в системе, все операции записываются в журнал в порядке и реплицируются на большинство узлов. Преимущества и недостатки: Преимущества: гарантирует строгую правильность данных, данные, прочитанные в любое время, не \u0026ldquo;откатываются\u0026rdquo;. Недостатки: при колебаниях сети, разделении или сбое лидера, для поддержания согласованности часто блокируются операции записи, что приводит к снижению общей доступности; производительность и пропускная способность также относительно ниже. 2.2 Итоговая согласованность # Итоговая согласованность (Eventual Consistency) является типичной формой слабой согласованности, она требует только, чтобы если в системе больше нет новых операций обновления, со временем данные всех реплик постепенно сходились к одному и тому же состоянию. В течение этого периода пользователи, считывающие данные реплики, могут видеть устаревшие значения, но в конечном итоге они станут согласованными.\nРаспространенная реализация: протокол Gossip, асинхронная репликация нескольких реплик, CRDT (Conflict-free Replicated Data Type) и т.д. Преимущества и недостатки: Преимущества: высокая доступность, высокая пропускная способность, низкая задержка операций записи, высокая устойчивость к разделению сети. Недостатки: необходимо допускать кратковременную несогласованность данных, более сложную логику приложения, может потребоваться обнаружение и слияние конфликтов. III. Распространенные протоколы и алгоритмы согласованности # Чтобы обеспечить согласованность между репликами распределенной системы, в отрасли было предложено множество классических алгоритмов и протоколов. Ниже кратко представлены некоторые из них:\n3.1 Paxos # Paxos - это алгоритм распределенной согласованности, предложенный Лесли Лэмпортом в 1990-х годах, который в основном используется для реализации строгой или линейной согласованности.\nОсновной принцип: путем разделения ролей (предлагающий Proposer, принимающий Acceptor, обучающийся Learner) проводится многораундовое голосование, чтобы определить, принята ли операция или значение большинством узлов. Преимущества и недостатки: Преимущества: может достичь согласованности при разделении сети и сбоях узлов, обладает высокой безопасностью. Недостатки: сложная реализация, высокая сложность отладки и устранения неполадок, многораундовое голосование приводит к ограничению производительности. В промышленности в основном используются его варианты (Multi-Paxos и т.д.). 3.2 Raft # Raft был официально предложен в 2013 году с целью упростить реализацию и понимание при сохранении той же безопасности, что и Paxos. Он устанавливает стабильную роль лидера (Leader), централизованно выполняя репликацию журналов и восстановление после сбоев:\nКлючевые этапы: выборы лидера (Leader Election), репликация журналов (Log Replication), безопасность (Safety) и т.д. Распространенные приложения: Etcd, Consul, TiKV, LogCabin и т.д. основаны на Raft для реализации строгой согласованной репликации. Преимущества и недостатки: Преимущества: относительно прост для понимания, меньший объем кода реализации; хорошая производительность для небольших и средних кластеров. Недостатки: зависит от основного узла (лидера), сбой или разделение основного узла вызовет кратковременную блокировку записи; при крупномасштабных кластерах или межрегиональном развертывании задержка и доступность будут затронуты. 3.3 Протокол Gossip # Протокол Gossip (сплетни) не является традиционным протоколом консенсуса, он в основном используется в децентрализованных сценариях для обмена метаданными или информацией о состоянии путем случайного взаимодействия узлов, чтобы распространять и сходиться по всей сети.\nОсобенности: децентрализация, низкие накладные расходы, периодический и случайный обмен сообщениями между узлами. Распространенные приложения: Cassandra, Riak, распределенное управление участниками (например, Serf) и т.д., используются для реализации итоговой согласованности, синхронизации состояния реплик и т.д. Преимущества и недостатки: Преимущества: хорошая масштабируемость, простая реализация, подходит для сценариев, где требования к согласованности невысоки, а требования к масштабируемости высоки. Недостатки: слабая гарантия согласованности, требуются более продвинутые средства обработки конфликтов (такие как CRDT, слияние номеров версий и т.д.) для окончательного разрешения конфликтов. 3.4 2PC / 3PC # В сценариях распределенных транзакций распространенными протоколами фиксации являются 2PC (Two-phase Commit) и 3PC (Three-phase Commit):\n2PC: координатор уведомляет всех участников о \u0026ldquo;подготовке (prepare)\u0026rdquo;, если все успешно, то транслирует \u0026ldquo;фиксацию (commit)\u0026rdquo;, в противном случае \u0026ldquo;откат (abort)\u0026rdquo;. 3PC: добавляет этап на основе 2PC, чтобы уменьшить блокировку, вызванную единичной точкой отказа, но реализация более сложная, и все еще существуют проблемы с недоступностью в экстремальных сценариях разделения сети или сбоев. Преимущества и недостатки: Преимущества: легко понять, четкая семантика транзакций, широко используется в распределенных базах данных, очередях сообщений и т.д. Недостатки: сильная зависимость от координатора, риск блокировки; транзакция может не продвигаться, если сеть разделена на длительное время. IV. Два основных варианта выбора CAP: CP и AP # После того, как мы определили, что P является \u0026ldquo;обязательным\u0026rdquo; атрибутом, если распределенная система хочет продолжать предоставлять услуги во время разделения сети, она должна сделать выбор между C и A. Поэтому распространенные конструкции систем разделяются на два основных лагеря: CP и AP.\n4.1 CP-системы # CP (Consistency + Partition tolerance): при возникновении разделения сети система выберет приоритет обеспечения согласованности, при необходимости жертвуя доступностью.\nТипичная реализация: Консенсус большинства (Paxos, Raft и т.д.), требуется, чтобы более половины узлов были активны и достигли согласия, прежде чем разрешить запись. Если в данный момент не удается достичь кворума (quorum) или происходит сбой основного узла, система будет блокировать или отклонять операции записи, чтобы предотвратить расщепление мозга, приводящее к несогласованности данных. Распространенные приложения: Zookeeper, Etcd, Consul, службы распределенной блокировки, распределенное управление метаданными и т.д. Основные процессы финансовых транзакций, банковские системы учета и другие сценарии с высокими требованиями к согласованности. Особенности: Имеет строгую гарантию данных: лучше отключиться, чем иметь двойной основной или путаницу данных. Жертвует определенной доступностью: при возникновении разделения сети или переключении при сбое будет окно, когда служба недоступна или отклоняет операции записи. 4.2 AP-системы # AP (Availability + Partition tolerance): при возникновении разделения сети система выберет приоритет обеспечения доступности, при этом ослабляя согласованность.\nТипичная реализация: Итоговая согласованность, репликация нескольких основных узлов, протокол Gossip, настраиваемая политика согласованности в стиле Dynamo и т.д. Распространенные приложения: Базы данных NoSQL (Cassandra, Riak, DynamoDB и т.д.), распределенные системы кэширования (Redis Cluster) и т.д. Социальные сети, сбор журналов, системы рекомендаций и другие виды бизнеса, которые требуют высокой доступности, высокой пропускной способности и относительно низких требований к согласованности данных. Особенности: Даже при разделении все узлы по-прежнему принимают запросы на чтение и запись, гарантируя, что система \u0026ldquo;максимально доступна\u0026rdquo;. Данные могут иметь кратковременную несогласованность, но будут постепенно сходиться в фоновом режиме посредством асинхронной синхронизации, слияния конфликтов и т.д. V. Как сделать выбор между CP и AP? # В реальных крупномасштабных распределенных системах редко полагаются только на одну модель, а скорее обрабатывают различные данные или бизнес-сценарии по уровням, чтобы добиться оптимального баланса между согласованностью и доступностью.\nДля основных данных выбирайте CP Например, баланс счета пользователя, оплата заказа, поток финансовых транзакций и т.д., которые имеют очень высокие требования к согласованности. Допускается кратковременная невозможность записи, вызванная колебаниями сети, но нельзя допускать ошибок в балансе или сумме транзакции. Для периферийных или кэшированных данных выбирайте AP Например, кэш страницы сведений о товаре, журналы поведения пользователей, списки кандидатов на рекомендации и т.д., которые имеют более низкие требования к согласованности. Больше внимания уделяется высокой параллельности и высокой доступности, допускается определенная задержка обновления или грязное чтение. Многие интернет-компании используют гибридную архитектуру: основные процессы транзакций используют хранилище в стиле CP (например, распределенные реляционные базы данных или распределенное хранилище со строгой согласованностью); периферийные бизнес-сценарии или сценарии \u0026ldquo;чтения больше, чем записи\u0026rdquo; используют хранилище в стиле AP или решения для кэширования.\nVI. Как CP и AP реализуют высокую параллельность и итоговую согласованность # 6.1 Как CP-системы справляются с высокой параллельностью # Хотя протоколы консенсуса сталкиваются с более высокой задержкой и более низкой пропускной способностью, когда размер одного кластерного узла и количество запросов на запись велики, они все же могут улучшить параллелизм и масштабируемость следующими способами:\nПакетное чтение и запись Упакуйте несколько операций записи на стороне клиента или на промежуточном уровне и запишите их на узел лидера за один раз, чтобы уменьшить количество сетевых переходов и раундов протокола. Разделение базы данных и таблиц и несколько кластеров Разделите данные на несколько кластеров (шардинг) по логике или хешу, каждый кластер по-прежнему запускает протокол CP; запросы распределяются по разным сегментам через уровень маршрутизации или прокси. Улучшите общую параллельную способность и ограничьте влияние сбоев в пределах одного сегмента. Пропускная способность односегментного кластера CP-систем часто в 2-10 раз ниже, чем у AP-систем.\n6.2 Как AP-системы обеспечивают итоговую согласованность # AP-системы обычно могут обеспечить высокую пропускную способность записи и доступность чтения, но они ослабляют согласованность, поэтому необходимо реализовать гарантию сходимости согласованности в фоновом режиме или на уровне бизнес-логики:\nНомер версии (Vector Clock) или логическая метка времени Назначьте номер версии (или на основе Lamport Clock / Hybrid Clock) каждой операции обновления, объедините в сценариях конфликтов или используйте стратегию выигрыша на основе метки времени (Last Write Wins). Протокол Gossip / механизм антиэнтропии (Anti-entropy) Узлы периодически обмениваются последними данными или метаданными, и если обнаруживаются конфликты, они объединяются. Настраиваемая политика согласованности Представленная моделью Dynamo, клиент может настроить такие параметры, как R, W (например, запись большинства, подтверждение реплики), чтобы гибко регулировать согласованность и доступность. Пользовательская стратегия разрешения конфликтов Объедините с бизнес-семантикой, например, объедините корзину покупок с помощью \u0026ldquo;объединения\u0026rdquo;, а счетчик использует CRDT (G-counter, PN-counter и т.д.) для обеспечения монотонности данных. VII. Реализация строгой согласованности между сегментами CP # Как упоминалось в главе VII, разделение базы данных и таблиц (Sharding) может \u0026ldquo;разделить\u0026rdquo; давление одного кластера CP на несколько подкластеров для поддержки более высокой параллельности. Однако, когда бизнесу необходимо выполнять транзакции между сегментами (т.е. обновление нескольких баз данных или таблиц), он по-прежнему сталкивается с проблемой согласованности нескольких сегментов. Обычно есть следующие идеи:\nРаспределенные транзакции: 2PC / 3PC Если приложению требуется атомарное обновление нескольких сегментов, обычно используются протоколы распределенных транзакций (например, 2PC, 3PC) для координации фиксации или отката каждого сегмента. Проблемы и контрмеры: 2PC/3PC зависят от узла координатора, который может стать узким местом. В экстремальных ситуациях, когда сеть сильно разделена или координатор выходит из строя, может возникнуть блокировка. Обычно используются переключение основного и резервного, обнаружение пульса и механизмы тайм-аута, идемпотентные повторные попытки, MVCC и т.д. для снижения влияния блокировки и риска несогласованности данных. Архитектура на основе ячеек (Cell-based) Разделите бизнес на несколько автономных ячеек, данные в каждой ячейке находятся в одном наборе сегментов, чтобы гарантировать, что большинство транзакций выполняются только в одной ячейке, уменьшая количество операций между сегментами. Используйте асинхронные или итоговые механизмы согласованности на границах ячеек для обмена данными, учитывая общую высокую доступность и согласованность. Глобальная распределенная база данных + глобальный протокол консенсуса Например, Google Spanner реализует строгую согласованную репликацию реплик через Paxos в каждом сегменте (Shard), а затем использует TrueTime API для предоставления глобальных меток времени для обеспечения согласованности между сегментами. Этот план имеет чрезвычайно высокую сложность реализации, но может обеспечить возможности распределенных транзакций, близкие к строгой согласованности в глобальном масштабе. Резюме: для межсегментных транзакций, которые строго требуют строгой согласованности, 2PC/3PC + координатор по-прежнему являются распространенными решениями, и путем максимально возможного повышения высокой доступности координатора снижается вероятность сбоя. Но в инженерной практике следует стараться максимально сократить операции записи между сегментами или использовать идею ячеек, чтобы ограничить большинство транзакций в пределах одного сегмента, чтобы снизить сложность системы.\nVIII. Обсуждение известных случаев # Ниже кратко рассмотрим несколько распределенных систем, которые часто упоминаются в отрасли, и посмотрим на их компромиссы и методы реализации в CAP:\nGoogle Spanner Типичная CP-система (даже может достичь \u0026ldquo;иллюзии CA\u0026rdquo;, о которой часто говорят внешние источники, но по сути все равно нужно пожертвовать частью доступности). Использует точные внешние метки времени, предоставляемые TrueTime + репликацию Paxos внутри каждого сегмента, чтобы гарантировать строгую согласованность между центрами обработки данных. Подходит для глобальных финансовых транзакций или сценариев с высокими требованиями к согласованности, но стоимость инфраструктуры чрезвычайно высока. BigTable / HBase На первый взгляд больше склоняется к CP, согласованность метаданных обеспечивается через распределенную координацию между RegionServer и Master. Но на самом деле путь чтения и записи также может обеспечить определенные средства высокой доступности за счет асинхронной репликации нескольких реплик, а согласованность чтения может быть скорректирована в соответствии с потребностями приложения. AWS DynamoDB Склоняется к AP, ранний дизайн был вдохновлен статьей Dynamo, и уровень согласованности можно регулировать с помощью таких параметров, как R, W. В режиме по умолчанию обеспечивает очень высокую доступность и итоговую согласованность, а также может включить \u0026ldquo;строгое согласованное чтение\u0026rdquo; (но гарантирует только строгую согласованность одного сегмента, не обязательно между сегментами). Cassandra Также склоняется к AP, в основе используется протокол Gossip для поддержания состояния топологии узлов. Согласованность чтения и записи может быть настроена с помощью количества реплик чтения и записи R / W, чтобы обеспечить плавный переход от итоговой согласованности к более строгой согласованности. Сравнение показывает: в инженерии не существует абсолютного \u0026ldquo;AP или CP\u0026rdquo;, скорее это смесь различных стратегий согласованности; большинство систем обеспечивают определенную степень настраиваемой согласованности для адаптации к различным сценариям применения.\nIX. Заключение # Теорема CAP не является универсальным решением В реальных распределенных системах нельзя просто сказать: \u0026ldquo;Я выбираю C и отказываюсь от A\u0026rdquo; или \u0026ldquo;Я выбираю A и отказываюсь от C\u0026rdquo;. В отрасли чаще встречается гибкий выбор режима CP или AP для разных измерений данных, разных типов операций, и даже в одной системе используются разные стратегии отказоустойчивости и согласованности для разных таблиц/разных функций. AP не является абсолютно 100% доступным Например, Cassandra, DynamoDB и т.д. также могут не удовлетворять запросы в экстремальных ситуациях разделения сети или массового отказа узлов. AP-системы просто спроектированы так, чтобы \u0026ldquo;записывать, пока реплика доступна для записи\u0026rdquo;, жертвуя частью гарантии согласованности в обмен на относительно более высокую доступность и пропускную способность. CP также может стараться обеспечить высокую доступность Paxos/Raft также могут обеспечить доступность 99,99% или даже выше в нормальных условиях, но требуется вложить больше сетевых, аппаратных и инженерных затрат, и при экстремальном разделении сети все равно будет блокировка записи, жертвуя доступностью для поддержания согласованности. Гибридная архитектура является основной Основные сценарии транзакций настаивают на строгой согласованности (CP), а периферийные вспомогательные сценарии или каналы кэширования используют слабую согласованность (AP), и они работают вместе. Необходимо учитывать толерантность бизнеса, сетевую среду, вложения в затраты и технические резервы команды для всестороннего компромисса. Теорема CAP обеспечивает высокоуровневую основу для проектирования распределенных систем, помогая нам принимать рациональные решения перед лицом неизбежной реальности разделения сети. В реальных системах необходимо использовать более богатые модели согласованности, протоколы консенсуса, механизмы репликации нескольких реплик, а также инженерную практику (аварийное восстановление, понижение, идемпотентность, слияние конфликтов и т.д.) для балансировки согласованности и доступности.\n","date":"27 января 2024","externalUrl":null,"permalink":"/ru/posts/1735350760948-cap/","section":"Posts","summary":"Обсуждение применения теоремы CAP в распределенных системах от теории к практике.","title":"Глубокий анализ теоремы CAP: создание высокопараллельных и высокодоступных распределенных систем","type":"posts"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 декабря 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 декабря 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 декабря 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 декабря 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 декабря 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"Быстрая сортировка — это алгоритм сортировки на основе сравнений, не являющийся устойчивым, использующий принцип «разделяй и властвуй». Средняя временная сложность составляет $O(n\\log n)$, в худшем случае — $O(n^2)$, а пространственная сложность — $O(1)$. Ниже на примере сортировки по возрастанию целочисленной последовательности рассмотрим детали реализации и распространенные ошибки.\nОписание задачи # Дана целочисленная последовательность длиной $n$. Используйте быструю сортировку для ее сортировки по возрастанию и выведите результат.\nФормат ввода # В первой строке вводится целое число $n$ Во второй строке вводятся $n$ целых чисел, каждое в диапазоне $[1,10^9]$ Формат вывода # В одной строке выводится отсортированная последовательность Ограничения # $1 \\leq n \\leq 100000$\nПример ввода # 5 3 1 2 4 5 Пример вывода # 1 2 3 4 5 Идея быстрой сортировки # При каждом разделении в быстрой сортировке выбирается произвольное число в качестве опорного элемента pivot (ниже выбирается число в середине).\nИспользуются левый и правый указатели, движущиеся навстречу друг другу. Левый указатель L движется слева направо, ища первое число, большее или равное pivot. Правый указатель R движется справа налево, ища первое число, меньшее или равное pivot. Затем эти два числа меняются местами.\nЭтот процесс повторяется до тех пор, пока левый и правый указатели не совпадут или левый указатель не станет на одну позицию правее правого. Это называется одной итерацией.\nПосле каждого перемещения и обмена указателей гарантируется, что структура «левая часть ≤ pivot, правая часть ≥ pivot» не нарушается, то есть существует инвариант [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nВ приведенном ниже примере кода left и right — это границы текущего обрабатываемого замкнутого интервала, а pivot берется как элемент в середине интервала.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Сложность и выбор pivot # Поскольку в худшем случае быстрая сортировка имеет сложность $O(n^2)$, выбор pivot очень важен. Если всегда выбирать первый или последний элемент, то в почти отсортированном массиве с большой вероятностью возникнет худший случай.\nПомимо выбора элемента в середине, можно также случайным образом выбрать элемент в качестве pivot или взять медиану из трех элементов: левого, среднего и правого.\nПримеры распространенных ошибок # Приведенный ниже код содержит несколько распространенных ошибок.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Анализ ошибок:\npivot должен быть числом из массива, а не индексом. Использовать \u0026lt; и \u0026gt; вместо \u0026lt;= и \u0026gt;=, иначе левый указатель может уйти дальше правого более чем на одну позицию, и массив не будет разделен на две части. После обнаружения l \u0026gt;= r следует немедленно выйти из цикла, не выполняя обмен. В противном случае нельзя гарантировать, что левые элементы не больше pivot, а правые не меньше pivot. После каждого обмена следует выполнять l++ и r--. pivot фактически берется как число, смещенное влево от середины. Поэтому, если использовать $l - 1$ и $l$ для разделения массива, то, рассмотрев массив [1, 2], нетрудно заметить, что это приведет к бесконечному циклу, постоянно разделяя массив на две части размером 0 и 2. Аналогично, использование $r$ и $l$ для разделения массива также не подходит. Напротив, в конце итерации $r$ обязательно меньше $right$, поэтому можно использовать $r$ и $r+1$ для разделения массива. Читатель может смоделировать процесс алгоритма, чтобы понять, почему. Другой простой способ избежать бесконечного цикла — это случайный выбор pivot или специальная обработка случая, когда есть только два элемента. Кроме того, использование $l$, $l+1$ также не подходит, поскольку такое разделение не соответствует определению. Когда $r$ находится слева от $l$, использование $l$, $l+1$ не может правильно разделить массив на две части: левую, где элементы меньше или равны pivot, и правую, где элементы больше или равны pivot. В этой задаче предполагается, что массив не пуст, поэтому случая \u0026gt; не существует. Однако рекомендуется использовать \u0026gt;=, это безопаснее. Дополнение # Быстрая сортировка также может быть преобразована в «быстрый выбор», позволяющий найти $k$-е наименьшее число в неупорядоченном массиве за ожидаемое время $O(n)$. Основная идея аналогична быстрой сортировке, но на каждой итерации рекурсия продолжается только в одной из подпоследовательностей, что снижает временную сложность.\n","date":"26 января 2024","externalUrl":null,"permalink":"/ru/posts/1735252761946-quick-sort/","section":"Posts","summary":"Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки.","title":"Быстрая сортировка","type":"posts"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 декабря 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"Если упорядоченное пространство решений разделено на левую и правую части, где одна часть удовлетворяет условию, а другая нет, то можно использовать двоичный поиск для нахождения критической точки в упорядоченном пространстве решений.\nОсновная идея двоичного поиска заключается в постоянном делении интервала поиска пополам. При каждой проверке проверяется средний элемент, и если средний элемент не удовлетворяет условию, то можно исключить половину интервала; в противном случае поиск продолжается в другой половине интервала. Поскольку каждый раз отбрасывается половина интервала поиска, временная сложность поиска может достигать $O(\\log n)$.\nПример задачи # Описание задачи: Дан отсортированный по возрастанию массив целых чисел длиной $n$, а также $q$ запросов. Каждый запрос задает целое число $k$, и нам нужно найти «начальную позицию» и «конечную позицию» $k$ в массиве (индексы начинаются с 0). Если этого числа нет в массиве, вернуть -1 -1.\nФормат ввода # Первая строка: два целых числа $n$ и $q$, представляющие длину массива и количество запросов соответственно. Вторая строка: $n$ целых чисел, представляющих полный массив, отсортированный по возрастанию. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса. Диапазон данных # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nФормат вывода # Для каждого запроса выведите в одной строке начальную и конечную позиции элемента в массиве. Если элемента нет в массиве, выведите -1 -1.\nПример:\nВвод: 6 3 1 2 2 3 3 4 3 4 5 Вывод: 3 4 5 5 -1 -1 Пояснение:\nДиапазон появления элемента $3$ равен $[3, 4]$; Элемент $4$ встречается только один раз, в позиции $5$; Элемента $5$ нет в массиве, поэтому возвращается $-1$ $-1$. Решение # Поиск «начальной позиции»: То есть поиск первой позиции, где значение больше или равно $k$. Можно разделить массив на две части:\nВсе числа слева «меньше» $k$ Все числа справа «больше или равны» $k$ Ответ — первая позиция справа Поиск «конечной позиции»: То есть поиск последней позиции, где значение меньше или равно $k$. Можно разделить массив на две части:\nВсе числа слева «меньше или равны» $k$ Все числа справа «больше» $k$ Ответ — последняя позиция слева Рекомендуемый шаблон # Ниже представлен элегантный и не склонный к ошибкам шаблон двоичного поиска.\nОпределим два указателя $l, r$, с инвариантом: замкнутый интервал $[0, l]$ принадлежит левой части, замкнутый интервал $[r, n - 1]$ принадлежит правой части. $l$ и $r$ инициализируются как $-1$ и $n$.\nКогда алгоритм завершается, $l$ и $r$ становятся соседними, указывая на последний элемент левой части и первый элемент правой части соответственно.\nПоскольку желаемое решение может не существовать, если в условии задачи не указано, что решение обязательно существует, нам нужно проверить, не выходят ли l или r за границы, и указывают ли они на правильное значение.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Поиск начальной позиции k 15 // Разделяем массив на две части, слева все \u0026lt; k, справа все \u0026gt;= k. 16 // Ответ - минимальный индекс правой части. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Если r выходит за границы или nums[r] != k, значит k не существует 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Поиск конечной позиции k 33 // Разделяем массив на две части, слева все \u0026lt;= k, справа все \u0026gt; k. 34 // Ответ - максимальный индекс левой части. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Преимущества # Этот подход имеет строго определенные инварианты. Он подходит как для поиска «начальной позиции», так и для поиска «конечной позиции», не требуя дополнительных обработок и изменений. Некоторые подходы используют l == r в качестве условия завершения. Когда $l$ и $r$ отличаются на $1$, вычисляется $mid$, равный $l$ или $r$. Если это не обработано правильно, обновление $l$ или $r$ до $mid$ приведет к тому, что интервал поиска не уменьшится, что приведет к бесконечному циклу. Напротив, этот подход завершается, когда $l$ и $r$ соседние, гарантируя, что $mid$ меньше $l$ и больше $r$, и при обновлении $l$ или $r$ интервал поиска обязательно уменьшится. STL # Если использовать функции lower_bound и upper_bound, предоставляемые C++ STL, можно добиться того же результата:\nlower_bound(first, last, val) вернет «первую позицию, где значение больше или равно val» upper_bound(first, last, val) вернет «первую позицию, где значение больше val» Например, предположим, что nums = {1,2,3,4,4,4,4,4,5,5,6}, и мы хотим узнать интервал, в котором появляется 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 указывает на первую позицию, где значение больше или равно $4$. it2 указывает на первую позицию, где значение больше $4$. Следовательно, it2 - it1 — это количество раз, когда $4$ появляется в массиве; it2 - nums.begin() - 1 — это позиция правой границы $4$. Дополнение # Двоичный поиск также можно расширить на поиск в диапазоне чисел с плавающей точкой (например, для нахождения корней уравнения), а также на тернарный поиск для нахождения экстремумов унимодальных функций.\nУпражнение # LeetCode 33. Search in Rotated Sorted Array\nПодсказка: на первом шаге используйте двоичный поиск, чтобы найти точку поворота, а на втором шаге используйте двоичный поиск, чтобы найти целевое значение.\n","date":"24 января 2024","externalUrl":null,"permalink":"/ru/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Как элегантно реализовать алгоритм двоичного поиска.","title":"Двоичный поиск","type":"posts"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":" Задача # Есть $N$ предметов. Объем $i$-го предмета равен $s_i$, а его стоимость равна $v_i$. Каждый предмет можно взять только один раз. При условии, что общий объем не превышает максимального предела $S$, найдите максимальную общую стоимость $V$, которую можно получить.\nФормат ввода # Первая строка содержит два целых числа $N$ и $S$, разделенных пробелом, представляющих количество предметов и максимальный общий предел объема соответственно. Следующие $N$ строк содержат по два целых числа $s_i$ и $v_i$, разделенных пробелом, представляющих объем и стоимость $i$-го предмета соответственно.\nФормат вывода # Выведите целое число, представляющее максимальную стоимость.\nДиапазон данных # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Пример ввода # 4 5 1 2 2 4 3 4 4 5 Пример вывода # 8 Решение # Определите состояние: f[i][j] представляет максимальную стоимость, которую можно получить из первых $i$ предметов с ограничением объема $j$. Если $i$-й предмет не берется, то f[i][j] = f[i - 1][j] Если $i$-й предмет берется, то f[i][j] = f[i - 1][j - s[i]] + v[i] При реализации перехода состояния обратите внимание на диапазон. Если $j \u003c s_i$, то не рассматривайте случай взятия $i$-го предмета. Потому что если $j - s_i$ отрицательно, то индекс массива будет недопустимым. Это также можно объяснить так: объем $i$-го предмета больше, чем предел объема, поэтому это невозможно. Определите начальное условие: Для первых $0$ предметов любое ограничение объема дает значение $0$, т.е. f[0][j] = 0, j $\\in [0, S]$. Временная сложность: $O(NS)$. Код # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Оптимизация 1D DP # Сжатие двумерного массива в одномерный массив может значительно сэкономить место и в определенной степени повысить скорость работы (недостаток заключается в том, что он не может удовлетворить особые требования некоторых типов задач). Обратите внимание, что в переходе состояния f[i][j] связан только с f[i - 1][j] и f[i - 1][j - s[i]]. Другими словами, в двумерном массиве f в коде, f[i][j] связан только с элементами в предыдущей строке, которые находятся слева от него или в том же столбце. Следовательно, двумерный массив можно сжать в одномерный массив или скользящий массив. Обратите внимание, что в приведенном ниже коде второй цикл выполняется в обратном порядке. Это связано с тем, что мы хотим убедиться, что при вычислении f[i][j] значение f[i - 1][j - s[i]] еще не было обновлено. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Если требуется количество схем # Нужно вывести не только максимальную общую стоимость, которую можно получить, но и \u0026ldquo;сколько различных способов выбора могут достичь этой максимальной общей стоимости\u0026rdquo;. Ниже описано, как подсчитать количество схем в задаче о рюкзаке 0-1.\n2D DP для подсчета схем # В качестве примера ниже используется 2D DP.\nОпределите состояние:\ndp[i][j] представляет \u0026ldquo;максимальную стоимость, которую можно получить при рассмотрении первых i предметов с вместимостью (ограничением объема) j\u0026rdquo;. ways[i][j] представляет \u0026ldquo;количество схем, соответствующих максимальной стоимости, полученной при рассмотрении первых i предметов с вместимостью j\u0026rdquo;. Переход состояния:\nЕсли i-й предмет не выбран: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Если i-й предмет выбран (при условии, что $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Независимо от того, выбирать или нет, окончательный dp[i][j] должен принимать большее из двух: Если $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ то это означает, что \u0026ldquo;выбор i-го предмета\u0026rdquo; имеет большее значение: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Если $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ это означает, что максимальное значение, полученное двумя методами, одинаково, тогда количество схем следует сложить: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Если $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ то это означает, что \u0026ldquo;невыбор i-го предмета\u0026rdquo; имеет большее значение, и количество схем наследует количество схем при невыборе: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Начальные условия:\ndp[0][j] = 0 означает, что когда есть 0 предметов, максимальное значение, полученное для любой вместимости, равно 0. ways[0][0] = 1 означает, что случай \u0026ldquo;0 предметов, вместимость 0\u0026rdquo; является возможной схемой (т.е. ничего не выбирать), и количество схем устанавливается равным 1. Для j \u0026gt; 0, когда нет предметов для выбора и вместимость больше 0, невозможно получить какое-либо положительное значение, и соответствующее количество схем равно 0, т.е. ways[0][j] = 0. Окончательный ответ:\ndp[N][S] - это максимальное значение. ways[N][S] - это количество схем для достижения этого максимального значения. Временная сложность: $O(NS)$. Эту задачу также можно оптимизировать с помощью 1D DP. Если требуется точно достичь предела объема # Определите состояние: f[i][j] представляет максимальную стоимость, когда первые i предметов имеют точно объем $j$. Если i-й предмет не берется, то f[i][j] = f[i - 1][j] Если i-й предмет берется, то f[i][j] = f[i - 1][j - s[i]] + v[i] Можно заметить, что в переходе состояния нет отличий от исходной задачи. Однако начальные условия отличаются. За исключением f[0][0] = 0, остальные f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ представляет невозможное состояние. Если предел объема $S$ очень велик (1e9), а количество предметов $N$ и максимальная общая стоимость $V$ относительно малы # Для таких задач есть решение со сложностью $O(NV)$. Определите состояние: f[i][j] представляет минимальный объем при выборе нескольких предметов из первых i предметов, а общая стоимость равна j. Если i-й предмет не берется, то f[i][j] = f[i - 1][j] Если i-й предмет берется, то f[i][j] = f[i - 1][j - v[i]] + s[i] Возьмите меньшее из двух. Начальные условия: f[0][0] = 0, остальные f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ представляет невозможное состояние. Обратите внимание, что это не $-\\infty$. Окончательный ответ - это наибольшее j в f[N][j], такое что f[N][j] \u0026lt;= S. Если предел объема $S$ и стоимость одного предмета $v_i$ очень велики (порядка 1e9), а количество предметов $N$ очень мало (не более 40) # Когда $N \\leq 20$, все подмножества можно перечислить напрямую грубой силой (временная сложность $O(2^N)$). Когда $N \\leq 40$, поскольку $2^{40}$ имеет порядок $10^{12}$, прямое перечисление грубой силой также будет относительно большим, поэтому можно использовать поиск посередине, чтобы уменьшить сложность примерно до $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, что можно выполнить за приемлемое время. ","date":"24 января 2024","externalUrl":null,"permalink":"/ru/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Самая базовая классическая задача о рюкзаке.","title":"Задача о рюкзаке 0-1","type":"posts"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ru/series/","section":"Series","summary":"","title":"Series","type":"series"}]