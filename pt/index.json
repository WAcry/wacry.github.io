[{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":" Busca Binária # Em uma sequência ordenada, a busca binária pode ser usada para encontrar um elemento específico rapidamente. Comparada à complexidade de tempo da busca linear $O(n)$, a busca binária requer apenas tempo de $O(\\log n)$, por isso é muito eficiente em casos de grande escala de dados.\nA Ideia Central da Busca Binária # A ideia básica da busca binária é dividir o intervalo de busca pela metade repetidamente. Em cada comparação, o elemento do ponto médio é comparado com o valor-alvo. Se o elemento do ponto médio não atender à condição, metade do intervalo é eliminada; caso contrário, a busca continua na outra metade do intervalo. Como metade do intervalo de busca é descartada a cada vez, a complexidade de tempo da busca pode atingir $O(\\log n)$.\nA busca binária é muito útil para problemas em que \u0026quot; a solução viável pode ser dividida em um intervalo ordenado (que atende à condição) e outro intervalo ordenado (que não atende à condição)\u0026quot;. Por exemplo:\nEncontrar se um determinado elemento existe em um array ordenado Encontrar a \u0026ldquo;primeira posição\u0026rdquo; ou a \u0026ldquo;última posição\u0026rdquo; em que um número aparece Exemplo: Encontrar as Posições Inicial e Final de um Elemento # Descrição do problema:\nDado um array de inteiros de comprimento $n$ em ordem crescente, e também $q$ consultas. Cada consulta fornece um inteiro $k$, e precisamos encontrar a \u0026ldquo;posição inicial\u0026rdquo; e a \u0026ldquo;posição final\u0026rdquo; de $k$ no array (índice começando em 0). Se o número não existir no array, retorne $-1$ $-1$.\nFormato de entrada:\nPrimeira linha: dois inteiros $n$ e $q$, representando o comprimento do array e o número de consultas, respectivamente. Segunda linha: $n$ inteiros (dentro do intervalo de 1 a 10000), representando o array completo, já ordenado em ordem crescente. Próximas $q$ linhas: cada linha contém um inteiro $k$, representando um elemento de consulta. Formato de saída:\nPara cada consulta, imprima a posição inicial e final do elemento no array em uma linha. Se o elemento não existir no array, imprima $-1$ $-1$.\nExemplo:\nEntrada: 6 3 1 2 2 3 3 4 3 4 5 Saída: 3 4 5 5 -1 -1 Explicação:\nO intervalo em que o elemento 3 aparece é [3, 4]; O elemento 4 aparece apenas uma vez, na posição 5; O elemento 5 não existe no array, então retorne -1 -1. Aplicação da Busca Binária # Neste problema, para encontrar o \u0026ldquo;limite esquerdo\u0026rdquo; e o \u0026ldquo;limite direito\u0026rdquo; de um determinado valor, podemos confiar na busca binária. A chave é entender como definir o intervalo de busca e como mover os ponteiros de acordo com o resultado da comparação.\nEncontrar o \u0026ldquo;limite esquerdo\u0026rdquo;:\nOu seja, encontrar a primeira posição maior ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores\u0026rdquo; que $k$ Todos os números à direita são \u0026ldquo;maiores ou iguais\u0026rdquo; a $k$ Encontrar o \u0026ldquo;limite direito\u0026rdquo;:\nOu seja, encontrar a última posição menor ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores ou iguais\u0026rdquo; a $k$ Todos os números à direita são \u0026ldquo;maiores\u0026rdquo; que $k$ Contanto que você possa manter esses dois intervalos corretamente, você pode obter os resultados rapidamente por meio da busca binária.\nModelo Recomendado: Busca Binária para Evitar Loops Infinitos # Abaixo está um modelo de busca binária elegante e sem erros. Ele garante que o loop termine quando $l$ e $r$ estiverem adjacentes, movendo $l$ e $r$ gradualmente para perto um do outro:\nDefina dois ponteiros $l, r$, com o invariante: o intervalo fechado $[0, l]$ pertence à parte esquerda e o intervalo fechado $[r, n - 1]$ pertence à parte direita. $l$ e $r$ são inicializados para $-1$ e $n$.\nQuando o algoritmo termina, $l$ e $r$ estão adjacentes, apontando respectivamente para o valor máximo da parte esquerda e o valor mínimo da parte direita.\nComo a solução que desejamos pode não existir, ao retornar $l$ ou $r$, precisamos verificar se o valor correspondente é o valor que queremos e se está fora dos limites. Por exemplo, $l$ representa o valor máximo $\\leq k$, e precisamos verificar l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Encontre a posição inicial de k (limite esquerdo) // Divida o array em duas partes, todos à esquerda \u0026lt; k, todos à direita \u0026gt;= k. // O limite esquerdo é o menor índice da parte direita. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Se r estiver fora dos limites ou nums[r] != k, significa que k não existe if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Registre o limite esquerdo de k // 2. Encontre a posição final de k (limite direito) // Divida o array em duas partes, todos à esquerda \u0026lt;= k, todos à direita \u0026gt; k. // O limite direito é o maior índice da parte esquerda. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Como já verificamos que k existe, não precisamos verificar novamente aqui int rightPos = l; // Limite direito cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } Por que essa escrita não é propensa a erros? # Esta escrita tem um invariante estritamente definido. Ela pode encontrar tanto o limite esquerdo quanto o limite direito, o que pode ser aplicado a todos os cenários. Algumas escritas usam $l == r$ como condição de parada. Quando $l$ e $r$ diferem em 1, o $mid$ será calculado como igual a l ou r. Se não for tratado corretamente, atualizando l ou r para mid, o intervalo de busca não será reduzido, o que levará a um loop infinito. Por outro lado, a escrita aqui termina quando $l$ e $r$ são adjacentes, o que evita esse problema. Solução STL: lower_bound e upper_bound # Se você usar as funções lower_bound e upper_bound fornecidas pelo C++ STL, poderá concluir facilmente a mesma coisa:\nlower_bound(first, last, val) retornará \u0026ldquo;a primeira posição maior ou igual a val\u0026rdquo; upper_bound(first, last, val) retornará \u0026ldquo;a primeira posição maior que val\u0026rdquo; Por exemplo, suponha nums = {1,2,3,4,4,4,4,4,5,5,6}, queremos saber o intervalo em que 4 aparece:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Significa que 4 não existe no array cout \u0026lt;\u0026lt; \u0026#34;4 aparece 0 vezes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;o primeiro 4 está em \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;o último 4 está em \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 aparece \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; vezes\u0026#34; \u0026lt;\u0026lt; endl; } it1 aponta para a primeira posição cujo valor é maior ou igual a 4. it2 aponta para a primeira posição cujo valor é maior que 4.\nPortanto, it2 - it1 é o número de vezes que 4 aparece no array; it2 - nums.begin() - 1 é o limite direito de 4. Essas duas funções são particularmente convenientes ao procurar intervalos ou contar o número de ocorrências.\nComplemento # A busca binária também pode ser estendida para a pesquisa em um intervalo de números de ponto flutuante (como encontrar raízes de uma equação) e a busca ternária para encontrar o máximo de uma função unimodal. Contanto que você entenda o princípio central de \u0026ldquo;em um intervalo ordenado, metade pode ser eliminada a cada vez\u0026rdquo;, você descobrirá que a busca binária pode ajudá-lo a resolver problemas de forma eficiente em muitas situações.\nExercícios # LeetCode 33. Search in Rotated Sorted Array\nDica: O primeiro passo é usar a busca binária para encontrar o ponto de rotação, e o segundo passo é usar a busca binária para encontrar o valor de destino.\n","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Como implementar elegantemente o algoritmo de busca binária de inteiros","title":"Busca Binária","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/pt/series/","section":"Series","summary":"","title":"Series","type":"series"}]