[{"content":" I. Teorema CAP # 1.1 O que é o Teorema CAP # O Teorema CAP foi proposto por Eric Brewer em 2000, e seu ponto central é:\nC (Consistência): Todos os nós do sistema veem os mesmos dados no mesmo instante. Mais estritamente, quando um cliente lê dados, o resultado deve ser consistente com os dados mais recentemente submetidos, independentemente de qual réplica seja lida (geralmente referindo-se à consistência forte/consistência linear). A (Disponibilidade): O sistema ainda pode fornecer serviços normais quando ocorrem falhas parciais, e cada solicitação pode obter uma \u0026ldquo;resposta válida\u0026rdquo; em um tempo razoável (não necessariamente bem-sucedida, incluindo respostas de falha corretas). P (Tolerância a Partição): O sistema pode tolerar partições de rede (comunicação inacessível entre nós), e mesmo que a rede se divida, o sistema pode fornecer um certo grau de disponibilidade ou consistência. Em ambientes distribuídos reais, as partições de rede são inevitáveis, então P é basicamente considerado um \u0026ldquo;item obrigatório\u0026rdquo;. Quando ocorre uma partição de rede, o sistema não pode levar em consideração simultaneamente a consistência forte dos dados em todos os nós e a alta disponibilidade, e só pode escolher entre C e A, resultando nos dois principais tipos CP e AP.\n1.2 Limitações do Teorema CAP # É importante notar que o Teorema CAP em si é uma teoria de nível relativamente alto, usada para orientação conceitual, e não deve ser simplesmente entendido como \u0026ldquo;escolher C ou escolher A\u0026rdquo;. Existem alguns equívocos comuns:\nC não é necessariamente consistência forte O C no Teorema CAP geralmente se refere à consistência no sentido mais estrito (ou seja, consistência linear). No entanto, em sistemas reais, existem muitos modelos de granularidade fina para escolher, como consistência fraca, leitura confirmada (Read Committed), consistência causal (Causal Consistency), etc. Disponibilidade não é 0 ou 1 Não é que escolher CP signifique que a disponibilidade seja completamente sacrificada; ou escolher AP signifique que a consistência não tenha garantia. Tanto a disponibilidade quanto a consistência têm diferentes graus de espaço de compensação e estratégias de degradação. Consistência eventual não viola o CAP É uma solução de compromisso muito comum, usando uma consistência de escrita mais baixa em troca de maior disponibilidade e taxa de transferência, e convergindo dados em segundo plano de forma assíncrona. Portanto, o Teorema CAP deve ser combinado com vários modelos de consistência e padrões de arquitetura de alta disponibilidade em cenários específicos para gerar um verdadeiro valor de orientação prática.\nII. Modelos de Consistência de Sistemas Distribuídos # A classificação dos modelos de consistência é muito rica, mas os modelos principais comuns podem ser divididos em: consistência forte e consistência fraca (que inclui consistência eventual, consistência causal, etc.). Este artigo apresenta principalmente consistência forte e consistência eventual, e explica suas aplicações comuns nos modos CP ou AP.\n2.1 Consistência Forte # Consistência Forte (Strong Consistency), também conhecida como Consistência Linear (Linearizability), refere-se ao fato de que, uma vez que uma operação de escrita é concluída e retorna com sucesso, qualquer operação de leitura subsequente pode ler o conteúdo atualizado. Ou seja, o sistema se comporta como se todas as operações fossem executadas em série.\nImplementação comum: Depende da replicação síncrona e de um mecanismo de quórum (maioria), e usa protocolos (como Paxos/Raft) para garantir que haja apenas um líder (Leader) válido no sistema, e todas as operações são gravadas no log em ordem e replicadas para a maioria dos nós. Vantagens e desvantagens: Vantagens: Garante a correção de dados mais estrita, e os dados lidos em qualquer momento não \u0026ldquo;retrocedem\u0026rdquo;. Desvantagens: Em caso de instabilidade de rede, partição ou falha do líder, para manter a consistência, as operações de escrita são frequentemente bloqueadas, levando a uma diminuição da disponibilidade geral; o desempenho e a taxa de transferência também são relativamente mais baixos. 2.2 Consistência Eventual # Consistência Eventual (Eventual Consistency) é uma forma típica de consistência fraca, que exige apenas que, se o sistema não tiver novas operações de atualização, com o tempo, os dados de todas as réplicas convergirão gradualmente para o mesmo estado. Durante este período, os usuários que leem dados de réplicas podem ver valores desatualizados, mas eventualmente se tornarão consistentes.\nImplementação comum: Protocolo Gossip, replicação assíncrona de várias réplicas, CRDT (Conflict-free Replicated Data Type), etc. Vantagens e desvantagens: Vantagens: Alta disponibilidade, alta taxa de transferência, baixa latência de operações de escrita e alta tolerância a partições de rede. Desvantagens: É necessário tolerar inconsistências de dados de curto prazo, a lógica da aplicação é mais complexa e pode ser necessário realizar detecção e fusão de conflitos. III. Protocolos e Algoritmos de Consistência Comuns # Para manter a consistência entre as réplicas do sistema distribuído, a indústria propôs muitos algoritmos e protocolos clássicos. A seguir, apresentamos brevemente alguns deles:\n3.1 Paxos # Paxos é um algoritmo de consistência distribuída proposto por Leslie Lamport na década de 1990, usado principalmente para implementar consistência forte ou consistência linear.\nPrincípio básico: Através da divisão de funções (Proponente, Aceitador, Aprendiz), várias rodadas de votação são realizadas para determinar se uma operação ou valor é aceito pela maioria dos nós. Vantagens e desvantagens: Vantagens: Pode chegar a um consenso sob partições de rede e falhas de nós, e tem alta segurança. Desvantagens: A implementação é complexa, a depuração e a solução de problemas são difíceis e várias rodadas de votação levam a um desempenho limitado. A indústria usa principalmente suas variantes (Multi-Paxos, etc.). 3.2 Raft # Raft foi formalmente proposto em 2013, com o objetivo de simplificar a implementação e a dificuldade de compreensão, garantindo a mesma segurança que o Paxos. Ele estabelece um líder (Leader) estável para realizar centralizadamente a replicação de logs e a recuperação de falhas:\nEtapas principais: Eleição de líder (Leader Election), replicação de logs (Log Replication), segurança (Safety), etc. Aplicações comuns: Etcd, Consul, TiKV, LogCabin, etc. são todos baseados em Raft para implementar replicação de consistência forte. Vantagens e desvantagens: Vantagens: Relativamente fácil de entender, menos código de implementação; bom desempenho para clusters de pequena e média escala. Desvantagens: Depende do nó principal (Líder), e falhas ou partições do nó principal causarão um bloqueio de escrita temporário; em clusters de grande escala ou implantações entre regiões, a latência e a disponibilidade serão afetadas. 3.3 Protocolo Gossip # O protocolo Gossip (fofoca) não é um protocolo de consenso tradicional, usado principalmente em cenários descentralizados para trocar metadados ou informações de estado por meio de interações aleatórias de nós, de modo a se espalhar e convergir em toda a rede.\nCaracterísticas: Descentralizado, baixo custo, troca periódica e aleatória de mensagens entre nós. Aplicações comuns: Cassandra, Riak, gerenciamento de membros distribuídos (como Serf), etc., usados para implementar consistência eventual, sincronização de estado de réplica, etc. Vantagens e desvantagens: Vantagens: Boa escalabilidade, simples de implementar, adequado para cenários que não exigem alta consistência e alta escalabilidade. Desvantagens: A garantia de consistência é fraca e são necessários meios de tratamento de conflitos de nível superior (como CRDT, fusão de número de versão, etc.) para resolver conflitos. 3.4 2PC / 3PC # Em cenários de transações distribuídas, os protocolos de commit comuns são 2PC (Two-phase Commit) e 3PC (Three-phase Commit):\n2PC: O coordenador notifica todos os participantes para \u0026ldquo;preparar (prepare)\u0026rdquo;, se todos forem bem-sucedidos, ele transmite \u0026ldquo;commit (commit)\u0026rdquo;, caso contrário, \u0026ldquo;abort (abort)\u0026rdquo;. 3PC: Adiciona uma etapa com base em 2PC para reduzir o bloqueio causado por falhas de ponto único, mas a implementação é mais complexa e ainda existem problemas de indisponibilidade em cenários extremos de partição de rede ou falha. Vantagens e desvantagens: Vantagens: Fácil de entender, semântica de transação clara, amplamente utilizada em bancos de dados distribuídos, filas de mensagens, etc. Desvantagens: Forte dependência do coordenador, risco de bloqueio; pode não ser possível continuar a transação quando a rede é particionada por um longo tempo. IV. As Duas Principais Escolhas do CAP: CP e AP # Depois que determinamos que P é um atributo \u0026ldquo;obrigatório\u0026rdquo;, se um sistema distribuído quiser continuar a fornecer serviços durante uma partição de rede, ele deve escolher entre C e A. O design comum do sistema é, portanto, dividido em dois campos principais: CP e AP.\n4.1 Sistemas CP # CP (Consistência + Tolerância a Partição): Ao encontrar uma partição de rede, o sistema escolherá priorizar a garantia de consistência e sacrificar a disponibilidade quando necessário.\nImplementação típica: Consenso da maioria (Paxos, Raft, etc.), mais da metade dos nós precisam estar ativos e chegar a um consenso para permitir a escrita. Se um quórum (número legal) não puder ser alcançado no momento ou se o nó principal falhar, o sistema bloqueará ou rejeitará operações de escrita para evitar inconsistências de dados causadas por divisão cerebral. Aplicações comuns: Zookeeper, Etcd, Consul, serviços de bloqueio distribuído, gerenciamento de metadados distribuídos, etc. Processos principais de transações financeiras, sistemas de contabilidade bancária e outros cenários que exigem alta consistência. Características: Possui garantia de dados estrita: prefere desligar a ter um mestre duplo ou confusão de dados. Sacrifica uma certa disponibilidade: quando ocorre uma partição de rede ou failover, haverá uma janela de serviço indisponível ou rejeição de operações de escrita. 4.2 Sistemas AP # AP (Disponibilidade + Tolerância a Partição): Ao encontrar uma partição de rede, o sistema escolherá priorizar a garantia de disponibilidade e, ao mesmo tempo, relaxar a consistência.\nImplementação típica: Consistência eventual, replicação multi-mestre, protocolo Gossip, estratégia de consistência ajustável no estilo Dynamo, etc. Aplicações comuns: Bancos de dados NoSQL (Cassandra, Riak, DynamoDB, etc.), sistemas de cache distribuído (Redis Cluster), etc. Redes sociais, coleta de logs, sistemas de recomendação e outros negócios que exigem alta disponibilidade, alta taxa de transferência e requisitos relativamente flexíveis de consistência de dados. Características: Mesmo que haja uma partição, todos os nós ainda aceitam solicitações de leitura e escrita, garantindo que o sistema esteja \u0026ldquo;o mais disponível possível\u0026rdquo;. Pode haver inconsistências de dados de curto prazo, mas eles convergirão gradualmente em segundo plano por meio de sincronização assíncrona, fusão de conflitos, etc. V. Como Escolher entre CP e AP? # Em sistemas distribuídos de grande escala reais, é raro depender de um único modelo, mas sim processar diferentes dados ou cenários de negócios em camadas, a fim de buscar o melhor equilíbrio entre consistência e disponibilidade.\nEscolha CP para dados principais Como saldos de contas de usuários, pagamentos de pedidos, fluxos de transações financeiras, etc., que têm requisitos extremamente altos de consistência. Tolere a indisponibilidade temporária de escrita causada por instabilidade de rede, mas não tolere erros no saldo ou no valor da transação. Escolha AP para dados de borda ou em cache Como o cache da página de detalhes do produto, logs de comportamento do usuário, listas de candidatos de recomendação, etc., que têm requisitos mais baixos de consistência. Mais foco em alta concorrência e alta disponibilidade, capaz de tolerar atualizações atrasadas ou leituras sujas por um certo tempo. Muitas empresas de internet adotarão uma arquitetura híbrida: os processos de transação principais usam armazenamento no estilo CP (como bancos de dados relacionais distribuídos ou armazenamento distribuído com consistência forte); os negócios periféricos ou cenários de \u0026ldquo;muitas leituras e poucas escritas\u0026rdquo; usam armazenamento no estilo AP ou soluções de cache.\nVI. Como CP e AP Alcançam Alta Concorrência e Consistência Eventual # 6.1 Como os Sistemas CP Lidam com Alta Concorrência # Embora os protocolos de consenso enfrentem alta latência e baixa taxa de transferência quando o tamanho do nó de um único cluster e o número de solicitações de escrita são grandes, a concorrência e a escalabilidade ainda podem ser melhoradas pelos seguintes meios:\nLeitura e escrita em lote Empacote várias operações de escrita no cliente ou na camada intermediária e grave-as no nó líder de uma só vez, reduzindo as viagens de ida e volta da rede e as rodadas de protocolo. Divisão de banco de dados e tabelas e vários clusters Divida os dados em vários clusters (sharding) por lógica ou hash, e cada cluster ainda executa o protocolo CP; as solicitações são dispersas para diferentes shards por meio de roteamento ou camada de proxy. Melhore a capacidade geral de concorrência e limite o impacto da falha ao escopo de um único shard. A taxa de transferência de um único cluster de shard de um sistema CP é geralmente 2 a 10 vezes menor do que a de um sistema AP.\n6.2 Como os Sistemas AP Garantem a Consistência Eventual # Os sistemas AP geralmente podem fornecer alta taxa de transferência de escrita e disponibilidade de leitura, mas relaxam a consistência, portanto, é necessário implementar garantias de convergência de consistência em segundo plano ou na camada de lógica de negócios:\nNúmero de versão (Vector Clock) ou carimbo de data/hora lógico Atribua um número de versão (ou baseado em Lamport Clock / Hybrid Clock) a cada operação de atualização e realize a fusão ou a estratégia de vitória baseada em carimbo de data/hora (Last Write Wins) em cenários de conflito. Protocolo Gossip / mecanismo anti-entropia Os nós trocam periodicamente os dados ou metadados mais recentes e, se encontrarem conflitos, eles são mesclados. Estratégia de consistência ajustável Representado pelo modelo Dynamo, o cliente pode configurar parâmetros como R e W (como gravar a maioria, confirmação de réplica), de modo a ajustar a consistência e a disponibilidade de forma flexível. Estratégia de resolução de conflitos personalizada Combine a semântica de negócios para mesclar, como usar \u0026ldquo;união\u0026rdquo; para mesclar carrinhos de compras e usar CRDT (G-counter, PN-counter, etc.) para garantir a monotonicidade dos dados para contadores. VII. Implementação de Consistência Forte entre Shards de CP # No Capítulo VII, foi mencionado que a divisão de bancos de dados e tabelas (Sharding) pode \u0026ldquo;dividir\u0026rdquo; a pressão de um único cluster CP em vários subclusters para suportar maior concorrência. No entanto, quando os negócios precisam executar transações entre shards (ou seja, envolvendo atualizações de vários bancos de dados ou tabelas), eles ainda enfrentam o desafio da consistência de vários shards. Geralmente, existem as seguintes ideias:\nTransações distribuídas: 2PC / 3PC Se o aplicativo precisar realizar atualizações atômicas em vários shards, os protocolos de transação distribuída (como 2PC, 3PC) são geralmente usados para coordenar o commit ou rollback de cada shard. Problemas e contramedidas: 2PC/3PC dependem de um nó coordenador, que pode se tornar um gargalo de ponto único. Em casos extremos de partição de rede grave ou falha do coordenador, pode ocorrer bloqueio. Geralmente, a troca mestre-escravo, detecção de batimentos cardíacos e mecanismos de tempo limite, repetição idempotente, MVCC, etc. são usados para reduzir o impacto do bloqueio e o risco de inconsistência de dados. Arquitetura baseada em células (Cell-based) Divida os negócios em várias unidades autônomas, e os dados em cada unidade estão no mesmo conjunto de shards, garantindo que a maioria das transações seja concluída em uma única unidade, reduzindo as operações entre shards. Use mecanismos assíncronos ou de consistência eventual nos limites da unidade para troca de dados, levando em consideração a alta disponibilidade e consistência geral. Banco de dados distribuído global + protocolo de consenso global Por exemplo, o Google Spanner implementa replicação de consistência forte em cada shard por meio de Paxos e usa a API TrueTime para fornecer carimbos de data/hora globais para garantir a consistência entre shards. Esta solução tem uma complexidade de implementação extremamente alta, mas pode fornecer recursos de transação distribuída quase consistentes em um escopo global. Resumo: Para transações entre shards que exigem estritamente consistência forte, 2PC/3PC + coordenador ainda são soluções comuns e, tanto quanto possível, a alta disponibilidade do coordenador é melhorada para reduzir a possibilidade de falha. No entanto, na prática de engenharia, as operações de escrita entre shards devem ser reduzidas o máximo possível, ou a complexidade do sistema deve ser reduzida limitando a maioria das transações ao escopo de um único shard por meio de ideias de unitização.\nVIII. Discussão de Casos Famosos # A seguir, discutiremos brevemente vários sistemas distribuídos que são frequentemente mencionados na indústria e veremos suas escolhas e métodos de implementação no CAP:\nGoogle Spanner Um sistema CP típico (pode até atingir a ilusão \u0026ldquo;CA\u0026rdquo; que o mundo exterior costuma dizer, mas na verdade ainda precisa sacrificar parte da disponibilidade). Use carimbos de data/hora externos precisos fornecidos pelo TrueTime + replicação Paxos dentro de cada shard para garantir consistência forte entre data centers. Adequado para transações financeiras globais ou cenários que exigem alta consistência, mas o custo da infraestrutura é extremamente alto. BigTable / HBase Superficialmente mais inclinado a CP, a consistência dos metadados é garantida por meio de coordenação distribuída entre RegionServer e Master. No entanto, no caminho real de leitura e escrita, ele também pode fornecer certos meios de alta disponibilidade por meio de replicação assíncrona de várias réplicas, e a consistência de leitura pode ser ajustada de acordo com as necessidades do aplicativo. AWS DynamoDB Inclinado a AP, o design inicial foi inspirado no artigo Dynamo, e o nível de consistência pode ser ajustado por meio de parâmetros como R e W. No modo padrão, ele fornece alta disponibilidade e consistência eventual, e também pode ativar a \u0026ldquo;leitura de consistência forte\u0026rdquo; (mas apenas garante a consistência forte de uma única partição, não necessariamente entre partições). Cassandra Também é uma tendência AP, o protocolo Gossip subjacente é usado para manter o estado da topologia do nó. A consistência de leitura e escrita pode ser configurada para ler e escrever o número de réplicas R / W, de modo a realizar uma transição suave da consistência eventual para uma consistência mais forte. Comparação visível: Não existe um \u0026ldquo;AP ou CP\u0026rdquo; absoluto na engenharia, mas sim uma mistura de várias estratégias de consistência; a maioria dos sistemas fornece um certo grau de consistência ajustável para se adaptar a diferentes cenários de aplicação.\nIX. Resumo # O Teorema CAP não é uma solução única Sistemas distribuídos reais não podem simplesmente dizer \u0026ldquo;Eu escolho C e desisto de A\u0026rdquo; ou \u0026ldquo;Eu escolho A e desisto de C\u0026rdquo;. O que é mais comum na indústria é escolher de forma flexível os modos CP ou AP para diferentes dimensões de dados e diferentes tipos de operação, e até mesmo dentro do mesmo sistema, diferentes tabelas/diferentes funções adotam diferentes estratégias de tolerância a falhas e consistência. AP não é absolutamente 100% disponível Por exemplo, Cassandra, DynamoDB, etc. também terão situações em que as solicitações não podem ser atendidas em casos extremos de partição de rede ou falha de grande área de nós. Os sistemas AP são projetados para preferir \u0026ldquo;escrever primeiro, desde que a réplica possa ser escrita\u0026rdquo;, sacrificando parte da garantia de consistência em troca de disponibilidade e taxa de transferência relativamente mais altas. CP também pode tentar alcançar alta disponibilidade Paxos/Raft também podem fornecer 99,99% ou até mais alta disponibilidade em circunstâncias normais, mas exigem mais investimento em rede, hardware e custos de engenharia, e ainda haverá bloqueio de escrita e sacrifício de disponibilidade para manter a consistência em partições de rede extremas. Arquitetura híbrida é a corrente principal Os cenários de transação principais insistem em consistência forte (CP), e os cenários auxiliares periféricos ou canais de cache adotam consistência fraca (AP), e os dois cooperam entre si. É necessário combinar a tolerância de negócios, o ambiente de rede, o investimento de custo e as reservas técnicas da equipe para fazer uma escolha abrangente. O Teorema CAP fornece uma estrutura de pensamento de alto nível para o design de sistemas distribuídos, ajudando-nos a tomar decisões racionais diante da realidade inevitável das partições de rede. Em sistemas reais, é necessário usar modelos de consistência mais ricos, protocolos de consenso, mecanismos de replicação de várias réplicas e práticas de engenharia (recuperação de desastres, degradação, idempotência, fusão de conflitos, etc.) para equilibrar consistência e disponibilidade.\n","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735350760948-cap/","section":"Posts","summary":"Discussão da teoria à prática sobre a aplicação do teorema CAP em sistemas distribuídos.","title":"Análise Profunda do Teorema CAP: Construindo Sistemas Distribuídos de Alta Concorrência e Alta Disponibilidade","type":"posts"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 dezembro 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 dezembro 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 dezembro 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"A ordenação rápida é um algoritmo de ordenação não estável baseado em comparação, que emprega a ideia de dividir e conquistar. Sua complexidade de tempo média é $O(n\\log n)$, no pior caso é $O(n^2)$, e a complexidade de espaço é $O(1)$. Abaixo, usando como exemplo a ordenação de uma sequência de números inteiros em ordem crescente, apresentamos os detalhes de implementação e erros comuns.\nDescrição do Problema # Dado uma sequência de $n$ números inteiros, ordene-a em ordem crescente usando a ordenação rápida e imprima o resultado.\nFormato de Entrada # A primeira linha contém o inteiro $n$. A segunda linha contém $n$ inteiros, todos no intervalo $[1,10^9]$. Formato de Saída # Uma linha contendo a sequência ordenada. Intervalo de Dados # $1 \\leq n \\leq 100000$\nExemplo de Entrada # 5 3 1 2 4 5 Exemplo de Saída # 1 2 3 4 5 Ideia da Ordenação Rápida # A ordenação rápida, a cada divisão, escolhe um número como pivô (pivot) (abaixo, escolhemos o número na posição central).\nUsamos ponteiros esquerdo (L) e direito (R) que se movem em direções opostas. O ponteiro esquerdo L procura da esquerda para a direita o primeiro número maior ou igual a pivot, e o ponteiro direito R procura da direita para a esquerda o primeiro número menor ou igual a pivot. Em seguida, trocamos esses dois números.\nRepetimos esse processo continuamente até que os ponteiros esquerdo e direito se sobreponham ou o ponteiro esquerdo esteja uma posição à frente do ponteiro direito. Isso é chamado de uma iteração.\nApós cada movimento e troca de ponteiros, garantimos que a estrutura \u0026ldquo;parte esquerda ≤ pivot, parte direita ≥ pivot\u0026rdquo; não seja quebrada, ou seja, temos o invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nNo código de exemplo abaixo, left e right são os limites do intervalo fechado que está sendo processado, e pivot é o elemento no ponto médio do intervalo.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexidade e Escolha do pivot # Como a ordenação rápida tem uma complexidade de $O(n^2)$ no pior caso, a escolha do pivot é crucial. Se sempre escolhermos o primeiro ou o último elemento, é muito provável que o pior caso ocorra em arrays quase ordenados.\nAlém de escolher o elemento na posição central, podemos escolher aleatoriamente um elemento como pivot, ou escolher a mediana dos três elementos: esquerdo, central e direito.\nExemplos de Erros Comuns # O código abaixo contém vários erros comuns.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Análise dos Erros:\npivot deve ser um número no array, não um índice. Use \u0026lt; e \u0026gt; em vez de \u0026lt;= e \u0026gt;=, caso contrário, o ponteiro esquerdo pode ultrapassar o ponteiro direito por mais de uma posição, o que impede a divisão do array em duas partes. Depois de encontrar l \u0026gt;= r, o loop deve ser interrompido imediatamente, sem realizar a troca. Caso contrário, não podemos garantir que os elementos à esquerda não sejam maiores que pivot e que os elementos à direita não sejam menores que pivot. Após cada troca, l++ e r-- devem ser executados. pivot na verdade pega o número do meio à esquerda. Portanto, se usarmos $l - 1$ e $l$ para dividir o array, considerando o array [1, 2], não é difícil perceber que isso levará a um loop infinito, dividindo continuamente o array em duas partes de tamanho 0 e 2. Da mesma forma, usar $r$ e $l$ para dividir o array também não funciona. Em vez disso, quando um loop termina, $r$ é necessariamente menor que $right$, então podemos usar $r$ e $r+1$ para dividir o array. O leitor pode simular o processo do algoritmo para ver o porquê. Outra maneira simples de evitar loops infinitos é escolher um pivot aleatoriamente ou tratar especialmente o caso em que há apenas dois elementos. Além disso, usar $l$, $l+1$ também não funciona, porque essa divisão não está de acordo com a definição. Quando $r$ está à esquerda de $l$, usar $l$, $l+1$ não divide corretamente o array em duas partes: uma à esquerda menor ou igual a pivot e outra à direita maior ou igual a pivot. Este problema assume que o array não está vazio, então não há caso de \u0026gt;. No entanto, é recomendável usar \u0026gt;=, o que é mais seguro. Adicional # A ordenação rápida também pode ser transformada em \u0026ldquo;seleção rápida\u0026rdquo;, que encontra o $k$-ésimo menor número em um array não ordenado em tempo esperado $O(n)$. A ideia específica é semelhante à ordenação rápida, exceto que a recursão continua apenas em um subintervalo a cada vez, reduzindo assim a complexidade de tempo.\n","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735252761946-quick-sort/","section":"Posts","summary":"Análise dos pontos-chave para implementar corretamente o algoritmo de ordenação rápida.","title":"Ordenação Rápida","type":"posts"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 dezembro 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 dezembro 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"Se um espaço de solução ordenado for dividido em duas partes, onde uma parte satisfaz a condição e a outra não, então a pesquisa binária pode ser usada para encontrar o ponto crítico no espaço de solução ordenado.\nA ideia básica da pesquisa binária é dividir continuamente o intervalo de pesquisa ao meio. A cada verificação, o elemento do meio é examinado. Se o elemento do meio não satisfaz a condição, metade do intervalo pode ser descartada; caso contrário, a pesquisa continua na outra metade do intervalo. Como metade do intervalo de pesquisa é descartada a cada vez, a complexidade de tempo da pesquisa pode atingir $O(\\log n)$.\nExemplo # Descrição do Problema:\nDado um array de inteiros de comprimento $n$ em ordem crescente, e $q$ consultas. Cada consulta fornece um inteiro $k$, e precisamos encontrar a \u0026ldquo;posição inicial\u0026rdquo; e a \u0026ldquo;posição final\u0026rdquo; de $k$ no array (índices começando em 0). Se o número não existir no array, retorne -1 -1.\nFormato de Entrada # Primeira linha: dois inteiros $n$ e $q$, representando o comprimento do array e o número de consultas, respectivamente. Segunda linha: $n$ inteiros, representando o array completo, já ordenado em ordem crescente. Próximas $q$ linhas: cada linha contém um inteiro $k$, representando um elemento de consulta. Intervalo de Dados # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormato de Saída # Para cada consulta, imprima a posição inicial e final do elemento no array em uma linha. Se o elemento não existir no array, imprima -1 -1.\nExemplo:\nEntrada: 6 3 1 2 2 3 3 4 3 4 5 Saída: 3 4 5 5 -1 -1 Explicação:\nO intervalo em que o elemento $3$ aparece é $[3, 4]$; O elemento $4$ aparece apenas uma vez, na posição $5$; O elemento $5$ não existe no array, então retorna $-1$ $-1$. Resposta # Encontrar a \u0026ldquo;posição inicial\u0026rdquo;: Ou seja, encontrar a primeira posição maior ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores\u0026rdquo; que $k$ Todos os números à direita são \u0026ldquo;maiores ou iguais\u0026rdquo; a $k$ A resposta é a primeira posição à direita Encontrar a \u0026ldquo;posição final\u0026rdquo;: Ou seja, encontrar a última posição menor ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores ou iguais\u0026rdquo; a $k$ Todos os números à direita são \u0026ldquo;maiores\u0026rdquo; que $k$ A resposta é a última posição à esquerda Modelo Recomendado # A seguir está um modelo de pesquisa binária elegante e menos propenso a erros.\nDefina dois ponteiros $l, r$, com o invariante: o intervalo fechado $[0, l]$ pertence à parte esquerda, e o intervalo fechado $[r, n - 1]$ pertence à parte direita. $l$ e $r$ são inicializados como $-1$ e $n$.\nQuando o algoritmo termina, $l$ e $r$ são adjacentes, apontando para o último elemento da parte esquerda e o primeiro elemento da parte direita, respectivamente.\nComo a solução que queremos pode não existir, se o problema não indicar que uma solução existe, precisamos verificar se l ou r estão fora dos limites e se apontam para o valor correto.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Encontrar a posição inicial de k 15 // Dividir o array em duas partes, à esquerda todos \u0026lt; k, à direita todos \u0026gt;= k. 16 // A resposta é o menor índice da parte direita. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Se r estiver fora dos limites ou nums[r] != k, significa que k não existe 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Encontrar a posição final de k 33 // Dividir o array em duas partes, à esquerda todos \u0026lt;= k, à direita todos \u0026gt; k. 34 // A resposta é o maior índice da parte esquerda. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Vantagens # Esta abordagem tem invariantes estritamente definidos. Ela se aplica tanto para encontrar a \u0026ldquo;posição inicial\u0026rdquo; quanto a \u0026ldquo;posição final\u0026rdquo;, sem a necessidade de tratamento e mudanças adicionais. Algumas abordagens usam l == r como condição de término. Quando $l$ e $r$ diferem em $1$, $mid$ será calculado como igual a $l$ ou $r$. Se não for tratado corretamente, atualizar $l$ ou $r$ para $mid$ fará com que o intervalo de pesquisa não diminua, levando a um loop infinito. Em vez disso, esta abordagem termina quando $l$ e $r$ são adjacentes, garantindo que $mid$ seja menor que $l$ e maior que $r$, e que o intervalo de pesquisa diminua ao atualizar $l$ ou $r$. STL # Se você usar as funções lower_bound e upper_bound fornecidas pela STL do C++, você também pode realizar a mesma tarefa:\nlower_bound(first, last, val) retornará a \u0026ldquo;primeira posição maior ou igual a val\u0026rdquo; upper_bound(first, last, val) retornará a \u0026ldquo;primeira posição maior que val\u0026rdquo; Por exemplo, suponha que nums = {1,2,3,4,4,4,4,4,5,5,6}, e queremos saber o intervalo em que 4 aparece:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 aparece 0 vezes\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;o primeiro 4 está em \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;o último 4 está em \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 aparece \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; vezes\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 aponta para a primeira posição com um valor maior ou igual a $4$. it2 aponta para a primeira posição com um valor maior que $4$.\nPortanto, it2 - it1 é o número de vezes que $4$ aparece no array; it2 - nums.begin() - 1 é a posição do limite direito de $4$. Adicional # A pesquisa binária também pode ser estendida para a pesquisa em intervalos de números de ponto flutuante (como encontrar raízes de equações) e para a pesquisa ternária para encontrar os valores máximos de funções unimodais.\nPrática # LeetCode 33. Search in Rotated Sorted Array\nDica: Primeiro, use a pesquisa binária para encontrar o ponto de rotação e, em seguida, use a pesquisa binária novamente para encontrar o valor alvo.\n","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Como implementar o algoritmo de pesquisa binária de forma elegante.","title":"Pesquisa Binária","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":" Problema # Existem $N$ itens. O volume do $i$-ésimo item é $s_i$ e seu valor é $v_i$. Cada item só pode ser levado uma vez. Sob a premissa de não exceder o limite máximo de volume total $S$, encontre o valor total máximo $V$ que pode ser obtido.\nFormato de Entrada # A primeira linha contém dois inteiros, $N$ e $S$, separados por um espaço, representando o número de itens e o limite máximo de volume total, respectivamente. As $N$ linhas seguintes contêm cada uma dois inteiros, $s_i$ e $v_i$, separados por um espaço, representando o volume e o valor do $i$-ésimo item, respectivamente.\nFormato de Saída # Imprima um inteiro representando o valor máximo.\nIntervalo de Dados # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Exemplo de Entrada # 4 5 1 2 2 4 3 4 4 5 Exemplo de Saída # 8 Solução # Defina o estado: f[i][j] representa o valor máximo que pode ser obtido com os primeiros $i$ itens com um limite de volume de $j$. Se o $i$-ésimo item não for levado, então f[i][j] = f[i - 1][j] Se o $i$-ésimo item for levado, então f[i][j] = f[i - 1][j - s[i]] + v[i] Ao implementar a transição de estado, preste atenção ao intervalo do domínio. Se $j \u003c s_i$, então não considere o caso de levar o $i$-ésimo item. Porque se $j - s_i$ for negativo, o índice do array é inválido. Também pode ser explicado desta forma: o volume do $i$-ésimo item é maior que o limite de volume, então é impossível. Defina a condição inicial: Para os primeiros $0$ itens, qualquer limite de volume resulta em um valor de $0$, ou seja, f[0][j] = 0, j $\\in [0, S]$. Complexidade de tempo: $O(NS)$. Código # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Otimização DP 1D # Comprimir o array bidimensional em um array unidimensional pode economizar significativamente espaço e melhorar a velocidade de execução até certo ponto (a desvantagem é que ele não pode atender aos requisitos especiais de alguns tipos de problemas). Observe que na transição de estado, f[i][j] está relacionado apenas a f[i - 1][j] e f[i - 1][j - s[i]]. Em outras palavras, no array bidimensional f no código, f[i][j] está relacionado apenas aos elementos na linha anterior que estão à sua esquerda ou na mesma coluna. Portanto, o array bidimensional pode ser comprimido em um array unidimensional ou um array rolante. Observe que no código abaixo, o segundo loop itera em ordem inversa. Isso ocorre porque queremos garantir que ao calcular f[i][j], f[i - 1][j - s[i]] ainda não tenha sido atualizado. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Se o Número de Esquemas for Necessário # Não apenas o valor total máximo que pode ser obtido deve ser impresso, mas também \u0026ldquo;quantos métodos de seleção diferentes podem atingir esse valor total máximo\u0026rdquo;. O seguinte descreve como contar o número de esquemas no problema da mochila 01.\nDP 2D para Contar Esquemas # O seguinte usa DP 2D como um exemplo para explicar.\nDefina o estado:\ndp[i][j] representa \u0026ldquo;o valor máximo que pode ser obtido ao considerar os primeiros i itens com uma capacidade (limite de volume) de j\u0026rdquo;. ways[i][j] representa \u0026ldquo;o número de esquemas correspondentes ao valor máximo obtido ao considerar os primeiros i itens com uma capacidade de j\u0026rdquo;. Transição de estado:\nSe o i-ésimo item não for selecionado: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Se o i-ésimo item for selecionado (desde que $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Se deve selecionar ou não, o dp[i][j] final deve pegar o maior dos dois: Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ então significa que \u0026ldquo;selecionar o i-ésimo item\u0026rdquo; tem um valor maior: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ significa que o valor máximo obtido pelos dois métodos é o mesmo, então o número de esquemas deve ser adicionado: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ então significa que \u0026ldquo;não selecionar o i-ésimo item\u0026rdquo; tem um valor maior, e o número de esquemas herda o número de esquemas ao não selecionar: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Condições iniciais:\ndp[0][j] = 0 significa que quando há 0 itens, o valor máximo obtido para qualquer capacidade é 0. ways[0][0] = 1 significa que o caso de \u0026ldquo;0 itens, capacidade 0\u0026rdquo; é um esquema viável (ou seja, não selecionar nada), e o número de esquemas é definido como 1. Para j \u0026gt; 0, quando não há itens para escolher e a capacidade é maior que 0, é impossível obter qualquer valor positivo, e o número correspondente de esquemas é 0, ou seja, ways[0][j] = 0. Resposta final:\ndp[N][S] é o valor máximo. ways[N][S] é o número de esquemas para atingir esse valor máximo. Complexidade de tempo: $O(NS)$. Este problema também pode ser otimizado usando DP 1D. Se o Requisito for Atingir Exatamente o Limite de Volume # Defina o estado: f[i][j] representa o valor máximo quando os primeiros i itens têm exatamente um volume de $j$. Se o i-ésimo item não for levado, então f[i][j] = f[i - 1][j] Se o i-ésimo item for levado, então f[i][j] = f[i - 1][j - s[i]] + v[i] Pode-se notar que não há diferença na transição de estado do problema original. No entanto, as condições iniciais são diferentes. Exceto por f[0][0] = 0, o resto f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ representa um estado impossível. Se o Limite de Volume $S$ for Muito Grande (1e9), Enquanto o Número de Itens $N$ e o Valor Total Máximo $V$ forem Relativamente Pequenos # Para tais problemas, existe uma solução com uma complexidade de $O(NV)$. Defina o estado: f[i][j] representa o volume mínimo ao selecionar vários itens dos primeiros i itens, e o valor total é exatamente j. Se o i-ésimo item não for levado, então f[i][j] = f[i - 1][j] Se o i-ésimo item for levado, então f[i][j] = f[i - 1][j - v[i]] + s[i] Pegue o menor dos dois. Condições iniciais: f[0][0] = 0, o resto f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ representa um estado impossível. Observe que não é $-\\infty$. A resposta final é o maior j em f[N][j] tal que f[N][j] \u0026lt;= S. Se o Limite de Volume $S$ e o Valor de um Único Item $v_i$ forem Ambos Muito Grandes (na ordem de 1e9), Enquanto o Número de Itens $N$ for Muito Pequeno (não mais que 40) # Quando $N \\leq 20$, todos os subconjuntos podem ser diretamente enumerados por força bruta (complexidade de tempo $O(2^N)$). Quando $N \\leq 40$, como $2^{40}$ está na ordem de $10^{12}$, a força bruta direta também será relativamente grande, então a busca meet-in-the-middle pode ser usada para reduzir a complexidade para aproximadamente $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, que pode ser concluída em um tempo aceitável. ","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"O problema da mochila clássico mais básico.","title":"Problema da Mochila 01","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/pt/series/","section":"Series","summary":"","title":"Series","type":"series"}]