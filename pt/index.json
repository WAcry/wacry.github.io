[{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":" Ordenação Rápida # A ordenação rápida é um algoritmo de ordenação não estável baseado em comparação, que utiliza a abordagem de divisão e conquista. Sua complexidade de tempo média é $O(n\\log n)$, no pior caso é $O(n^2)$, e a complexidade de espaço é $O(1)$. Abaixo, usando a ordenação de uma sequência de números inteiros em ordem crescente como exemplo, apresentamos os detalhes de implementação e erros comuns.\nDescrição do Problema # Dado um sequência de $n$ números inteiros, use a ordenação rápida para ordená-los em ordem crescente e imprima o resultado.\nFormato de Entrada # A primeira linha contém o inteiro $n$ A segunda linha contém $n$ inteiros, todos no intervalo $[1,10^9]$ Formato de Saída # Uma linha contendo a sequência ordenada Intervalo de Dados # $1 \\leq n \\leq 100000$\nExemplo de Entrada # 5 3 1 2 4 5 Exemplo de Saída # 1 2 3 4 5 Ideia da Ordenação Rápida # Na ordenação rápida, a cada divisão, um número é escolhido como o número de referência pivot (abaixo, o número na posição do meio é escolhido).\nUsando ponteiros esquerdo e direito que se movem em direções opostas, o ponteiro esquerdo L procura da esquerda para a direita o primeiro número maior ou igual a pivot, e o ponteiro direito R procura da direita para a esquerda o primeiro número menor ou igual a pivot, e então esses dois números são trocados.\nEste processo é repetido continuamente até que os ponteiros esquerdo e direito se sobreponham ou o ponteiro esquerdo seja uma posição maior que o ponteiro direito. Isso é chamado de uma iteração.\nApós cada movimento e troca de ponteiro, a estrutura \u0026ldquo;parte esquerda ≤ pivot, parte direita ≥ pivot\u0026rdquo; é garantida, ou seja, há um invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nNo exemplo de código abaixo, left e right são os limites do intervalo fechado atual que está sendo processado, e pivot é o elemento no ponto médio do intervalo.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complexidade e Escolha do pivot # Como a ordenação rápida tem uma complexidade de $O(n^2)$ no pior caso, a escolha do pivot é crucial. Se o primeiro ou o último elemento for sempre escolhido, o pior caso provavelmente ocorrerá em um array quase ordenado.\nAlém de escolher o elemento na posição do meio, um elemento pode ser escolhido aleatoriamente como pivot, ou a mediana dos três elementos à esquerda, no meio e à direita pode ser escolhida como pivot.\nExemplos de Erros Comuns # O código abaixo contém vários erros comuns.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Análise de Erros:\npivot deve ser um número no array, não um índice. Use \u0026lt; e \u0026gt; em vez de \u0026lt;= e \u0026gt;=, caso contrário, o ponteiro esquerdo pode ultrapassar o ponteiro direito em mais de uma posição, o que impede que o array seja dividido em duas partes. Depois de encontrar l \u0026gt;= r, o loop deve ser encerrado imediatamente e nenhuma troca deve ser executada. Caso contrário, não é garantido que os elementos à esquerda não sejam maiores que pivot e que os elementos à direita não sejam menores que pivot. Após cada troca, l++ e r-- devem ser executados. pivot na verdade pega o número do meio à esquerda. Portanto, se você usar $l - 1$ e $l$ para dividir o array, considere o array [1, 2], não é difícil descobrir que isso levará a um loop infinito, dividindo continuamente o array em duas partes de tamanho 0 e 2. Da mesma forma, usar $r$ e $l$ para distinguir o array também não funciona. Em vez disso, quando um loop termina, $r$ deve ser menor que $right$, então $r$ e $r+1$ podem ser usados para dividir o array. O leitor pode simular o processo do algoritmo para ver por quê. Outra maneira simples de evitar loops infinitos é escolher um pivot aleatoriamente ou lidar com o caso especial de apenas dois elementos. Além disso, usar $l$, $l+1$ também não funciona, porque essa divisão não está de acordo com a definição. Quando $r$ está à esquerda de $l$, usar $l$, $l+1$ não pode dividir corretamente o array em duas partes onde a esquerda é menor ou igual a pivot e a direita é maior ou igual a pivot. Este problema assume que o array não está vazio, então não há caso de \u0026gt;. Mas é recomendável usar \u0026gt;=, o que é mais seguro. Adicional # A ordenação rápida também pode evoluir para \u0026ldquo;seleção rápida\u0026rdquo;, que pode encontrar o $k$-ésimo menor número em um array não ordenado em um tempo esperado de $O(n)$. A ideia específica é semelhante à ordenação rápida, exceto que a recursão continua apenas em um subintervalo de cada vez, reduzindo assim a complexidade de tempo.\n","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735252761946-quick-sort/","section":"Posts","summary":"Análise dos pontos-chave para implementar corretamente o algoritmo de ordenação rápida.","title":"Ordenação Rápida","type":"posts"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24 dezembro 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":" Problema # Há $N$ itens. O volume do $i$-ésimo item é $s_i$, e seu valor é $v_i$. Cada item só pode ser pego uma vez. Sob a premissa de não exceder a restrição de volume total máximo $S$, encontre o valor total máximo $V$ que pode ser obtido.\nFormato de Entrada # A primeira linha contém dois inteiros, $N$ e $S$, separados por um espaço, representando o número de itens e a restrição de volume total máximo, respectivamente. As próximas $N$ linhas contêm dois inteiros, $s_i$ e $v_i$, separados por um espaço, representando o volume e o valor do $i$-ésimo item, respectivamente.\nFormato de Saída # Imprima um inteiro, representando o valor máximo.\nIntervalo de Dados # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Exemplo de Entrada # 4 5 1 2 2 4 3 4 4 5 Exemplo de Saída # 8 Solução # Definição do estado: f[i][j] representa o valor máximo que pode ser obtido com os primeiros $i$ itens, com uma restrição de volume de $j$. Se o $i$-ésimo item não for pego, então f[i][j] = f[i - 1][j] Se o $i$-ésimo item for pego, então f[i][j] = f[i - 1][j - s[i]] + v[i] Ao implementar a transição de estado, preste atenção ao intervalo do domínio. Se $j \u003c s_i$, então não considere o caso de pegar o $i$-ésimo item. Porque se $j-s_i$ for um número negativo, o índice do array não é válido. Também pode ser explicado assim: o volume do $i$-ésimo item é maior que a restrição de volume, então é impossível. Definição da condição inicial: Para os primeiros $0$ itens, qualquer restrição de volume obtém um valor de $0$, ou seja, f[0][j] = 0, j $\\in [0, S]$. Complexidade de tempo: $O(NS)$. Código # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Otimização DP Unidimensional # Comprimir o array bidimensional em um array unidimensional pode economizar significativamente espaço e aumentar a velocidade de execução até certo ponto (a desvantagem é que não pode atender aos requisitos especiais de certos tipos de problemas) Observe que na transição de estado, f[i][j] está relacionado apenas a f[i - 1][j] e f[i - 1][j - s[i]]. Em outras palavras, no array bidimensional f no código, f[i][j] está relacionado apenas aos elementos de sua linha anterior que estão mais à esquerda ou na mesma coluna, portanto, o array bidimensional pode ser comprimido em um array unidimensional ou um array de rolagem. Observe que no código abaixo, o segundo loop itera na ordem inversa, isso ocorre porque queremos garantir que ao calcular f[i][j], f[i - 1][j - s[i]] ainda não tenha sido atualizado. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Se o número de soluções for necessário # Não apenas o valor total máximo que pode ser obtido precisa ser impresso, mas também \u0026ldquo;quantas maneiras diferentes de seleção podem atingir esse valor total máximo\u0026rdquo;. A seguir, apresentamos como contar o número de soluções no problema da mochila 0/1.\nContagem de Soluções com DP Bidimensional # A seguir, usaremos DP bidimensional como exemplo para explicar.\nDefinição do estado:\ndp[i][j] representa \u0026ldquo;o valor máximo que pode ser obtido quando os primeiros i itens são considerados, com uma capacidade (restrição de volume) de j\u0026rdquo;. ways[i][j] representa \u0026ldquo;o número de soluções correspondente quando os primeiros i itens são considerados, com uma capacidade de j, e o valor máximo é obtido\u0026rdquo;. Transição de estado:\nSe o $i$-ésimo item não for selecionado: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Se o $i$-ésimo item for selecionado (a premissa é $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Selecionar ou não, o dp[i][j] final deve pegar o maior dos dois: Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ então isso indica que o valor de \u0026ldquo;selecionar o i-ésimo item\u0026rdquo; é maior: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ isso indica que o valor máximo obtido pelas duas maneiras é o mesmo, então o número de soluções deve ser sobreposto: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ então isso indica que o valor de \u0026ldquo;não selecionar o i-ésimo item\u0026rdquo; é maior, e o número de soluções herda o número de soluções quando não selecionado: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Condição inicial:\ndp[0][j] = 0 indica que quando os primeiros 0 itens são considerados, o valor máximo obtido para qualquer capacidade é 0. ways[0][0] = 1 indica que \u0026ldquo;os primeiros 0 itens, capacidade 0\u0026rdquo; é uma solução viável (ou seja, nada é selecionado), e o número de soluções é definido como 1. Para j \u0026gt; 0, quando não há itens para selecionar e a capacidade é maior que 0, é impossível obter qualquer valor positivo, e o número de soluções correspondente é 0, ou seja, ways[0][j] = 0. Resposta final:\ndp[N][S] é o valor máximo. ways[N][S] é o número de soluções para atingir esse valor máximo. Complexidade de tempo: $O(NS)$. Este problema também pode ser otimizado usando DP unidimensional. Se for necessário atingir exatamente a restrição de volume # Definição do estado: f[i][j] representa o valor máximo dos primeiros i itens com exatamente o volume $j$. Se o i-ésimo item não for pego, então f[i][j] = f[i - 1][j] Se o i-ésimo item for pego, então f[i][j] = f[i - 1][j - s[i]] + v[i] Pode-se notar que não há diferença na transição de estado em relação ao problema original. Mas as condições iniciais são diferentes. Além de f[0][0] = 0, o restante f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ representa um estado impossível. Se a restrição de volume $S$ for muito grande (1e9), enquanto o número de itens $N$ e o valor total máximo $V$ forem relativamente pequenos # Para esse tipo de problema, existe uma solução com complexidade de $O(NV)$. Definição do estado: f[i][j] representa o volume mínimo dos primeiros i itens selecionando alguns itens, onde a soma dos valores é exatamente j. Se o i-ésimo item não for pego, então f[i][j] = f[i - 1][j] Se o i-ésimo item for pego, então f[i][j] = f[i - 1][j - v[i]] + s[i] Pegue o menor dos dois. Condição inicial: f[0][0] = 0, o restante f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ representa um estado impossível. Observe que não é $-\\infty$. A resposta final é o maior j em f[N][j] tal que f[N][j] \u0026lt;= S. Se a restrição de volume $S$ e o valor de um único item $v_i$ forem muito grandes (na ordem de $1e9$), enquanto o número de itens $N$ for muito pequeno (no máximo 40) # Quando $N \\leq 20$, todos os subconjuntos podem ser enumerados diretamente (complexidade de tempo $O(2^N)$). Quando $N \\leq 40$, como $2^{40}$ está na ordem de $10^{12}$, a enumeração direta também será relativamente grande, então a busca por divisão ao meio pode ser usada para reduzir a complexidade para aproximadamente $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ , que pode ser concluída em um tempo aceitável. ","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"O problema da mochila clássico mais básico.","title":"Problema da Mochila 0/1","type":"posts"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":" markdown # title: \u0026ldquo;Busca Binária\u0026rdquo; date: 2024-12-24 draft: false description: \u0026ldquo;Como implementar elegantemente o algoritmo de busca binária.\u0026rdquo; summary: \u0026ldquo;Como implementar elegantemente o algoritmo de busca binária.\u0026rdquo; tags: [ \u0026ldquo;Algoritmo\u0026rdquo;, \u0026ldquo;Busca Binária\u0026rdquo;, \u0026ldquo;Template de Algoritmo\u0026rdquo; ] categories: [ \u0026ldquo;Algoritmos e Estruturas de Dados\u0026rdquo; ] # Se um espaço de solução ordenado é dividido em duas partes, onde uma parte satisfaz uma condição e a outra não, então a busca binária pode ser usada para encontrar o ponto crítico no espaço de solução ordenado.\nA ideia básica da busca binária é reduzir repetidamente pela metade o intervalo de busca. A cada vez, o elemento do meio é verificado. Se o elemento do meio não satisfaz a condição, metade do intervalo pode ser eliminada; caso contrário, a busca continua na outra metade. Como metade do intervalo de busca é descartada a cada vez, a complexidade de tempo da busca pode atingir $O(\\log n)$.\nProblema de Exemplo # Descrição do Problema: Dado um array de inteiros ordenado de forma crescente de tamanho $n$, e $q$ consultas. Cada consulta fornece um inteiro $k$, e precisamos encontrar a \u0026ldquo;posição inicial\u0026rdquo; e a \u0026ldquo;posição final\u0026rdquo; de $k$ no array (os índices começam em 0). Se o número não existir no array, retorne -1 -1.\nFormato de Entrada # Primeira linha: dois inteiros $n$ e $q$, representando o tamanho do array e o número de consultas, respectivamente. Segunda linha: $n$ inteiros, representando o array completo, já ordenado em ordem crescente. Próximas $q$ linhas: cada linha contém um inteiro $k$, representando um elemento de consulta. Intervalo de Dados # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormato de Saída # Para cada consulta, imprima as posições inicial e final do elemento no array em uma única linha. Se o elemento não existir no array, imprima -1 -1.\nExemplo:\nEntrada: 6 3 1 2 2 3 3 4 3 4 5 Saída: 3 4 5 5 -1 -1 Explicação:\nO intervalo onde o elemento $3$ aparece é $[3, 4]$; O elemento $4$ aparece apenas uma vez, na posição $5$; O elemento $5$ não existe no array, então retorne $-1$ $-1$. Solução # Encontrando a \u0026ldquo;Posição Inicial\u0026rdquo;: Ou seja, encontrar a primeira posição que é maior ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores que\u0026rdquo; $k$ Todos os números à direita são \u0026ldquo;maiores ou iguais a\u0026rdquo; $k$ A resposta é a primeira posição à direita Encontrando a \u0026ldquo;Posição Final\u0026rdquo;: Ou seja, encontrar a última posição que é menor ou igual a $k$. O array pode ser dividido em duas partes:\nTodos os números à esquerda são \u0026ldquo;menores ou iguais a\u0026rdquo; $k$ Todos os números à direita são \u0026ldquo;maiores que\u0026rdquo; $k$ A resposta é a última posição à esquerda Template Recomendado # Abaixo está um template de busca binária elegante e menos propenso a erros.\nDefina dois ponteiros $l, r$, com o invariante: o intervalo fechado $[0, l]$ pertence à parte esquerda, e o intervalo fechado $[r, n - 1]$ pertence à parte direita. $l$ e $r$ são inicializados com $-1$ e $n$, respectivamente.\nQuando o algoritmo termina, $l$ e $r$ são adjacentes, apontando para o último elemento da parte esquerda e o primeiro elemento da parte direita, respectivamente.\nComo a solução que queremos pode não existir, se o problema não afirmar que uma solução definitivamente existe, precisamos verificar se l ou r está fora dos limites e se aponta para o valor correto.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Encontrar a posição inicial de k 15 // Dividir o array em duas partes, a parte esquerda é toda \u0026lt; k, e a parte direita é toda \u0026gt;= k. 16 // A resposta é o menor índice da parte direita. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Se r estiver fora dos limites ou nums[r] != k, significa que k não existe 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Encontrar a posição final de k 33 // Dividir o array em duas partes, a parte esquerda é toda \u0026lt;= k, e a parte direita é toda \u0026gt; k. 34 // A resposta é o maior índice da parte esquerda. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Vantagens # Esta abordagem tem invariantes estritamente definidos. Aplica-se tanto para encontrar a \u0026ldquo;posição inicial\u0026rdquo; quanto a \u0026ldquo;posição final\u0026rdquo; sem tratamento ou alterações extras. Algumas abordagens usam l == r como condição de término. Quando $l$ e $r$ diferem em $1$, $mid$ será calculado para ser igual a $l$ ou $r$. Se não for tratado corretamente, atualizar $l$ ou $r$ para $mid$ não reduzirá o intervalo de busca, levando a um loop infinito. Em contraste, esta abordagem termina quando $l$ e $r$ são adjacentes, garantindo que $mid$ seja menor que $l$ e maior que $r$, e atualizar $l$ ou $r$ sempre reduzirá o intervalo de busca. STL # Se você usar as funções lower_bound e upper_bound fornecidas pela STL do C++, você pode obter o mesmo resultado:\nlower_bound(first, last, val) retornará \u0026ldquo;a primeira posição que é maior ou igual a val\u0026rdquo; upper_bound(first, last, val) retornará \u0026ldquo;a primeira posição que é maior que val\u0026rdquo; Por exemplo, suponha que nums = {1,2,3,4,4,4,4,4,5,5,6}, e queremos saber o intervalo onde 4 aparece:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 aparece 0 vezes\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;o primeiro 4 está em \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;o último 4 está em \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 aparece \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; vezes\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 aponta para a primeira posição onde o valor é maior ou igual a $4$. it2 aponta para a primeira posição onde o valor é maior que $4$. Portanto, it2 - it1 é o número de vezes que $4$ aparece no array; it2 - nums.begin() - 1 é a posição do limite direito de $4$. Notas Adicionais # A busca binária também pode ser estendida para pesquisar em intervalos de ponto flutuante (como encontrar as raízes de uma equação) e busca ternária para encontrar os extremos de funções unimodais.\nPrática # LeetCode 33. Search in Rotated Sorted Array\nDica: Primeiro, use a busca binária para encontrar o ponto de rotação e, em seguida, use a busca binária para encontrar o valor alvo.\n","externalUrl":null,"permalink":"/pt/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"","title":"","type":"posts"}]