[{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":" Ordinamento Rapido # L\u0026rsquo;ordinamento rapido (Quicksort) è un algoritmo di ordinamento non stabile basato sul confronto, che adotta la strategia divide et impera. La sua complessità temporale media è $O(n\\log n)$, nel caso peggiore è $O(n^2)$, mentre la complessità spaziale è $O(1)$. Di seguito, prendendo come esempio l\u0026rsquo;ordinamento crescente di una sequenza di numeri interi, vengono presentati i dettagli di implementazione e gli errori comuni.\nDescrizione del Problema # Data una sequenza di $n$ numeri interi, ordinarla in modo crescente utilizzando l\u0026rsquo;ordinamento rapido e stampare il risultato.\nFormato di Input # La prima riga contiene l\u0026rsquo;intero $n$ La seconda riga contiene $n$ numeri interi, tutti compresi nell\u0026rsquo;intervallo $[1,10^9]$ Formato di Output # Una riga contenente la sequenza ordinata Intervallo di Dati # $1 \\leq n \\leq 100000$\nEsempio di Input # 5 3 1 2 4 5 Esempio di Output # 1 2 3 4 5 Approccio all\u0026rsquo;Ordinamento Rapido # Ad ogni passo di divide et impera, l\u0026rsquo;ordinamento rapido seleziona un numero come pivot (di seguito, viene scelto il numero nella posizione centrale).\nSi utilizzano due puntatori, uno sinistro L e uno destro R, che si muovono in direzioni opposte. Il puntatore sinistro L si sposta da sinistra verso destra cercando il primo numero maggiore o uguale al pivot, mentre il puntatore destro R si sposta da destra verso sinistra cercando il primo numero minore o uguale al pivot. Quindi, questi due numeri vengono scambiati.\nQuesto processo viene ripetuto finché i puntatori sinistro e destro si sovrappongono o il puntatore sinistro supera di una posizione il puntatore destro. Questo è chiamato un ciclo.\nDopo ogni spostamento e scambio dei puntatori, si garantisce che la struttura \u0026ldquo;parte sinistra ≤ pivot, parte destra ≥ pivot\u0026rdquo; non venga violata, ovvero si mantiene l\u0026rsquo;invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nNel codice di esempio seguente, left e right sono i limiti dell\u0026rsquo;intervallo chiuso attualmente in elaborazione, mentre pivot è l\u0026rsquo;elemento nel punto medio dell\u0026rsquo;intervallo.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complessità e Scelta del pivot # Poiché nel caso peggiore l\u0026rsquo;ordinamento rapido ha una complessità di $O(n^2)$, la scelta del pivot è cruciale. Se si sceglie sempre il primo o l\u0026rsquo;ultimo elemento, è molto probabile che si verifichi il caso peggiore in array quasi ordinati.\nOltre a scegliere l\u0026rsquo;elemento nella posizione centrale, è possibile selezionare casualmente un elemento come pivot, oppure scegliere la mediana tra gli elementi di sinistra, centrale e destra.\nEsempio di Errori Comuni # Il seguente codice contiene diversi errori comuni.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Analisi degli Errori:\npivot dovrebbe essere un numero nell\u0026rsquo;array, non un indice. Si usano \u0026lt;= e \u0026gt;= invece di \u0026lt; e \u0026gt;, altrimenti il puntatore sinistro potrebbe superare il puntatore destro di più di una posizione, impedendo la divisione dell\u0026rsquo;array in due parti. Dopo aver trovato l \u0026gt;= r, il ciclo dovrebbe terminare immediatamente, senza eseguire lo scambio. Altrimenti, non si garantisce che gli elementi a sinistra non siano maggiori di pivot e che gli elementi a destra non siano minori di pivot. Dopo ogni scambio, è necessario eseguire l++ e r--. pivot in realtà prende il numero centrale sinistro. Pertanto, se si usa $l - 1$ e $l$ per dividere l\u0026rsquo;array, considerando l\u0026rsquo;array [1, 2], è facile vedere che si verificherà un ciclo infinito, dividendo continuamente l\u0026rsquo;array in due parti di dimensione 0 e 2. Analogamente, non è corretto usare $r$ e $l$ per dividere l\u0026rsquo;array. Al contrario, alla fine di un ciclo, $r$ è necessariamente minore di $right$, quindi è possibile usare $r$ e $r+1$ per dividere l\u0026rsquo;array. Il lettore può simulare il processo dell\u0026rsquo;algoritmo per capire il perché. Un altro modo semplice per evitare il ciclo infinito è scegliere casualmente il pivot o gestire in modo speciale il caso in cui ci sono solo due elementi. Inoltre, non è corretto usare $l$, $l+1$ perché questa divisione non è conforme alla definizione. Quando $r$ è a sinistra di $l$, usare $l$, $l+1$ non divide correttamente l\u0026rsquo;array in due parti, una a sinistra minore o uguale a pivot e una a destra maggiore o uguale a pivot. Questo problema presuppone che l\u0026rsquo;array non sia vuoto, quindi non esiste il caso \u0026gt;. Tuttavia, si consiglia di usare \u0026gt;=, per maggiore sicurezza. Aggiunte # L\u0026rsquo;ordinamento rapido può anche essere trasformato in \u0026ldquo;selezione rapida\u0026rdquo;, che consente di trovare l\u0026rsquo;elemento $k$-esimo più piccolo in un array non ordinato in un tempo atteso di $O(n)$. L\u0026rsquo;idea è simile all\u0026rsquo;ordinamento rapido, ma ad ogni passo si continua la ricorsione solo in un sottointervallo, riducendo così la complessità temporale.\n","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analisi dei punti chiave per implementare correttamente l\u0026rsquo;algoritmo di ordinamento rapido.","title":"Ordinamento Rapido","type":"posts"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/las-nueve-lecciones-de-la-mochila/","section":"Series","summary":"","title":"Las Nueve Lecciones De La Mochila","type":"series"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/series/nine-lectures-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Lectures on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":" Problema # C\u0026rsquo;è un numero $N$ di oggetti. L\u0026rsquo;oggetto $i$-esimo ha volume $s_i$ e valore $v_i$. Ogni oggetto può essere preso solo una volta. Trovare il valore totale massimo $V$ che si può ottenere senza superare il limite di volume totale massimo $S$.\nFormato di Input # La prima riga contiene due interi, $N$ e $S$, separati da uno spazio, che rappresentano rispettivamente il numero di oggetti e il limite di volume totale massimo. Le successive $N$ righe contengono due interi, $s_i$ e $v_i$, separati da uno spazio, che rappresentano rispettivamente il volume e il valore dell\u0026rsquo;oggetto $i$-esimo.\nFormato di Output # Restituisci un intero, che rappresenta il valore massimo.\nIntervallo di Dati # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Esempio di Input # 4 5 1 2 2 4 3 4 4 5 Esempio di Output # 8 Soluzione # Definizione dello stato: f[i][j] rappresenta il valore massimo che si può ottenere considerando i primi $i$ oggetti, con un limite di volume di $j$. Se non prendiamo l\u0026rsquo;oggetto $i$-esimo, allora f[i][j] = f[i - 1][j] Se prendiamo l\u0026rsquo;oggetto $i$-esimo, allora f[i][j] = f[i - 1][j - s[i]] + v[i] Quando si implementa la transizione di stato, bisogna prestare attenzione all\u0026rsquo;intervallo del dominio. Se $j \u003c s_i$, allora non si considera il caso in cui si prende l\u0026rsquo;oggetto $i$-esimo. Questo perché se $j-s_i$ fosse un numero negativo, l\u0026rsquo;indice dell\u0026rsquo;array non sarebbe valido. Si può anche spiegare così: il volume dell\u0026rsquo;oggetto $i$-esimo è maggiore del limite di volume, quindi è impossibile prenderlo. Definizione delle condizioni iniziali: considerando i primi $0$ oggetti, si ottiene un valore di $0$ per qualsiasi limite di volume, cioè f[0][j] = 0, j $\\in [0, S]$. Complessità temporale: $O(NS)$. Codice # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Ottimizzazione DP a una Dimensione # Comprimendo l\u0026rsquo;array bidimensionale in un array unidimensionale, si può risparmiare significativamente spazio e aumentare in una certa misura la velocità di esecuzione (lo svantaggio è che non si possono soddisfare i requisiti speciali di alcuni tipi di problemi) Si noti che nella transizione di stato, f[i][j] è correlato solo a f[i - 1][j] e f[i - 1][j - s[i]]. In altre parole, nell\u0026rsquo;array bidimensionale f nel codice, f[i][j] è correlato solo agli elementi della riga precedente che si trovano più a sinistra o nella stessa colonna, quindi l\u0026rsquo;array bidimensionale può essere compresso in un array unidimensionale o in un array scorrevole. Si noti che nel codice seguente, il secondo ciclo itera in ordine inverso, questo perché dobbiamo assicurarci che quando calcoliamo f[i][j], f[i - 1][j - s[i]] non sia ancora stato aggiornato. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Se si Richiede il Numero di Soluzioni # Non solo si deve restituire il valore totale massimo che si può ottenere, ma anche \u0026ldquo;quanti modi diversi ci sono per selezionare gli oggetti per raggiungere questo valore totale massimo\u0026rdquo;. Di seguito viene introdotto come contare il numero di soluzioni nel problema dello zaino 0/1.\nConteggio delle Soluzioni con DP Bidimensionale # Di seguito viene spiegato l\u0026rsquo;esempio con DP bidimensionale.\nDefinizione dello stato:\ndp[i][j] rappresenta \u0026ldquo;il valore massimo che si può ottenere considerando i primi i oggetti, con una capacità (limite di volume) di j\u0026rdquo;. ways[i][j] rappresenta \u0026ldquo;il numero di soluzioni corrispondenti al valore massimo ottenuto considerando i primi i oggetti, con una capacità di j\u0026rdquo;. Transizione di stato:\nSe non si seleziona l\u0026rsquo;oggetto i-esimo: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Se si seleziona l\u0026rsquo;oggetto i-esimo (a condizione che $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Selezionando o non selezionando, alla fine dp[i][j] dovrebbe prendere il valore maggiore tra i due: Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ allora significa che il valore di \u0026ldquo;selezionare l\u0026rsquo;oggetto i-esimo\u0026rdquo; è maggiore: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ significa che il valore massimo ottenuto in entrambi i modi è lo stesso, quindi il numero di soluzioni dovrebbe essere sommato: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ allora significa che il valore di \u0026ldquo;non selezionare l\u0026rsquo;oggetto i-esimo\u0026rdquo; è maggiore, e il numero di soluzioni eredita il numero di soluzioni quando non si seleziona: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Condizioni iniziali:\ndp[0][j] = 0 significa che quando ci sono 0 oggetti, il valore massimo ottenuto per qualsiasi capacità è 0. ways[0][0] = 1 significa che \u0026ldquo;0 oggetti, capacità 0\u0026rdquo; è una soluzione fattibile (cioè non selezionare nulla), e il numero di soluzioni è impostato a 1. Per j \u0026gt; 0, quando non ci sono oggetti tra cui scegliere e la capacità è maggiore di 0, è impossibile ottenere qualsiasi valore positivo, e il numero di soluzioni corrispondente è 0, cioè ways[0][j] = 0. Risposta finale:\ndp[N][S] è il valore massimo. ways[N][S] è il numero di soluzioni per raggiungere questo valore massimo. Complessità temporale: $O(NS)$. Questo problema può anche essere ottimizzato utilizzando DP unidimensionale. Se si Richiede di Raggiungere Esattamente il Limite di Volume # Definizione dello stato: f[i][j] rappresenta il valore massimo quando i primi i oggetti hanno esattamente un volume di $j$. Se non si prende l\u0026rsquo;oggetto i-esimo, allora f[i][j] = f[i - 1][j] Se si prende l\u0026rsquo;oggetto i-esimo, allora f[i][j] = f[i - 1][j - s[i]] + v[i] Si può notare che non c\u0026rsquo;è differenza nella transizione di stato rispetto al problema originale. Tuttavia, le condizioni iniziali sono diverse. Oltre a f[0][0] = 0, il resto di f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ rappresenta uno stato impossibile. Se il Limite di Volume $S$ è Molto Grande (1e9), mentre il Numero di Oggetti $N$ e il Valore Totale Massimo $V$ sono Relativamente Piccoli # Per questo tipo di problema, esiste una soluzione con una complessità di $O(NV)$. Definizione dello stato: f[i][j] rappresenta il volume minimo quando si selezionano alcuni dei primi i oggetti, e la somma dei valori è esattamente j. Se non si prende l\u0026rsquo;oggetto i-esimo, allora f[i][j] = f[i - 1][j] Se si prende l\u0026rsquo;oggetto i-esimo, allora f[i][j] = f[i - 1][j - v[i]] + s[i] Si prende il valore minore tra i due. Condizioni iniziali: f[0][0] = 0, il resto di f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ rappresenta uno stato impossibile. Si noti che non è $-\\infty$. La risposta finale è il massimo j in f[N][j] tale che f[N][j] \u0026lt;= S. Se il Limite di Volume $S$ e il Valore del Singolo Oggetto $v_i$ sono Entrambi Molto Grandi (nell\u0026rsquo;ordine di 1e9), mentre il Numero di Oggetti $N$ è Molto Piccolo (non più di 40) # Quando $N \\leq 20$, si possono enumerare direttamente tutti i sottoinsiemi (complessità temporale $O(2^N)$). Quando $N \\leq 40$, poiché $2^{40}$ è nell\u0026rsquo;ordine di $10^{12}$, l\u0026rsquo;enumerazione diretta sarebbe ancora troppo grande, quindi si può usare la ricerca a metà , che riduce approssimativamente la complessità a $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ , che può essere completata in un tempo accettabile. ","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Il problema dello zaino classico più basilare.","title":"Problema dello Zaino 0/1","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"Se uno spazio di soluzioni ordinato viene diviso in due parti, dove una parte soddisfa una condizione e l\u0026rsquo;altra no, allora la ricerca binaria può essere utilizzata per trovare il punto critico nello spazio di soluzioni ordinato.\nL\u0026rsquo;idea di base della ricerca binaria è quella di dimezzare ripetutamente l\u0026rsquo;intervallo di ricerca. Ogni volta, l\u0026rsquo;elemento centrale viene controllato. Se l\u0026rsquo;elemento centrale non soddisfa la condizione, metà dell\u0026rsquo;intervallo può essere eliminata; altrimenti, la ricerca continua nell\u0026rsquo;altra metà. Poiché metà dell\u0026rsquo;intervallo di ricerca viene scartata ogni volta, la complessità temporale della ricerca può raggiungere $O(\\log n)$.\nEsempio di Problema # Descrizione del Problema: Dato un array di interi ordinato in modo crescente di lunghezza $n$, e $q$ query. Ogni query fornisce un intero $k$, e dobbiamo trovare la \u0026ldquo;posizione iniziale\u0026rdquo; e la \u0026ldquo;posizione finale\u0026rdquo; di $k$ nell\u0026rsquo;array (gli indici partono da 0). Se il numero non esiste nell\u0026rsquo;array, restituire -1 -1.\nFormato di Input # Prima riga: due interi $n$ e $q$, che rappresentano rispettivamente la lunghezza dell\u0026rsquo;array e il numero di query. Seconda riga: $n$ interi, che rappresentano l\u0026rsquo;array completo, già ordinato in modo crescente. Successive $q$ righe: ogni riga contiene un intero $k$, che rappresenta un elemento di query. Range di Dati # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormato di Output # Per ogni query, stampare su una singola riga le posizioni iniziale e finale dell\u0026rsquo;elemento nell\u0026rsquo;array. Se l\u0026rsquo;elemento non esiste nell\u0026rsquo;array, stampare -1 -1.\nEsempio:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Spiegazione:\nL\u0026rsquo;intervallo in cui appare l\u0026rsquo;elemento $3$ è $[3, 4]$; L\u0026rsquo;elemento $4$ appare una sola volta, alla posizione $5$; L\u0026rsquo;elemento $5$ non esiste nell\u0026rsquo;array, quindi restituire $-1$ $-1$. Soluzione # Trovare la \u0026ldquo;Posizione Iniziale\u0026rdquo;: Cioè, trovare la prima posizione che è maggiore o uguale a $k$. L\u0026rsquo;array può essere diviso in due parti:\nTutti i numeri a sinistra sono \u0026ldquo;minori di\u0026rdquo; $k$ Tutti i numeri a destra sono \u0026ldquo;maggiori o uguali a\u0026rdquo; $k$ La risposta è la prima posizione a destra Trovare la \u0026ldquo;Posizione Finale\u0026rdquo;: Cioè, trovare l\u0026rsquo;ultima posizione che è minore o uguale a $k$. L\u0026rsquo;array può essere diviso in due parti:\nTutti i numeri a sinistra sono \u0026ldquo;minori o uguali a\u0026rdquo; $k$ Tutti i numeri a destra sono \u0026ldquo;maggiori di\u0026rdquo; $k$ La risposta è l\u0026rsquo;ultima posizione a sinistra Template Raccomandato # Di seguito è riportato un template di ricerca binaria elegante e meno soggetto a errori.\nDefinisci due puntatori $l, r$, con l\u0026rsquo;invariante: l\u0026rsquo;intervallo chiuso $[0, l]$ appartiene alla parte sinistra e l\u0026rsquo;intervallo chiuso $[r, n - 1]$ appartiene alla parte destra. $l$ e $r$ sono inizializzati rispettivamente a $-1$ e $n$.\nQuando l\u0026rsquo;algoritmo termina, $l$ e $r$ sono adiacenti, puntando rispettivamente all\u0026rsquo;ultimo elemento della parte sinistra e al primo elemento della parte destra.\nPoiché la soluzione che vogliamo potrebbe non esistere, se il problema non afferma che una soluzione esiste sicuramente, dobbiamo controllare se l o r sono fuori dai limiti e se puntano al valore corretto.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Trova la posizione iniziale di k 15 // Dividi l\u0026#39;array in due parti, la parte sinistra è tutta \u0026lt; k, e la parte destra è tutta \u0026gt;= k. 16 // La risposta è l\u0026#39;indice più piccolo della parte destra. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Se r è fuori dai limiti o nums[r] != k, significa che k non esiste 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Trova la posizione finale di k 33 // Dividi l\u0026#39;array in due parti, la parte sinistra è tutta \u0026lt;= k, e la parte destra è tutta \u0026gt; k. 34 // La risposta è l\u0026#39;indice più grande della parte sinistra. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} Vantaggi # Questo approccio ha invarianti strettamente definiti. Si applica sia alla ricerca della \u0026ldquo;posizione iniziale\u0026rdquo; che della \u0026ldquo;posizione finale\u0026rdquo; senza gestione o modifiche extra. Alcuni approcci usano l == r come condizione di terminazione. Quando $l$ e $r$ differiscono di $1$, $mid$ verrà calcolato in modo da essere uguale a $l$ o $r$. Se non gestito correttamente, l\u0026rsquo;aggiornamento di $l$ o $r$ a $mid$ non ridurrà l\u0026rsquo;intervallo di ricerca, portando a un ciclo infinito. Al contrario, questo approccio termina quando $l$ e $r$ sono adiacenti, assicurando che $mid$ sia minore di $l$ e maggiore di $r$, e l\u0026rsquo;aggiornamento di $l$ o $r$ ridurrà sempre l\u0026rsquo;intervallo di ricerca. STL # Se usi le funzioni lower_bound e upper_bound fornite da C++ STL, puoi ottenere lo stesso risultato:\nlower_bound(first, last, val) restituirà \u0026ldquo;la prima posizione che è maggiore o uguale a val\u0026rdquo; upper_bound(first, last, val) restituirà \u0026ldquo;la prima posizione che è maggiore di val\u0026rdquo; Ad esempio, supponiamo che nums = {1,2,3,4,4,4,4,4,5,5,6}, e vogliamo sapere l\u0026rsquo;intervallo in cui appare 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appare 0 volte\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;il primo 4 è a \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;l\u0026#39;ultimo 4 è a \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appare \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; volte\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 punta alla prima posizione in cui il valore è maggiore o uguale a $4$. it2 punta alla prima posizione in cui il valore è maggiore di $4$. Pertanto, it2 - it1 è il numero di volte in cui $4$ appare nell\u0026rsquo;array; it2 - nums.begin() - 1 è la posizione del limite destro di $4$. Note Aggiuntive # La ricerca binaria può essere estesa anche alla ricerca in intervalli di numeri in virgola mobile (come trovare le radici di un\u0026rsquo;equazione) e alla ricerca ternaria per trovare gli estremi di funzioni unimodali.\nEsercizio # LeetCode 33. Search in Rotated Sorted Array\nSuggerimento: Per prima cosa, usa la ricerca binaria per trovare il punto di rotazione, e poi usa la ricerca binaria per trovare il valore target.\n","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Come implementare elegantemente l\u0026rsquo;algoritmo di ricerca binaria.","title":"Ricerca Binaria","type":"posts"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"}]