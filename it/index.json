[{"content":" I. Il Teorema CAP # 1.1 Cos\u0026rsquo;è il Teorema CAP # Il Teorema CAP è stato proposto da Eric Brewer nel 2000, e il suo concetto fondamentale è:\nC (Consistency, Coerenza): Tutti i nodi del sistema vedono gli stessi dati nello stesso momento. Più precisamente, quando un client legge i dati, indipendentemente dalla replica da cui legge, il risultato dovrebbe essere coerente con i dati più recenti (solitamente si riferisce a coerenza forte/coerenza lineare). A (Availability, Disponibilità): Il sistema può ancora fornire servizi normali anche in caso di guasti parziali, e ogni richiesta può ottenere una \u0026ldquo;risposta valida\u0026rdquo; in un tempo ragionevole (non necessariamente sempre positiva, ma anche risposte di errore corrette). P (Partition tolerance, Tolleranza alle partizioni): Il sistema può tollerare le partizioni di rete (comunicazione non raggiungibile tra i nodi), e anche se la rete si divide, il sistema può fornire un certo grado di disponibilità o coerenza. In un ambiente distribuito reale, le partizioni di rete sono inevitabili, quindi P è fondamentalmente considerata un\u0026rsquo;opzione \u0026ldquo;obbligatoria\u0026rdquo;. Quando si verifica una partizione di rete, il sistema non può garantire contemporaneamente la forte coerenza e l\u0026rsquo;alta disponibilità dei dati su tutti i nodi, e può solo scegliere tra C e A, da cui derivano i due tipi principali CP e AP.\n1.2 Limiti del Teorema CAP # È necessario sottolineare che il Teorema CAP è di per sé una teoria di livello relativamente alto, utilizzata come guida concettuale, e non può essere semplicemente inteso come \u0026ldquo;o si sceglie C o si sceglie A\u0026rdquo;. Esistono alcuni malintesi comuni:\nC non è necessariamente una forte coerenza La C nel Teorema CAP si riferisce spesso alla coerenza nel senso più stretto (cioè la coerenza lineare). Tuttavia, nei sistemi reali, abbiamo molti modelli più granulari tra cui scegliere, come la coerenza debole, la lettura confermata (Read Committed), la coerenza causale (Causal Consistency), ecc. La disponibilità non è 0 o 1 Non significa che se si sceglie CP, la disponibilità sia completamente sacrificata; o se si sceglie AP, la coerenza non sia affatto garantita. Sia la disponibilità che la coerenza hanno diversi gradi di compromesso e strategie di downgrade. La coerenza finale non viola il CAP È una soluzione di compromesso molto comune, che scambia una minore coerenza di scrittura con una maggiore disponibilità e throughput, e converge i dati in background in modo asincrono. Pertanto, il Teorema CAP dovrebbe essere combinato con vari modelli di coerenza e modelli di architettura ad alta disponibilità in scenari specifici, per generare un vero valore di guida pratica.\nII. Modelli di Coerenza nei Sistemi Distribuiti # La classificazione dei modelli di coerenza è molto ricca, ma i modelli principali comuni possono essere suddivisi in: forte coerenza e debole coerenza (che include la coerenza finale, la coerenza causale, ecc.). Questo articolo introduce principalmente la forte coerenza e la coerenza finale, e spiega le loro applicazioni comuni in modalità CP o AP.\n2.1 Forte Coerenza # La forte coerenza (Strong Consistency), nota anche come coerenza lineare (Linearizability), si riferisce al fatto che una volta che un\u0026rsquo;operazione di scrittura viene completata e restituisce successo, qualsiasi operazione di lettura successiva può leggere il contenuto aggiornato. In altre parole, il sistema si comporta come se tutte le operazioni fossero state eseguite in serie.\nImplementazione comune: Si basa sulla replica sincrona e su un meccanismo di arbitraggio (maggioranza), e utilizza protocolli (come Paxos/Raft) per garantire che ci sia un solo leader (Leader) valido nel sistema, e tutte le operazioni vengono scritte nel log in ordine e replicate sulla maggior parte dei nodi. Vantaggi e svantaggi: Vantaggi: Garantisce la correttezza dei dati più rigorosa, e i dati letti in qualsiasi momento non \u0026ldquo;tornano indietro\u0026rdquo;. Svantaggi: In caso di fluttuazioni di rete, partizioni o guasti del leader, per mantenere la coerenza, le operazioni di scrittura vengono spesso bloccate, con conseguente diminuzione della disponibilità complessiva; anche le prestazioni e il throughput sono relativamente inferiori. 2.2 Coerenza Finale # La coerenza finale (Eventual Consistency) è una forma tipica di coerenza debole, che richiede solo che se il sistema non ha più nuove operazioni di aggiornamento, con il passare del tempo, i dati di tutte le repliche convergeranno gradualmente allo stesso stato. Durante questo periodo, gli utenti che leggono i dati della replica potrebbero vedere valori obsoleti, ma alla fine diventeranno coerenti.\nImplementazione comune: Protocollo Gossip, replica asincrona multi-replica, CRDT (Conflict-free Replicated Data Type), ecc. Vantaggi e svantaggi: Vantaggi: Alta disponibilità, alto throughput, bassa latenza di scrittura, alta tolleranza alle partizioni di rete. Svantaggi: È necessario tollerare l\u0026rsquo;incoerenza dei dati per un breve periodo, la logica dell\u0026rsquo;applicazione è più complessa e potrebbe essere necessario eseguire il rilevamento e l\u0026rsquo;unione dei conflitti. III. Protocolli e Algoritmi di Coerenza Comuni # Per mantenere la coerenza tra le repliche dei sistemi distribuiti, l\u0026rsquo;industria ha proposto molti algoritmi e protocolli classici. Di seguito è riportata una breve introduzione ad alcuni di essi:\n3.1 Paxos # Paxos è un algoritmo di coerenza distribuita proposto da Leslie Lamport negli anni \u0026lsquo;90, utilizzato principalmente per implementare una forte coerenza o coerenza lineare.\nPrincipio di base: Attraverso la divisione dei ruoli (Proponente Proposer, Accettatore Acceptor, Apprendista Learner), vengono eseguite più tornate di votazione per decidere se un\u0026rsquo;operazione o un valore viene accettato dalla maggior parte dei nodi. Vantaggi e svantaggi: Vantaggi: Può raggiungere un consenso anche in caso di partizioni di rete e guasti dei nodi, con un\u0026rsquo;elevata sicurezza. Svantaggi: L\u0026rsquo;implementazione è complessa, la difficoltà di debug e risoluzione dei problemi è elevata e le molteplici tornate di votazione portano a prestazioni limitate. L\u0026rsquo;industria utilizza spesso le sue varianti (Multi-Paxos, ecc.). 3.2 Raft # Raft è stato formalmente proposto nel 2013, con l\u0026rsquo;obiettivo di semplificare la difficoltà di implementazione e comprensione, garantendo al contempo la stessa sicurezza di Paxos. Stabilisce un ruolo di leader (Leader) stabile, per eseguire centralmente la replica dei log e il ripristino dei guasti:\nFasi chiave: Elezione del leader (Leader Election), replica dei log (Log Replication), sicurezza (Safety), ecc. Applicazioni comuni: Etcd, Consul, TiKV, LogCabin, ecc. si basano su Raft per implementare la replica a forte coerenza. Vantaggi e svantaggi: Vantaggi: Relativamente facile da capire, la quantità di codice di implementazione è inferiore; le prestazioni sono migliori per i cluster di piccole e medie dimensioni. Svantaggi: Dipende dal nodo principale (Leader), i guasti o le partizioni del nodo principale causano un blocco temporaneo della scrittura; in cluster di grandi dimensioni o distribuzioni transregionali, la latenza e la disponibilità ne risentono. 3.3 Protocollo Gossip # Il protocollo Gossip (pettegolezzo) non è un protocollo di consenso tradizionale, ma viene utilizzato principalmente in scenari decentralizzati per scambiare metadati o informazioni sullo stato attraverso interazioni casuali tra i nodi, in modo da diffondere e convergere in tutta la rete.\nCaratteristiche: Decentralizzato, a basso costo, i nodi scambiano messaggi periodicamente e casualmente. Applicazioni comuni: Cassandra, Riak, gestione distribuita dei membri (come Serf), ecc., utilizzati per implementare la coerenza finale, la sincronizzazione dello stato della replica, ecc. Vantaggi e svantaggi: Vantaggi: Buona scalabilità, semplice da implementare, adatto a scenari con bassi requisiti di coerenza e alti requisiti di scalabilità. Svantaggi: La garanzia di coerenza è debole, sono necessari mezzi di gestione dei conflitti di livello superiore (come CRDT, unione di numeri di versione, ecc.) per risolvere i conflitti in modo definitivo. 3.4 2PC / 3PC # Negli scenari di transazioni distribuite, i protocolli di commit comuni sono 2PC (Two-phase Commit) e 3PC (Three-phase Commit):\n2PC: Il coordinatore notifica a tutti i partecipanti \u0026ldquo;prepara (prepare)\u0026rdquo;, se tutti hanno successo, trasmette \u0026ldquo;commit (commit)\u0026rdquo;, altrimenti \u0026ldquo;rollback (abort)\u0026rdquo;. 3PC: Aggiunge una fase sulla base di 2PC, riducendo il blocco causato da guasti single-point, ma l\u0026rsquo;implementazione è più complessa e ci sono ancora problemi di indisponibilità in scenari estremi di partizioni di rete o guasti. Vantaggi e svantaggi: Vantaggi: Facile da capire, semantica delle transazioni chiara, ampiamente utilizzata in database distribuiti, code di messaggi, ecc. Svantaggi: Forte dipendenza dal coordinatore, rischio di blocco; quando la rete è partizionata per un periodo di tempo più lungo, potrebbe non essere possibile continuare a far avanzare la transazione. IV. Le Due Principali Scelte del CAP: CP e AP # Dopo aver stabilito che P è un attributo \u0026ldquo;obbligatorio\u0026rdquo;, se un sistema distribuito vuole continuare a fornire servizi durante una partizione di rete, deve scegliere tra C e A. La progettazione comune del sistema è quindi divisa in due campi principali: CP e AP.\n4.1 Sistemi CP # CP (Consistency + Partition tolerance): Quando si verifica una partizione di rete, il sistema sceglie di dare la priorità alla garanzia della coerenza, e sacrifica la disponibilità quando necessario.\nImplementazione tipica: Consenso della maggioranza (Paxos, Raft, ecc.), richiede che più della metà dei nodi siano attivi e raggiungano un consenso prima di consentire la scrittura. Se non è possibile raggiungere il quorum (numero legale) o si verifica un guasto del nodo principale, il sistema blocca o rifiuta le operazioni di scrittura, per evitare che la divisione del cervello causi incoerenza dei dati. Applicazioni comuni: Zookeeper, Etcd, Consul, servizi di blocco distribuiti, gestione di metadati distribuiti, ecc. Processi core di transazioni finanziarie, sistemi di contabilità bancaria e altri scenari con elevati requisiti di coerenza. Caratteristiche: Ha una rigorosa garanzia dei dati: preferisce l\u0026rsquo;arresto piuttosto che la comparsa di doppi master o confusione dei dati. Sacrifica una certa disponibilità: quando si verifica una partizione di rete o un failover, ci sarà una finestra di servizio non disponibile o di rifiuto delle operazioni di scrittura. 4.2 Sistemi AP # AP (Availability + Partition tolerance): Quando si verifica una partizione di rete, il sistema sceglie di dare la priorità alla garanzia della disponibilità, e allo stesso tempo allenta la coerenza.\nImplementazione tipica: Coerenza finale, replica multi-master, protocollo Gossip, strategia di coerenza regolabile in stile Dynamo, ecc. Applicazioni comuni: Database NoSQL (Cassandra, Riak, DynamoDB, ecc.), sistemi di cache distribuiti (Redis Cluster), ecc. Social network, acquisizione di log, sistemi di raccomandazione e altri servizi che richiedono alta disponibilità, alto throughput e requisiti di coerenza dei dati relativamente flessibili. Caratteristiche: Anche in caso di partizione, tutti i nodi continuano a ricevere richieste di lettura e scrittura, garantendo che il sistema sia \u0026ldquo;il più disponibile possibile\u0026rdquo;. I dati potrebbero essere temporaneamente incoerenti, ma convergeranno gradualmente in background attraverso la sincronizzazione asincrona, l\u0026rsquo;unione dei conflitti, ecc. V. Come Scegliere tra CP e AP? # In un sistema distribuito su larga scala reale, è raro fare affidamento su un singolo modello, ma piuttosto elaborare diversi dati o scenari di servizio a livelli, al fine di ottenere il miglior equilibrio tra coerenza e disponibilità.\nI dati core scelgono CP Come il saldo del conto utente, il pagamento degli ordini, il flusso di transazioni finanziarie, ecc., che hanno requisiti di coerenza estremamente elevati. Tollerano la temporanea non scrivibilità causata da fluttuazioni di rete, ma non possono tollerare errori nel saldo o nell\u0026rsquo;importo della transazione. I dati periferici o della cache scelgono AP Come la cache della pagina dei dettagli del prodotto, i log del comportamento dell\u0026rsquo;utente, gli elenchi di candidati per le raccomandazioni, ecc., che hanno requisiti di coerenza inferiori. Danno più importanza all\u0026rsquo;alta concorrenza e all\u0026rsquo;alta disponibilità, e possono tollerare aggiornamenti ritardati o letture sporche per un certo periodo di tempo. Molte aziende Internet adottano un\u0026rsquo;architettura ibrida: i processi di transazione core utilizzano l\u0026rsquo;archiviazione in stile CP (come database relazionali distribuiti o archiviazione distribuita con forte coerenza); i servizi periferici o gli scenari \u0026ldquo;lettura più scrittura meno\u0026rdquo; utilizzano l\u0026rsquo;archiviazione in stile AP o soluzioni di cache.\nVI. Come CP e AP Realizzano Alta Concorrenza e Coerenza Finale # 6.1 Come i Sistemi CP Gestiscono l\u0026rsquo;Alta Concorrenza # Sebbene i protocolli di consenso possano affrontare latenze più elevate e throughput inferiori quando la scala dei nodi di un singolo cluster e la quantità di richieste di scrittura sono elevate, è comunque possibile migliorare la concorrenza e la scalabilità attraverso i seguenti mezzi:\nLettura e scrittura in batch Impacchetta più operazioni di scrittura sul client o nel livello intermedio e le scrive sul nodo leader in una sola volta, riducendo i round trip di rete e i round di protocollo. Suddivisione di database e tabelle e multi-cluster Suddivide i dati in più cluster (sharding) in base alla logica o all\u0026rsquo;hash, e ogni cluster esegue ancora il protocollo CP; le richieste vengono distribuite a diverse partizioni attraverso il routing o il livello proxy. Migliora la capacità di concorrenza complessiva e limita l\u0026rsquo;impatto dei guasti all\u0026rsquo;interno di una singola partizione. Il throughput di un singolo cluster di partizioni di un sistema CP è spesso da 2 a 10 volte inferiore rispetto a un sistema AP.\n6.2 Come i Sistemi AP Garantiscono la Coerenza Finale # I sistemi AP sono in genere in grado di fornire un elevato throughput di scrittura e disponibilità di lettura, ma allentano la coerenza, quindi è necessario implementare garanzie di convergenza della coerenza in background o nel livello della logica di business:\nNumero di versione (Vector Clock) o timestamp logico Assegna un numero di versione a ogni operazione di aggiornamento (o basato su Lamport Clock / Hybrid Clock), ed esegue l\u0026rsquo;unione in scenari di conflitto o una strategia di vittoria basata sul timestamp (Last Write Wins). Protocollo Gossip / meccanismo anti-entropia I nodi scambiano periodicamente i dati o i metadati più recenti e, se vengono rilevati conflitti, vengono uniti. Strategia di coerenza regolabile Rappresentata dal modello Dynamo, il client può configurare parametri come R, W (come la scrittura della maggioranza, la conferma della replica), in modo da regolare in modo flessibile tra coerenza e disponibilità. Strategia di risoluzione dei conflitti personalizzata Unisce in base alla semantica del servizio, come l\u0026rsquo;unione del carrello della spesa con \u0026ldquo;unione\u0026rdquo;, e il contatore utilizza CRDT (G-counter, PN-counter, ecc.) per garantire la monotonicità dei dati. VII. Implementazione della Forte Coerenza Cross-Shard di CP # Nel capitolo VII, è stato menzionato che la suddivisione di database e tabelle (Sharding) può \u0026ldquo;dividere\u0026rdquo; la pressione di un singolo cluster CP in più sottocluster, per supportare una maggiore concorrenza. Tuttavia, quando un servizio deve eseguire transazioni cross-shard (ovvero, coinvolge aggiornamenti di più database o tabelle), si trova ancora di fronte alla sfida della coerenza multi-shard. Di solito ci sono le seguenti idee:\nTransazioni distribuite: 2PC / 3PC Se un\u0026rsquo;applicazione deve eseguire aggiornamenti atomici su più partizioni, di solito utilizza protocolli di transazioni distribuite (come 2PC, 3PC) per coordinare il commit o il rollback di ciascuna partizione. Problemi e contromisure: Sia 2PC/3PC si basano su un nodo coordinatore, che può diventare un collo di bottiglia single-point. In casi estremi di gravi partizioni di rete o guasti del coordinatore, potrebbe verificarsi un blocco. In genere, il failover master-slave, il rilevamento heartbeat e il meccanismo di timeout, il retry idempotente, MVCC, ecc. vengono utilizzati per ridurre l\u0026rsquo;impatto del blocco e il rischio di incoerenza dei dati. Architettura basata su celle (Cell-based) Divide il servizio in più unità autonome, i dati all\u0026rsquo;interno di ciascuna unità si trovano nello stesso set di partizioni, garantendo che la maggior parte delle transazioni venga completata in una singola unità, riducendo le operazioni cross-shard. Utilizza meccanismi asincroni o di coerenza finale al confine dell\u0026rsquo;unità per lo scambio di dati, tenendo conto dell\u0026rsquo;alta disponibilità e della coerenza complessive. Database distribuiti globali + protocollo di consenso globale Ad esempio, Google Spanner implementa la replica a forte coerenza su ciascuna partizione (Shard) tramite Paxos, e quindi utilizza l\u0026rsquo;API TrueTime per fornire timestamp globali per garantire la coerenza cross-shard. Questa soluzione ha un\u0026rsquo;elevata complessità di implementazione, ma può fornire capacità di transazioni distribuite quasi a forte coerenza a livello globale. Riepilogo: Per le transazioni cross-shard che richiedono rigorosamente una forte coerenza, 2PC/3PC + coordinatore è ancora una soluzione comune, e la possibilità di guasti viene ridotta il più possibile migliorando l\u0026rsquo;alta disponibilità del coordinatore. Tuttavia, nella pratica ingegneristica, è necessario ridurre al minimo le operazioni di scrittura cross-shard o limitare la maggior parte delle transazioni all\u0026rsquo;interno di una singola partizione attraverso l\u0026rsquo;idea di unità, riducendo la complessità del sistema.\nVIII. Discussione di Casi Famosi # Di seguito, vengono brevemente discussi alcuni sistemi distribuiti che vengono spesso menzionati nel settore, per vedere i loro compromessi e metodi di implementazione sul CAP:\nGoogle Spanner Un tipico sistema CP (può persino raggiungere l\u0026rsquo;illusione \u0026ldquo;CA\u0026rdquo; che il mondo esterno dice spesso, ma in sostanza deve comunque sacrificare parte della disponibilità). Utilizza timestamp esterni precisi forniti da TrueTime + replica Paxos all\u0026rsquo;interno di ciascuna partizione per garantire una forte coerenza tra i data center. Adatto per transazioni finanziarie globali o scenari con elevati requisiti di coerenza, ma i costi infrastrutturali sono estremamente elevati. BigTable / HBase In superficie, è più orientato a CP, e la coerenza dei metadati è garantita attraverso il coordinamento distribuito tra RegionServer e Master. Tuttavia, nel percorso di lettura e scrittura effettivo, può anche fornire alcuni mezzi di alta disponibilità attraverso la replica asincrona multi-replica, e la coerenza di lettura può essere regolata in base alle esigenze dell\u0026rsquo;applicazione. AWS DynamoDB Tende a AP, il design iniziale è stato ispirato dal documento Dynamo, e il livello di coerenza può essere regolato tramite parametri come R, W. Nella modalità predefinita, fornisce un\u0026rsquo;altissima disponibilità e coerenza finale, e può anche attivare la \u0026ldquo;lettura a forte coerenza\u0026rdquo; (ma garantisce solo la forte coerenza di una singola partizione, non necessariamente cross-partition). Cassandra Allo stesso modo, è orientato a AP, e il protocollo Gossip viene utilizzato a livello inferiore per mantenere lo stato della topologia dei nodi. La coerenza di lettura e scrittura può configurare il numero di repliche di lettura e scrittura R / W, per ottenere una transizione graduale dalla coerenza finale a una coerenza più forte. Confronto visibile: In termini ingegneristici, non esiste un \u0026ldquo;AP o CP\u0026rdquo; assoluto, ma piuttosto una combinazione di più strategie di coerenza; la maggior parte dei sistemi fornisce un certo grado di coerenza regolabile per adattarsi a diversi scenari applicativi.\nIX. Riepilogo # Il Teorema CAP non è una soluzione unica I sistemi distribuiti reali non possono semplicemente dire \u0026ldquo;scelgo C, rinuncio ad A\u0026rdquo; o \u0026ldquo;scelgo A, rinuncio a C\u0026rdquo;. È più comune nel settore scegliere in modo flessibile la modalità CP o AP per diverse dimensioni di dati e diversi tipi di operazioni, e persino all\u0026rsquo;interno dello stesso sistema, adottare diverse strategie di tolleranza ai guasti e coerenza per diverse tabelle/diverse funzioni. AP non è assolutamente disponibile al 100% Ad esempio, Cassandra, DynamoDB, ecc. possono anche non essere in grado di soddisfare le richieste in caso di partizioni di rete estreme o guasti su larga scala dei nodi. I sistemi AP sono progettati per preferire \u0026ldquo;scrivere prima finché la replica è scrivibile\u0026rdquo;, sacrificando parte della garanzia di coerenza in cambio di una disponibilità e un throughput relativamente più elevati. Anche CP può cercare di ottenere un\u0026rsquo;elevata disponibilità Paxos/Raft possono anche fornire una disponibilità del 99,99% o superiore in condizioni normali, ma è necessario investire più costi di rete, hardware e ingegneristici, e in caso di partizioni di rete estreme, si verificheranno comunque blocchi di scrittura e sacrifici di disponibilità per mantenere la coerenza. L\u0026rsquo;architettura ibrida è la corrente principale Gli scenari di transazioni core insistono sulla forte coerenza (CP), mentre gli scenari ausiliari periferici o i canali di cache adottano la coerenza debole (AP), e i due si coordinano tra loro. È necessario combinare la tolleranza del servizio, l\u0026rsquo;ambiente di rete, l\u0026rsquo;investimento dei costi e le riserve tecniche del team per fare compromessi completi. Il Teorema CAP fornisce un quadro di pensiero di alto livello per la progettazione di sistemi distribuiti, aiutandoci a prendere decisioni razionali di fronte alla realtà inevitabile delle partizioni di rete. Nei sistemi reali, è necessario utilizzare modelli di coerenza, protocolli di consenso, meccanismi di replica multi-replica più ricchi e pratiche ingegneristiche (tolleranza ai disastri, downgrade, idempotenza, unione dei conflitti, ecc.) per bilanciare coerenza e disponibilità.\n","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735350760948-cap/","section":"Posts","summary":"Discussione dall\u0026rsquo;aspetto teorico a quello pratico dell\u0026rsquo;applicazione del teorema CAP nei sistemi distribuiti.","title":"Analisi Approfondita del Teorema CAP: Creare Sistemi Distribuiti ad Alta Concorrenza e Alta Disponibilità","type":"posts"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 dicembre 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"L\u0026rsquo;ordinamento rapido è un algoritmo di ordinamento non stabile basato sul confronto, che adotta l\u0026rsquo;idea del divide et impera. La sua complessità temporale media è $O(n\\log n)$, nel caso peggiore è $O(n^2)$, e la complessità spaziale è $O(1)$. Di seguito, prendendo come esempio l\u0026rsquo;ordinamento crescente di una sequenza di numeri interi, vengono presentati i dettagli della sua implementazione e gli errori comuni.\nDescrizione del problema # Dato un elenco di numeri interi di lunghezza $n$, utilizzare l\u0026rsquo;ordinamento rapido per ordinarlo in ordine crescente e stampare il risultato.\nFormato di input # La prima riga inserisce l\u0026rsquo;intero $n$ La seconda riga inserisce $n$ numeri interi, tutti nell\u0026rsquo;intervallo $[1,10^9]$ Formato di output # Una riga che stampa la sequenza ordinata Intervallo di dati # $1 \\leq n \\leq 100000$\nEsempio di input # 5 3 1 2 4 5 Esempio di output # 1 2 3 4 5 Idea dell\u0026rsquo;ordinamento rapido # Ogni volta che l\u0026rsquo;ordinamento rapido divide, viene scelto un numero qualsiasi come numero di riferimento pivot (di seguito viene scelto il numero nella posizione centrale).\nSi utilizzano puntatori sinistro e destro che si muovono l\u0026rsquo;uno verso l\u0026rsquo;altro. Il puntatore sinistro L cerca da sinistra a destra il primo numero maggiore o uguale a pivot, mentre il puntatore destro R cerca da destra a sinistra il primo numero minore o uguale a pivot, quindi si scambiano questi due numeri.\nQuesto processo viene ripetuto continuamente finché i puntatori sinistro e destro non si sovrappongono o il puntatore sinistro non è di una posizione maggiore del puntatore destro. Questo è chiamato un ciclo.\nDopo ogni spostamento e scambio dei puntatori, si garantisce che la struttura \u0026ldquo;parte sinistra ≤ pivot, parte destra ≥ pivot\u0026rdquo; non venga distrutta, ovvero che ci sia l\u0026rsquo;invariante [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot.\nNel seguente codice di esempio, left e right sono i limiti dell\u0026rsquo;intervallo chiuso attualmente in elaborazione, mentre pivot prende l\u0026rsquo;elemento nel punto medio dell\u0026rsquo;intervallo.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} Complessità e scelta del pivot # Poiché nel caso peggiore l\u0026rsquo;ordinamento rapido ha una complessità di $O(n^2)$, la scelta del pivot è fondamentale. Se si sceglie sempre il primo o l\u0026rsquo;ultimo elemento, è molto probabile che si verifichi il caso peggiore in un array quasi ordinato.\nOltre a prendere l\u0026rsquo;elemento nella posizione centrale, è anche possibile selezionare casualmente un elemento come pivot, oppure prendere la mediana dei tre elementi a sinistra, al centro e a destra come pivot.\nEsempi di errori comuni # Il seguente codice contiene diversi errori comuni.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} Analisi degli errori:\npivot dovrebbe essere un numero nell\u0026rsquo;array, non un indice. Utilizzare rispettivamente \u0026lt; e \u0026gt; invece di \u0026lt;= e \u0026gt;=, altrimenti il puntatore sinistro potrebbe superare il puntatore destro di più di una posizione, e in questo modo non è possibile dividere l\u0026rsquo;array in due parti. Dopo aver rilevato l \u0026gt;= r, è necessario uscire immediatamente dal ciclo, senza eseguire lo scambio. Altrimenti, non è possibile garantire che gli elementi a sinistra non siano maggiori di pivot e che gli elementi a destra non siano minori di pivot. Dopo ogni scambio, è necessario eseguire l++ e r--. pivot in realtà prende il numero centrale spostato a sinistra. Pertanto, se si utilizza $l - 1$ e $l$ per dividere l\u0026rsquo;array, considerando l\u0026rsquo;array [1, 2], non è difficile scoprire che si verificherà un ciclo infinito, dividendo continuamente l\u0026rsquo;array in due parti di dimensione 0 e 2. Allo stesso modo, non è possibile utilizzare $r$ e $l$ per distinguere l\u0026rsquo;array. Al contrario, quando un ciclo termina, $r$ è necessariamente minore di $right$, quindi è possibile utilizzare $r$ e $r+1$ per dividere l\u0026rsquo;array. Il lettore può simulare il processo dell\u0026rsquo;algoritmo per vedere perché. Un altro modo semplice per evitare cicli infiniti è selezionare casualmente pivot o gestire in modo speciale il caso in cui ci sono solo due elementi. Inoltre, non è possibile utilizzare $l$, $l+1$, perché questa divisione non è conforme alla definizione. Quando $r$ si trova a sinistra di $l$, l\u0026rsquo;utilizzo di $l$, $l+1$ non può dividere correttamente l\u0026rsquo;array in due parti, una a sinistra minore o uguale a pivot e una a destra maggiore o uguale a pivot. Questo problema presuppone che l\u0026rsquo;array non sia vuoto, quindi non esiste il caso \u0026gt;. Tuttavia, si consiglia di utilizzare \u0026gt;=, che è più sicuro. Aggiunte # L\u0026rsquo;ordinamento rapido può anche evolvere in \u0026ldquo;selezione rapida\u0026rdquo;, che consente di trovare l\u0026rsquo;$k$-esimo numero più piccolo in un array non ordinato in un tempo previsto di $O(n)$. L\u0026rsquo;idea specifica è simile all\u0026rsquo;ordinamento rapido, tranne per il fatto che ogni volta si continua la ricorsione solo in un sottointervallo, riducendo così la complessità temporale.\n","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735252761946-quick-sort/","section":"Posts","summary":"Analisi dei punti chiave per implementare correttamente l\u0026rsquo;algoritmo di ordinamento rapido.","title":"Ordinamento rapido","type":"posts"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 dicembre 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 dicembre 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":" Problema # Ci sono $N$ oggetti. Il volume dell\u0026rsquo;oggetto $i$-esimo è $s_i$ e il suo valore è $v_i$. Ogni oggetto può essere preso solo una volta. Con la premessa di non superare il limite massimo di volume totale $S$, trova il valore totale massimo $V$ che può essere ottenuto.\nFormato di Input # La prima riga contiene due interi, $N$ e $S$, separati da uno spazio, che rappresentano rispettivamente il numero di oggetti e il limite massimo di volume totale. Le seguenti $N$ righe contengono ciascuna due interi, $s_i$ e $v_i$, separati da uno spazio, che rappresentano rispettivamente il volume e il valore dell\u0026rsquo;oggetto $i$-esimo.\nFormato di Output # Restituisci un intero che rappresenta il valore massimo.\nIntervallo di Dati # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ Esempio di Input # 4 5 1 2 2 4 3 4 4 5 Esempio di Output # 8 Soluzione # Definisci lo stato: f[i][j] rappresenta il valore massimo che può essere ottenuto dai primi $i$ oggetti con un limite di volume di $j$. Se l\u0026rsquo;oggetto $i$-esimo non viene preso, allora f[i][j] = f[i - 1][j] Se l\u0026rsquo;oggetto $i$-esimo viene preso, allora f[i][j] = f[i - 1][j - s[i]] + v[i] Quando si implementa la transizione di stato, prestare attenzione all\u0026rsquo;intervallo del dominio. Se $j \u003c s_i$, allora non considerare il caso di prendere l\u0026rsquo;oggetto $i$-esimo. Perché se $j - s_i$ è negativo, l\u0026rsquo;indice dell\u0026rsquo;array non è valido. Può anche essere spiegato in questo modo: il volume dell\u0026rsquo;oggetto $i$-esimo è maggiore del limite di volume, quindi è impossibile. Definisci la condizione iniziale: per i primi $0$ oggetti, qualsiasi limite di volume produce un valore di $0$, cioè f[0][j] = 0, j $\\in [0, S]$. Complessità temporale: $O(NS)$. Codice # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} Ottimizzazione DP 1D # La compressione dell\u0026rsquo;array bidimensionale in un array unidimensionale può far risparmiare significativamente spazio e migliorare in una certa misura la velocità di esecuzione (lo svantaggio è che non può soddisfare i requisiti speciali di alcuni tipi di problemi). Si noti che nella transizione di stato, f[i][j] è correlato solo a f[i - 1][j] e f[i - 1][j - s[i]]. In altre parole, nell\u0026rsquo;array bidimensionale f nel codice, f[i][j] è correlato solo agli elementi nella riga precedente che si trovano alla sua sinistra o nella stessa colonna. Pertanto, l\u0026rsquo;array bidimensionale può essere compresso in un array unidimensionale o in un array scorrevole. Si noti che nel codice seguente, il secondo ciclo itera in ordine inverso. Questo perché vogliamo assicurarci che quando si calcola f[i][j], f[i - 1][j - s[i]] non sia ancora stato aggiornato. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} Se è Richiesto il Numero di Schemi # Non solo dovrebbe essere restituito il valore totale massimo che può essere ottenuto, ma anche \u0026ldquo;quanti metodi di selezione diversi possono raggiungere questo valore totale massimo\u0026rdquo;. Di seguito viene descritto come contare il numero di schemi nel problema dello zaino 0/1.\nDP 2D per Contare gli Schemi # Di seguito viene utilizzato il DP 2D come esempio per spiegare.\nDefinisci lo stato:\ndp[i][j] rappresenta \u0026ldquo;il valore massimo che può essere ottenuto quando si considerano i primi i oggetti con una capacità (limite di volume) di j\u0026rdquo;. ways[i][j] rappresenta \u0026ldquo;il numero di schemi corrispondenti al valore massimo ottenuto quando si considerano i primi i oggetti con una capacità di j\u0026rdquo;. Transizione di stato:\nSe l\u0026rsquo;oggetto i-esimo non è selezionato: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ Se l\u0026rsquo;oggetto i-esimo è selezionato (a condizione che $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ Che si selezioni o meno, il dp[i][j] finale dovrebbe prendere il maggiore dei due: Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ allora significa che \u0026ldquo;selezionare l\u0026rsquo;oggetto i-esimo\u0026rdquo; ha un valore maggiore: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ significa che il valore massimo ottenuto dai due metodi è lo stesso, quindi il numero di schemi dovrebbe essere aggiunto: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ Se $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ allora significa che \u0026ldquo;non selezionare l\u0026rsquo;oggetto i-esimo\u0026rdquo; ha un valore maggiore e il numero di schemi eredita il numero di schemi quando non si seleziona: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ Condizioni iniziali:\ndp[0][j] = 0 significa che quando ci sono 0 oggetti, il valore massimo ottenuto per qualsiasi capacità è 0. ways[0][0] = 1 significa che il caso di \u0026ldquo;0 oggetti, capacità 0\u0026rdquo; è uno schema fattibile (cioè, non selezionare nulla) e il numero di schemi è impostato a 1. Per j \u0026gt; 0, quando non ci sono oggetti tra cui scegliere e la capacità è maggiore di 0, è impossibile ottenere qualsiasi valore positivo e il numero di schemi corrispondente è 0, cioè ways[0][j] = 0. Risposta finale:\ndp[N][S] è il valore massimo. ways[N][S] è il numero di schemi per raggiungere questo valore massimo. Complessità temporale: $O(NS)$. Questo problema può anche essere ottimizzato usando il DP 1D. Se il Requisito è di Raggiungere Esattamente il Limite di Volume # Definisci lo stato: f[i][j] rappresenta il valore massimo quando i primi i oggetti hanno esattamente un volume di $j$. Se l\u0026rsquo;oggetto i-esimo non viene preso, allora f[i][j] = f[i - 1][j] Se l\u0026rsquo;oggetto i-esimo viene preso, allora f[i][j] = f[i - 1][j - s[i]] + v[i] Si può notare che non c\u0026rsquo;è differenza nella transizione di stato rispetto al problema originale. Tuttavia, le condizioni iniziali sono diverse. Ad eccezione di f[0][0] = 0, il resto f[0][j] = $-\\infty$, j $\\in [1, S]$. $-\\infty$ rappresenta uno stato impossibile. Se il Limite di Volume $S$ è Molto Grande (1e9), Mentre il Numero di Oggetti $N$ e il Valore Totale Massimo $V$ sono Relativamente Piccoli # Per tali problemi, esiste una soluzione con una complessità di $O(NV)$. Definisci lo stato: f[i][j] rappresenta il volume minimo quando si selezionano diversi oggetti dai primi i oggetti e il valore totale è esattamente j. Se l\u0026rsquo;oggetto i-esimo non viene preso, allora f[i][j] = f[i - 1][j] Se l\u0026rsquo;oggetto i-esimo viene preso, allora f[i][j] = f[i - 1][j - v[i]] + s[i] Prendi il minore dei due. Condizioni iniziali: f[0][0] = 0, il resto f[0][j] = $\\infty$, j $\\in [1, V]$. $\\infty$ rappresenta uno stato impossibile. Si noti che non è $-\\infty$. La risposta finale è il più grande j in f[N][j] tale che f[N][j] \u0026lt;= S. Se il Limite di Volume $S$ e il Valore di un Singolo Oggetto $v_i$ sono Entrambi Molto Grandi (dell\u0026rsquo;ordine di 1e9), Mentre il Numero di Oggetti $N$ è Molto Piccolo (non più di 40) # Quando $N \\leq 20$, tutti i sottoinsiemi possono essere enumerati direttamente con la forza bruta (complessità temporale $O(2^N)$). Quando $N \\leq 40$, poiché $2^{40}$ è dell\u0026rsquo;ordine di $10^{12}$, anche la forza bruta diretta sarà relativamente grande, quindi la ricerca meet-in-the-middle può essere utilizzata per ridurre la complessità a circa $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$, che può essere completata in un tempo accettabile. ","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"Il problema dello zaino classico più basilare.","title":"Problema dello Zaino 0/1","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"Se uno spazio di soluzioni ordinato viene diviso in due parti, dove una parte soddisfa una condizione e l\u0026rsquo;altra no, allora è possibile utilizzare la ricerca binaria per trovare il punto critico nello spazio di soluzioni ordinato.\nL\u0026rsquo;idea di base della ricerca binaria è quella di dividere ripetutamente a metà l\u0026rsquo;intervallo di ricerca. Ad ogni controllo, si verifica l\u0026rsquo;elemento centrale; se l\u0026rsquo;elemento centrale non soddisfa la condizione, si può escludere metà dell\u0026rsquo;intervallo; altrimenti, si continua la ricerca nell\u0026rsquo;altra metà dell\u0026rsquo;intervallo. Poiché ad ogni passo si scarta metà dell\u0026rsquo;intervallo di ricerca, la complessità temporale della ricerca può raggiungere $O(\\log n)$.\nEsempio # Descrizione del problema:\nDato un array di interi di lunghezza $n$ ordinato in modo crescente, e $q$ query. Ogni query fornisce un intero $k$, e dobbiamo trovare la \u0026ldquo;posizione iniziale\u0026rdquo; e la \u0026ldquo;posizione finale\u0026rdquo; di $k$ nell\u0026rsquo;array (gli indici partono da 0). Se il numero non esiste nell\u0026rsquo;array, restituisci -1 -1.\nFormato di input # Prima riga: due interi $n$ e $q$, che rappresentano rispettivamente la lunghezza dell\u0026rsquo;array e il numero di query. Seconda riga: $n$ interi, che rappresentano l\u0026rsquo;array completo, già ordinato in modo crescente. Le successive $q$ righe: ogni riga contiene un intero $k$, che rappresenta un elemento di query. Intervallo di dati # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\nFormato di output # Per ogni query, stampa in una riga la posizione iniziale e finale dell\u0026rsquo;elemento nell\u0026rsquo;array. Se l\u0026rsquo;elemento non esiste nell\u0026rsquo;array, stampa -1 -1.\nEsempio:\nInput: 6 3 1 2 2 3 3 4 3 4 5 Output: 3 4 5 5 -1 -1 Spiegazione:\nL\u0026rsquo;intervallo in cui appare l\u0026rsquo;elemento $3$ è $[3, 4]$; L\u0026rsquo;elemento $4$ appare solo una volta, nella posizione $5$; L\u0026rsquo;elemento $5$ non esiste nell\u0026rsquo;array, quindi restituisce $-1$ $-1$. Soluzione # Trovare la \u0026ldquo;posizione iniziale\u0026rdquo;: Cioè, trovare la prima posizione maggiore o uguale a $k$. Possiamo dividere l\u0026rsquo;array in due parti:\nTutti i numeri a sinistra sono \u0026ldquo;minori\u0026rdquo; di $k$ Tutti i numeri a destra sono \u0026ldquo;maggiori o uguali\u0026rdquo; a $k$ La risposta è la prima posizione a destra Trovare la \u0026ldquo;posizione finale\u0026rdquo;: Cioè, trovare l\u0026rsquo;ultima posizione minore o uguale a $k$. Possiamo dividere l\u0026rsquo;array in due parti:\nTutti i numeri a sinistra sono \u0026ldquo;minori o uguali\u0026rdquo; a $k$ Tutti i numeri a destra sono \u0026ldquo;maggiori\u0026rdquo; di $k$ La risposta è l\u0026rsquo;ultima posizione a sinistra Modello consigliato # Di seguito è riportato un modello di ricerca binaria elegante e poco incline a errori.\nDefinisci due puntatori $l, r$, con l\u0026rsquo;invariante: l\u0026rsquo;intervallo chiuso $[0, l]$ appartiene alla parte sinistra, l\u0026rsquo;intervallo chiuso $[r, n - 1]$ appartiene alla parte destra. $l$ e $r$ sono inizializzati rispettivamente a $-1$ e $n$.\nQuando l\u0026rsquo;algoritmo termina, $l$ e $r$ sono adiacenti, puntando rispettivamente all\u0026rsquo;ultimo elemento della parte sinistra e al primo elemento della parte destra.\nPoiché la soluzione che cerchiamo potrebbe non esistere, se il problema non specifica che una soluzione esiste sicuramente, dobbiamo verificare se l o r sono fuori dai limiti, e se puntano al valore corretto.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. Trova la posizione iniziale di k 15 // Dividi l\u0026#39;array in due parti, a sinistra tutti \u0026lt; k, a destra tutti \u0026gt;= k. 16 // La risposta è l\u0026#39;indice minimo della parte destra. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // Se r è fuori dai limiti o nums[r] != k, significa che k non esiste 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. Trova la posizione finale di k 33 // Dividi l\u0026#39;array in due parti, a sinistra tutti \u0026lt;= k, a destra tutti \u0026gt; k. 34 // La risposta è l\u0026#39;indice massimo della parte sinistra. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} Vantaggi # Questa scrittura ha invarianti rigorosamente definiti. Si applica sia alla ricerca della \u0026ldquo;posizione iniziale\u0026rdquo; che della \u0026ldquo;posizione finale\u0026rdquo;, senza bisogno di elaborazioni o modifiche aggiuntive. Alcune scritture usano l == r come condizione di terminazione. Quando $l$ e $r$ differiscono di $1$, si calcola che $mid$ è uguale a $l$ o $r$. Se non viene gestito correttamente, aggiornando $l$ o $r$ a $mid$, l\u0026rsquo;intervallo di ricerca non si riduce, portando a un ciclo infinito. Al contrario, questa scrittura termina quando $l$ e $r$ sono adiacenti, garantendo che $mid$ sia minore di $l$ e maggiore di $r$, e che l\u0026rsquo;intervallo di ricerca si riduca quando si aggiorna $l$ o $r$. STL # Se si utilizzano le funzioni lower_bound e upper_bound fornite dalla STL di C++, si può ottenere lo stesso risultato:\nlower_bound(first, last, val) restituisce \u0026ldquo;la prima posizione maggiore o uguale a val\u0026rdquo; upper_bound(first, last, val) restituisce \u0026ldquo;la prima posizione maggiore di val\u0026rdquo; Ad esempio, supponiamo che nums = {1,2,3,4,4,4,4,4,5,5,6}, e vogliamo sapere l\u0026rsquo;intervallo in cui appare 4:\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appare 0 volte\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;il primo 4 è in \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;l\u0026#39;ultimo 4 è in \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appare \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; volte\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 punta alla prima posizione con un valore maggiore o uguale a $4$. it2 punta alla prima posizione con un valore maggiore di $4$.\nQuindi it2 - it1 è il numero di volte in cui $4$ appare nell\u0026rsquo;array; it2 - nums.begin() - 1 è la posizione del limite destro di $4$. Aggiunte # La ricerca binaria può essere estesa anche alla ricerca in intervalli di numeri in virgola mobile (come trovare le radici di un\u0026rsquo;equazione) e alla ricerca ternaria per trovare il valore massimo di una funzione unimodale.\nEsercizi # LeetCode 33. Search in Rotated Sorted Array\nSuggerimento: il primo passo è usare la ricerca binaria per trovare il punto di rotazione, il secondo passo è usare di nuovo la ricerca binaria per trovare il valore target.\n","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Come implementare elegantemente l\u0026rsquo;algoritmo di ricerca binaria.","title":"Ricerca Binaria","type":"posts"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","externalUrl":null,"permalink":"/it/series/","section":"Series","summary":"","title":"Series","type":"series"}]