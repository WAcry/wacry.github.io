[{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithmes-de-tri/","section":"Tags","summary":"","title":"Algorithmes De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmo Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmos-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmos De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/schnellsortierung/","section":"Tags","summary":"","title":"Schnellsortierung","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/teile-und-herrsche-algorithmus/","section":"Tags","summary":"","title":"Teile-Und-Herrsche-Algorithmus","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘과 자료구조","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":" 퀵 정렬 # 퀵 정렬은 비교 기반의 불안정 정렬 알고리즘으로, 분할 정복 방식을 사용하며 평균 시간 복잡도는 $O(n\\log n)$이고 최악의 경우 $O(n^2)$입니다. 공간 복잡도는 $O(1)$입니다. 아래에서는 정수 수열을 오름차순으로 정렬하는 예시를 통해 구현 세부 사항과 흔한 오류를 소개합니다.\n문제 설명 # 길이가 $n$인 정수 수열이 주어졌을 때, 퀵 정렬을 사용하여 오름차순으로 정렬하고 결과를 출력하세요.\n입력 형식 # 첫 번째 줄에 정수 $n$을 입력합니다. 두 번째 줄에 $n$개의 정수를 입력하며, 각 정수는 $[1, 10^9]$ 범위 내에 있습니다. 출력 형식 # 정렬된 수열을 한 줄에 출력합니다. 데이터 범위 # $1 \\leq n \\leq 100000$\n입력 예시 # 5 3 1 2 4 5 출력 예시 # 1 2 3 4 5 퀵 정렬 아이디어 # 퀵 정렬은 매 분할 시 임의의 수를 기준 수 pivot으로 선택합니다 (아래에서는 중간 위치의 수를 선택).\n좌우 포인터를 사용하여 서로 마주보며 이동합니다. 왼쪽 포인터 L은 왼쪽에서 오른쪽으로 이동하며 pivot보다 크거나 같은 첫 번째 수를 찾고, 오른쪽 포인터 R은 오른쪽에서 왼쪽으로 이동하며 pivot보다 작거나 같은 첫 번째 수를 찾습니다. 그런 다음 이 두 수를 교환합니다.\n이 과정을 왼쪽 포인터와 오른쪽 포인터가 겹치거나 왼쪽 포인터가 오른쪽 포인터보다 한 칸 커질 때까지 반복합니다. 이를 한 번의 순환이라고 합니다.\n각 포인터 이동 및 교환이 완료될 때마다 \u0026ldquo;왼쪽 부분 ≤ pivot, 오른쪽 부분 ≥ pivot\u0026rdquo; 구조가 유지되도록 합니다. 즉, 불변량 [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot을 유지합니다.\n다음 예시 코드에서 left와 right는 현재 처리 중인 닫힌 구간의 경계이고, pivot은 구간 중간 지점의 요소를 취합니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 복잡도 및 pivot 선택 # 최악의 경우 퀵 정렬의 복잡도는 $O(n^2)$이므로 pivot 선택이 매우 중요합니다. 항상 첫 번째 또는 마지막 요소를 선택하면 거의 정렬된 배열에서 최악의 경우가 발생할 가능성이 높습니다.\n중간 위치의 요소를 선택하는 것 외에도 임의의 요소를 pivot으로 선택하거나 왼쪽, 중간, 오른쪽 세 요소의 중앙값을 pivot으로 선택할 수 있습니다.\n흔한 오류 예시 # 다음 코드는 여러 가지 흔한 오류를 포함하고 있습니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 오류 분석:\npivot은 배열의 인덱스가 아닌 배열의 값이어야 합니다. \u0026lt;=와 \u0026gt;= 대신 \u0026lt;와 \u0026gt;를 사용해야 합니다. 그렇지 않으면 왼쪽 포인터가 오른쪽 포인터를 한 칸 이상 초과할 수 있으며, 이로 인해 배열을 두 부분으로 나눌 수 없게 됩니다. l \u0026gt;= r을 발견한 후에는 즉시 루프를 종료하고 교환을 더 이상 수행하지 않아야 합니다. 그렇지 않으면 왼쪽 요소가 pivot보다 크지 않고 오른쪽 요소가 pivot보다 작지 않다는 것을 보장할 수 없습니다. 매번 교환 후에는 l++와 r--를 실행해야 합니다. pivot은 실제로 중간에서 약간 왼쪽에 있는 수를 취합니다. 따라서 $l - 1$과 $l$을 사용하여 배열을 분할하면 배열 [1, 2]의 경우 무한 루프가 발생하여 배열을 크기가 0과 2인 두 부분으로 계속 분할하게 됩니다. 마찬가지로 $r$과 $l$을 사용하여 배열을 구분하는 것도 불가능합니다. 반대로, 한 번의 순환이 끝나면 $r$은 반드시 $right$보다 작으므로 $r$과 $r+1$을 사용하여 배열을 분할할 수 있습니다. 왜 그런지 알고리즘 과정을 시뮬레이션해 보세요. 무한 루프를 피하는 또 다른 간단한 방법은 pivot을 무작위로 선택하거나 두 개의 요소만 있는 경우를 특별히 처리하는 것입니다. 또한 $l$, $l+1$을 사용하는 것도 불가능합니다. 이 분할은 정의에 맞지 않으며, $r$이 $l$ 왼쪽에 있는 경우 $l$, $l+1$을 사용하면 배열을 왼쪽은 pivot보다 작거나 같고 오른쪽은 pivot보다 크거나 같은 두 부분으로 올바르게 나눌 수 없습니다. 이 문제는 배열이 비어 있지 않다고 가정하므로 \u0026gt;의 경우는 없습니다. 그러나 \u0026gt;=를 사용하는 것이 더 안전합니다. 추가 설명 # 퀵 정렬은 \u0026ldquo;퀵 선택\u0026quot;으로 발전하여 $O(n)$의 기대 시간 내에 정렬되지 않은 배열에서 $k$번째로 작은 수를 찾을 수 있습니다. 구체적인 아이디어는 퀵 정렬과 유사하지만 매번 한쪽 하위 구간에서만 재귀를 계속하여 시간 복잡도를 줄입니다.\n","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/posts/1735252761946-quick-sort/","section":"Posts","summary":"퀵 정렬 알고리즘을 올바르게 구현하기 위한 핵심 요점 분석.","title":"퀵 정렬","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":" 문제 # https://www.acwing.com/problem/content/2/\n$N$개의 물건이 있습니다. $i$번째 물건의 부피는 $s_i$, 가치는 $v_i$입니다. 각 물건은 한 번만 가져갈 수 있습니다. 최대 총 부피 제한 $S$를 넘지 않는 전제 하에, 얻을 수 있는 최대 총 가치 $V$를 구하세요.\n입력 형식 # 첫 번째 줄에는 두 정수 $N, S$가 공백으로 구분되어 주어집니다. 각각 물건의 개수와 최대 총 부피 제한을 나타냅니다. 다음 $N$개의 줄에는 각 줄마다 두 정수 $s_i, v_i$가 공백으로 구분되어 주어집니다. 각각 $i$번째 물건의 부피와 가치를 나타냅니다.\n출력 형식 # 최대 가치를 나타내는 정수를 출력합니다.\n데이터 범위 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 입력 예제 # 4 5 1 2 2 4 3 4 4 5 출력 예제 # 8 문제 해설 # 상태 정의: f[i][j]는 처음 $i$개의 물건을 고려했을 때, 부피 제한이 $j$일 때 얻을 수 있는 최대 가치를 나타냅니다. 만약 $i$번째 물건을 선택하지 않는다면, f[i][j] = f[i - 1][j]입니다. 만약 $i$번째 물건을 선택한다면, f[i][j] = f[i - 1][j - s[i]] + v[i]입니다. 상태 전이를 구현할 때, 정의된 범위에 주의해야 합니다. 만약 $j \u003c s_i$라면, $i$번째 물건을 선택하는 경우는 고려하지 않습니다. 왜냐하면 $j - s_i$가 음수가 되어 배열 인덱스가 유효하지 않기 때문입니다. 다른 말로 설명하면, $i$번째 물건의 부피가 부피 제한보다 크므로 불가능합니다. 초기 조건 정의: 처음 0개의 물건에 대해서는 어떤 부피 제한이든 얻을 수 있는 가치는 0입니다. 즉, f[0][j] = 0, j $\\in [0, S]$입니다. 시간 복잡도: $O(NS)$입니다. 코드 # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1차원 DP 최적화 # 2차원 배열을 1차원 배열로 압축하면 공간을 크게 절약하고 실행 속도를 어느 정도 향상시킬 수 있습니다 (단점은 일부 문제 유형의 특수한 요구 사항을 충족할 수 없다는 것입니다). 상태 전이에서 f[i][j]는 f[i - 1][j]와 f[i - 1][j - s[i]]에만 관련되어 있다는 점에 주목하세요. 다시 말해, 코드의 2차원 배열 f에서 f[i][j]는 이전 행에서 자신보다 왼쪽 또는 같은 열에 있는 요소에만 관련되어 있으므로 2차원 배열을 1차원 배열 또는 롤링 배열로 압축할 수 있습니다. 아래 코드에서 두 번째 루프가 역순으로 순회하는 이유는 f[i][j]를 계산할 때 f[i - 1][j - s[i]]가 아직 업데이트되지 않았는지 확인해야 하기 때문입니다. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 만약 해법의 수를 요구한다면 # 얻을 수 있는 최대 총 가치뿐만 아니라 \u0026ldquo;이 최대 총 가치를 달성할 수 있는 서로 다른 선택 방법의 수는 몇 가지인가\u0026quot;를 출력해야 합니다. 다음은 01 배낭 문제에서 해법의 수를 세는 방법을 소개합니다.\nhttps://www.acwing.com/problem/content/11/\n2차원 DP로 해법의 수 세기 # 다음은 2차원 DP를 예로 들어 설명합니다.\n상태 정의:\ndp[i][j]는 \u0026ldquo;처음 i개의 물건을 고려했을 때, 용량(부피 제한)이 j일 때 얻을 수 있는 최대 가치\u0026quot;를 나타냅니다. ways[i][j]는 \u0026ldquo;처음 i개의 물건을 고려했을 때, 용량이 j이고, 최대 가치를 얻을 때 해당하는 해법의 수\u0026ldquo;를 나타냅니다. 상태 전이:\n만약 i번째 물건을 선택하지 않는다면: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ 만약 i번째 물건을 선택한다면 (전제 조건은 $ j \\ge s_i $): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 선택하거나 선택하지 않거나, 최종적으로 dp[i][j]는 둘 중 더 큰 값을 취해야 합니다: 만약 $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ 라면 \u0026ldquo;i번째 물건을 선택하는 것\u0026quot;이 더 큰 가치를 갖는다는 의미입니다: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ 만약 $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ 라면 두 가지 방법으로 얻는 최대 가치가 동일하다는 의미이므로 해법의 수를 더해야 합니다: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ 만약 $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ 라면 \u0026ldquo;i번째 물건을 선택하지 않는 것\u0026quot;이 더 큰 가치를 갖는다는 의미이므로 해법의 수는 선택하지 않을 때의 해법의 수를 상속합니다: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 초기 조건:\ndp[0][j] = 0은 처음 0개의 물건에 대해서는 어떤 용량으로든 얻을 수 있는 최대 가치가 0임을 나타냅니다. ways[0][0] = 1은 \u0026ldquo;처음 0개의 물건, 용량이 0\u0026quot;인 경우가 가능한 해법(즉, 아무것도 선택하지 않음)이며, 해법의 수를 1로 설정합니다. j \u0026gt; 0에 대해서는 선택할 수 있는 물건이 없을 때 용량이 0보다 크면 어떤 양의 가치도 얻을 수 없으므로 해당하는 해법의 수는 0입니다. 즉, ways[0][j] = 0입니다. 최종 답:\ndp[N][S]는 최대 가치입니다. ways[N][S]는 해당 최대 가치를 달성하는 해법의 수입니다. 시간 복잡도: $O(NS)$입니다. 이 문제는 1차원 DP를 사용하여 최적화할 수도 있습니다. 만약 정확히 부피 제한을 달성하는 경우를 요구한다면 # 상태 정의: f[i][j]는 처음 i개의 물건을 고려했을 때 정확히 부피 $j$를 갖는 최대 가치를 나타냅니다. 만약 i번째 물건을 선택하지 않는다면, f[i][j] = f[i - 1][j]입니다. 만약 i번째 물건을 선택한다면, f[i][j] = f[i - 1][j - s[i]] + v[i]입니다. 원래 문제의 상태 전이와 차이가 없다는 것을 알 수 있습니다. 하지만 초기 조건이 다릅니다. f[0][0] = 0을 제외하고 나머지 f[0][j] = $-\\infty$, j $\\in [1, S]$입니다. $-\\infty$는 불가능한 상태를 나타냅니다. 만약 부피 제한 $S$가 매우 크고 (1e9), 동시에 물건의 개수 $N$과 최대 총 가치 $V$가 비교적 작다면 # 이러한 문제에 대해서는 $O(NV)$의 복잡도를 갖는 해법이 있습니다. 상태 정의: f[i][j]는 처음 i개의 물건 중에서 몇 개를 선택하여 가치 총합이 정확히 j일 때의 최소 부피를 나타냅니다. 만약 i번째 물건을 선택하지 않는다면, f[i][j] = f[i - 1][j]입니다. 만약 i번째 물건을 선택한다면, f[i][j] = f[i - 1][j - v[i]] + s[i]입니다. 둘 중 더 작은 값을 취합니다. 초기 조건: f[0][0] = 0, 나머지 f[0][j] = $\\infty$, j $\\in [1, V]$입니다. $\\infty$는 불가능한 상태를 나타냅니다. $-\\infty$가 아닙니다. 최종 답은 f[N][j] 중에서 f[N][j] \u0026lt;= S를 만족하는 가장 큰 j입니다. 만약 부피 제한 $S$와 개별 물건의 가치 $v_i$가 모두 매우 크고($1e9$ 수준), 동시에 물건의 개수 $N$이 매우 작다면 (최대 40개 이하) # https://www.acwing.com/solution/content/38250/\n$N \\leq 20$일 때는 모든 부분 집합을 직접 열거할 수 있습니다 (시간 복잡도 $O(2^N)$). $N \\leq 40$일 때는 $2^{40}$이 $10^{12}$ 수준이므로 직접 열거하는 것은 너무 크므로 중간 분할 검색을 사용할 수 있습니다. 복잡도를 대략 $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$로 줄일 수 있으며, 허용 가능한 시간 내에 완료할 수 있습니다. ","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"가장 기초적인 고전 배낭 문제.","title":"01 배낭 문제","type":"posts"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/las-nueve-lecciones-de-la-mochila/","section":"Series","summary":"","title":"Las Nueve Lecciones De La Mochila","type":"series"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/le-nove-lezioni-sullo-zaino/","section":"Series","summary":"","title":"Le Nove Lezioni Sullo Zaino","type":"series"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/les-neuf-le%C3%A7ons-sur-le-sac-%C3%A0-dos/","section":"Series","summary":"","title":"Les Neuf Leçons Sur Le Sac À Dos","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-lektionen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Lektionen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/series/nine-lectures-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Lectures on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-a-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre a Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-anlat%C4%B1m/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Anlatım","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/template-de-algoritmo/","section":"Tags","summary":"","title":"Template De Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Бинарный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"정렬된 해 공간이 두 부분으로 나뉘어 한 부분은 조건을 만족하고 다른 부분은 만족하지 않는 경우, 이분 탐색을 사용하여 정렬된 해 공간에서 임계점을 찾을 수 있습니다.\n이분 탐색의 기본 아이디어는 검색 간격을 반복적으로 반으로 줄이는 것입니다. 매번 중간 요소를 확인합니다. 중간 요소가 조건을 만족하지 않으면 간격의 절반을 제거할 수 있습니다. 그렇지 않으면 다른 절반에서 검색을 계속합니다. 매번 검색 간격의 절반이 버려지므로 검색 시간 복잡도는 $O(\\log n)$에 도달할 수 있습니다.\n예제 문제 # 문제 설명: 길이가 $n$인 오름차순으로 정렬된 정수 배열과 $q$개의 쿼리가 주어집니다. 각 쿼리는 정수 $k$를 제공하며, 배열에서 $k$의 \u0026ldquo;시작 위치\u0026quot;와 \u0026ldquo;끝 위치\u0026quot;를 찾아야 합니다 (인덱스는 0부터 시작). 배열에 숫자가 없으면 -1 -1을 반환합니다.\n입력 형식 # 첫 번째 줄: 배열의 길이와 쿼리 수를 나타내는 두 정수 $n$과 $q$입니다. 두 번째 줄: 오름차순으로 정렬된 전체 배열을 나타내는 $n$개의 정수입니다. 다음 $q$줄: 각 줄에는 쿼리 요소를 나타내는 정수 $k$가 포함됩니다. 데이터 범위 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n출력 형식 # 각 쿼리에 대해 배열에서 요소의 시작 및 끝 위치를 한 줄에 출력합니다. 배열에 요소가 없으면 -1 -1을 출력합니다.\n예시:\n입력: 6 3 1 2 2 3 3 4 3 4 5 출력: 3 4 5 5 -1 -1 설명:\n요소 $3$이 나타나는 범위는 $[3, 4]$입니다. 요소 $4$는 위치 $5$에서 한 번만 나타납니다. 요소 $5$는 배열에 존재하지 않으므로 $-1$ $-1$을 반환합니다. 해결 방법 # \u0026ldquo;시작 위치\u0026rdquo; 찾기: 즉, $k$보다 크거나 같은 첫 번째 위치를 찾는 것입니다. 배열은 두 부분으로 나눌 수 있습니다.\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작습니다\u0026rdquo;. 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;크거나 같습니다\u0026rdquo;. 정답은 오른쪽의 첫 번째 위치입니다. \u0026ldquo;끝 위치\u0026rdquo; 찾기: 즉, $k$보다 작거나 같은 마지막 위치를 찾는 것입니다. 배열은 두 부분으로 나눌 수 있습니다.\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작거나 같습니다\u0026rdquo;. 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;큽니다\u0026rdquo;. 정답은 왼쪽의 마지막 위치입니다. 추천 템플릿 # 다음은 우아하고 오류가 적은 이분 탐색 템플릿입니다.\n두 개의 포인터 $l, r$을 정의하고, 불변성은 닫힌 구간 $[0, l]$이 왼쪽 부분에 속하고, 닫힌 구간 $[r, n - 1]$이 오른쪽 부분에 속합니다. $l$과 $r$은 각각 $-1$과 $n$으로 초기화됩니다.\n알고리즘이 종료되면 $l$과 $r$은 인접하여 왼쪽 부분의 마지막 요소와 오른쪽 부분의 첫 번째 요소를 가리킵니다.\n우리가 원하는 해답이 존재하지 않을 수도 있으므로, 문제에서 해답이 반드시 존재한다고 명시하지 않은 경우, l 또는 r이 범위를 벗어났는지, 그리고 올바른 값을 가리키는지 확인해야 합니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k의 시작 위치 찾기 15 // 배열을 두 부분으로 나눕니다. 왼쪽 부분은 모두 \u0026lt; k이고, 오른쪽 부분은 모두 \u0026gt;= k입니다. 16 // 정답은 오른쪽 부분의 가장 작은 인덱스입니다. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음을 의미합니다. 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k의 끝 위치 찾기 33 // 배열을 두 부분으로 나눕니다. 왼쪽 부분은 모두 \u0026lt;= k이고, 오른쪽 부분은 모두 \u0026gt; k입니다. 34 // 정답은 왼쪽 부분의 가장 큰 인덱스입니다. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} 장점 # 이 접근 방식은 엄격하게 정의된 불변성을 가집니다. 추가 처리나 변경 없이 \u0026ldquo;시작 위치\u0026quot;와 \u0026ldquo;끝 위치\u0026quot;를 모두 찾는 데 적용됩니다. 일부 접근 방식에서는 l == r을 종료 조건으로 사용합니다. $l$과 $r$이 $1$만큼 차이가 나면 $mid$는 $l$ 또는 $r$과 같게 계산됩니다. 올바르게 처리하지 않으면 $l$ 또는 $r$을 $mid$로 업데이트해도 검색 간격이 줄어들지 않아 무한 루프가 발생합니다. 반면, 이 접근 방식은 $l$과 $r$이 인접할 때 종료되므로 $mid$가 $l$보다 작고 $r$보다 크며, $l$ 또는 $r$을 업데이트하면 항상 검색 간격이 줄어듭니다. STL # C++ STL에서 제공하는 lower_bound 및 upper_bound 함수를 사용하면 동일한 결과를 얻을 수 있습니다.\nlower_bound(first, last, val)은 \u0026ldquo;val보다 크거나 같은 첫 번째 위치\u0026quot;를 반환합니다. upper_bound(first, last, val)은 \u0026ldquo;val보다 큰 첫 번째 위치\u0026quot;를 반환합니다. 예를 들어, nums = {1,2,3,4,4,4,4,4,5,5,6}이고, 4가 나타나는 범위를 알고 싶다고 가정해 봅시다.\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4는 0번 나타납니다\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;첫 번째 4는 \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; \u0026#34;에 있습니다\u0026#34; \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;마지막 4는 \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; \u0026#34;에 있습니다\u0026#34; \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4는 \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34;번 나타납니다\u0026#34; \u0026lt;\u0026lt; endl; 11} it1은 값이 $4$보다 크거나 같은 첫 번째 위치를 가리킵니다. it2는 값이 $4$보다 큰 첫 번째 위치를 가리킵니다. 따라서 it2 - it1은 배열에서 $4$가 나타나는 횟수입니다. it2 - nums.begin() - 1은 $4$의 오른쪽 경계 위치입니다. 추가 참고 사항 # 이분 탐색은 부동 소수점 범위에서 검색(예: 방정식의 근 찾기)과 단봉 함수의 극값을 찾는 삼분 탐색으로 확장될 수도 있습니다.\n연습 문제 # LeetCode 33. Search in Rotated Sorted Array\n힌트: 먼저 이분 탐색을 사용하여 회전점을 찾은 다음, 이분 탐색을 사용하여 목표 값을 찾습니다.\n","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"이분 탐색 알고리즘을 우아하게 구현하는 방법.","title":"이분 탐색","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"}]