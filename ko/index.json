[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":" 1. CAP 정리 # 1.1 CAP 정리란 무엇인가 # CAP 정리는 2000년 Eric Brewer가 제안한 것으로, 핵심 내용은 다음과 같습니다.\nC(Consistency, 일관성): 시스템 내 모든 노드가 동일한 시점에 동일한 데이터를 보는 것을 의미합니다. 더 엄격하게 말하면, 클라이언트가 데이터를 읽을 때 어떤 복제본에서 읽든 결과는 최신 커밋된 데이터와 일치해야 합니다(일반적으로 강한 일관성/선형 일관성을 의미). A(Availability, 가용성): 시스템에 부분적인 장애가 발생하더라도 정상적인 서비스를 제공할 수 있어야 하며, 모든 요청은 합리적인 시간 내에 \u0026ldquo;유효한 응답\u0026rdquo;(성공뿐만 아니라 올바른 실패 응답 포함)을 받아야 합니다. P(Partition tolerance, 파티션 내성): 시스템은 네트워크 파티션(노드 간 통신이 불가능해지는 상황)을 견딜 수 있어야 하며, 네트워크 분할이 발생하더라도 시스템은 어느 정도의 가용성 또는 일관성을 제공할 수 있어야 합니다. 실제 분산 환경에서는 네트워크 파티션이 불가피하므로 P는 기본적으로 \u0026ldquo;필수 옵션\u0026quot;으로 간주됩니다. 네트워크 파티션이 발생하면 시스템은 모든 노드에 대한 데이터의 강한 일관성과 고가용성을 동시에 보장할 수 없으므로 C와 A 중에서 선택해야 하며, 그 결과 CP와 AP라는 두 가지 주요 유형이 파생됩니다.\n1.2 CAP 정리의 한계 # CAP 정리는 개념적 지침을 제공하는 상대적으로 높은 수준의 이론이며, \u0026ldquo;C를 선택하거나 A를 선택해야 한다\u0026quot;고 단순하게 이해해서는 안 된다는 점을 지적해야 합니다. 몇 가지 일반적인 오해가 있습니다.\nC가 반드시 강한 일관성을 의미하는 것은 아님 CAP 정리에서 C는 종종 가장 엄격한 의미의 일관성(즉, 선형 일관성)을 의미합니다. 그러나 실제 시스템에서는 약한 일관성, 읽기 커밋(Read Committed), 인과적 일관성(Causal Consistency) 등 다양한 세분화된 모델을 선택할 수 있습니다. 가용성이 0 또는 1인 것은 아님 CP를 선택했다고 해서 가용성이 완전히 희생되는 것은 아니며, AP를 선택했다고 해서 일관성이 전혀 보장되지 않는 것도 아닙니다. 가용성과 일관성 모두 다양한 수준의 절충 공간과 다운그레이드 전략이 있습니다. 최종 일관성은 CAP를 위반하지 않음 이는 매우 일반적인 절충안으로, 낮은 쓰기 일관성을 통해 더 높은 가용성과 처리량을 얻고, 백그라운드에서 비동기 방식으로 데이터를 수렴합니다. 따라서 CAP 정리는 다양한 일관성 모델, 고가용성 아키텍처 패턴과 함께 구체적인 시나리오에 적용해야 진정한 실질적인 지침 가치를 창출할 수 있습니다.\n2. 분산 시스템의 일관성 모델 # 일관성 모델의 분류는 매우 다양하지만, 일반적인 주류 모델은 강한 일관성과 약한 일관성(최종 일관성, 인과적 일관성 등 포함)으로 나눌 수 있습니다. 이 문서에서는 주로 강한 일관성과 최종 일관성을 소개하고, CP 또는 AP 모드에서 이들이 어떻게 사용되는지 설명합니다.\n2.1 강한 일관성 # 강한 일관성(Strong Consistency) 또는 **선형 일관성(Linearizability)**은 쓰기 작업이 성공적으로 완료되어 반환되면 이후의 모든 읽기 작업에서 해당 업데이트 내용을 읽을 수 있음을 의미합니다. 즉, 시스템은 모든 작업을 직렬로 실행한 것처럼 동작합니다.\n일반적인 구현: 동기 복제와 중재(다수파) 메커니즘에 의존하며, 프로토콜(예: Paxos/Raft)을 통해 시스템에 유효한 리더(Leader)가 하나만 있는지 확인하고, 모든 작업은 순서대로 로그에 기록되어 다수 노드로 복제됩니다. 장단점: 장점: 가장 엄격한 데이터 정확성을 보장하며, 언제든 읽는 데이터가 \u0026ldquo;롤백\u0026quot;되지 않습니다. 단점: 네트워크 불안정, 파티션 또는 리더 장애 시 일관성을 유지하기 위해 쓰기 작업이 차단되어 전체 가용성이 저하될 수 있으며, 성능과 처리량도 상대적으로 낮습니다. 2.2 최종 일관성 # **최종 일관성(Eventual Consistency)**은 약한 일관성의 대표적인 형태로, 시스템에 더 이상 새로운 업데이트 작업이 없으면 시간이 지남에 따라 모든 복제본의 데이터가 점차 동일한 상태로 수렴되는 것을 요구합니다. 그동안 사용자가 복제본 데이터를 읽으면 오래된 값을 볼 수 있지만, 결국에는 일관성이 유지됩니다.\n일반적인 구현: Gossip 프로토콜, 다중 복제본 비동기 복제, CRDT(Conflict-free Replicated Data Type) 등. 장단점: 장점: 고가용성, 고처리량, 쓰기 작업 지연 시간이 짧고, 네트워크 파티션에 대한 내성이 높습니다. 단점: 짧은 시간 동안의 데이터 불일치를 허용해야 하며, 애플리케이션 로직이 더 복잡하고, 충돌 감지 및 병합을 수행해야 할 수 있습니다. 3. 일반적인 일관성 프로토콜 및 알고리즘 # 분산 시스템 복제본 간의 일관성을 유지하기 위해 업계에서는 다양한 고전적인 알고리즘과 프로토콜을 제안했습니다. 다음은 몇 가지를 간략하게 소개합니다.\n3.1 Paxos # Paxos는 Leslie Lamport가 1990년대에 제안한 분산 일관성 알고리즘으로, 주로 강한 일관성 또는 선형 일관성을 구현하는 데 사용됩니다.\n기본 원리: 역할 분할(제안자 Proposer, 수락자 Acceptor, 학습자 Learner)을 통해 여러 번의 투표를 거쳐 작업 또는 값이 다수 노드에서 수락되는지 여부를 결정합니다. 장단점: 장점: 네트워크 파티션, 노드 장애 시에도 일관성을 달성할 수 있으며, 보안성이 매우 높습니다. 단점: 구현이 복잡하고, 디버깅 및 문제 해결이 어렵고, 여러 번의 투표로 인해 성능이 제한됩니다. 산업계에서는 변형된 형태(Multi-Paxos 등)를 많이 사용합니다. 3.2 Raft # Raft는 2013년에 공식적으로 제안되었으며, Paxos와 동일한 보안성을 보장하면서 구현 및 이해 난이도를 단순화하는 것을 목표로 합니다. 안정적인 리더(Leader) 역할을 설정하여 중앙 집중식으로 로그 복제 및 장애 복구를 수행합니다.\n주요 단계: 리더 선출(Leader Election), 로그 복제(Log Replication), 안전성(Safety) 등. 일반적인 응용: Etcd, Consul, TiKV, LogCabin 등은 Raft를 기반으로 강한 일관성 복제를 구현합니다. 장단점: 장점: 상대적으로 이해하기 쉽고, 구현 코드량이 적으며, 중소 규모 클러스터에서 성능이 좋습니다. 단점: 주 노드(리더)에 의존하며, 주 노드 장애 또는 파티션으로 인해 일시적인 쓰기 차단이 발생할 수 있습니다. 대규모 클러스터 또는 지역 간 배포 시 지연 시간과 가용성이 영향을 받을 수 있습니다. 3.3 Gossip 프로토콜 # Gossip(가십) 프로토콜은 전통적인 합의 프로토콜이 아니며, 주로 탈중앙화된 시나리오에서 노드 간의 무작위 상호 작용을 통해 메타데이터 또는 상태 정보를 교환하여 전체 네트워크에 확산 및 수렴하는 데 사용됩니다.\n특징: 탈중앙화, 낮은 오버헤드, 노드 간 주기적이고 무작위적인 메시지 교환. 일반적인 응용: Cassandra, Riak, 분산 멤버 관리(예: Serf) 등에서 최종 일관성, 복제본 상태 동기화 등을 구현하는 데 사용됩니다. 장단점: 장점: 확장성이 뛰어나고, 구현이 간단하며, 일관성 요구 사항이 높지 않고 확장성 요구 사항이 높은 시나리오에 적합합니다. 단점: 일관성 보장이 약하며, 충돌을 최종적으로 해결하기 위해 더 높은 수준의 충돌 처리 수단(예: CRDT, 버전 번호 병합 등)이 필요합니다. 3.4 2PC / 3PC # 분산 트랜잭션 시나리오에서 일반적인 커밋 프로토콜은 **2PC(Two-phase Commit)**와 **3PC(Three-phase Commit)**입니다.\n2PC: 코디네이터가 모든 참여자에게 \u0026ldquo;준비(prepare)\u0026ldquo;를 알리고, 모두 성공하면 \u0026ldquo;커밋(commit)\u0026ldquo;을 브로드캐스트하고, 그렇지 않으면 \u0026ldquo;롤백(abort)\u0026ldquo;합니다. 3PC: 2PC에 단계를 추가하여 단일 지점 장애로 인한 차단을 줄이지만, 구현이 더 복잡하고, 여전히 극단적인 네트워크 파티션 또는 장애 시나리오에서 사용할 수 없는 문제가 있습니다. 장단점: 장점: 이해하기 쉽고, 트랜잭션 의미가 명확하며, 분산 데이터베이스, 메시지 큐 등에서 널리 사용됩니다. 단점: 코디네이터에 대한 의존성이 강하고, 차단 위험이 있으며, 네트워크 파티션이 장시간 지속되면 트랜잭션을 계속 진행할 수 없습니다. 4. CAP의 두 가지 주요 선택: CP와 AP # P가 \u0026ldquo;필수\u0026rdquo; 속성으로 간주되면 분산 시스템은 네트워크 파티션 시에도 계속 서비스를 제공하려면 C와 A 중에서 선택해야 합니다. 따라서 일반적인 시스템 설계는 CP와 AP라는 두 가지 주요 진영으로 나뉩니다.\n4.1 CP 시스템 # CP(Consistency + Partition tolerance): 네트워크 파티션이 발생하면 시스템은 일관성을 우선적으로 보장하고, 필요한 경우 가용성을 희생합니다.\n일반적인 구현: 다수파 합의(Paxos, Raft 등), 과반수 노드가 활성화되어 합의에 도달해야 쓰기가 허용됩니다. 현재 쿼럼(법정 인원)에 도달할 수 없거나 주 노드에 장애가 발생하면 시스템은 쓰기 작업을 차단하거나 거부하여 데이터 불일치를 유발하는 브레인 스플릿을 방지합니다. 일반적인 응용: Zookeeper, Etcd, Consul, 분산 잠금 서비스, 분산 메타데이터 관리 등. 금융 거래 핵심 프로세스, 은행 회계 시스템 등 높은 일관성이 요구되는 시나리오. 특징: 엄격한 데이터 보장: 시스템이 중단되더라도 이중 주체 또는 데이터 혼란이 발생하지 않습니다. 일정 수준의 가용성 희생: 네트워크 파티션 또는 장애 조치 시 서비스가 일시적으로 사용할 수 없거나 쓰기 작업을 거부하는 기간이 있습니다. 4.2 AP 시스템 # AP(Availability + Partition tolerance): 네트워크 파티션이 발생하면 시스템은 가용성을 우선적으로 보장하고, 동시에 일관성을 완화합니다.\n일반적인 구현: 최종 일관성, 다중 주체 복제, Gossip 프로토콜, Dynamo 스타일의 조정 가능한 일관성 정책 등. 일반적인 응용: NoSQL 데이터베이스(Cassandra, Riak, DynamoDB 등), 분산 캐시 시스템(Redis Cluster) 등. 소셜 네트워크, 로그 수집, 추천 시스템 등 고가용성, 고처리량이 필요하고 데이터 일관성 요구 사항이 상대적으로 낮은 비즈니스. 특징: 파티션이 발생하더라도 모든 노드가 읽기 및 쓰기 요청을 계속 수신하여 시스템이 \u0026ldquo;가능한 한 사용 가능\u0026quot;하도록 보장합니다. 데이터에 일시적인 불일치가 있을 수 있지만, 비동기 동기화, 충돌 병합 등의 방식으로 백그라운드에서 점진적으로 수렴됩니다. 5. CP와 AP 중에서 어떻게 선택해야 할까요? # 실제 대규모 분산 시스템에서는 단일 모델에만 의존하는 경우는 거의 없으며, 다양한 데이터 또는 비즈니스 시나리오에 대해 계층적으로 처리하여 일관성과 가용성의 최적 균형을 추구합니다.\n핵심 데이터는 CP 선택 사용자 계정 잔액, 주문 결제, 금융 거래 내역 등 일관성 요구 사항이 매우 높습니다. 네트워크 불안정으로 인한 일시적인 쓰기 불가능을 허용하지만, 잔액 또는 거래 금액 오류는 허용할 수 없습니다. 에지 또는 캐시 데이터는 AP 선택 상품 상세 페이지 캐시, 사용자 행동 로그, 추천 후보 목록 등 일관성 요구 사항이 낮습니다. 고동시성, 고가용성을 더 중요하게 생각하며, 일정 시간의 지연 업데이트 또는 더티 리드를 허용할 수 있습니다. 많은 인터넷 기업에서 혼합 아키텍처를 채택합니다. 핵심 거래 프로세스에는 CP 스타일의 스토리지(예: 분산 관계형 데이터베이스 또는 강한 일관성을 갖는 분산 스토리지)를 사용하고, 주변 비즈니스 또는 \u0026ldquo;읽기 위주\u0026rdquo; 시나리오에는 AP 스타일의 스토리지 또는 캐시 솔루션을 사용합니다.\n6. CP와 AP는 어떻게 고동시성과 최종 일관성을 구현할까요? # 6.1 CP 시스템이 고동시성에 대처하는 방법 # 합의 프로토콜은 단일 클러스터 노드 규모와 쓰기 요청량이 많을 때 높은 지연 시간과 낮은 처리량에 직면할 수 있지만, 다음과 같은 방법으로 동시성과 확장성을 향상시킬 수 있습니다.\n일괄 읽기 및 쓰기 여러 쓰기 작업을 클라이언트 또는 중간 계층에서 패키징하여 리더 노드에 한 번에 쓰기 작업을 수행하여 네트워크 왕복 및 프로토콜 라운드를 줄입니다. 데이터베이스 분할 및 다중 클러스터 데이터를 논리적 또는 해시 방식으로 여러 클러스터(샤딩)로 분할하고, 각 클러스터 내부에서 CP 프로토콜을 계속 실행합니다. 요청은 라우팅 또는 프록시 계층을 통해 다른 샤드로 분산됩니다. 전체 동시성 기능을 향상시키고, 장애 영향을 단일 샤드 범위로 제한합니다. CP 시스템의 단일 샤드 클러스터 처리량은 AP 시스템보다 2~10배 낮은 경우가 많습니다.\n6.2 AP 시스템이 최종 일관성을 보장하는 방법 # AP 시스템은 일반적으로 높은 쓰기 처리량과 읽기 가용성을 제공할 수 있지만, 일관성을 완화하므로 백그라운드 또는 비즈니스 로직 계층에서 일관성 수렴을 보장해야 합니다.\n버전 번호(Vector Clock) 또는 논리 타임스탬프 각 업데이트 작업에 버전 번호(또는 Lamport Clock / Hybrid Clock 기반)를 할당하고, 충돌 시나리오에서 병합하거나 타임스탬프 기반 승리 전략(Last Write Wins)을 사용합니다. Gossip 프로토콜 / 반엔트로피(Anti-entropy) 메커니즘 노드가 주기적으로 최신 데이터 또는 메타데이터를 교환하고, 충돌이 발견되면 병합합니다. 조정 가능한 일관성 정책 Dynamo 모델을 대표적으로, 클라이언트는 R, W 등의 매개변수(예: 다수파 쓰기, 복제본 확인)를 구성하여 일관성과 가용성 사이에서 유연하게 조정할 수 있습니다. 사용자 정의 충돌 해결 정책 비즈니스 의미와 결합하여 병합합니다. 예를 들어, 장바구니는 \u0026ldquo;합집합\u0026quot;으로 병합하고, 카운터는 CRDT(G-counter, PN-counter 등)를 사용하여 데이터의 단조성을 보장합니다. 7. CP의 샤드 간 강한 일관성 구현 # 7장에서 언급했듯이, **데이터베이스 분할(샤딩)**을 통해 단일 CP 클러스터의 부하를 여러 하위 클러스터로 \u0026ldquo;분할\u0026quot;하여 더 높은 동시성을 지원할 수 있습니다. 그러나 비즈니스에서 샤드 간 트랜잭션(즉, 여러 데이터베이스 또는 테이블 업데이트 관련)을 실행해야 하는 경우 여전히 다중 샤드 일관성 문제가 발생합니다. 일반적으로 다음과 같은 접근 방식이 있습니다.\n분산 트랜잭션: 2PC / 3PC 애플리케이션에서 여러 샤드에 걸쳐 원자적 업데이트를 수행해야 하는 경우 일반적으로 분산 트랜잭션 프로토콜(예: 2PC, 3PC)을 사용하여 각 샤드의 커밋 또는 롤백을 조정합니다. 문제 및 해결 방법: 2PC/3PC는 모두 코디네이터 노드에 의존하므로 단일 지점 병목 현상이 될 수 있습니다. 네트워크 파티션이 심각하거나 코디네이터에 장애가 발생한 극단적인 상황에서는 차단이 발생할 수 있습니다. 일반적으로 주/종속 전환, 하트비트 감지 및 시간 초과 메커니즘, 멱등 재시도, MVCC 등을 통해 차단 영향과 데이터 불일치 위험을 줄입니다. 셀 기반 아키텍처 비즈니스를 여러 자율 셀로 분할하고, 각 셀 내의 데이터는 동일한 샤드 집합에 있으므로 대부분의 트랜잭션이 단일 셀에서 완료되도록 하여 샤드 간 작업을 줄입니다. 셀 경계에서 비동기 또는 최종 일관성 메커니즘을 사용하여 데이터 교환을 수행하여 전체 고가용성과 일관성을 모두 고려합니다. 글로벌 분산 데이터베이스 + 글로벌 합의 프로토콜 예를 들어 Google Spanner는 각 샤드에서 Paxos를 통해 복제본 강한 일관성 복제를 구현하고, TrueTime API를 사용하여 글로벌 타임스탬프를 제공하여 샤드 간 일관성을 보장합니다. 이 솔루션은 구현 복잡성이 매우 높지만, 글로벌 범위에서 강한 일관성에 가까운 분산 트랜잭션 기능을 제공할 수 있습니다. 요약: 강한 일관성이 엄격하게 요구되는 샤드 간 트랜잭션의 경우 2PC/3PC + 코디네이터가 여전히 일반적인 솔루션이며, 코디네이터의 고가용성을 최대한 높여 장애 가능성을 줄입니다. 그러나 엔지니어링 실무에서는 샤드 간 쓰기 작업을 최대한 줄이거나 셀 기반 접근 방식을 통해 대부분의 트랜잭션을 단일 샤드 범위로 제한하여 시스템 복잡성을 줄여야 합니다.\n8. 유명 사례 논의 # 다음은 업계에서 자주 언급되는 몇 가지 분산 시스템을 간략하게 살펴보고, CAP에서 이들이 어떻게 선택하고 구현하는지 살펴보겠습니다.\nGoogle Spanner 전형적인 CP 시스템(심지어 외부에서 흔히 말하는 \u0026ldquo;CA\u0026rdquo; 환상을 만들 수 있지만, 실제로는 여전히 일부 가용성을 희생해야 함). TrueTime에서 제공하는 외부 정확한 타임스탬프와 각 샤드 내부의 Paxos 복제를 사용하여 데이터 센터 간의 강한 일관성을 보장합니다. 글로벌 금융 거래 또는 높은 일관성 요구 사항 시나리오에 적합하지만, 인프라 비용이 매우 높습니다. BigTable / HBase 겉으로는 CP에 더 가깝고, RegionServer와 Master 간에 분산 조정을 통해 메타데이터의 일관성을 보장합니다. 그러나 실제 읽기 및 쓰기 경로에서도 다중 복제본 비동기 복제를 통해 일정 수준의 고가용성 수단을 제공할 수 있으며, 읽기 일관성은 애플리케이션 요구 사항에 따라 조정할 수 있습니다. AWS DynamoDB AP를 지향하며, 초기 설계는 Dynamo 논문에서 영감을 얻었으며, R, W 등의 매개변수를 통해 일관성 수준을 조정할 수 있습니다. 기본 모드에서는 매우 높은 가용성과 최종 일관성을 제공하며, \u0026ldquo;강한 일관성 읽기\u0026quot;를 활성화할 수도 있습니다(단, 단일 파티션의 강한 일관성만 보장하며, 파티션 간에는 보장하지 않음). Cassandra 마찬가지로 AP를 지향하며, 기본적으로 Gossip 프로토콜을 사용하여 노드 토폴로지 상태를 유지합니다. 읽기 및 쓰기 일관성은 읽기 및 쓰기 복제본 수 R / W를 구성하여 최종 일관성에서 더 강한 일관성으로 원활하게 전환할 수 있습니다. 비교를 통해 알 수 있듯이: 엔지니어링에는 절대적인 \u0026ldquo;AP 또는 CP\u0026quot;가 없으며, 다양한 일관성 전략이 혼합되어 있습니다. 대부분의 시스템은 다양한 애플리케이션 시나리오에 맞게 일정 수준의 조정 가능한 일관성을 제공합니다.\n9. 결론 # CAP 정리는 일률적인 것이 아님 실제 분산 시스템에서는 \u0026ldquo;C를 선택하고 A를 포기한다\u0026quot;거나 \u0026ldquo;A를 선택하고 C를 포기한다\u0026quot;고 단순하게 말할 수 없습니다. 업계에서는 다양한 데이터 차원, 다양한 작업 유형에 따라 CP 또는 AP 모드를 유연하게 선택하거나, 심지어 동일한 시스템 내에서 다른 테이블/다른 기능에 대해 다른 내결함성 및 일관성 전략을 채택하는 것이 더 일반적입니다. AP가 절대적으로 100% 사용 가능한 것은 아님 예를 들어, Cassandra, DynamoDB 등도 극단적인 네트워크 파티션 또는 노드 대규모 장애 시 요청을 충족할 수 없는 상황이 발생할 수 있습니다. AP 시스템은 설계상 \u0026ldquo;복제본을 쓸 수 있으면 먼저 쓴다\u0026quot;는 경향이 있으며, 상대적으로 더 높은 가용성과 처리량을 얻기 위해 일부 일관성 보장을 희생합니다. CP도 최대한 고가용성을 달성할 수 있음 Paxos/Raft는 정상적인 상황에서도 99.99% 이상의 가용성을 제공할 수 있지만, 더 많은 네트워크, 하드웨어 및 엔지니어링 비용이 필요하며, 극단적인 네트워크 파티션 시에는 여전히 쓰기 차단이 발생하고 일관성을 유지하기 위해 가용성을 희생합니다. 혼합 아키텍처가 주류임 핵심 거래 시나리오에서는 강한 일관성(CP)을 유지하고, 주변 보조 시나리오 또는 캐시 채널에서는 약한 일관성(AP)을 채택하여 서로 협력합니다. 비즈니스 허용 범위, 네트워크 환경, 비용 투자, 팀 기술 역량을 종합적으로 고려하여 선택해야 합니다. CAP 정리는 분산 시스템 설계에 대한 높은 수준의 사고 프레임워크를 제공하여 네트워크 파티션이라는 불가피한 현실에 직면했을 때 합리적인 결정을 내리는 데 도움이 됩니다. 실제 시스템에서는 더 풍부한 일관성 모델, 합의 프로토콜, 다중 복제본 복제 메커니즘 및 엔지니어링 실무(재해 복구, 다운그레이드, 멱등성, 충돌 병합 등)를 통해 일관성과 가용성의 균형을 맞춰야 합니다.\n","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/posts/1735350760948-cap/","section":"Posts","summary":"분산 시스템에서 CAP 정리의 응용에 대해 이론에서 실제까지 논의합니다.","title":"CAP 정리 심층 분석: 고동시성 및 고가용성 분산 시스템 구축","type":"posts"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 12월 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 12월 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"퀵 정렬은 비교 기반의 불안정 정렬 알고리즘으로, 분할 정복 방식을 사용하며 평균 시간 복잡도는 $O(n\\log n)$이고 최악의 경우 $O(n^2)$입니다. 공간 복잡도는 $O(1)$입니다. 아래에서는 정수 수열을 오름차순으로 정렬하는 예시를 통해 구현 세부 사항과 흔한 오류를 소개합니다.\n문제 설명 # 길이가 $n$인 정수 수열이 주어졌을 때, 퀵 정렬을 사용하여 오름차순으로 정렬하고 결과를 출력하세요.\n입력 형식 # 첫 번째 줄에 정수 $n$을 입력합니다. 두 번째 줄에 $n$개의 정수를 입력하며, 각 정수는 $[1, 10^9]$ 범위 내에 있습니다. 출력 형식 # 정렬된 수열을 한 줄에 출력합니다. 데이터 범위 # $1 \\leq n \\leq 100000$\n입력 예시 # 5 3 1 2 4 5 출력 예시 # 1 2 3 4 5 퀵 정렬 아이디어 # 퀵 정렬은 매 분할 시 임의의 수를 기준수 pivot으로 선택합니다(아래에서는 중간 위치의 수를 선택).\n좌우 포인터를 사용하여 서로 마주보며 이동합니다. 왼쪽 포인터 L은 왼쪽에서 오른쪽으로 이동하며 pivot보다 크거나 같은 첫 번째 수를 찾고, 오른쪽 포인터 R은 오른쪽에서 왼쪽으로 이동하며 pivot보다 작거나 같은 첫 번째 수를 찾습니다. 그런 다음 이 두 수를 교환합니다.\n이 과정을 왼쪽 포인터와 오른쪽 포인터가 겹치거나 왼쪽 포인터가 오른쪽 포인터보다 한 칸 커질 때까지 반복합니다. 이를 한 번의 순환이라고 합니다.\n각 포인터 이동 및 교환 후에는 항상 \u0026ldquo;왼쪽 부분 ≤ pivot, 오른쪽 부분 ≥ pivot\u0026rdquo; 구조가 유지되도록 합니다. 즉, 불변량 [left, L) \u0026lt;= pivot, (R, right] \u0026gt;= pivot이 유지됩니다.\n아래 예시 코드에서 left와 right는 현재 처리 중인 닫힌 구간 경계이고, pivot은 구간 중간 지점의 요소를 취합니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 복잡도 및 pivot 선택 # 최악의 경우 퀵 정렬의 복잡도는 $O(n^2)$이므로 pivot 선택이 매우 중요합니다. 항상 첫 번째 또는 마지막 요소를 선택하면 거의 정렬된 배열에서 최악의 경우가 발생할 가능성이 높습니다.\n중간 위치의 요소를 선택하는 것 외에도 임의의 요소를 pivot으로 선택하거나 왼쪽, 중간, 오른쪽 세 요소의 중앙값을 pivot으로 선택할 수 있습니다.\n흔한 오류 예시 # 아래 코드는 여러 가지 흔한 오류를 포함하고 있습니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 오류 분석:\npivot은 배열의 인덱스가 아닌 배열의 값이어야 합니다. \u0026lt;=와 \u0026gt;= 대신 각각 \u0026lt;와 \u0026gt;를 사용해야 합니다. 그렇지 않으면 왼쪽 포인터가 오른쪽 포인터를 한 칸 이상 초과할 수 있으며, 이로 인해 배열을 두 부분으로 나눌 수 없게 됩니다. l \u0026gt;= r을 발견한 후에는 즉시 루프를 종료하고 교환을 더 이상 수행하지 않아야 합니다. 그렇지 않으면 왼쪽 요소가 pivot보다 크지 않고 오른쪽 요소가 pivot보다 작지 않다는 것을 보장할 수 없습니다. 매번 교환 후에는 l++와 r--를 실행해야 합니다. pivot은 실제로 중간에서 약간 왼쪽에 있는 수를 취합니다. 따라서 $l - 1$과 $l$을 사용하여 배열을 분할하면 배열 [1, 2]의 경우 무한 루프가 발생하여 배열을 크기가 0과 2인 두 부분으로 계속 분할하게 됩니다. 마찬가지로 $r$과 $l$을 사용하여 배열을 구분하는 것도 불가능합니다. 반대로, 한 번의 순환이 끝나면 $r$은 반드시 $right$보다 작으므로 $r$과 $r+1$을 사용하여 배열을 분할할 수 있습니다. 독자는 알고리즘 과정을 시뮬레이션하여 그 이유를 확인할 수 있습니다. 무한 루프를 피하는 또 다른 간단한 방법은 pivot을 임의로 선택하거나 요소가 두 개인 경우를 특별히 처리하는 것입니다. 또한 $l$, $l+1$을 사용하는 것도 불가능합니다. 이 분할은 정의에 맞지 않기 때문입니다. $r$이 $l$ 왼쪽에 있는 경우 $l$, $l+1$을 사용하면 배열을 왼쪽은 pivot보다 작거나 같고 오른쪽은 pivot보다 크거나 같은 두 부분으로 올바르게 나눌 수 없습니다. 이 문제는 배열이 비어 있지 않다고 가정하므로 \u0026gt;의 경우는 존재하지 않습니다. 그러나 \u0026gt;=를 사용하는 것이 더 안전합니다. 추가 설명 # 퀵 정렬은 \u0026ldquo;퀵 선택\u0026quot;으로 발전하여 $O(n)$의 기대 시간 내에 정렬되지 않은 배열에서 $k$번째로 작은 수를 찾을 수 있습니다. 구체적인 아이디어는 퀵 정렬과 유사하지만 매번 한쪽 하위 구간에서만 재귀를 계속하여 시간 복잡도를 줄입니다.\n","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/posts/1735252761946-quick-sort/","section":"Posts","summary":"퀵 정렬 알고리즘을 올바르게 구현하기 위한 핵심 사항 분석.","title":"퀵 정렬","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":" 문제 # $N$개의 물건이 있습니다. $i$번째 물건의 부피는 $s_i$이고, 가치는 $v_i$입니다. 각 물건은 한 번만 가져갈 수 있습니다. 최대 총 부피 제한 $S$를 초과하지 않는다는 전제 하에, 얻을 수 있는 최대 총 가치 $V$를 구하세요.\n입력 형식 # 첫 번째 줄에는 공백으로 구분된 두 정수 $N$과 $S$가 주어지며, 각각 물건의 개수와 최대 총 부피 제한을 나타냅니다. 다음 $N$개의 줄에는 각각 공백으로 구분된 두 정수 $s_i$와 $v_i$가 주어지며, 각각 $i$번째 물건의 부피와 가치를 나타냅니다.\n출력 형식 # 최대 가치를 나타내는 정수를 출력합니다.\n데이터 범위 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 입력 예시 # 4 5 1 2 2 4 3 4 4 5 출력 예시 # 8 해결 방법 # 상태 정의: f[i][j]는 첫 번째 $i$개 물건에서 부피 제한이 $j$일 때 얻을 수 있는 최대 가치를 나타냅니다. $i$번째 물건을 선택하지 않으면 f[i][j] = f[i - 1][j]입니다. $i$번째 물건을 선택하면 f[i][j] = f[i - 1][j - s[i]] + v[i]입니다. 상태 전이를 구현할 때, 도메인 범위를 주의해야 합니다. 만약 $j \u003c s_i$이면, $i$번째 물건을 선택하는 경우를 고려하지 마십시오. 왜냐하면 $j - s_i$가 음수이면 배열 인덱스가 유효하지 않기 때문입니다. 이것은 다음과 같이 설명할 수도 있습니다. $i$번째 물건의 부피가 부피 제한보다 크므로 불가능합니다. 초기 조건 정의: 첫 번째 $0$개 물건의 경우, 어떤 부피 제한이든 가치는 $0$입니다. 즉, f[0][j] = 0, j $\\in [0, S]$입니다. 시간 복잡도: $O(NS)$. 코드 # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 1차원 DP 최적화 # 2차원 배열을 1차원 배열로 압축하면 공간을 크게 절약하고 실행 속도를 어느 정도 향상시킬 수 있습니다 (단점은 일부 문제 유형의 특수한 요구 사항을 충족할 수 없다는 것입니다). 상태 전이에서 f[i][j]는 f[i - 1][j]와 f[i - 1][j - s[i]]에만 관련되어 있다는 점에 유의하십시오. 즉, 코드의 2차원 배열 f에서 f[i][j]는 이전 행에서 왼쪽 또는 같은 열에 있는 요소에만 관련됩니다. 따라서 2차원 배열을 1차원 배열 또는 롤링 배열로 압축할 수 있습니다. 아래 코드에서 두 번째 루프는 역순으로 반복됩니다. 이는 f[i][j]를 계산할 때 f[i - 1][j - s[i]]가 아직 업데이트되지 않았는지 확인하기 위해서입니다. 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 만약 경우의 수가 필요한 경우 # 얻을 수 있는 최대 총 가치뿐만 아니라 \u0026ldquo;이 최대 총 가치를 달성할 수 있는 서로 다른 선택 방법의 수\u0026quot;도 출력해야 합니다. 다음은 01 배낭 문제에서 경우의 수를 세는 방법을 설명합니다.\n2차원 DP로 경우의 수 세기 # 다음은 2차원 DP를 예로 들어 설명합니다.\n상태 정의:\ndp[i][j]는 \u0026ldquo;용량(부피 제한)이 j인 첫 번째 i개 물건을 고려할 때 얻을 수 있는 최대 가치\u0026quot;를 나타냅니다. ways[i][j]는 \u0026ldquo;용량이 j인 첫 번째 i개 물건을 고려할 때 얻은 최대 가치에 해당하는 경우의 수\u0026ldquo;를 나타냅니다. 상태 전이:\ni번째 물건을 선택하지 않은 경우: $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ i번째 물건을 선택한 경우 (단, $ j \\ge s_i $인 경우): $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 선택 여부에 관계없이 최종 dp[i][j]는 둘 중 더 큰 값을 취해야 합니다. 만약 $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ 이면 \u0026ldquo;i번째 물건을 선택하는 것\u0026quot;이 더 큰 값을 갖는다는 의미입니다. $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ 만약 $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ 이면 두 방법으로 얻은 최대 가치가 동일하다는 의미입니다. 그러면 경우의 수를 더해야 합니다. $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ 만약 $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ 이면 \u0026ldquo;i번째 물건을 선택하지 않는 것\u0026quot;이 더 큰 값을 갖는다는 의미이며, 경우의 수는 선택하지 않을 때의 경우의 수를 상속합니다. $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 초기 조건:\ndp[0][j] = 0은 물건이 0개일 때 어떤 용량에 대해서든 얻을 수 있는 최대 가치가 0임을 의미합니다. ways[0][0] = 1은 \u0026ldquo;물건 0개, 용량 0\u0026quot;의 경우가 가능한 경우(즉, 아무것도 선택하지 않음)이며, 경우의 수는 1로 설정됩니다. j \u0026gt; 0의 경우, 선택할 물건이 없고 용량이 0보다 크면 어떤 양수 값도 얻을 수 없으며, 해당 경우의 수는 0입니다. 즉, ways[0][j] = 0입니다. 최종 답:\ndp[N][S]는 최대 가치입니다. ways[N][S]는 이 최대 가치를 달성하는 경우의 수입니다. 시간 복잡도: $O(NS)$. 이 문제는 1차원 DP를 사용하여 최적화할 수도 있습니다. 만약 정확히 부피 제한에 도달해야 하는 경우 # 상태 정의: f[i][j]는 첫 번째 i개 물건이 정확히 부피 $j$를 가질 때의 최대 가치를 나타냅니다. i번째 물건을 선택하지 않으면 f[i][j] = f[i - 1][j]입니다. i번째 물건을 선택하면 f[i][j] = f[i - 1][j - s[i]] + v[i]입니다. 상태 전이는 원래 문제와 차이가 없다는 것을 알 수 있습니다. 그러나 초기 조건이 다릅니다. f[0][0] = 0을 제외하고 나머지 f[0][j] = $-\\infty$, j $\\in [1, S]$입니다. $-\\infty$는 불가능한 상태를 나타냅니다. 만약 부피 제한 $S$가 매우 크고 (1e9), 물건의 개수 $N$과 최대 총 가치 $V$가 비교적 작은 경우 # 이러한 문제의 경우, 복잡도가 $O(NV)$인 해결 방법이 있습니다. 상태 정의: f[i][j]는 첫 번째 i개 물건에서 여러 물건을 선택할 때 총 가치가 정확히 j일 때의 최소 부피를 나타냅니다. i번째 물건을 선택하지 않으면 f[i][j] = f[i - 1][j]입니다. i번째 물건을 선택하면 f[i][j] = f[i - 1][j - v[i]] + s[i]입니다. 둘 중 더 작은 값을 취합니다. 초기 조건: f[0][0] = 0, 나머지 f[0][j] = $\\infty$, j $\\in [1, V]$입니다. $\\infty$는 불가능한 상태를 나타냅니다. $-\\infty$가 아님에 유의하십시오. 최종 답은 f[N][j]에서 f[N][j] \u0026lt;= S인 가장 큰 j입니다. 만약 부피 제한 $S$와 단일 물건의 가치 $v_i$가 모두 매우 크고 (1e9 정도), 물건의 개수 $N$이 매우 작은 경우 (40개 이하) # $N \\leq 20$인 경우, 모든 부분 집합을 무차별 대입으로 직접 열거할 수 있습니다 (시간 복잡도 $O(2^N)$). $N \\leq 40$인 경우, $2^{40}$은 $10^{12}$ 정도이므로 직접적인 무차별 대입도 비교적 크므로 중간에서 만나기 검색을 사용하여 복잡도를 대략 $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$로 줄일 수 있으며, 이는 허용 가능한 시간 내에 완료할 수 있습니다. ","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"가장 기본적인 고전적인 배낭 문제.","title":"01 배낭 문제","type":"posts"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"정렬된 해 공간이 좌우 두 부분으로 나뉘어, 한 부분은 조건을 만족하고 다른 부분은 조건을 만족하지 않는 경우, 이분 탐색을 사용하여 정렬된 해 공간에서 임계점을 찾을 수 있습니다.\n이분 탐색의 기본 아이디어는 검색 구간을 계속해서 반으로 나누는 것입니다. 매번 중간 요소를 확인하고, 중간 요소가 조건을 만족하지 않으면 한쪽 구간을 제외할 수 있습니다. 반대로, 다른 구간에서 계속 검색합니다. 매번 검색 구간의 절반을 버리기 때문에 검색 시간 복잡도는 $O(\\log n)$에 도달할 수 있습니다.\n예제 # 문제 설명:\n길이가 $n$인 오름차순으로 정렬된 정수 배열과 $q$개의 쿼리가 주어집니다. 각 쿼리는 정수 $k$를 제공하며, 배열에서 $k$의 \u0026ldquo;시작 위치\u0026quot;와 \u0026ldquo;종료 위치\u0026rdquo;(인덱스는 0부터 시작)를 찾아야 합니다. 배열에 해당 숫자가 없으면 -1 -1을 반환합니다.\n입력 형식 # 첫 번째 줄: 배열 길이와 쿼리 횟수를 나타내는 두 정수 $n$과 $q$입니다. 두 번째 줄: 오름차순으로 정렬된 전체 배열을 나타내는 $n$개의 정수입니다. 다음 $q$줄: 각 줄에는 쿼리 요소를 나타내는 정수 $k$가 포함됩니다. 데이터 범위 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n출력 형식 # 각 쿼리에 대해 배열에서 해당 요소의 시작 및 종료 위치를 한 줄에 출력합니다. 배열에 해당 요소가 없으면 -1 -1을 출력합니다.\n예시:\n입력: 6 3 1 2 2 3 3 4 3 4 5 출력: 3 4 5 5 -1 -1 설명:\n요소 $3$이 나타나는 범위는 $[3, 4]$입니다. 요소 $4$는 위치 $5$에서 한 번만 나타납니다. 요소 $5$는 배열에 없으므로 $-1$ $-1$을 반환합니다. 해답 # \u0026ldquo;시작 위치\u0026rdquo; 찾기: 즉, $k$보다 크거나 같은 첫 번째 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작습니다\u0026rdquo;. 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;크거나 같습니다\u0026rdquo;. 답은 오른쪽의 첫 번째 위치입니다. \u0026ldquo;종료 위치\u0026rdquo; 찾기: 즉, $k$보다 작거나 같은 마지막 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작거나 같습니다\u0026rdquo;. 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;큽니다\u0026rdquo;. 답은 왼쪽의 마지막 위치입니다. 추천 템플릿 # 다음은 우아하고 오류가 발생하기 쉬운 이분 탐색 템플릿입니다.\n두 개의 포인터 $l, r$을 정의합니다. 불변성은 닫힌 구간 $[0, l]$은 왼쪽 부분에 속하고, 닫힌 구간 $[r, n - 1]$은 오른쪽 부분에 속합니다. $l$과 $r$은 각각 $-1$과 $n$으로 초기화됩니다.\n알고리즘이 종료되면 $l$과 $r$은 인접하며, 각각 왼쪽 부분의 마지막 요소와 오른쪽 부분의 첫 번째 요소를 가리킵니다.\n우리가 원하는 해답이 존재하지 않을 수 있으므로, 문제에서 해답이 반드시 존재한다고 명시하지 않은 경우, l 또는 r이 범위를 벗어났는지, 올바른 값을 가리키는지 확인해야 합니다.\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k의 시작 위치 찾기 15 // 배열을 두 부분으로 나눕니다. 왼쪽은 모두 \u0026lt; k, 오른쪽은 모두 \u0026gt;= k입니다. 16 // 답은 오른쪽 부분의 최소 인덱스입니다. 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // 만약 r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음을 의미합니다. 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k의 종료 위치 찾기 33 // 배열을 두 부분으로 나눕니다. 왼쪽은 모두 \u0026lt;= k, 오른쪽은 모두 \u0026gt; k입니다. 34 // 답은 왼쪽 부분의 최대 인덱스입니다. 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} 장점 # 이 코드는 엄격하게 정의된 불변성을 가지고 있습니다. \u0026ldquo;시작 위치\u0026quot;와 \u0026ldquo;종료 위치\u0026rdquo; 두 가지 경우 모두에 적용할 수 있으며, 추가적인 처리나 변경이 필요하지 않습니다. 일부 코드는 l == r을 종료 조건으로 사용합니다. $l$과 $r$이 $1$ 차이가 나면 $mid$가 $l$ 또는 $r$과 같게 계산됩니다. 올바르게 처리하지 않으면 $l$ 또는 $r$을 $mid$로 업데이트하면 검색 구간이 줄어들지 않아 무한 루프가 발생할 수 있습니다. 반대로, 여기의 코드는 $l$과 $r$이 인접할 때 종료되므로 $mid$가 $l$보다 작고 $r$보다 크다는 것을 보장하며, $l$ 또는 $r$을 업데이트할 때 검색 구간이 반드시 줄어듭니다. STL # C++ STL에서 제공하는 lower_bound와 upper_bound 함수를 사용하면 동일한 작업을 수행할 수 있습니다.\nlower_bound(first, last, val)은 \u0026ldquo;val보다 크거나 같은 첫 번째 위치\u0026quot;를 반환합니다. upper_bound(first, last, val)은 \u0026ldquo;val보다 큰 첫 번째 위치\u0026quot;를 반환합니다. 예를 들어, nums = {1,2,3,4,4,4,4,4,5,5,6}이고 4가 나타나는 구간을 알고 싶다고 가정해 봅시다.\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1은 $4$보다 크거나 같은 첫 번째 값을 가리킵니다. it2는 $4$보다 큰 첫 번째 값을 가리킵니다.\n따라서 it2 - it1은 배열에서 $4$가 나타나는 횟수이고, it2 - nums.begin() - 1은 $4$의 오른쪽 경계 위치입니다. 추가 # 이분 탐색은 부동 소수점 범위의 검색(예: 방정식의 근 구하기) 및 삼분 탐색으로 단봉 함수의 최댓값을 구하는 데까지 확장할 수 있습니다.\n연습 # LeetCode 33. Search in Rotated Sorted Array\n힌트: 첫 번째 단계에서 이분 탐색을 사용하여 회전점을 찾고, 두 번째 단계에서 이분 탐색을 사용하여 목표 값을 찾습니다.\n","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"이분 탐색 알고리즘을 우아하게 구현하는 방법.","title":"이분 탐색","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ko/series/","section":"Series","summary":"","title":"Series","type":"series"}]