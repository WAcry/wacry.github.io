[{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 12월 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":" 이분 검색 # 정렬된 시퀀스에서 특정 요소를 찾을 때, 이분 검색을 사용하여 빠르게 완료할 수 있습니다. 선형 검색의 시간 복잡도 $O(n)$에 비해, 이분 검색은 $O(\\log n)$의 시간만 필요하므로 데이터 규모가 큰 경우 매우 효율적입니다.\n이분 검색의 핵심 아이디어 # 이분 검색의 기본 아이디어는 검색 범위를 계속해서 반으로 나누는 것입니다. 매번 중간 요소와 목표 값의 크기를 비교하여, 중간 요소가 조건을 충족하지 않으면 한쪽 범위를 제외할 수 있습니다. 반대로, 다른 절반 범위에서 계속 검색합니다. 매번 검색 범위를 반으로 줄이기 때문에 검색 시간 복잡도는 $O(\\log n)$에 도달할 수 있습니다.\n\u0026ldquo;가능한 해답을 정렬된 구간(조건 충족)과 다른 정렬된 구간(조건 불충족)으로 나눌 수 있는\u0026rdquo; 문제에 대해 이분 검색은 매우 유용합니다. 예를 들어:\n정렬된 배열에서 특정 요소의 존재 여부를 찾을 때 어떤 숫자가 나타나는 \u0026ldquo;첫 번째 위치\u0026rdquo; 또는 \u0026ldquo;마지막 위치\u0026quot;를 찾을 때 예제 문제: 요소의 시작 위치와 종료 위치 찾기 # 문제 설명:\n오름차순으로 정렬된 길이가 $n$인 정수 배열과 $q$개의 쿼리가 주어집니다. 각 쿼리는 정수 $k$를 제공하며, 배열에서 $k$의 \u0026ldquo;시작 위치\u0026quot;와 \u0026ldquo;종료 위치\u0026rdquo;(인덱스는 0부터 시작)를 찾아야 합니다. 배열에 해당 숫자가 없으면 $-1$ $-1$을 반환합니다.\n입력 형식:\n첫 번째 줄: 배열 길이와 쿼리 횟수를 나타내는 두 정수 $n$과 $q$입니다. 두 번째 줄: 전체 배열을 나타내는 $n$개의 정수(1 ~ 10000 범위)이며, 오름차순으로 정렬되어 있습니다. 다음 $q$개의 줄: 각 줄에는 쿼리 요소를 나타내는 정수 $k$가 포함됩니다. 출력 형식:\n각 쿼리에 대해, 해당 요소가 배열에서 시작하고 끝나는 위치를 한 줄에 출력합니다. 배열에 해당 요소가 없으면 $-1$ $-1$을 출력합니다.\n예제:\n입력: 6 3 1 2 2 3 3 4 3 4 5 출력: 3 4 5 5 -1 -1 설명:\n요소 3이 나타나는 범위는 [3, 4]입니다. 요소 4는 한 번만 나타나며, 위치 5에 있습니다. 요소 5는 배열에 존재하지 않으므로 -1 -1을 반환합니다. 이분 검색 응용 아이디어 # 이 문제에서 특정 값의 \u0026ldquo;왼쪽 경계\u0026quot;와 \u0026ldquo;오른쪽 경계\u0026quot;를 찾기 위해 이분 검색에 의존할 수 있습니다. 핵심은 검색 범위를 어떻게 정의하고, 비교 결과에 따라 포인터를 어떻게 이동할지 이해하는 것입니다.\n\u0026ldquo;왼쪽 경계\u0026rdquo; 찾기:\n즉, $k$보다 크거나 같은 첫 번째 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다:\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작습니다\u0026rdquo; 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;크거나 같습니다\u0026rdquo; \u0026ldquo;오른쪽 경계\u0026rdquo; 찾기:\n즉, $k$보다 작거나 같은 마지막 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다:\n왼쪽의 모든 숫자는 $k$보다 \u0026ldquo;작거나 같습니다\u0026rdquo; 오른쪽의 모든 숫자는 $k$보다 \u0026ldquo;큽니다\u0026rdquo; 이 두 범위를 올바르게 유지할 수 있다면 이분 검색을 통해 빠르게 결과를 얻을 수 있습니다.\n추천 템플릿: 데드락을 피하는 이분 검색 작성법 # 다음은 우아하고 오류가 발생하기 쉬운 이분 템플릿입니다. $l$과 $r$이 점진적으로 수렴하도록 하여, 두 값이 인접할 때 루프가 항상 종료되도록 보장합니다:\n두 포인터 $l, r$을 정의하고, 불변량: 닫힌 구간 $[0, l]$은 왼쪽 부분에 속하고, 닫힌 구간 $[r, n - 1]$은 오른쪽 부분에 속합니다. $l$과 $r$은 모두 $-1$과 $n$으로 초기화됩니다.\n알고리즘이 종료될 때, $l$과 $r$은 인접하며, 각각 왼쪽 부분의 최대값과 오른쪽 부분의 최소값을 가리킵니다.\n우리가 원하는 해답이 존재하지 않을 수도 있으므로, $l$ 또는 $r$을 반환할 때, 해당하는 값이 우리가 원하는 값인지, 범위를 벗어나는지 확인해야 합니다. 예를 들어, $l$은 $\\leq k$의 최대값을 나타내며, l != -1 \u0026amp;\u0026amp; nums[l] == k를 확인해야 합니다.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. k의 시작 위치(왼쪽 경계) 찾기 // 배열을 두 부분으로 나누어 왼쪽은 \u0026lt; k, 오른쪽은 \u0026gt;= k // 왼쪽 경계는 오른쪽 부분의 최소 인덱스입니다. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음 if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // k의 왼쪽 경계 기록 // 2. k의 종료 위치(오른쪽 경계) 찾기 // 배열을 두 부분으로 나누어 왼쪽은 \u0026lt;= k, 오른쪽은 \u0026gt; k // 오른쪽 경계는 왼쪽 부분의 최대 인덱스입니다. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // k가 존재하는지 이미 확인했으므로 여기에서 다시 확인할 필요 없음 int rightPos = l; // 오른쪽 경계 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } 이렇게 작성하면 오류가 발생하기 어려운 이유는 무엇일까요? # 이 작성법은 엄격하게 정의된 불변량을 갖습니다. 왼쪽 경계와 오른쪽 경계를 모두 찾을 수 있으므로 모든 시나리오에 적용할 수 있습니다. 일부 작성법에서는 $l == r$을 종료 조건으로 사용합니다. $l$과 $r$이 1만큼 차이날 때 $mid$가 l 또는 r과 같게 계산됩니다. 올바르게 처리하지 않으면 l 또는 r을 mid로 업데이트하여 검색 범위가 줄어들지 않아 데드락이 발생할 수 있습니다. 반대로, 여기의 작성법은 $l$과 $r$이 인접할 때 종료되므로 이 문제를 피할 수 있습니다. STL 해법: lower_bound 및 upper_bound # C++ STL에서 제공하는 lower_bound 및 upper_bound 함수를 사용하면 같은 작업을 쉽게 완료할 수 있습니다:\nlower_bound(first, last, val)은 \u0026ldquo;val보다 크거나 같은 첫 번째 위치\u0026quot;를 반환합니다. upper_bound(first, last, val)은 \u0026ldquo;val보다 큰 첫 번째 위치\u0026quot;를 반환합니다. 예를 들어, nums = {1,2,3,4,4,4,4,4,5,5,6}이라고 가정하고 4가 나타나는 구간을 알고 싶다면 다음과 같습니다:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // 배열에 4가 존재하지 않음을 나타냄 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; } it1은 값 4보다 크거나 같은 첫 번째 위치를 가리킵니다. it2는 값 4보다 큰 첫 번째 위치를 가리킵니다.\n따라서 it2 - it1은 배열에서 4가 나타나는 횟수이고, it2 - nums.begin() - 1은 4의 오른쪽 경계입니다. 이 두 함수는 구간을 찾거나 나타나는 횟수를 통계할 때 특히 편리합니다.\n추가 사항 # 이분 검색은 부동 소수점 범위 검색(예: 방정식 근 구하기)과 단봉 함수의 최댓값을 찾는 삼분 검색으로 확장될 수도 있습니다. \u0026ldquo;정렬된 구간에서 매번 절반을 제외할 수 있다\u0026quot;는 핵심 원리를 이해하면 이분 검색이 많은 시나리오에서 문제를 효율적으로 해결하는 데 도움이 된다는 것을 알게 될 것입니다.\n과제 # LeetCode 33. Search in Rotated Sorted Array\n힌트: 첫 번째 단계에서 이분 검색을 사용하여 회전점을 찾고, 두 번째 단계에서 이분 검색을 사용하여 목표 값을 찾습니다.\n","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"정수 이분 검색 알고리즘을 우아하게 구현하는 방법","title":"이분 검색","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","externalUrl":null,"permalink":"/ko/series/","section":"Series","summary":"","title":"Series","type":"series"}]