[{"content":" 問題 # $N$ 個の品物があります。$i$ 番目の品物の体積は $s_i$、価値は $v_i$ です。 各品物は一度しか取ることができません。最大総体積制限 $S$ を超えない範囲で、取得できる最大総価値 $V$ を求めてください。\n入力形式 # 1行目に2つの整数 $N, S$ が空白で区切られて与えられます。それぞれ品物の数と最大総体積制限を表します。 続く $N$ 行に、各行に2つの整数 $s_i, v_i$ が空白で区切られて与えられます。それぞれ $i$ 番目の品物の体積と価値を表します。\n出力形式 # 最大価値を表す整数を1つ出力します。\nデータ範囲 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 入力例 # 4 5 1 2 2 4 3 4 4 5 出力例 # 8 解法 # 状態の定義: f[i][j] は、最初の $i$ 個の品物で、体積制限が $j$ である場合に得られる最大価値を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を選ぶ場合、f[i][j] = f[i - 1][j - s[i]] + v[i] 状態遷移を実装する際には、定義域の範囲に注意する必要があります。$j \u003c s_i$ の場合、$i$ 番目の品物を選ぶケースは考慮しません。なぜなら、$j-s_i$ が負の数になる場合、配列の添え字が不正になるからです。 あるいは、$i$ 番目の品物の体積が体積制限よりも大きいので、不可能であると解釈することもできます。 初期条件の定義: 最初の $0$ 個の品物の場合、どのような体積制限でも価値は $0$ になるので、f[0][j] = 0、$j$ $\\in [0, S]$ です。 時間計算量: $O(NS)$。 コード # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 一次元DPの最適化 # 二次元配列を一次元配列に圧縮することで、大幅な空間削減と一定程度の実行速度向上が可能です（欠点は、一部の特殊な問題要件を満たせないことです）。 状態遷移では、f[i][j] は f[i - 1][j] と f[i - 1][j - s[i]] のみに依存することに注意してください。言い換えると、コード中の二次元配列 f では、 f[i][j] はその前の行の左側にある要素または同じ列の要素のみに依存するため、二次元配列を一次元配列またはローリング配列に圧縮することができます。 下のコードでは、二番目のループが逆順に走査していることに注意してください。これは、f[i][j] を計算する際に、f[i - 1][j - s[i]] がまだ更新されていないことを保証するためです。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} 解法の数を求める場合 # 取得できる最大総価値を出力するだけでなく、「この最大総価値を達成できる異なる選択方法の数はいくつあるか」を出力する必要があります。以下に、01ナップサック問題で解法の数を数える方法を紹介します。\n二次元DPによる解法数の統計 # 以下では、二次元DPを例に解説します。\n状態の定義：\ndp[i][j] は「最初の i 個の品物で、容量（体積制限）が j のときに得られる最大価値」を表します。 ways[i][j] は「最初の i 個の品物で、容量が j のときに、最大価値を達成する解法の数」を表します。 状態遷移：\n$i$ 番目の品物を選ばない場合： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ $i$ 番目の品物を選ぶ場合（前提は $ j \\ge s_i $）： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 選ぶか選ばないか、最終的に dp[i][j] は2つのうち大きい方を取る必要があります： もし $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ ならば、「$i$ 番目の品物を選ぶ」方が価値が大きいことを示します： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ もし $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ ならば、2つの方法で得られる最大価値が同じであることを示します。したがって、解法の数は加算する必要があります： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ もし $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ ならば、「$i$ 番目の品物を選ばない」方が価値が大きいことを示します。解法の数は選ばない場合の解法の数を継承します： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 初期条件：\ndp[0][j] = 0 は、最初の0個の品物の場合、どんな容量でも得られる最大価値は0であることを示します。 ways[0][0] = 1 は、「最初の0個の品物、容量が0」という状態が1つの実行可能な解法であることを示します（つまり何も選ばない）。解法の数は1に設定されます。 j \u0026gt; 0 の場合、選べる品物がないときに容量が0より大きければ、どんな正の価値も得られないため、対応する解法の数は0、つまり ways[0][j] = 0 です。 最終的な答え：\ndp[N][S] は最大価値です。 ways[N][S] は、その最大価値に到達する解法の数です。 時間計算量：$O(NS)$。 この問題は、一次元DPで最適化することもできます。 体積制限にちょうど一致する場合を求める場合 # 状態の定義: f[i][j] は、最初の i 個の品物で、体積がちょうど $j$ である場合の最大価値を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を選ぶ場合、f[i][j] = f[i - 1][j - s[i]] + v[i] 元の問題の状態遷移と違いがないことに注意できます。 ただし、初期条件が異なります。f[0][0] = 0 に加え、残りの f[0][j] = $-\\infty$、j $\\in [1, S]$。$-\\infty$ は不可能な状態を表します。 体積制限 $S$ が非常に大きい (1e9) が、品物の数 $N$ と最大総価値 $V$ が比較的小さい場合 # このような問題の場合、計算量が $O(NV)$ の解法があります。 状態の定義: f[i][j] は、最初の i 個の品物からいくつか選び、価値の合計がちょうど j になる場合の最小体積を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を選ぶ場合、f[i][j] = f[i - 1][j - v[i]] + s[i] 2つのうち小さい方を取ります。 初期条件: f[0][0] = 0 で、残りの f[0][j] = $\\infty$、j $\\in [1, V]$。$\\infty$ は不可能な状態を表します。 $-\\infty$ ではありません。 最終的な答えは f[N][j] の中で f[N][j] \u0026lt;= S を満たす最大の j になります。 体積制限 $S$ と個々の品物の価値 $v_i$ がどちらも非常に大きい（$1e9$ のオーダー）が、品物の数 $N$ が非常に小さい（最大でも40以下）場合 # $N \\leq 20$ の場合、すべての部分集合を直接列挙する総当たり法が使えます（時間計算量 $O(2^N)$）。 $N \\leq 40$ の場合、$2^{40}$ が $10^{12}$ オーダーなので、直接的な総当たり法は大きくなりすぎます。そのため、半分全列挙を利用することで、計算量を $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ 程度に減らすことができ、許容できる時間内に完了できます。 ","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"最も基本的な古典的なナップサック問題。","title":"01背包問題","type":"posts"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/series/ch%C3%ADn-b%C3%A0i-gi%E1%BA%A3ng-v%E1%BB%81-c%C3%A1i-t%C3%BAi/","section":"Series","summary":"","title":"Chín Bài Giảng Về Cái Túi","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/series/lezioni-sul-problema-dello-zaino/","section":"Series","summary":"","title":"Lezioni Sul Problema Dello Zaino","type":"series"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelo-de-algoritmo/","section":"Tags","summary":"","title":"Modelo De Algoritmo","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/series/neuf-conf%C3%A9rences-sur-les-sacs-%C3%A0-dos/","section":"Series","summary":"","title":"Neuf Conférences Sur Les Sacs À Dos","type":"series"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/series/neun-vorlesungen-zum-rucksackproblem/","section":"Series","summary":"","title":"Neun Vorlesungen Zum Rucksackproblem","type":"series"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/series/nine-chapters-on-knapsack-problems/","section":"Series","summary":"","title":"Nine Chapters on Knapsack Problems","type":"series"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/series/nove-palestras-sobre-mochila/","section":"Series","summary":"","title":"Nove Palestras Sobre Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/series/nueve-lecciones-sobre-la-mochila/","section":"Series","summary":"","title":"Nueve Lecciones Sobre La Mochila","type":"series"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantilla-de-algoritmo/","section":"Tags","summary":"","title":"Plantilla De Algoritmo","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/series/s%C4%B1rt-%C3%A7antas%C4%B1-dokuz-ders/","section":"Series","summary":"","title":"Sırt Çantası Dokuz Ders","type":"series"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/series/%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D1%8C-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Series","summary":"","title":"Девять Лекций О Рюкзаке","type":"series"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%97%E0%A4%A4%E0%A4%BF%E0%A4%B6%E0%A5%80%E0%A4%B2-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"गतिशील प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/series/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%A8%E0%A5%8C-%E0%A4%B5%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%96%E0%A5%8D%E0%A4%AF%E0%A4%BE%E0%A4%A8/","section":"Series","summary":"","title":"बैग नौ व्याख्यान","type":"series"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A5%88%E0%A4%97-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"बैग समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95/","section":"Tags","summary":"","title":"동적 계획법","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/series/%EB%B0%B0%EB%82%AD-9%EA%B0%95/","section":"Series","summary":"","title":"배낭 9강","type":"series"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/series/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"ナップサック九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"もし、順序付けられた解空間が左右の二つの部分に分けられ、一方の部分が条件を満たし、もう一方の部分が条件を満たさない場合、二分探索を使用して順序付けられた解空間で臨界点を見つけることができます。\n二分探索の基本的な考え方は、探索区間を絶えず半分に分割することです。毎回、中点の要素をチェックし、もし中点の要素が条件を満たさない場合は、区間の半分を排除することができます。そうでない場合は、もう半分の区間で探索を続けます。毎回探索区間の半分を破棄するため、探索時間計算量は $O(\\log n)$ に達することができます。\n例題 # 問題の説明：\n長さ $n$ の昇順にソートされた整数配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内の $k$ の「開始位置」と「終了位置」（インデックスは 0 から始まる）を見つける必要があります。もし配列中にこの数が存在しない場合は、-1 -1 を返します。\n入力形式 # 1行目：2つの整数 $n$ と $q$ が与えられます。それぞれ配列の長さとクエリの回数を表します。 2行目：$n$ 個の整数が与えられます。これは完全な配列を表し、昇順にソートされています。 次の $q$ 行：各行には整数 $k$ が含まれており、これはクエリ要素を表します。 データ範囲 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n出力形式 # 各クエリに対し、配列内の要素の開始位置と終了位置を1行に出力します。もし配列中にその要素が存在しない場合は、-1 -1 を出力します。\nサンプル：\n入力： 6 3 1 2 2 3 3 4 3 4 5 出力： 3 4 5 5 -1 -1 解説：\n要素 $3$ が出現する範囲は $[3, 4]$ です。 要素 $4$ は1度だけ出現し、位置 $5$ にあります。 要素 $5$ は配列中に存在しないため、$-1$ $-1$ を返します。 解答 # 「開始位置」を見つける： これは、最初の $k$ 以上となる位置を見つけることです。配列を2つの部分に分割できます。\n左側のすべての数は $k$ より「小さい」。 右側のすべての数は $k$ 以上である。 答えは右側の最初の位置です。 「終了位置」を見つける： これは、最後の $k$ 以下となる位置を見つけることです。配列を2つの部分に分割できます。\n左側のすべての数は $k$ 以下である。 右側のすべての数は $k$ より「大きい」。 答えは左側の最後の位置です。 おすすめテンプレート # 以下は、エレガントで間違いにくい二分探索のテンプレートです。これは、$l$ と $r$ を徐々に近づけることで、ループが両者の隣接時に必ず終了することを保証します。\n2つのポインタ $l, r$ を定義し、不変条件は：閉区間 $[0, l]$ はすべて左側の部分に属し、閉区間 $[r, n - 1]$ はすべて右側の部分に属する。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化します。\nアルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左側の最後の要素と右側の最初の要素を指します。\n探している解が存在しない可能性があるため、問題に必ず解が存在すると記載されていない場合は、l または r が範囲外に出ていないか、正しい値を指しているかを確認する必要があります。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k の開始位置を探す 15 // 配列を2つの部分に分割し、左側はすべて \u0026lt; k、右側はすべて \u0026gt;= k。 16 // 答えは右側の最小インデックス。 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // もし r が範囲外か nums[r] != k の場合、k が存在しない 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k の終了位置を探す 33 // 配列を2つの部分に分割し、左側はすべて \u0026lt;= k、右側はすべて \u0026gt; k。 34 // 答えは左側の最大インデックス。 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 return 0; 46} この書き方をする理由 # この書き方には、厳密に定義された不変条件があります。 これは、「開始位置」と「終了位置」の両方を求める場合に適用でき、追加の処理や変更は必要ありません。 一部の書き方では、l == r を終了条件として使用しています。$l$ と $r$ が $1$ だけ異なる場合、$mid$ が $l$ または $r$ と同じ値になることがあります。もし適切に処理しないと、$l$ または $r$ を $mid$ に更新したときに、検索区間が縮小せず、無限ループにつながる可能性があります。逆に、ここの書き方は、$l$ と $r$ が隣接したときに終了するため、$mid$ が $l$ より小さく $r$ より大きいことを保証し、$l$ または $r$ を更新すると検索区間が必ず縮小します。 STL # もし C++ STL で提供される lower_bound と upper_bound 関数を使用すると、同じことを実現できます。\nlower_bound(first, last, val) は「最初の val 以上の位置」を返します。 upper_bound(first, last, val) は「最初の val より大きい位置」を返します。 例として、もし nums = {1,2,3,4,4,4,4,4,5,5,6} で、4 が出現する区間を知りたいとします。\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 は、最初の値が $4$ 以上の位置を指します。 it2 は、最初の値が $4$ より大きい位置を指します。 なので、it2 - it1 は配列中で $4$ が出現する回数であり、 it2 - nums.begin() - 1 は $4$ の右境界です。 補足 # 二分探索は、浮動小数点数の範囲での探索（例えば、方程式の根を求める）や、単峰関数の最大値を求めるための三分探索にも拡張できます。 「順序付けられた区間内で、毎回半分を排除できる」というコアな原理を理解すれば、二分探索が多くの場面で効率的に問題を解決できることに気づくでしょう。\n練習 # LeetCode 33. Search in Rotated Sorted Array\nヒント：最初に二分探索を使用して回転点を見つけ、次に二分探索を使用して目標値を見つけます。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"二分探索アルゴリズムをエレガントに実装する方法。","title":"二分探索","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/","section":"Series","summary":"","title":"背包九讲","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/series/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AC%9B/","section":"Series","summary":"","title":"背包九講","type":"series"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"}]