[{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/cap-teoremi/","section":"Tags","summary":"","title":"CAP Teoremi","type":"tags"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/tags/cap-theorem/","section":"Tags","summary":"","title":"CAP Theorem","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/cap-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%AE%E0%A5%87%E0%A4%AF/","section":"Tags","summary":"","title":"CAP प्रमेय","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/cap-%EC%A0%95%EB%A6%AC/","section":"Tags","summary":"","title":"CAP 정리","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/cap-%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP 定理","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/cap%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"CAP定理","type":"tags"},{"content":" 一、CAP定理 # 1.1 CAP定理とは # CAP定理は、2000年にEric Brewerによって提唱されたもので、その核心的な考え方は以下のとおりです。\nC（Consistency、一貫性）：システム内のすべてのノードが、同じ瞬間に同じデータを見ている状態を指します。より厳密に言えば、クライアントがデータを読み取る際、どのレプリカから読み取っても、結果は最新のコミットされたデータと一致している必要があります（通常、強い一貫性/線形一貫性を指します）。 A（Availability、可用性）：システムが部分的な障害が発生した場合でも、正常なサービスを提供し続けることができる状態を指します。すべてのリクエストが妥当な時間内に「有効な応答」（必ずしも成功だけでなく、正しい失敗応答も含む）を得られる必要があります。 P（Partition tolerance、分断耐性）：システムがネットワーク分断（ノード間の通信が到達不能になる）を許容できる状態を指します。ネットワークが分断された場合でも、システムはある程度の可用性または一貫性を提供できる必要があります。 実際の分散環境では、ネットワーク分断は避けられないため、Pは基本的に「必須」と見なされます。ネットワーク分断が発生した場合、システムはすべてのノードのデータの強い一貫性と高可用性を同時に両立させることはできず、CとAのどちらかを選択する必要があります。これにより、CPとAPという2つの主要なタイプが派生しました。\n1.2 CAP定理の限界 # 注意すべき点は、CAP定理自体が比較的高レベルの理論であり、概念的な指針として適用されるべきであり、「Cを選ぶか、Aを選ぶか」と単純に理解すべきではないということです。以下のような一般的な誤解があります。\nCは必ずしも強い一貫性ではない CAP定理におけるCは、最も厳密な意味での一貫性（すなわち線形一貫性）を指すことが多いです。しかし、実際のシステムでは、弱い一貫性、読み取りコミット（Read Committed）、因果一貫性（Causal Consistency）など、多くの細粒度モデルを選択できます。 可用性は0か1ではない CPを選んだからといって、可用性が完全に犠牲になるわけではありません。また、APを選んだからといって、一貫性が全く保証されないわけでもありません。可用性と一貫性には、さまざまな程度のトレードオフとダウングレード戦略が存在します。 結果整合性はCAPに違反しない これは非常に一般的な妥協案であり、低い書き込み一貫性と引き換えに、より高い可用性とスループットを実現し、バックグラウンドで非同期的にデータを収束させます。 したがって、CAP定理は、さまざまな一貫性モデルや高可用性アーキテクチャパターンと具体的なシナリオを組み合わせて初めて、真の具体的な指導価値を生み出すことができます。\n二、分散システムの一貫性モデル # 一貫性モデルの分類は非常に豊富ですが、一般的な主流モデルは、強い一貫性と弱い一貫性（結果整合性、因果一貫性などを含む）に大別できます。この記事では、主に強い一貫性と結果整合性を紹介し、それらがCPまたはAPモードでどのように一般的に使用されるかを説明します。\n2.1 強い一貫性 # **強い一貫性（Strong Consistency）**は、**線形一貫性（Linearizability）**とも呼ばれ、一度書き込み操作が完了して成功が返された場合、その後のすべての読み取り操作でその更新内容を読み取ることができる状態を指します。つまり、システムはすべての操作をシリアルに実行したかのように外部に振る舞います。\n一般的な実装：同期レプリケーションと仲裁（多数派）メカニズムに依存し、プロトコル（Paxos/Raftなど）を通じて、システム内に有効なリーダー（Leader）が1つだけであることを保証します。すべての操作はログに順番に書き込まれ、多数のノードに複製されます。 メリットとデメリット： メリット：最も厳密なデータの正確性を保証し、いつでも読み取ったデータが「ロールバック」することはありません。 デメリット：ネットワークの揺れ、分断、またはリーダーの障害が発生した場合、一貫性を維持するために書き込み操作がブロックされることが多く、全体的な可用性が低下します。パフォーマンスとスループットも比較的低くなります。 2.2 結果整合性 # **結果整合性（Eventual Consistency）**は、弱い一貫性の典型的な形式であり、システムに新しい更新操作がなくなった場合、時間の経過とともに、すべてのレプリカのデータが徐々に同じ状態に収束することを要求するだけです。その間、ユーザーがレプリカデータを読み取ると、古い値が表示される可能性がありますが、最終的には一貫性が保たれます。\n一般的な実装：Gossipプロトコル、マルチレプリカ非同期レプリケーション、CRDT（Conflict-free Replicated Data Type）など。 メリットとデメリット： メリット：高可用性、高スループット、書き込み操作の遅延が少なく、ネットワーク分断に対する耐性が高い。 デメリット：短時間でのデータ不整合を許容する必要があり、アプリケーションロジックがより複雑になり、競合検出とマージが必要になる場合があります。 三、一般的な一貫性プロトコルとアルゴリズム # 分散システムのレプリカ間で一貫性を保つために、業界では多くの古典的なアルゴリズムとプロトコルが提案されています。以下に、いくつかの簡単な紹介をします。\n3.1 Paxos # Paxosは、1990年代にLeslie Lamportによって提案された分散一貫性アルゴリズムであり、主に強い一貫性または線形一貫性を実現するために使用されます。\n基本原理：役割分担（提案者Proposer、承認者Acceptor、学習者Learner）を通じて、複数回の投票を行い、操作または値が多数のノードによって受け入れられるかどうかを決定します。 メリットとデメリット： メリット：ネットワーク分断やノード障害が発生した場合でも、一貫性を達成でき、非常に高い安全性を備えています。 デメリット：実装が複雑で、デバッグとトラブルシューティングが難しく、複数回の投票によりパフォーマンスが制限されます。業界では、そのバリアント（Multi-Paxosなど）がよく使用されます。 3.2 Raft # Raftは2013年に正式に提案され、Paxosと同等の安全性を保証することを前提に、実装と理解の難易度を簡素化することを目標としています。安定した**リーダー（Leader）**の役割を確立し、集中型でログの複製と障害回復を行います。\n重要な段階：リーダー選出（Leader Election）、ログ複製（Log Replication）、安全性（Safety）など。 一般的な応用：Etcd、Consul、TiKV、LogCabinなどは、Raftに基づいて強い一貫性のある複製を実現しています。 メリットとデメリット： メリット：比較的理解しやすく、実装コード量が少ない。中小規模のクラスターではパフォーマンスが良好です。 デメリット：主ノード（Leader）に依存しており、主ノードの障害や分断は、一時的な書き込みブロックを引き起こします。大規模なクラスターや地域をまたがるデプロイでは、遅延と可用性が影響を受ける可能性があります。 3.3 Gossipプロトコル # Gossip（噂）プロトコルは、従来のコンセンサスプロトコルではなく、主に分散型のシナリオで、ノードがランダムに相互作用してメタデータや状態情報を交換し、ネットワーク全体に拡散および収束させるために使用されます。\n特徴：分散型、低コスト、ノード間で定期的にランダムにメッセージを交換します。 一般的な応用：Cassandra、Riak、分散メンバー管理（Serfなど）などで、結果整合性、レプリカ状態の同期などを実現するために使用されます。 メリットとデメリット： メリット：拡張性が高く、実装が簡単で、一貫性の要求が低く、拡張性の要求が高いシナリオに適しています。 デメリット：一貫性の保証が弱く、競合を最終的に解決するために、より高度な競合処理手段（CRDT、バージョン番号のマージなど）が必要です。 3.4 2PC / 3PC # 分散トランザクションのシナリオでは、一般的なコミットプロトコルは**2PC（Two-phase Commit）と3PC（Three-phase Commit）**です。\n2PC：コーディネーターはすべての参加者に「プリコミット（prepare）」を通知し、すべて成功した場合は「コミット（commit）」をブロードキャストし、それ以外の場合は「ロールバック（abort）」します。 3PC：2PCに基づいて段階を追加し、単一障害点によるブロックを減らしますが、実装がより複雑になり、極端なネットワーク分断や障害シナリオでは依然として利用できない問題があります。 メリットとデメリット： メリット：理解しやすく、トランザクションセマンティクスが明確で、分散データベースやメッセージキューなどで広く使用されています。 デメリット：コーディネーターへの依存性が高く、ブロックのリスクがあります。ネットワークが長期間分断された場合、トランザクションを続行できない可能性があります。 四、CAPの2つの主流な選択：CPとAP # Pが「必須」の属性であると認識した場合、分散システムがネットワーク分断時にサービスを提供し続けるためには、CとAの間で選択する必要があります。一般的なシステム設計は、CPとAPの2つの主要な陣営に分かれます。\n4.1 CPシステム # CP（Consistency + Partition tolerance）：ネットワーク分断が発生した場合、システムは一貫性を優先的に保証し、必要に応じて可用性を犠牲にします。\n典型的な実装： 多数派コンセンサス（Paxos、Raftなど）。書き込みを許可するには、過半数のノードが存続し、合意に達する必要があります。 現在、クォーラム（法定数）に達することができない場合、または主ノードが故障した場合、システムは書き込み操作をブロックまたは拒否し、脳分裂によるデータ不整合を防ぎます。 一般的な応用： Zookeeper、Etcd、Consul、分散ロックサービス、分散メタデータ管理など。 金融取引のコアプロセス、銀行の会計システムなど、高い一貫性が要求されるシナリオ。 特徴： 厳格なデータ保証：二重の主ノードやデータの混乱が発生するよりも、停止することを選択します。 一定の可用性を犠牲にする：ネットワーク分断やフェイルオーバーが発生した場合、サービスが利用できないか、書き込み操作が拒否される期間があります。 4.2 APシステム # AP（Availability + Partition tolerance）：ネットワーク分断が発生した場合、システムは可用性を優先的に保証し、同時に一貫性を緩和します。\n典型的な実装： 結果整合性、マルチマスターレプリケーション、Gossipプロトコル、Dynamoスタイルの調整可能な一貫性ポリシーなど。 一般的な応用： NoSQLデータベース（Cassandra、Riak、DynamoDBなど）、分散キャッシュシステム（Redis Cluster）など。 ソーシャルネットワーク、ログ収集、レコメンデーションシステムなど、高可用性、高スループットが必要で、データの一貫性に対する要求が比較的緩いビジネス。 特徴： 分断が発生した場合でも、すべてのノードが読み取りおよび書き込みリクエストを受け入れ、システムが「可能な限り利用可能」であることを保証します。 データに一時的な不整合が存在する可能性がありますが、非同期同期、競合マージなどの方法でバックグラウンドで徐々に収束します。 五、CPとAPのどちらを選択するか？ # 実際の大規模な分散システムでは、単一のモデルにのみ依存することはほとんどなく、さまざまなデータまたはビジネスシナリオに対して階層化された処理を行い、一貫性と可用性の最適なバランスを追求します。\nコアデータにはCPを選択 ユーザーアカウントの残高、注文支払い、金融取引フローなど、一貫性が非常に要求されるもの。 ネットワークの揺れによる一時的な書き込み不可を許容しますが、残高や取引金額のエラーは許容できません。 エッジまたはキャッシュデータにはAPを選択 商品詳細ページのキャッシュ、ユーザー行動ログ、レコメンデーション候補リストなど、一貫性の要求が低いもの。 高並行性、高可用性を重視し、一定時間の遅延更新やダーティリードを許容できます。 多くのインターネット企業はハイブリッドアーキテクチャを採用しています。コアトランザクションプロセスにはCPスタイルのストレージ（分散リレーショナルデータベースや強い一貫性のある分散ストレージなど）を使用し、周辺ビジネスや「読み取りが多い書き込みが少ない」シナリオにはAPスタイルのストレージまたはキャッシュソリューションを使用します。\n六、CPとAPはどのように高並行性と結果整合性を実現するか # 6.1 CPシステムはどのように高並行性に対応するか # コンセンサスプロトコルは、単一のクラスターノードの規模と書き込みリクエストの量が多い場合、高い遅延と低いスループットに直面しますが、以下の方法で並行性と拡張性を向上させることができます。\nバッチ読み書き 複数の書き込み操作をクライアントまたは中間層でパッケージ化し、リーダーノードに一度に書き込むことで、ネットワークラウンドトリップとプロトコルラウンドを削減します。 データベース分割とテーブル分割＆マルチクラスター データを論理的またはハッシュで複数のクラスター（シャーディング）に分割します。各クラスター内では、引き続きCPプロトコルを実行します。リクエストは、ルーティングまたはプロキシ層を介して異なるシャードに分散されます。 全体的な並行性を向上させ、障害の影響を単一のシャード範囲に制限します。 CPシステムの単一シャードクラスターのスループットは、APシステムよりも2〜10倍低いことがよくあります。\n6.2 APシステムはどのように結果整合性を保証するか # APシステムは通常、高い書き込みスループットと読み取り可用性を提供できますが、一貫性を緩和するため、バックグラウンドまたはビジネスロジック層で一貫性収束の保証を実装する必要があります。\nバージョン番号（Vector Clock）または論理タイムスタンプ 各更新操作にバージョン番号（またはLamport Clock / Hybrid Clockに基づく）を割り当て、競合シナリオでマージするか、タイムスタンプに基づく優先戦略（Last Write Wins）を使用します。 Gossipプロトコル/反エントロピー（Anti-entropy）メカニズム ノードは定期的に最新のデータまたはメタデータを交換し、競合を発見した場合はマージします。 調整可能な一貫性ポリシー Dynamoモデルを代表として、クライアントはR、Wなどのパラメーター（多数派への書き込み、レプリカ確認など）を設定でき、一貫性と可用性の間で柔軟に調整できます。 カスタム競合解決ポリシー ビジネスセマンティクスと組み合わせてマージします。たとえば、ショッピングカートは「和集合」でマージし、カウンターはCRDT（G-counter、PN-counterなど）を使用してデータの単調性を保証します。 七、CPのクロスシャードの強い一貫性の実現 # 第7章で述べたように、データベース分割とテーブル分割（シャーディング）を使用すると、単一のCPクラスターの負荷を複数のサブクラスターに「分割」して、より高い並行性をサポートできます。ただし、ビジネスがクロスシャードトランザクション（複数のデータベースまたはテーブルの更新を含む）を実行する必要がある場合、依然としてマルチシャードの一貫性という課題に直面します。通常、次の考え方があります。\n分散トランザクション：2PC / 3PC アプリケーションが複数のシャードにまたがってアトミックな更新を実行する必要がある場合は、通常、分散トランザクションプロトコル（2PC、3PCなど）を使用して、各シャードのコミットまたはロールバックを調整します。 問題と対策： 2PC/3PCはどちらもコーディネーターノードに依存しており、単一のボトルネックになる可能性があります。 ネットワーク分断が深刻な場合やコーディネーターが故障した極端な状況では、ブロックが発生する可能性があります。 一般的に、マスター/スレーブの切り替え、ハートビート検出とタイムアウトメカニズム、べき等再試行、MVCCなどを使用して、ブロックの影響とデータ不整合のリスクを軽減します。 セルベース（Cell-based）アーキテクチャ ビジネスを複数の自律ユニットに分割します。各ユニット内のデータは同じシャードセットにあり、ほとんどのトランザクションが単一のユニット内で完了することを保証し、クロスシャード操作を減らします。 ユニット境界で非同期または結果整合性メカニズムを使用してデータを交換し、全体的な高可用性と一貫性を両立させます。 グローバル分散データベース+グローバルコンセンサスプロトコル たとえば、Google Spannerは、各シャード（Shard）でPaxosを使用してレプリカの強い一貫性のある複製を実現し、TrueTime APIを使用してグローバルタイムスタンプを提供し、クロスシャードの一貫性を保証します。 このソリューションは実装が非常に複雑ですが、グローバル範囲でほぼ強い一貫性のある分散トランザクション機能を提供できます。 まとめ：強い一貫性が厳密に要求されるクロスシャードトランザクションの場合、2PC/3PC + コーディネーターが依然として一般的なソリューションであり、コーディネーターの高可用性を可能な限り向上させることで、障害の可能性を減らします。ただし、エンジニアリングの実践では、クロスシャード書き込み操作をできるだけ減らすか、セル化の考え方を使用して、ほとんどのトランザクションを単一のシャード範囲に制限し、システムの複雑さを軽減する必要があります。\n八、有名な事例の議論 # 以下に、業界でよく言及されるいくつかの分散システムについて簡単に説明し、それらがCAPでどのようにトレードオフを行い、実装しているかを見てみましょう。\nGoogle Spanner 典型的なCPシステム（外部でよく言われる「CA」の錯覚を実現することもできますが、実際には依然として可用性の一部を犠牲にする必要があります）。 TrueTimeが提供する外部の正確なタイムスタンプと、各シャード内部のPaxos複製を利用して、データセンター間の強い一貫性を保証します。 グローバルな金融取引や高い一貫性が要求されるシナリオに適していますが、インフラストラクチャのコストが非常に高くなります。 BigTable / HBase 表面的にはCPに偏っており、RegionServerとMasterの間で分散調整を通じてメタデータの一貫性を保証します。 ただし、実際の読み取り/書き込みパスでは、マルチレプリカ非同期複製を通じて一定の高可用性手段を提供することもでき、読み取り一貫性はアプリケーションのニーズに応じて調整できます。 AWS DynamoDB APに傾倒しており、初期の設計はDynamo論文に触発されたもので、R、Wなどのパラメーターで一貫性レベルを調整できます。 デフォルトモードでは、非常に高い可用性と結果整合性を提供しますが、「強い一貫性のある読み取り」を有効にすることもできます（ただし、単一パーティションの強い一貫性のみが保証され、必ずしもクロスパーティションではありません）。 Cassandra 同じくAPに傾倒しており、基盤ではGossipプロトコルを使用してノードトポロジの状態を維持します。 読み取り/書き込みの一貫性は、読み取り/書き込みレプリカ数R / Wを設定して、結果整合性からより強い一貫性へのスムーズな移行を実現できます。 比較からわかること：エンジニアリングには絶対的な「APまたはCP」は存在せず、より多くの一貫性ポリシーの混合です。ほとんどのシステムは、さまざまなアプリケーションシナリオに適応するために、ある程度調整可能な一貫性を提供します。\n九、まとめ # CAP定理は一刀両断ではない 実際の分散システムでは、「Cを選んでAを放棄する」または「Aを選んでCを放棄する」と単純に言うことはできません。 業界でより一般的なのは、異なるデータディメンション、異なる操作タイプに対して、柔軟にCPまたはAPモードを選択することです。同じシステム内でも、異なるテーブル/異なる機能に対して異なるフォールトトレランスと一貫性ポリシーを採用することもあります。 APは絶対的に100％利用可能ではない たとえば、Cassandra、DynamoDBなども、極端なネットワーク分断やノードの大規模な障害が発生した場合、リクエストを満たすことができない状況が発生します。 APシステムは、設計上「レプリカが書き込み可能であれば、まず書き込む」という傾向があり、一貫性保証の一部を犠牲にして、比較的高い可用性とスループットを実現します。 CPも可能な限り高可用性を実現できる Paxos/Raftは、通常の場合、99.99％以上の可用性を提供できますが、より多くのネットワーク、ハードウェア、エンジニアリングコストを投入する必要があり、極端なネットワーク分断が発生した場合は、書き込みをブロックし、可用性を犠牲にして一貫性を維持します。 ハイブリッドアーキテクチャが主流 コアトランザクションシナリオでは強い一貫性（CP）を維持し、周辺補助シナリオまたはキャッシュチャネルでは弱い一貫性（AP）を採用し、両者が相互に連携します。 ビジネスの許容度、ネットワーク環境、コスト投入、チームの技術的蓄えを組み合わせて、総合的にトレードオフを行う必要があります。 CAP定理は、分散システムの設計に高レベルの思考フレームワークを提供し、ネットワーク分断という避けられない現実の前で合理的な意思決定を行うのに役立ちます。実際のシステムでは、より豊富な一貫性モデル、コンセンサスプロトコル、マルチレプリカ複製メカニズム、およびエンジニアリングの実践（災害復旧、ダウングレード、べき等性、競合マージなど）を利用して、一貫性と可用性のバランスを取る必要があります。\n","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/posts/1735350760948-cap/","section":"Posts","summary":"分散システムにおけるCAP定理の応用を理論から実践まで議論します。","title":"CAP定理の徹底解説：高並行性と高可用性を備えた分散システムを構築する","type":"posts"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/conception-de-syst%C3%A8mes/","section":"Tags","summary":"","title":"Conception De Systèmes","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/conception-de-syst%C3%A8mes/","section":"Categories","summary":"","title":"Conception De Systèmes","type":"categories"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/tags/consistency-models/","section":"Tags","summary":"","title":"Consistency Models","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Tags","summary":"","title":"Dağıtık Sistemler","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/da%C4%9F%C4%B1t%C4%B1k-sistemler/","section":"Categories","summary":"","title":"Dağıtık Sistemler","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/design-de-sistemas/","section":"Categories","summary":"","title":"Design De Sistemas","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/design-de-sistemas/","section":"Tags","summary":"","title":"Design De Sistemas","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/%C4%91%E1%BB%8Bnh-l%C3%BD-cap/","section":"Tags","summary":"","title":"Định Lý CAP","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/dise%C3%B1o-de-sistemas/","section":"Tags","summary":"","title":"Diseño De Sistemas","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/dise%C3%B1o-de-sistemas/","section":"Categories","summary":"","title":"Diseño De Sistemas","type":"categories"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/categories/distributed-systems/","section":"Categories","summary":"","title":"Distributed Systems","type":"categories"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/tags/distributed-systems/","section":"Tags","summary":"","title":"Distributed Systems","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Categories","summary":"","title":"Hệ Thống Phân Tán","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/h%E1%BB%87-th%E1%BB%91ng-ph%C3%A2n-t%C3%A1n/","section":"Tags","summary":"","title":"Hệ Thống Phân Tán","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/konsistenzmodelle/","section":"Tags","summary":"","title":"Konsistenzmodelle","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%C3%B4-h%C3%ACnh-nh%E1%BA%A5t-qu%C3%A1n/","section":"Tags","summary":"","title":"Mô Hình Nhất Quán","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8les-de-coh%C3%A9rence/","section":"Tags","summary":"","title":"Modèles De Cohérence","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-coerenza/","section":"Tags","summary":"","title":"Modelli Di Coerenza","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/modelos-de-consistencia/","section":"Tags","summary":"","title":"Modelos De Consistencia","type":"tags"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-consist%C3%AAncia/","section":"Tags","summary":"","title":"Modelos De Consistência","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/progettazione-di-sistemi/","section":"Categories","summary":"","title":"Progettazione Di Sistemi","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/progettazione-di-sistemi/","section":"Tags","summary":"","title":"Progettazione Di Sistemi","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/sistem-tasar%C4%B1m%C4%B1/","section":"Tags","summary":"","title":"Sistem Tasarımı","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/sistem-tasar%C4%B1m%C4%B1/","section":"Categories","summary":"","title":"Sistem Tasarımı","type":"categories"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/sistemas-distribuidos/","section":"Tags","summary":"","title":"Sistemas Distribuidos","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/categories/sistemas-distribuidos/","section":"Categories","summary":"","title":"Sistemas Distribuidos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/sistemas-distribu%C3%ADdos/","section":"Categories","summary":"","title":"Sistemas Distribuídos","type":"categories"},{"content":"","date":"27 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/sistemas-distribu%C3%ADdos/","section":"Tags","summary":"","title":"Sistemas Distribuídos","type":"tags"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/categories/sistemi-distribuiti/","section":"Categories","summary":"","title":"Sistemi Distribuiti","type":"categories"},{"content":"","date":"27 gennaio 2024","externalUrl":null,"permalink":"/it/tags/sistemi-distribuiti/","section":"Tags","summary":"","title":"Sistemi Distribuiti","type":"tags"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/categories/system-design/","section":"Categories","summary":"","title":"System Design","type":"categories"},{"content":"","date":"27 12月 2024","externalUrl":null,"permalink":"/tags/system-design/","section":"Tags","summary":"","title":"System Design","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/systemdesign/","section":"Tags","summary":"","title":"Systemdesign","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/systemdesign/","section":"Categories","summary":"","title":"Systemdesign","type":"categories"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/syst%C3%A8mes-distribu%C3%A9s/","section":"Tags","summary":"","title":"Systèmes Distribués","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/categories/syst%C3%A8mes-distribu%C3%A9s/","section":"Categories","summary":"","title":"Systèmes Distribués","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 de enero de 2024","externalUrl":null,"permalink":"/es/tags/teorema-cap/","section":"Tags","summary":"","title":"Teorema CAP","type":"tags"},{"content":"","date":"27 janvier 2024","externalUrl":null,"permalink":"/fr/tags/th%C3%A9or%C3%A8me-cap/","section":"Tags","summary":"","title":"Théorème CAP","type":"tags"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Categories","summary":"","title":"Thiết Kế Hệ Thống","type":"categories"},{"content":"","date":"27 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng/","section":"Tags","summary":"","title":"Thiết Kế Hệ Thống","type":"tags"},{"content":"","date":"27 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/tutarl%C4%B1l%C4%B1k-modelleri/","section":"Tags","summary":"","title":"Tutarlılık Modelleri","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/tags/verteilte-systeme/","section":"Tags","summary":"","title":"Verteilte Systeme","type":"tags"},{"content":"","date":"27. Januar 2024","externalUrl":null,"permalink":"/de/categories/verteilte-systeme/","section":"Categories","summary":"","title":"Verteilte Systeme","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8/","section":"Tags","summary":"","title":"Модели Согласованности","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Tags","summary":"","title":"Проектирование Систем","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC/","section":"Categories","summary":"","title":"Проектирование Систем","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Распределенные Системы","type":"tags"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/categories/%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/","section":"Categories","summary":"","title":"Распределенные Системы","type":"categories"},{"content":"","date":"27 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0-cap/","section":"Tags","summary":"","title":"Теорема CAP","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Categories","summary":"","title":"वितरित प्रणाली","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%A4%E0%A4%B0%E0%A4%BF%E0%A4%A4-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%A3%E0%A4%BE%E0%A4%B2%E0%A5%80/","section":"Tags","summary":"","title":"वितरित प्रणाली","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%82%E0%A4%97%E0%A4%A4%E0%A4%BF-%E0%A4%AE%E0%A5%89%E0%A4%A1%E0%A4%B2/","section":"Tags","summary":"","title":"संगति मॉडल","type":"tags"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Categories","summary":"","title":"सिस्टम डिज़ाइन","type":"categories"},{"content":"","date":"27 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A4%BF%E0%A4%B8%E0%A5%8D%E0%A4%9F%E0%A4%AE-%E0%A4%A1%E0%A4%BF%E0%A4%9C%E0%A4%BC%E0%A4%BE%E0%A4%87%E0%A4%A8/","section":"Tags","summary":"","title":"सिस्टम डिज़ाइन","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Categories","summary":"","title":"분산 시스템","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C/","section":"Tags","summary":"","title":"분산 시스템","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/categories/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Categories","summary":"","title":"시스템 설계","type":"categories"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/","section":"Tags","summary":"","title":"시스템 설계","type":"tags"},{"content":"","date":"2024년 12월 27일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%AA%A8%EB%8D%B8/","section":"Tags","summary":"","title":"일관성 모델","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"システム設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"システム設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E4%B8%80%E8%B2%AB%E6%80%A7%E3%83%A2%E3%83%87%E3%83%AB/","section":"Tags","summary":"","title":"一貫性モデル","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"一致性模型","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"系统设计","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","section":"Categories","summary":"","title":"系统设计","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Categories","summary":"","title":"系統設計","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E7%B3%BB%E7%B5%B1%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"系統設計","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/categories/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Categories","summary":"","title":"分散システム","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E6%95%A3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0/","section":"Tags","summary":"","title":"分散システム","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/categories/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Categories","summary":"","title":"分散式系統","type":"categories"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%95%A3%E5%BC%8F%E7%B3%BB%E7%B5%B1/","section":"Tags","summary":"","title":"分散式系統","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"","date":"2024年12月27日","externalUrl":null,"permalink":"/zh-cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"26 12月 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-de-tri/","section":"Tags","summary":"","title":"Algorithme De Tri","type":"tags"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme-diviser-pour-r%C3%A9gner/","section":"Tags","summary":"","title":"Algorithme Diviser Pour Régner","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"26 12月 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi/","section":"Tags","summary":"","title":"Algoritmi","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-di-ordinamento/","section":"Tags","summary":"","title":"Algoritmi Di Ordinamento","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmi-divide-et-impera/","section":"Tags","summary":"","title":"Algoritmi Divide Et Impera","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-divis%C3%A3o-e-conquista/","section":"Tags","summary":"","title":"Algoritmo De Divisão E Conquista","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/algoritmo-de-ordena%C3%A7%C3%A3o/","section":"Tags","summary":"","title":"Algoritmo De Ordenação","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-divide-y-vencer%C3%A1s/","section":"Tags","summary":"","title":"Algoritmos De Divide Y Vencerás","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos-de-ordenamiento/","section":"Tags","summary":"","title":"Algoritmos De Ordenamiento","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/b%C3%B6l-ve-fethet-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Böl Ve Fethet Algoritması","type":"tags"},{"content":"","date":"26 12月 2024","externalUrl":null,"permalink":"/tags/divide-and-conquer/","section":"Tags","summary":"","title":"Divide and Conquer","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/divide-and-conquer-algorithmus/","section":"Tags","summary":"","title":"Divide-and-Conquer-Algorithmus","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/h%C4%B1zl%C4%B1-s%C4%B1ralama/","section":"Tags","summary":"","title":"Hızlı Sıralama","type":"tags"},{"content":"","date":"26 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/ordena%C3%A7%C3%A3o-r%C3%A1pida/","section":"Tags","summary":"","title":"Ordenação Rápida","type":"tags"},{"content":"","date":"26 de enero de 2024","externalUrl":null,"permalink":"/es/tags/ordenamiento-r%C3%A1pido/","section":"Tags","summary":"","title":"Ordenamiento Rápido","type":"tags"},{"content":"","date":"26 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ordinamento-rapido/","section":"Tags","summary":"","title":"Ordinamento Rapido","type":"tags"},{"content":"","date":"26 12月 2024","externalUrl":null,"permalink":"/tags/quick-sort/","section":"Tags","summary":"","title":"Quick Sort","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/quicksort/","section":"Tags","summary":"","title":"Quicksort","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/s%E1%BA%AFp-x%E1%BA%BFp-nhanh/","section":"Tags","summary":"","title":"Sắp Xếp Nhanh","type":"tags"},{"content":"","date":"26 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1ralama-algoritmas%C4%B1/","section":"Tags","summary":"","title":"Sıralama Algoritması","type":"tags"},{"content":"","date":"26. Januar 2024","externalUrl":null,"permalink":"/de/tags/sortieralgorithmus/","section":"Tags","summary":"","title":"Sortieralgorithmus","type":"tags"},{"content":"","date":"26 12月 2024","externalUrl":null,"permalink":"/tags/sorting-algorithm/","section":"Tags","summary":"","title":"Sorting Algorithm","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-chia-%C4%91%E1%BB%83-tr%E1%BB%8B/","section":"Tags","summary":"","title":"Thuật Toán Chia Để Trị","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n-s%E1%BA%AFp-x%E1%BA%BFp/","section":"Tags","summary":"","title":"Thuật Toán Sắp Xếp","type":"tags"},{"content":"","date":"26 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"26 janvier 2024","externalUrl":null,"permalink":"/fr/tags/tri-rapide/","section":"Tags","summary":"","title":"Tri Rapide","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9-%D0%B8-%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9/","section":"Tags","summary":"","title":"Алгоритм Разделяй И Властвуй","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","section":"Tags","summary":"","title":"Алгоритмы","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/","section":"Tags","summary":"","title":"Алгоритмы Сортировки","type":"tags"},{"content":"","date":"26 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/","section":"Tags","summary":"","title":"Быстрая Сортировка","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचना","type":"categories"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%95%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%95-%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F/","section":"Tags","summary":"","title":"क्विक सॉर्ट","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B5%E0%A4%BF%E0%A4%AD%E0%A4%BE%E0%A4%9C%E0%A4%A8-%E0%A4%94%E0%A4%B0-%E0%A4%9C%E0%A5%80%E0%A4%A4-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"विभाजन और जीत एल्गोरिथम","type":"tags"},{"content":"","date":"26 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%B8%E0%A5%89%E0%A4%B0%E0%A5%8D%E0%A4%9F%E0%A4%BF%E0%A4%82%E0%A4%97-%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"सॉर्टिंग एल्गोरिथम","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"분할 정복 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"정렬 알고리즘","type":"tags"},{"content":"","date":"2024년 12월 26일","externalUrl":null,"permalink":"/ko/tags/%ED%80%B5-%EC%A0%95%EB%A0%AC/","section":"Tags","summary":"","title":"퀵 정렬","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%BD%E3%83%BC%E3%83%88%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"ソートアルゴリズム","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%AF%E3%82%BD%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"クイックソート","type":"tags"},{"content":"クイックソートは、比較に基づく非安定ソートアルゴリズムであり、分割統治法を採用しています。平均時間計算量は $O(n\\log n)$、最悪の場合は $O(n^2)$、空間計算量は $O(1)$ です。以下では、整数数列を小さい順にソートする例を基に、実装の詳細とよくある間違いについて説明します。\n問題の説明 # 長さ $n$ の整数数列が与えられたとき、クイックソートを用いて小さい順にソートし、結果を出力してください。\n入力形式 # 1行目に整数 $n$ が入力されます。 2行目に $n$ 個の整数が入力されます。各整数は $[1,10^9]$ の範囲内です。 出力形式 # ソートされた数列を1行に出力します。 データ範囲 # $1 \\leq n \\leq 100000$\n入力例 # 5 3 1 2 4 5 出力例 # 1 2 3 4 5 クイックソートの考え方 # クイックソートは、分割統治を行う際に、任意の数を基準数 pivot として選択します（以下では中央の数を選択します）。\n左右のポインタを互いに向かって移動させます。左ポインタ L は左から右へ pivot 以上の最初の数を見つけ、右ポインタ R は右から左へ pivot 以下の最初の数を見つけます。そして、これらの数を交換します。\nこのプロセスを、左ポインタと右ポインタが重なるか、左ポインタが右ポインタより1つ大きくなるまで繰り返します。これを1回のループと呼びます。\nポインタの移動と交換が完了するたびに、「左側の部分は ≤ pivot、右側の部分は ≥ pivot」という構造が維持されるようにします。つまり、不変条件 [left, L) \u0026lt;= pivot、(R, right] \u0026gt;= pivot が成り立ちます。\n以下のサンプルコードでは、left と right は現在処理中の閉区間の境界であり、pivot は区間の中央にある要素を取ります。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left \u0026gt;= right) return; 6 7 int pivot = a[(left + right) / 2]; 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt; pivot) l++; 12 while (a[r] \u0026gt; pivot) r--; 13 if (l \u0026gt;= r) break; 14 swap(a[l], a[r]); 15 l++; r--; 16 } 17 18 quickSort(a, left, r); 19 quickSort(a, r + 1, right); 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 return 0; 31} 計算量と pivot の選択 # 最悪の場合、クイックソートは $O(n^2)$ の計算量になるため、pivot の選択は非常に重要です。常に最初または最後の要素を選択すると、ほぼソート済みの配列では最悪のケースが発生する可能性が高くなります。\n中央の要素を選択する以外に、ランダムに要素を pivot として選択したり、左、中央、右の3つの要素の中央値を pivot として選択することもできます。\nよくある間違いの例 # 以下のコードには、よくある間違いが複数含まれています。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;a, int left, int right) { 5 if (left == right) return; // 7 6 7 int pivot = (left + right) \u0026gt;\u0026gt; 1; // 1 8 int l = left, r = right; 9 10 while (true) { 11 while (a[l] \u0026lt;= pivot) l++; // 2 12 while (a[r] \u0026gt;= pivot) r--; // 2 13 swap(a[l], a[r]); 14 if (l \u0026gt;= r) break; // 3 15 // 4 16 } 17 18 quickSort(a, left, l - 1); // 5, 6 19 quickSort(a, l, right); // 5, 6 20} 21 22int main() { 23 int n; cin \u0026gt;\u0026gt; n; 24 vector\u0026lt;int\u0026gt; a(n); 25 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; 26 27 quickSort(a, 0, n - 1); 28 29 for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 30 31 return 0; 32} 間違いの分析：\npivot は配列内の数であるべきで、インデックスではありません。 \u0026lt;= と \u0026gt;= ではなく、それぞれ \u0026lt; と \u0026gt; を使用する必要があります。そうしないと、左ポインタが右ポインタを1つ以上超える可能性があり、配列を2つの部分に分割できなくなります。 l \u0026gt;= r を検出したら、すぐにループを終了し、交換を実行しないようにする必要があります。そうしないと、左側の要素が pivot 以下、右側の要素が pivot 以上であることを保証できません。 交換するたびに、l++ と r-- を実行する必要があります。 pivot は実際には中央より左の数を選択しています。したがって、$l - 1$ と $l$ で配列を分割すると、配列 [1, 2] を考慮すると、配列をサイズが0と2の2つの部分に分割し続ける無限ループが発生することがわかります。同様に、$r$ と $l$ で配列を区別することもできません。逆に、1回のループが終了すると、$r$ は必ず $right$ より小さくなるため、$r$ と $r+1$ で配列を分割できます。読者はアルゴリズムのプロセスをシミュレートして、その理由を確認できます。無限ループを回避するもう1つの簡単な方法は、pivot をランダムに選択するか、要素が2つしかない場合を特別に処理することです。 また、$l$, $l+1$ も使用できません。この分割は定義に合致せず、$r$ が $l$ の左側にある場合、$l$, $l+1$ を使用して、配列を左側が pivot 以下、右側が pivot 以上の2つの部分に正しく分割することはできません。 この問題では、配列が空でないことを前提としているため、\u0026gt; のケースは存在しません。ただし、\u0026gt;= を使用することをお勧めします。より安全です。 補足 # クイックソートは「クイック選択」に発展させることもでき、$O(n)$ の期待時間で、順序付けられていない配列の中で $k$ 番目に小さい数を見つけることができます。具体的な考え方はクイックソートと似ていますが、毎回片側の部分区間のみを再帰的に処理することで、時間計算量を削減します。\n","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/posts/1735252761946-quick-sort/","section":"Posts","summary":"クイックソートアルゴリズムを正しく実装するための要点解説。","title":"クイックソート","type":"posts"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"快速排序","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"排序算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/ja/tags/%E5%88%86%E5%89%B2%E7%B5%B1%E6%B2%BB%E6%B3%95/","section":"Tags","summary":"","title":"分割統治法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%88%86%E6%B2%BB%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治演算法","type":"tags"},{"content":"","date":"2024年12月26日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"分治算法","type":"tags"},{"content":" 問題 # https://www.acwing.com/problem/content/2/\n$N$ 個の品物があります。$i$ 番目の品物の体積は $s_i$、価値は $v_i$ です。 各品物は一度しか取れません。最大総体積制限 $S$ を超えない範囲で、取得できる最大総価値 $V$ を求めてください。\n入力形式 # 1行目に2つの整数 $N, S$ がスペース区切りで与えられます。それぞれ品物の数と最大総体積制限を表します。 続く $N$ 行には、各行に2つの整数 $s_i, v_i$ がスペース区切りで与えられます。それぞれ $i$ 番目の品物の体積と価値を表します。\n出力形式 # 最大価値を表す整数を1つ出力してください。\nデータ範囲 # $$0 \\le N, S \\leq 1000$$$$0 \\le s_i, v_i \\leq 1000$$ 入力例 # 4 5 1 2 2 4 3 4 4 5 出力例 # 8 解法 # 状態の定義: f[i][j] は、最初の $i$ 個の品物で、体積制限が $j$ のときに得られる最大価値を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を取る場合、f[i][j] = f[i - 1][j - s[i]] + v[i] 状態遷移を実装する際には、定義域の範囲に注意する必要があります。もし $j \u003c s_i$ なら、$i$ 番目の品物を取るケースは考慮しません。なぜなら、$j - s_i$ が負の数になると、配列のインデックスが不正になるからです。 別の言い方をすると、$i$ 番目の品物の体積が体積制限よりも大きいため、ありえないということです。 初期条件の定義: 最初の $0$ 個の品物では、どんな体積制限でも価値は $0$ です。つまり、f[0][j] = 0、$j$ $\\in [0, S]$。 時間計算量: $O(NS)$。 コード # 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f(N + 1, vector\u0026lt;int\u0026gt;(S + 1)); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = 0; j \u0026lt;= S; j++) { 11 f[i][j] = f[i - 1][j]; 12 if (j \u0026gt;= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]); 13 } 14 } 15 cout \u0026lt;\u0026lt; f[N][S] \u0026lt;\u0026lt; endl; 16 return 0; 17} 一次元DPによる最適化 # 二次元配列を一次元配列に圧縮することで、空間を大幅に節約し、実行速度をある程度向上させることができます（欠点は、一部のタイプの問題の特殊な要件を満たせないことです）。 状態遷移において、f[i][j] は f[i - 1][j] と f[i - 1][j - s[i]] のみに関連していることに注意してください。言い換えれば、コード内の二次元配列 f では、 f[i][j] は、その上の行で、より左側にあるか、同じ列にある要素のみに関連しています。したがって、二次元配列を一次元配列またはローリング配列に圧縮できます。 次のコードでは、2番目のループが逆順に反復処理されていることに注意してください。これは、f[i][j] を計算するときに、f[i - 1][j - s[i]] がまだ更新されていないことを保証するためです。 1#include\u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main() { 4 int N, S; 5 cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; 6 vector\u0026lt;int\u0026gt; s(N + 1), v(N + 1); 7 for (int i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; v[i]; 8 vector\u0026lt;int\u0026gt; f(S + 1); 9 for (int i = 1; i \u0026lt;= N; i++) { 10 for (int j = S; j \u0026gt;= s[i]; j--) { 11 f[j] = max(f[j], f[j - s[i]] + v[i]); 12 } 13 } 14 cout \u0026lt;\u0026lt; f[S] \u0026lt;\u0026lt; endl; 15 return 0; 16} もし解の数を求める場合 # 取得できる最大総価値を出力するだけでなく、「この最大総価値を達成できる異なる選択方法が何通りあるか」も出力する必要がある場合、01ナップサック問題で解の数を数える方法を以下に紹介します。\nhttps://www.acwing.com/problem/content/11/\n二次元DPで解の数を数える # 以下では、二次元DPを例に説明します。\n状態の定義：\ndp[i][j] は、「最初の i 個の品物で、容量（体積制限）が j のとき、取得できる最大価値」を表します。 ways[i][j] は、「最初の i 個の品物で、容量が j のとき、最大価値を取得するときの解の数」を表します。 状態遷移：\ni 番目の品物を選ばない場合： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] $$ i 番目の品物を選ぶ場合（前提条件は $ j \\ge s_i $）： $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i] $$ 選ぶか選ばないか、最終的に dp[i][j] は2つのうち大きい方を取る必要があります。 もし $$ \\text{dp}[i-1][j - s_i] + v_i \u003e \\text{dp}[i-1][j], $$ ならば、「i 番目の品物を選ぶ」方が価値が大きいことを示します。 $$ \\text{dp}[i][j] = \\text{dp}[i-1][j - s_i] + v_i, \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j - s_i]. $$ もし $$ \\text{dp}[i-1][j - s_i] + v_i = \\text{dp}[i-1][j], $$ ならば、2つの方法で得られる最大価値が同じであることを示します。この場合、解の数を加算する必要があります。 $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j] + \\text{ways}[i-1][j - s_i]. $$ もし $$ \\text{dp}[i-1][j - s_i] + v_i \u003c \\text{dp}[i-1][j], $$ ならば、「i 番目の品物を選ばない」方が価値が大きいことを示します。解の数は選ばないときの解の数を継承します。 $$ \\text{dp}[i][j] = \\text{dp}[i-1][j], \\quad \\text{ways}[i][j] = \\text{ways}[i-1][j]. $$ 初期条件：\ndp[0][j] = 0 は、最初の0個の品物の場合、どんな容量でも得られる最大価値は0であることを示します。 ways[0][0] = 1 は、「最初の0個の品物、容量が0」という状況が1つの実行可能な解（つまり、何も選ばない）であることを示し、解の数を1に設定します。 j \u0026gt; 0 の場合、選べる品物がないのに容量が0より大きい場合は、正の価値を得ることは不可能であり、対応する解の数は0です。つまり、ways[0][j] = 0。 最終的な答え：\ndp[N][S] が最大価値です。 ways[N][S] がその最大価値を達成する解の数です。 時間計算量：$O(NS)$。 この問題も一次元DPで最適化できます。 もし体積制限にちょうど一致する場合を求める場合 # 状態の定義: f[i][j] は、最初の i 個の品物で、体積がちょうど $j$ であるときの最大価値を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を取る場合、f[i][j] = f[i - 1][j - s[i]] + v[i] 元の問題の状態遷移と違いがないことに気づくでしょう。 しかし、初期条件が異なります。f[0][0] = 0 を除いて、残りの f[0][j] = $-\\infty$、j $\\in [1, S]$ です。$-\\infty$ は不可能な状態を表します。 もし体積制限 $S$ が非常に大きく (1e9)、同時に品物の数 $N$ と最大総価値 $V$ が比較的小さい場合 # このような問題に対しては、$O(NV)$ の計算量で解く方法があります。 状態の定義: f[i][j] は、最初の i 個の品物からいくつかを選び、価値の合計がちょうど j であるときの最小体積を表します。 $i$ 番目の品物を取らない場合、f[i][j] = f[i - 1][j] $i$ 番目の品物を取る場合、f[i][j] = f[i - 1][j - v[i]] + s[i] 2つのうち小さい方を取ります。 初期条件: f[0][0] = 0、残りの f[0][j] = $\\infty$、j $\\in [1, V]$。$\\infty$ は不可能な状態を表します。$-\\infty$ ではないことに注意してください。 最終的な答えは、f[N][j] の中で f[N][j] \u0026lt;= S を満たす最大の j です。 もし体積制限 $S$ と個々の品物の価値 $v_i$ が非常に大きく（1e9オーダー）、同時に品物の数 $N$ が非常に小さい場合（最大でも40以下） # https://www.acwing.com/solution/content/38250/\n$N \\leq 20$ の場合、すべての部分集合を直接列挙できます（時間計算量 $O(2^N)$）。 $N \\leq 40$ の場合、$2^{40}$ は $10^{12}$ オーダーであるため、直接列挙すると計算量が大きくなります。したがって、半分全列挙を使用できます。 これにより、計算量を $O\\bigl(2^{\\frac{N}{2}} \\times \\log(2^{\\frac{N}{2}})\\bigr) \\approx O(N \\cdot 2^{\\frac{N}{2}})$ に削減できます。 これにより、許容可能な時間内に完了できます。 ","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/posts/1735112650761-0-1-knapsack-problem/","section":"Posts","summary":"最も基礎的な古典的ナップサック問題。","title":"01ナップサック問題","type":"posts"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmusvorlage/","section":"Tags","summary":"","title":"Algorithmusvorlage","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/b%C3%A0i-to%C3%A1n-c%C3%A1i-t%C3%BAi/","section":"Tags","summary":"","title":"Bài Toán Cái Túi","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/dinamik-programlama/","section":"Tags","summary":"","title":"Dinamik Programlama","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/dynamic-programming/","section":"Tags","summary":"","title":"Dynamic Programming","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/dynamische-programmierung/","section":"Tags","summary":"","title":"Dynamische Programmierung","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"Ikili Arama","type":"tags"},{"content":"","date":"24 12月 2024","externalUrl":null,"permalink":"/tags/knapsack-problem/","section":"Tags","summary":"","title":"Knapsack Problem","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/modelli-di-algoritmi/","section":"Tags","summary":"","title":"Modelli Di Algoritmi","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/pesquisa-bin%C3%A1ria/","section":"Tags","summary":"","title":"Pesquisa Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/problema-da-mochila/","section":"Tags","summary":"","title":"Problema Da Mochila","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/problema-de-la-mochila/","section":"Tags","summary":"","title":"Problema De La Mochila","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/problema-dello-zaino/","section":"Tags","summary":"","title":"Problema Dello Zaino","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/probl%C3%A8me-du-sac-%C3%A0-dos/","section":"Tags","summary":"","title":"Problème Du Sac À Dos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/programa%C3%A7%C3%A3o-din%C3%A2mica/","section":"Tags","summary":"","title":"Programação Dinâmica","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/programaci%C3%B3n-din%C3%A1mica/","section":"Tags","summary":"","title":"Programación Dinámica","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/programmation-dynamique/","section":"Tags","summary":"","title":"Programmation Dynamique","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/programmazione-dinamica/","section":"Tags","summary":"","title":"Programmazione Dinamica","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/","section":"Tags","summary":"","title":"Quy Hoạch Động","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/rucksackproblem/","section":"Tags","summary":"","title":"Rucksackproblem","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/s%C4%B1rt-%C3%A7antas%C4%B1-problemi/","section":"Tags","summary":"","title":"Sırt Çantası Problemi","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/","section":"Tags","summary":"","title":"Динамическое Программирование","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BE-%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5/","section":"Tags","summary":"","title":"Задача О Рюкзаке","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/","section":"Tags","summary":"","title":"Шаблоны Алгоритмов","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A6%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिदम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A1%E0%A4%BE%E0%A4%AF%E0%A4%A8%E0%A5%87%E0%A4%AE%E0%A4%BF%E0%A4%95-%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%97%E0%A5%8D%E0%A4%B0%E0%A4%BE%E0%A4%AE%E0%A4%BF%E0%A4%82%E0%A4%97/","section":"Tags","summary":"","title":"डायनेमिक प्रोग्रामिंग","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A6%E0%A5%8D%E0%A4%B5%E0%A4%BF%E0%A4%86%E0%A4%A7%E0%A4%BE%E0%A4%B0%E0%A5%80-%E0%A4%96%E0%A5%8B%E0%A4%9C/","section":"Tags","summary":"","title":"द्विआधारी खोज","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%A8%E0%A5%88%E0%A4%AA%E0%A4%B8%E0%A5%87%E0%A4%95-%E0%A4%B8%E0%A4%AE%E0%A4%B8%E0%A5%8D%E0%A4%AF%E0%A4%BE/","section":"Tags","summary":"","title":"नैपसेक समस्या","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"Tags","summary":"","title":"동적 프로그래밍","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C/","section":"Tags","summary":"","title":"배낭 문제","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/","section":"Tags","summary":"","title":"이분 탐색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"ナップサック問題","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E7%AE%97%E6%B3%95%E8%88%87%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"算法與數據結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/","section":"Tags","summary":"","title":"動態規劃","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E5%8B%95%E7%9A%84%E8%A8%88%E7%94%BB%E6%B3%95/","section":"Tags","summary":"","title":"動的計画法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"もし順序付けられた解空間が左右の2つの部分に分割され、一方の部分が条件を満たし、もう一方の部分が条件を満たさない場合、二分探索を使用して順序付けられた解空間で臨界点を見つけることができます。\n二分探索の基本的な考え方は、検索範囲を半分に分割し続けることです。毎回、中央の要素をチェックし、中央の要素が条件を満たさない場合は、範囲の半分を排除できます。そうでない場合は、もう半分の範囲で検索を続けます。毎回検索範囲の半分を破棄するため、検索時間計算量は $O(\\log n)$ に達することができます。\n例題 # 問題の説明：\n昇順にソートされた長さ $n$ の整数配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内で $k$ の「開始位置」と「終了位置」（インデックスは 0 から開始）を見つける必要があります。配列にこの数が存在しない場合は、-1 -1 を返します。\n入力形式 # 1行目：2つの整数 $n$ と $q$。それぞれ配列の長さとクエリの回数を表します。 2行目：$n$ 個の整数。昇順にソートされた完全な配列を表します。 次の $q$ 行：各行には整数 $k$ が含まれ、クエリ要素を表します。 データ範囲 # $1 \\leq n \\leq 100000$\n$1 \\leq q \\leq 10000$\n$1 \\leq k \\leq 10000$\n出力形式 # 各クエリについて、配列内の要素の開始位置と終了位置を1行に出力します。配列に要素が存在しない場合は、-1 -1 を出力します。\nサンプル：\n入力： 6 3 1 2 2 3 3 4 3 4 5 出力： 3 4 5 5 -1 -1 説明：\n要素 $3$ が出現する範囲は $[3, 4]$ です。 要素 $4$ は1回だけ出現し、位置 $5$ にあります。 要素 $5$ は配列に存在しないため、$-1$ $-1$ を返します。 解答 # 「開始位置」を見つける： つまり、$k$ 以上の最初の位置を見つけます。配列を2つの部分に分割できます。\n左側のすべての数は $k$ より「小さい」 右側のすべての数は $k$ 以上 答えは右側の最初の位置です 「終了位置」を見つける： つまり、$k$ 以下の最後の位置を見つけます。配列を2つの部分に分割できます。\n左側のすべての数は $k$ 以下 右側のすべての数は $k$ より「大きい」 答えは左側の最後の位置です おすすめテンプレート # 以下は、エレガントでエラーを起こしにくい二分探索テンプレートです。\n2つのポインタ $l, r$ を定義します。不変条件は、閉区間 $[0, l]$ が左半分に属し、閉区間 $[r, n - 1]$ が右半分に属することです。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化されます。\nアルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左半分の最後の要素と右半分の最初の要素を指します。\n必要な解が存在しない可能性があるため、問題に必ず解が存在すると明記されていない場合は、$l$ または $r$ が範囲外かどうか、正しい値を指しているかどうかを判断する必要があります。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n, q; 6 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 7 vector\u0026lt;int\u0026gt; nums(n); 8 for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; 9 10 while(q--) { 11 int k; 12 cin \u0026gt;\u0026gt; k; 13 14 // 1. k の開始位置を見つける 15 // 配列を2つの部分に分割し、左側はすべて \u0026lt; k、右側はすべて \u0026gt;= k。 16 // 答えは右半分の最小インデックス。 17 int l = -1, r = n; 18 while(l \u0026lt; r - 1) { 19 int mid = (l + r) / 2; 20 if(nums[mid] \u0026gt;= k) r = mid; 21 else l = mid; 22 } 23 24 // もし r が範囲外または nums[r] != k なら、k は存在しない 25 if (r == n || nums[r] != k) { 26 cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; 27 continue; 28 } 29 30 int leftPos = r; 31 32 // 2. k の終了位置を見つける 33 // 配列を2つの部分に分割し、左側はすべて \u0026lt;= k、右側はすべて \u0026gt; k。 34 // 答えは左半分の最大インデックス。 35 l = -1, r = n; 36 while(l \u0026lt; r - 1) { 37 int mid = (l + r) / 2; 38 if(nums[mid] \u0026lt;= k) l = mid; 39 else r = mid; 40 } 41 42 int rightPos = l; 43 cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; 44 } 45 46 return 0; 47} 利点 # この書き方には厳密に定義された不変条件があります。 「開始位置」と「終了位置」の両方のケースに適用でき、追加の処理や変更は必要ありません。 一部の書き方では、終了条件として l == r を使用します。$l$ と $r$ が $1$ 異なる場合、$mid$ は $l$ または $r$ と等しく計算されます。正しく処理しないと、$l$ または $r$ を $mid$ に更新すると、検索範囲が縮小せず、無限ループが発生します。対照的に、ここの書き方では、$l$ と $r$ が隣接すると終了するため、$mid$ が $l$ より小さく、$r$ より大きいことが保証され、$l$ または $r$ を更新すると検索範囲が必ず縮小します。 STL # C++ STL が提供する lower_bound 関数と upper_bound 関数を使用すると、同じことを実行できます。\nlower_bound(first, last, val) は「val 以上の最初の位置」を返します。 upper_bound(first, last, val) は「val より大きい最初の位置」を返します。 例として、nums = {1,2,3,4,4,4,4,4,5,5,6} と仮定し、4 が出現する範囲を知りたいとします。\n1vector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; 2auto it1 = lower_bound(nums.begin(), nums.end(), 4); 3auto it2 = upper_bound(nums.begin(), nums.end(), 4); 4 5if (it1 == nums.end() || *it1 != 4) { 6 cout \u0026lt;\u0026lt; \u0026#34;4 appears 0 times\u0026#34; \u0026lt;\u0026lt; endl; 7} else { 8 cout \u0026lt;\u0026lt; \u0026#34;first 4 is at \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;last 4 is at \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; 10 cout \u0026lt;\u0026lt; \u0026#34;4 appears \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; endl; 11} it1 は、値が $4$ 以上の最初の位置を指します。 it2 は、値が $4$ より大きい最初の位置を指します。 したがって、it2 - it1 は配列内で $4$ が出現する回数です。it2 - nums.begin() - 1 は $4$ の右境界の位置です。 補足 # 二分探索は、浮動小数点数の範囲の検索（方程式の根を求めるなど）や、単峰関数の最大値を求めるための三分探索にも拡張できます。\n練習 # LeetCode 33. Search in Rotated Sorted Array\nヒント：最初のステップで二分探索を使用して回転点を見つけ、2番目のステップで二分探索を使用して目標値を見つけます。\n","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"二分探索アルゴリズムをエレガントに実装する方法。","title":"二分探索","type":"posts"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","section":"Tags","summary":"","title":"背包问题","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C/","section":"Tags","summary":"","title":"背包問題","type":"tags"},{"content":"","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"}]