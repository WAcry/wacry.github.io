[{"content":"","date":"24 diciembre 2024","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"24 diciembre 2024","externalUrl":null,"permalink":"/tags/algorithm-template/","section":"Tags","summary":"","title":"Algorithm Template","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithm-vorlage/","section":"Tags","summary":"","title":"Algorithm Vorlage","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/algorithme/","section":"Tags","summary":"","title":"Algorithme","type":"tags"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/categories/algorithmen-und-datenstrukturen/","section":"Categories","summary":"","title":"Algorithmen Und Datenstrukturen","type":"categories"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/categories/algorithmes-et-structures-de-donn%C3%A9es/","section":"Categories","summary":"","title":"Algorithmes Et Structures De Données","type":"categories"},{"content":"","date":"24 diciembre 2024","externalUrl":null,"permalink":"/categories/algorithms-and-data-structures/","section":"Categories","summary":"","title":"Algorithms and Data Structures","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/algorithmus/","section":"Tags","summary":"","title":"Algorithmus","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma/","section":"Tags","summary":"","title":"Algoritma","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/algoritma-%C5%9Fablonu/","section":"Tags","summary":"","title":"Algoritma Şablonu","type":"tags"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/categories/algoritmalar-ve-veri-yap%C4%B1lar%C4%B1/","section":"Categories","summary":"","title":"Algoritmalar Ve Veri Yapıları","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/categories/algoritmi-e-strutture-dati/","section":"Categories","summary":"","title":"Algoritmi E Strutture Dati","type":"categories"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/algoritmo/","section":"Tags","summary":"","title":"Algoritmo","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/algoritmos/","section":"Tags","summary":"","title":"Algoritmos","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/categories/algoritmos-e-estruturas-de-dados/","section":"Categories","summary":"","title":"Algoritmos E Estruturas De Dados","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/algoritmos-y-estructuras-de-datos/","section":"Categories","summary":"","title":"Algoritmos Y Estructuras De Datos","type":"categories"},{"content":"","date":"24. Januar 2024","externalUrl":null,"permalink":"/de/tags/bin%C3%A4re-suche/","section":"Tags","summary":"","title":"Binäre Suche","type":"tags"},{"content":"","date":"24 diciembre 2024","externalUrl":null,"permalink":"/tags/binary-search/","section":"Tags","summary":"","title":"Binary Search","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/busca-bin%C3%A1ria/","section":"Tags","summary":"","title":"Busca Binária","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/b%C3%BAsqueda-binaria/","section":"Tags","summary":"","title":"Búsqueda Binaria","type":"tags"},{"content":" Búsqueda Binaria # En una secuencia ordenada, se puede utilizar la búsqueda binaria para encontrar un elemento específico rápidamente. Comparado con la complejidad temporal de $O(n)$ de la búsqueda lineal, la búsqueda binaria solo necesita un tiempo de $O(\\log n)$, por lo que es muy eficiente en casos de grandes volúmenes de datos.\nLa idea central de la búsqueda binaria # La idea básica de la búsqueda binaria es dividir continuamente el intervalo de búsqueda por la mitad. En cada comparación, se compara el elemento del punto medio con el valor objetivo. Si el elemento del punto medio no cumple la condición, se puede excluir la mitad del intervalo; de lo contrario, se continúa la búsqueda en la otra mitad del intervalo. Dado que cada vez se descarta la mitad del intervalo de búsqueda, la complejidad temporal de búsqueda puede alcanzar $O(\\log n)$.\nLa búsqueda binaria es muy útil para problemas donde \u0026quot; las soluciones factibles se pueden dividir en un intervalo ordenado (que satisface la condición) y otro intervalo ordenado (que no satisface la condición) \u0026ldquo;. Por ejemplo:\nEncontrar si existe un elemento en una matriz ordenada. Encontrar la \u0026ldquo;primera posición\u0026rdquo; o la \u0026ldquo;última posición\u0026rdquo; en la que aparece un número. Ejemplo de problema: Encontrar la posición inicial y final de un elemento # Descripción del problema: Dado un array de enteros de longitud $n$ ordenado ascendentemente y $q$ consultas. Cada consulta proporciona un entero $k$, necesitamos encontrar la \u0026ldquo;posición inicial\u0026rdquo; y la \u0026ldquo;posición final\u0026rdquo; de $k$ en la matriz (los índices comienzan desde 0). Si el número no existe en el array, devolver $-1$ $-1$.\nFormato de entrada:\nPrimera línea: dos enteros $n$ y $q$, que representan la longitud del array y el número de consultas respectivamente. Segunda línea: $n$ enteros (en el rango de 1 ~ 10000), que representan el array completo, que ya está ordenado en orden ascendente. Siguientes $q$ líneas: cada línea contiene un entero $k$, que representa un elemento de consulta. Formato de salida: Para cada consulta, imprimir en una línea la posición inicial y final del elemento en el array. Si el elemento no existe en el array, imprimir $-1$ $-1$.\nEjemplo:\nEntrada: 6 3 1 2 2 3 3 4 3 4 5 Salida: 3 4 5 5 -1 -1 Explicación:\nEl rango donde aparece el elemento 3 es [3, 4]; El elemento 4 aparece solo una vez, en la posición 5; El elemento 5 no existe en el array, por lo que devuelve -1 -1. Ideas de aplicación de la búsqueda binaria # En este problema, para encontrar el \u0026ldquo;límite izquierdo\u0026rdquo; y el \u0026ldquo;límite derecho\u0026rdquo; de un valor dado, podemos recurrir a la búsqueda binaria. La clave es comprender cómo definir el intervalo de búsqueda y cómo mover los punteros de acuerdo con el resultado de la comparación.\nEncontrar el \u0026ldquo;límite izquierdo\u0026rdquo;: Es decir, encontrar la primera posición mayor o igual a $k$. El array se puede dividir en dos partes:\nTodos los números de la izquierda son \u0026ldquo;menores\u0026rdquo; que $k$. Todos los números de la derecha son \u0026ldquo;mayores o iguales\u0026rdquo; que $k$. Encontrar el \u0026ldquo;límite derecho\u0026rdquo;: Es decir, encontrar la última posición menor o igual a $k$. El array se puede dividir en dos partes:\nTodos los números de la izquierda son \u0026ldquo;menores o iguales\u0026rdquo; que $k$. Todos los números de la derecha son \u0026ldquo;mayores\u0026rdquo; que $k$. Siempre que se puedan mantener correctamente estos dos intervalos, se pueden obtener los resultados rápidamente mediante la búsqueda binaria.\nPlantilla recomendada: Escritura de búsqueda binaria para evitar bucles infinitos # La siguiente es una plantilla de búsqueda binaria elegante y menos propensa a errores. Al permitir que $l$ y $r$ converjan gradualmente, garantiza que el bucle termine cuando ambos son adyacentes:\nDefinir dos punteros $l, r$, con invariante: el intervalo cerrado $[0, l]$ pertenece a la mitad izquierda y el intervalo cerrado $[r, n - 1]$ pertenece a la mitad derecha. $l$ y $r$ se inicializan en $-1$ y $n$.\nCuando el algoritmo finaliza, $l$ y $r$ son adyacentes, apuntando al valor máximo de la mitad izquierda y al valor mínimo de la mitad derecha, respectivamente.\nDado que la solución que queremos podría no existir, al devolver $l$ o $r$, es necesario verificar si el valor correspondiente es el valor que queremos y si está fuera de rango. Por ejemplo, $l$ representa el valor máximo $\\leq k$, y necesitamos verificar l != -1 \u0026amp;\u0026amp; nums[l] == k\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; nums(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; while(q--) { int k; cin \u0026gt;\u0026gt; k; // 1. Buscar la posición inicial de k (límite izquierdo) // Dividir el array en dos partes, la izquierda toda \u0026lt; k, la derecha toda \u0026gt;= k. // El límite izquierdo es el índice mínimo de la parte derecha. int l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026gt;= k) r = mid; else l = mid; } // Si r está fuera de rango o nums[r] != k, significa que k no existe if (r == n || nums[r] != k) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; continue; } int leftPos = r; // Registrar el límite izquierdo de k // 2. Buscar la posición final de k (límite derecho) // Dividir el array en dos partes, la izquierda toda \u0026lt;= k, la derecha toda \u0026gt; k. // El límite derecho es el índice máximo de la parte izquierda. l = -1, r = n; while(l \u0026lt; r - 1) { int mid = (l + r) / 2; if(nums[mid] \u0026lt;= k) l = mid; else r = mid; } // Dado que ya hemos verificado que k existe, no es necesario verificarlo de nuevo aquí int rightPos = l; // Límite derecho cout \u0026lt;\u0026lt; leftPos \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; rightPos \u0026lt;\u0026lt; endl; } return 0; } ¿Por qué esta forma de escribir es menos propensa a errores? # Esta forma de escribir tiene invariantes estrictamente definidos. Puede encontrar tanto el límite izquierdo como el límite derecho, y puede aplicarse a todos los escenarios. Algunas formas de escribir usan $l == r$ como condición de terminación. Cuando $l$ y $r$ difieren en 1, se calculará $mid$ y será igual a l o r. Si no se maneja correctamente y se actualiza l o r a mid, el intervalo de búsqueda no se reducirá, lo que provocará un bucle infinito. Por el contrario, esta forma de escribir termina cuando $l$ y $r$ son adyacentes, evitando este problema. Solución con STL: lower_bound y upper_bound # Si se utilizan las funciones lower_bound y upper_bound proporcionadas por C++ STL, también se puede lograr lo mismo fácilmente:\nlower_bound(first, last, val) devuelve \u0026ldquo;la primera posición mayor o igual que val\u0026rdquo; upper_bound(first, last, val) devuelve \u0026ldquo;la primera posición mayor que val\u0026rdquo; Por ejemplo, supongamos que nums = {1,2,3,4,4,4,4,4,5,5,6}, y queremos saber el intervalo donde aparece 4:\nvector\u0026lt;int\u0026gt; nums = {1,2,3,4,4,4,4,4,5,5,6}; auto it1 = lower_bound(nums.begin(), nums.end(), 4); auto it2 = upper_bound(nums.begin(), nums.end(), 4); if (it1 == nums.end() || *it1 != 4) { // Indica que 4 no existe en el array cout \u0026lt;\u0026lt; \u0026#34;4 aparece 0 veces\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;El primer 4 está en \u0026#34; \u0026lt;\u0026lt; it1 - nums.begin() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;El último 4 está en \u0026#34; \u0026lt;\u0026lt; it2 - nums.begin() - 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4 aparece \u0026#34; \u0026lt;\u0026lt; it2 - it1 \u0026lt;\u0026lt; \u0026#34; veces\u0026#34; \u0026lt;\u0026lt; endl; } it1 apunta a la primera posición con un valor mayor o igual que 4. it2 apunta a la primera posición con un valor mayor que 4. Por lo tanto, it2 - it1 es el número de veces que aparece 4 en el array; it2 - nums.begin() - 1 es el límite derecho de 4. Estas dos funciones son especialmente convenientes para buscar intervalos o contar el número de ocurrencias.\nComplemento # La búsqueda binaria también se puede extender a la búsqueda en el rango de números de punto flotante (como encontrar la raíz de una ecuación) y la búsqueda ternaria para encontrar el valor máximo de una función unimodal. Mientras comprendas el principio central de \u0026quot; en un intervalo ordenado, siempre se puede descartar la mitad \u0026ldquo;, encontrarás que la búsqueda binaria puede ayudarte a resolver problemas de manera eficiente en muchos escenarios.\nEjercicio después de clase # LeetCode 33. Search in Rotated Sorted Array\nPista: En el primer paso, utiliza la búsqueda binaria para encontrar el punto de rotación y en el segundo paso, vuelve a utilizar la búsqueda binaria para encontrar el valor objetivo.\n","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/posts/1735078223417-binary-search-intro/","section":"Posts","summary":"Cómo implementar elegantemente el algoritmo de búsqueda binaria en enteros","title":"Búsqueda Binaria","type":"posts"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/","section":"David Zhang","summary":"","title":"David Zhang","type":"page"},{"content":"","date":"24 Ocak 2024","externalUrl":null,"permalink":"/tr/tags/ikili-arama/","section":"Tags","summary":"","title":"İkili Arama","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/m%E1%BA%ABu-thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Mẫu Thuật Toán","type":"tags"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/mod%C3%A8le-dalgorithme/","section":"Tags","summary":"","title":"Modèle D'algorithme","type":"tags"},{"content":"","date":"24 de janeiro de 2024","externalUrl":null,"permalink":"/pt/tags/modelos-de-algoritmos/","section":"Tags","summary":"","title":"Modelos De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/plantillas-de-algoritmos/","section":"Tags","summary":"","title":"Plantillas De Algoritmos","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"24 janvier 2024","externalUrl":null,"permalink":"/fr/tags/recherche-binaire/","section":"Tags","summary":"","title":"Recherche Binaire","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/ricerca-binaria/","section":"Tags","summary":"","title":"Ricerca Binaria","type":"tags"},{"content":"","date":"24 de enero de 2024","externalUrl":null,"permalink":"/es/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"24 gennaio 2024","externalUrl":null,"permalink":"/it/tags/template-algoritmo/","section":"Tags","summary":"","title":"Template Algoritmo","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/thu%E1%BA%ADt-to%C3%A1n/","section":"Tags","summary":"","title":"Thuật Toán","type":"tags"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/categories/thu%E1%BA%ADt-to%C3%A1n-v%C3%A0-c%E1%BA%A5u-tr%C3%BAc-d%E1%BB%AF-li%E1%BB%87u/","section":"Categories","summary":"","title":"Thuật Toán Và Cấu Trúc Dữ Liệu","type":"categories"},{"content":"","date":"24 tháng 12 năm 2024","externalUrl":null,"permalink":"/vi/tags/t%C3%ACm-ki%E1%BA%BFm-nh%E1%BB%8B-ph%C3%A2n/","section":"Tags","summary":"","title":"Tìm Kiếm Nhị Phân","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC/","section":"Tags","summary":"","title":"Алгоритм","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/categories/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/","section":"Categories","summary":"","title":"Алгоритмы И Структуры Данных","type":"categories"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/","section":"Tags","summary":"","title":"Двоичный Поиск","type":"tags"},{"content":"","date":"24 января 2024","externalUrl":null,"permalink":"/ru/tags/%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0/","section":"Tags","summary":"","title":"Шаблон Алгоритма","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE/","section":"Tags","summary":"","title":"एल्गोरिथम","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/categories/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%94%E0%A4%B0-%E0%A4%A1%E0%A5%87%E0%A4%9F%E0%A4%BE-%E0%A4%B8%E0%A4%82%E0%A4%B0%E0%A4%9A%E0%A4%A8%E0%A4%BE%E0%A4%8F%E0%A4%82/","section":"Categories","summary":"","title":"एल्गोरिथम और डेटा संरचनाएं","type":"categories"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%8F%E0%A4%B2%E0%A5%8D%E0%A4%97%E0%A5%8B%E0%A4%B0%E0%A4%BF%E0%A4%A5%E0%A4%AE-%E0%A4%9F%E0%A5%87%E0%A4%AE%E0%A5%8D%E0%A4%AA%E0%A4%B2%E0%A5%87%E0%A4%9F/","section":"Tags","summary":"","title":"एल्गोरिथम टेम्पलेट","type":"tags"},{"content":"","date":"24 जनवरी 2024","externalUrl":null,"permalink":"/hi/tags/%E0%A4%AC%E0%A4%BE%E0%A4%87%E0%A4%A8%E0%A4%B0%E0%A5%80-%E0%A4%B8%E0%A4%B0%E0%A5%8D%E0%A4%9A/","section":"Tags","summary":"","title":"बाइनरी सर्च","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","section":"Tags","summary":"","title":"알고리즘","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%8F-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","section":"Categories","summary":"","title":"알고리즘 및 자료 구조","type":"categories"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%85%9C%ED%94%8C%EB%A6%BF/","section":"Tags","summary":"","title":"알고리즘 템플릿","type":"tags"},{"content":"","date":"2024년 12월 24일","externalUrl":null,"permalink":"/ko/tags/%EC%9D%B4%EB%B6%84-%EA%B2%80%EC%83%89/","section":"Tags","summary":"","title":"이분 검색","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/","section":"Tags","summary":"","title":"アルゴリズム","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88/","section":"Tags","summary":"","title":"アルゴリズムテンプレート","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/","section":"Categories","summary":"","title":"アルゴリズムとデータ構造","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/ja/tags/%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2/","section":"Tags","summary":"","title":"二分探索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/","section":"Tags","summary":"","title":"二分搜尋","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"演算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"演算法模板","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-tw/categories/%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/","section":"Categories","summary":"","title":"演算法與資料結構","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"算法与数据结构","type":"categories"},{"content":"","date":"2024年12月24日","externalUrl":null,"permalink":"/zh-cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","section":"Tags","summary":"","title":"算法模板","type":"tags"},{"content":"","externalUrl":null,"permalink":"/es/series/","section":"Series","summary":"","title":"Series","type":"series"}]