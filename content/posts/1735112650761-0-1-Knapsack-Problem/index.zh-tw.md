markdown
---
title: "01背包問題"
date: 2024-12-24
draft: false
description: "最基礎的經典背包問題。"
summary: "最基礎的經典背包問題。"
tags: [ "算法", "動態規劃", "背包問題" ]
categories: [ "算法與數據結構" ]
series: [ "背包九講" ]
series_order: 1
---

## 題目

有 $N$ 件物品. 第 $i$ 件物品的體積是 $s_i$, 價值是 $v_i$.
每件物品只能取一次. 在不超過最大總體積限制 $S$ 的前提下，求能夠取得的最大總價值 $V$.

## 輸入格式

第一行兩個整數, $N, S$, 用空格隔開, 分別表示物品數量和最大總體積限制.
接下來有 $N$ 行, 每行兩個整數 $s_i, v_i$, 用空格隔開, 分別表示第 $i$ 件物品的體積和價值.

## 輸出格式

輸出一個整數, 表示最大價值.

## 數據範圍

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 輸入範例

```
4 5
1 2
2 4
3 4
4 5
```

## 輸出範例

```
8
```

## 題解

- 定義狀態: `f[i][j]` 表示前 $i$ 件物品，體積限制為 $j$ 可以獲得的最大價值。
    - 若不取第 $i$ 件物品, 那麼 `f[i][j] = f[i - 1][j]`
    - 若取第 $i$ 件物品, 那麼 `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - 實現狀態轉移時, 要注意定義域範圍. 若 $j < s_i$, 那麼不考慮取第 $i$ 件物品的情況。因為若 $j-s_i$ 為負數, 數組下標不合法。
      也可以這麼解釋: 第 $i$ 件物品的體積大於體積限制, 所以不可能。
- 定義初始條件: 前 $0$ 件物品，任何體積限制都獲得價值 $0$, 即 `f[0][j] = 0`, `j` $\in [0, S]$。
- 時間複雜度: $O(NS)$。

## 代碼

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 一維DP優化

- 將二維數組壓縮成一維數組, 可以顯著節省空間並提高一定程度的運行速度（缺點是無法滿足某些題型的特殊要求）
- 注意到狀態轉移中, `f[i][j]` 只與 `f[i - 1][j]` 和 `f[i - 1][j - s[i]]` 有關. 換言之在代碼中的二維數組 `f` 中,
  `f[i][j]` 只與它的上一行中比它更靠左或同列的元素有關, 因此可以將二維數組壓縮成一維數組或者滾動數組。
- 注意下面的代碼中, 第二層循環逆序遍歷, 這是因為我們要保證在計算 `f[i][j]` 時, `f[i - 1][j - s[i]]` 還沒有被更新.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 如果要求方案數

不僅要輸出能夠取得的最大總價值，還需要輸出“有多少種不同的選取方法可以達到這個最大總價值”。下面介紹在 01 背包問題中**如何統計方案數**。

### 二維 DP 統計方案數

下面以二維 DP 為例進行講解。

- 定義狀態：
  - `dp[i][j]` 表示「前 i 件物品，容量（體積限制）為 j 時，能取得的最大價值」。
  - `ways[i][j]` 表示「前 i 件物品，容量為 j，取得最大價值時對應的**方案數**」。

- 狀態轉移：
  1. 如果不選第 `i` 件物品：
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. 如果選第 `i` 件物品（前提是 $ j \ge s_i $）：
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 選或不選，最終 `dp[i][j]` 應取二者的較大值：
     - 如果
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       那麼說明「選第 i 件物品」的價值更大：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - 如果
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       說明兩種方式得到的最大價值相同，則方案數應該疊加：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - 如果
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       那麼說明「不選第 i 件物品」的價值更大，方案數繼承不選時的方案數：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 初始條件：
  - `dp[0][j] = 0` 表示前 0 件物品時，任何容量得到的最大價值都是 0。  
  - `ways[0][0] = 1` 表示「前 0 件物品、容量為 0」這一種情況是一種可行方案（即什麼都不選），**方案數**設為 1。  
  - 對於 `j > 0`，沒有物品可選時容量又大於 0，就不可能取得任何正價值，對應的方案數為 0，即 `ways[0][j] = 0`。

- 最終答案：  
  - `dp[N][S]` 即為最大價值。  
  - `ways[N][S]` 即為達到該最大價值的方案數。
  - 時間複雜度：$O(NS)$。
  - 這道題也可以使用一維 DP 進行優化。

## 如果要求恰好達到體積限制的情況

- 定義狀態: `f[i][j]` 表示前 `i` 件物品恰好有體積 $j$ 的最大價值.
- 若不取第 `i` 件物品, 那麼 `f[i][j] = f[i - 1][j]`
- 若取第 `i` 件物品, 那麼 `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- 可以注意到和原問題的狀態轉移沒有區別.
- 但是初始條件不同. 除了 `f[0][0] = 0`, 其餘 `f[0][j]` = $-\infty$, `j` $\in [1, S]$. $-\infty$ 表示不可能的狀態.

## 如果體積限制 $S$ 特別大 (1e9), 同時物品數量 $N$ 和最大總價值 $V$ 比較小

- 對於這樣的題, 有一種複雜度為 $O(NV)$ 的解法.
- 定義狀態: `f[i][j]` 表示前 `i` 件物品挑選若干件, 價值總和恰好為 `j` 的最小體積.
    - 若不取第 `i` 件物品, 那麼 `f[i][j] = f[i - 1][j]`
    - 若取第 `i` 件物品, 那麼 `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - 取兩者的較小值.
- 初始條件: `f[0][0] = 0`, 其餘 `f[0][j]` = $\infty$, `j` $\in [1, V]$. $\infty$ 表示不可能的狀態. 注意不是 $-\infty$.
- 最終答案為 `f[N][j]` 中最大的 `j` 使得 `f[N][j] <= S`.

## 如果體積限制 $S$ 和單個物品價值 $v_i$ 都特別大($1e9$ 量級), 同時物品數量 $N$ 特別小（最高不超過 40）

- 當 $N \leq 20$ 時，可以直接暴力枚舉所有子集（時間複雜度 $O(2^N)$。
- 當 $N \leq 40$ 時，由於 $2^{40}$ 在 $10^{12}$ 量級，直接暴力也會比較大，所以可以使用 **折半搜索**
  ，將複雜度大致降低到 $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$
  ，可以在可接受的時間內完成。