---
title: "01背包问题"
date: 2024-12-24
draft: false
description: "最基础的经典背包问题。"
summary: "最基础的经典背包问题。"
tags: [ "算法", "动态规划", "背包问题" ]
series: [ "背包经典问题集" ]
series_order: 1
---

## 题目

https://www.acwing.com/problem/content/2/

有 $N$ 件物品. 第 $i$ 件物品的体积是 $s_i$, 价值是 $v_i$.
每件物品只能取一次. 在不超过最大总体积限制 $S$ 的前提下，求能够取得的最大总价值 $V$.

## 输入格式

第一行两个整数, $N, S$, 用空格隔开, 分别表示物品数量和最大总体积限制.
接下来有 $N$ 行, 每行两个整数 $s_i, v_i$, 用空格隔开, 分别表示第 $i$ 件物品的体积和价值.

## 输出格式

输出一个整数, 表示最大价值.

## 数据范围

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

## 输出样例

```
8
```

## 题解

- 定义状态: `f[i][j]` 表示前 $i$ 件物品，体积限制为 $j$ 可以获得的最大价值。
    - 若不取第 $i$ 件物品, 那么 `f[i][j] = f[i - 1][j]`
    - 若取第 $i$ 件物品, 那么 `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - 实现状态转移时, 要注意定义域范围. 若 $j < s_i$, 那么不考虑取第 $i$ 件物品的情况。因为若 $j-s_i$ 为负数, 数组下标不合法。
      也可以这么解释: 第 $i$ 件物品的体积大于体积限制, 所以不可能。
- 定义初始条件: 前 $0$ 件物品，任何体积限制都获得价值 $0$, 即 `f[0][j] = 0`, `j` $\in [0, S]$。
- 时间复杂度: $O(NS)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 一维DP优化

- 将二维数组压缩成一维数组, 可以显著节省空间并提高一定程度的运行速度（缺点是无法满足某些题型的特殊要求）
- 注意到状态转移中, `f[i][j]` 只与 `f[i - 1][j]` 和 `f[i - 1][j - s[i]]` 有关. 换言之在代码中的二维数组 `f` 中,
  `f[i][j]` 只与它的上一行中比它更靠左或同列的元素有关, 因此可以将二维数组压缩成一维数组或者滚动数组。
- 注意下面的代码中, 第二层循环逆序遍历, 这是因为我们要保证在计算 `f[i][j]` 时, `f[i - 1][j - s[i]]` 还没有被更新.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 如果要求方案数

不仅要输出能够取得的最大总价值，还需要输出“有多少种不同的选取方法可以达到这个最大总价值”。下面介绍在 01 背包问题中*
*如何统计方案数**。

https://www.acwing.com/problem/content/11/

### 二维 DP 统计方案数

下面以二维 DP 为例进行讲解。

- 定义状态：
    - `dp[i][j]` 表示「前 i 件物品，容量（体积限制）为 j 时，能取得的最大价值」。
    - `ways[i][j]` 表示「前 i 件物品，容量为 j，取得最大价值时对应的**方案数**」。

- 状态转移：
    1. 如果不选第 `i` 件物品：
       $$
       \text{dp}[i][j] = \text{dp}[i-1][j],
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
       $$
    2. 如果选第 `i` 件物品（前提是 $ j \ge s_i $）：
       $$
       \text{dp}[i][j]
       = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
       = \text{ways}[i-1][j - s_i]
       $$
    3. 选或不选，最终 `dp[i][j]` 应取二者的较大值：
        - 如果
          $$
          \text{dp}[i-1][j - s_i] + v_i
          > \text{dp}[i-1][j],
          $$
          那么说明「选第 i 件物品」的价值更大：
          $$
          \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
          \quad
          \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
          $$
        - 如果
          $$
          \text{dp}[i-1][j - s_i] + v_i
          = \text{dp}[i-1][j],
          $$
          说明两种方式得到的最大价值相同，则方案数应该叠加：
          $$
          \text{dp}[i][j] = \text{dp}[i-1][j],
          \quad
          \text{ways}[i][j]
          = \text{ways}[i-1][j]
            + \text{ways}[i-1][j - s_i].
              $$
        - 如果
          $$
          \text{dp}[i-1][j - s_i] + v_i
          < \text{dp}[i-1][j],
          $$
          那么说明「不选第 i 件物品」的价值更大，方案数继承不选时的方案数：
          $$
          \text{dp}[i][j] = \text{dp}[i-1][j],
          \quad
          \text{ways}[i][j] = \text{ways}[i-1][j].
          $$

- 初始条件：
    - `dp[0][j] = 0` 表示前 0 件物品时，任何容量得到的最大价值都是 0。
    - `ways[0][0] = 1` 表示「前 0 件物品、容量为 0」这一种情况是一种可行方案（即什么都不选），**方案数**设为 1。
    - 对于 `j > 0`，没有物品可选时容量又大于 0，就不可能取得任何正价值，对应的方案数为 0，即 `ways[0][j] = 0`。

- 最终答案：
    - `dp[N][S]` 即为最大价值。
    - `ways[N][S]` 即为达到该最大价值的方案数。
    - 时间复杂度：$O(NS)$。
    - 这道题也可以使用一维 DP 进行优化。

## 如果要求恰好达到体积限制的情况

- 定义状态: `f[i][j]` 表示前 `i` 件物品恰好有体积 $j$ 的最大价值.
- 若不取第 `i` 件物品, 那么 `f[i][j] = f[i - 1][j]`
- 若取第 `i` 件物品, 那么 `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- 可以注意到和原问题的状态转移没有区别.
- 但是初始条件不同. 除了 `f[0][0] = 0`, 其余 `f[0][j]` = $-\infty$, `j` $\in [1, S]$. $-\infty$ 表示不可能的状态.

## 如果体积限制 $S$ 特别大 (1e9), 同时物品数量 $N$ 和最大总价值 $V$ 比较小

- 对于这样的题, 有一种复杂度为 $O(NV)$ 的解法.
- 定义状态: `f[i][j]` 表示前 `i` 件物品挑选若干件, 价值总和恰好为 `j` 的最小体积.
    - 若不取第 `i` 件物品, 那么 `f[i][j] = f[i - 1][j]`
    - 若取第 `i` 件物品, 那么 `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - 取两者的较小值.
- 初始条件: `f[0][0] = 0`, 其余 `f[0][j]` = $\infty$, `j` $\in [1, V]$. $\infty$ 表示不可能的状态. 注意不是 $-\infty$.
- 最终答案为 `f[N][j]` 中最大的 `j` 使得 `f[N][j] <= S`.

## 如果体积限制 $S$ 和单个物品价值 $v_i$ 都特别大($1e9$ 量级), 同时物品数量 $N$ 特别小（最高不超过 40）

https://www.acwing.com/solution/content/38250/

- 当 $N \leq 20$ 时，可以直接暴力枚举所有子集（时间复杂度 $O(2^N)$。
- 当 $N \leq 40$ 时，由于 $2^{40}$ 在 $10^{12}$ 量级，直接暴力也会比较大，所以可以使用 **折半搜索**
  ，将复杂度大致降低到 $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$
  ，可以在可接受的时间内完成。