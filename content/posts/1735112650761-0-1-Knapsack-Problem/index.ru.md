---
title: "01背包问题"
date: 2024-12-24
draft: false
description: "Самая базовая классическая задача о рюкзаке."
summary: "Самая базовая классическая задача о рюкзаке."
tags: [ "алгоритмы", "динамическое программирование", "задача о рюкзаке" ]
categories: [ "алгоритмы и структуры данных" ]
series: [ "девять лекций о рюкзаке" ]
---

## Задача

Есть $N$ предметов. Объем $i$-го предмета равен $s_i$, а его стоимость равна $v_i$.
Каждый предмет можно взять только один раз. При условии, что общий объем не превышает максимальное ограничение $S$, найдите максимальную общую стоимость $V$, которую можно получить.

## Формат ввода

В первой строке два целых числа, $N$ и $S$, разделенные пробелом, которые представляют количество предметов и максимальное ограничение по общему объему, соответственно.
Следующие $N$ строк содержат по два целых числа $s_i$ и $v_i$, разделенные пробелом, которые представляют объем и стоимость $i$-го предмета, соответственно.

## Формат вывода

Выведите одно целое число, представляющее максимальную стоимость.

## Ограничения данных

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## Пример ввода

```
4 5
1 2
2 4
3 4
4 5
```

## Пример вывода

```
8
```

## Решение

- Определение состояния: `f[i][j]` представляет максимальную стоимость, которую можно получить, используя первые $i$ предметов при ограничении объема $j$.
    - Если не брать $i$-й предмет, то `f[i][j] = f[i - 1][j]`.
    - Если брать $i$-й предмет, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`.
    - При реализации перехода состояний следует обращать внимание на область определения. Если $j < s_i$, то не следует рассматривать случай с взятием $i$-го предмета, так как если $j-s_i$ будет отрицательным числом, то индекс массива станет недействительным.
      Также можно объяснить это так: объем $i$-го предмета больше ограничения по объему, поэтому это невозможно.
- Определение начальных условий: первые $0$ предметов при любом ограничении по объему дают стоимость $0$, то есть `f[0][j] = 0`, `j` $\in [0, S]$.
- Временная сложность: $O(NS)$.

## Код

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## Оптимизация с одномерным DP

- Сжатие двумерного массива в одномерный может значительно сэкономить место и несколько увеличить скорость выполнения (недостатком является невозможность удовлетворить особые требования некоторых типов задач).
- Обратите внимание, что в переходе состояний `f[i][j]` зависит только от `f[i - 1][j]` и `f[i - 1][j - s[i]]`. Другими словами, в двумерном массиве `f` в коде `f[i][j]` зависит только от элементов, находящихся в предыдущей строке левее или в том же столбце, поэтому двумерный массив можно сжать в одномерный массив или использовать скользящий массив.
- Обратите внимание, что во втором цикле в приведенном ниже коде используется обратный проход, потому что мы хотим гарантировать, что при вычислении `f[i][j]` значение `f[i - 1][j - s[i]]` еще не было обновлено.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## Если требуется количество вариантов

Не только вывести максимальную общую стоимость, которую можно получить, но и вывести "сколько различных способов выбора может достичь этой максимальной общей стоимости". Ниже описано, **как подсчитать количество вариантов** в задаче о рюкзаке 01.

### Подсчет количества вариантов с помощью двумерного DP

Ниже мы рассмотрим это на примере двумерного DP.

- Определение состояния:
  - `dp[i][j]` представляет "максимальную стоимость, которую можно получить, используя первые i предметов при объеме (ограничении объема) j".
  - `ways[i][j]` представляет "количество **вариантов**, которые соответствуют максимальной стоимости, полученной с помощью первых i предметов при объеме j".

- Переход состояний:
  1. Если не выбирать `i`-й предмет:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. Если выбирать `i`-й предмет (при условии $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. Выбирать или не выбирать, окончательное значение `dp[i][j]` должно быть наибольшим из двух:
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       то это означает, что "выбор i-го предмета" имеет большую стоимость:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       это означает, что максимальная стоимость, полученная двумя способами, одинакова, поэтому количество вариантов должно быть сложено:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       то это означает, что "не выбирать i-й предмет" имеет большую стоимость, поэтому количество вариантов наследуется от количества вариантов, когда не выбирается предмет:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- Начальные условия:
  - `dp[0][j] = 0` означает, что максимальная стоимость, полученная с помощью 0 предметов, при любом объеме равна 0.
  - `ways[0][0] = 1` означает, что "0 предметов, объем 0" является одним из возможных вариантов (то есть ничего не выбирать), и **количество вариантов** устанавливается равным 1.
  - Для `j > 0`, когда нет предметов для выбора, а объем больше 0, невозможно получить какую-либо положительную стоимость, поэтому количество вариантов равно 0, то есть `ways[0][j] = 0`.

- Окончательный ответ:
  - `dp[N][S]` - это максимальная стоимость.
  - `ways[N][S]` - это количество вариантов достижения этой максимальной стоимости.
  - Временная сложность: $O(NS)$.
  - Эту задачу также можно оптимизировать с помощью одномерного DP.

## Если требуется точно достичь ограничения по объему

- Определение состояния: `f[i][j]` представляет максимальную стоимость для первых `i` предметов, общий объем которых составляет ровно `j`.
- Если не брать `i`-й предмет, то `f[i][j] = f[i - 1][j]`.
- Если брать `i`-й предмет, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`.
- Можно заметить, что переход состояний не отличается от исходной задачи.
- Однако начальные условия другие. Помимо `f[0][0] = 0`, остальные `f[0][j]` = $-\infty$, `j` $\in [1, S]$. $-\infty$ означает невозможное состояние.

## Если ограничение по объему $S$ особенно велико (1e9), а количество предметов $N$ и максимальная общая стоимость $V$ относительно малы

- Для таких задач есть решение со сложностью $O(NV)$.
- Определение состояния: `f[i][j]` представляет минимальный объем при выборе нескольких из первых `i` предметов, общая стоимость которых составляет ровно `j`.
    - Если не брать `i`-й предмет, то `f[i][j] = f[i - 1][j]`.
    - Если брать `i`-й предмет, то `f[i][j] = f[i - 1][j - v[i]] + s[i]`.
    - Берем меньшее из двух значений.
- Начальные условия: `f[0][0] = 0`, остальные `f[0][j]` = $\infty$, `j` $\in [1, V]$. $\infty$ означает невозможное состояние. Обратите внимание, что это не $-\infty$.
- Окончательный ответ - это наибольшее `j` из `f[N][j]`, при котором `f[N][j] <= S`.

## Если ограничение по объему $S$ и стоимость отдельного предмета $v_i$ особенно велики (порядка $1e9$), а количество предметов $N$ особенно мало (не более 40)

- Когда $N \leq 20$, можно напрямую перечислить все подмножества (временная сложность $O(2^N)$).
- Когда $N \leq 40$, так как $2^{40}$ находится в диапазоне $10^{12}$, то прямой перебор будет слишком большим, поэтому можно использовать **поиск по методу «разделяй и властвуй»**, что примерно снизит сложность до $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$
  , и это можно сделать за приемлемое время.