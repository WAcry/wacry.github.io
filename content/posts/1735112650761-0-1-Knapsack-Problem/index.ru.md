---
title: "01背包问题"
date: 2024-12-24
draft: false
description: "Самая базовая классическая задача о рюкзаке."
summary: "Самая базовая классическая задача о рюкзаке."
tags: [ "Алгоритмы", "Динамическое программирование", "Задача о рюкзаке" ]
categories: [ "Алгоритмы и структуры данных" ]
series: [ "Девять лекций о рюкзаке" ]
series_order: 1
---

## Задача

Есть $N$ предметов. Объем $i$-го предмета равен $s_i$, а его ценность равна $v_i$.
Каждый предмет можно взять только один раз. При условии, что общий объем не превышает максимального ограничения $S$, найдите максимальную общую ценность $V$, которую можно получить.

## Формат ввода

В первой строке два целых числа $N$ и $S$, разделенные пробелом, обозначающие количество предметов и максимальное ограничение общего объема соответственно.
В следующих $N$ строках по два целых числа $s_i$ и $v_i$, разделенные пробелом, обозначающие объем и ценность $i$-го предмета соответственно.

## Формат вывода

Выведите одно целое число, представляющее максимальную ценность.

## Ограничения

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## Пример ввода

```
4 5
1 2
2 4
3 4
4 5
```

## Пример вывода

```
8
```

## Решение

- Определение состояния: `f[i][j]` представляет максимальную ценность, которую можно получить, используя первые $i$ предметов при ограничении объема $j$.
    - Если не брать $i$-й предмет, то `f[i][j] = f[i - 1][j]`
    - Если брать $i$-й предмет, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - При реализации перехода состояний следует обратить внимание на область определения. Если $j < s_i$, то не рассматриваем случай взятия $i$-го предмета. Потому что если $j-s_i$ отрицательное число, то индекс массива будет недействительным.
      Можно объяснить и так: объем $i$-го предмета больше ограничения объема, поэтому это невозможно.
- Определение начальных условий: для первых $0$ предметов при любом ограничении объема ценность равна $0$, то есть `f[0][j] = 0`, `j` $\in [0, S]$.
- Временная сложность: $O(NS)$.

## Код

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## Оптимизация с помощью одномерного DP

- Преобразование двумерного массива в одномерный позволяет значительно сэкономить место и немного увеличить скорость выполнения (недостаток в том, что это не удовлетворяет особым требованиям некоторых типов задач)
- Заметим, что в переходе состояний `f[i][j]` зависит только от `f[i - 1][j]` и `f[i - 1][j - s[i]]`. Другими словами, в двумерном массиве `f` в коде,
  `f[i][j]` зависит только от элементов в предыдущей строке, которые находятся левее или в том же столбце, поэтому двумерный массив можно преобразовать в одномерный или использовать скользящий массив.
- Обратите внимание, что во вложенном цикле ниже, второй цикл проходит в обратном порядке, это потому, что мы хотим гарантировать, что при вычислении `f[i][j]`, `f[i - 1][j - s[i]]` еще не был обновлен.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## Если требуется количество решений

Нужно не только вывести максимальную общую ценность, но и "сколько различных способов выбора позволяют достичь этой максимальной общей ценности". Ниже описано, **как подсчитать количество решений** в задаче о рюкзаке 0-1.

### Подсчет количества решений с помощью двумерного DP

Ниже приводится объяснение на примере двумерного DP.

- Определение состояния:
  - `dp[i][j]` представляет "максимальную ценность, которую можно получить, используя первые i предметов при ограничении объема (лимита) j".
  - `ways[i][j]` представляет "количество **решений**, соответствующих максимальной ценности, полученной при использовании первых i предметов при объеме j".

- Переход состояний:
  1. Если не выбирать `i`-й предмет:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. Если выбрать `i`-й предмет (при условии, что $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. Выбирать или не выбирать, в конечном итоге `dp[i][j]` должен принимать большее из двух значений:
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       то это означает, что "выбор i-го предмета" имеет большую ценность:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       это означает, что максимальная ценность, полученная двумя способами, одинакова, тогда количество решений должно быть сложено:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       то это означает, что "не выбирать i-й предмет" имеет большую ценность, количество решений наследуется от количества решений, когда предмет не выбирается:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- Начальные условия:
  - `dp[0][j] = 0` означает, что при использовании первых 0 предметов максимальная ценность, полученная при любом объеме, равна 0.
  - `ways[0][0] = 1` означает, что случай "первые 0 предметов, объем 0" является одним из возможных решений (то есть ничего не выбирать), **количество решений** устанавливается равным 1.
  - Для `j > 0`, когда нет предметов для выбора, а объем больше 0, невозможно получить какую-либо положительную ценность, соответствующее количество решений равно 0, то есть `ways[0][j] = 0`.

- Окончательный ответ:
  - `dp[N][S]` - это максимальная ценность.
  - `ways[N][S]` - это количество решений, позволяющих достичь этой максимальной ценности.
  - Временная сложность: $O(NS)$.
  - Эту задачу также можно оптимизировать с помощью одномерного DP.

## Если требуется точное соответствие ограничению объема

- Определение состояния: `f[i][j]` представляет максимальную ценность, когда первые `i` предметов имеют точный объем $j$.
- Если не брать `i`-й предмет, то `f[i][j] = f[i - 1][j]`
- Если брать `i`-й предмет, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- Можно заметить, что переход состояний не отличается от исходной задачи.
- Но начальные условия отличаются. Кроме `f[0][0] = 0`, остальные `f[0][j]` = $-\infty$, `j` $\in [1, S]$. $-\infty$ означает невозможное состояние.

## Если ограничение объема $S$ очень велико (1e9), а количество предметов $N$ и максимальная общая ценность $V$ относительно малы

- Для такой задачи есть решение со сложностью $O(NV)$.
- Определение состояния: `f[i][j]` представляет минимальный объем, когда из первых `i` предметов выбрано несколько, а общая ценность равна `j`.
    - Если не брать `i`-й предмет, то `f[i][j] = f[i - 1][j]`
    - Если брать `i`-й предмет, то `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - Берем меньшее из двух значений.
- Начальные условия: `f[0][0] = 0`, остальные `f[0][j]` = $\infty$, `j` $\in [1, V]$. $\infty$ означает невозможное состояние. Обратите внимание, что это не $-\infty$.
- Окончательный ответ - это наибольшее `j` из `f[N][j]`, такое что `f[N][j] <= S`.

## Если ограничение объема $S$ и ценность отдельного предмета $v_i$ очень велики (порядка $1e9$), а количество предметов $N$ очень мало (не более 40)

- Когда $N \leq 20$, можно напрямую перебрать все подмножества (временная сложность $O(2^N)$).
- Когда $N \leq 40$, поскольку $2^{40}$ имеет порядок $10^{12}$, прямой перебор также будет довольно большим, поэтому можно использовать **поиск с разделением пополам**,
  чтобы снизить сложность примерно до $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$
  , что можно выполнить за приемлемое время.