---
title: "Задача о рюкзаке 0-1"
date: 2024-12-24
draft: false
description: "Самая базовая классическая задача о рюкзаке."
summary: "Самая базовая классическая задача о рюкзаке."
tags: [ "Алгоритм", "Динамическое программирование", "Задача о рюкзаке" ]
categories: [ "Алгоритмы и структуры данных" ]
---

## Задача

Есть $N$ предметов. Объем $i$-го предмета равен $s_i$, а его стоимость равна $v_i$.
Каждый предмет можно взять только один раз. При условии, что общий объем не превышает максимального предела $S$, найдите максимальную общую стоимость $V$, которую можно получить.

## Формат ввода

Первая строка содержит два целых числа $N$ и $S$, разделенных пробелом, представляющих количество предметов и максимальный общий предел объема соответственно.
Следующие $N$ строк содержат по два целых числа $s_i$ и $v_i$, разделенных пробелом, представляющих объем и стоимость $i$-го предмета соответственно.

## Формат вывода

Выведите целое число, представляющее максимальную стоимость.

## Диапазон данных

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## Пример ввода

```
4 5
1 2
2 4
3 4
4 5
```

## Пример вывода

```
8
```

## Решение

- Определите состояние: `f[i][j]` представляет максимальную стоимость, которую можно получить из первых $i$ предметов с ограничением объема $j$.
    - Если $i$-й предмет не берется, то `f[i][j] = f[i - 1][j]`
    - Если $i$-й предмет берется, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - При реализации перехода состояния обратите внимание на диапазон. Если $j < s_i$, то не рассматривайте случай взятия $i$-го предмета. Потому что если $j - s_i$ отрицательно, то индекс массива будет недопустимым.
      Это также можно объяснить так: объем $i$-го предмета больше, чем предел объема, поэтому это невозможно.
- Определите начальное условие: Для первых $0$ предметов любое ограничение объема дает значение $0$, т.е. `f[0][j] = 0`, `j` $\in [0, S]$.
- Временная сложность: $O(NS)$.

## Код

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## Оптимизация 1D DP

- Сжатие двумерного массива в одномерный массив может значительно сэкономить место и в определенной степени повысить скорость работы (недостаток заключается в том, что он не может удовлетворить особые требования некоторых типов задач).
- Обратите внимание, что в переходе состояния `f[i][j]` связан только с `f[i - 1][j]` и `f[i - 1][j - s[i]]`. Другими словами, в двумерном массиве `f` в коде,
  `f[i][j]` связан только с элементами в предыдущей строке, которые находятся слева от него или в том же столбце. Следовательно, двумерный массив можно сжать в одномерный массив или скользящий массив.
- Обратите внимание, что в приведенном ниже коде второй цикл выполняется в обратном порядке. Это связано с тем, что мы хотим убедиться, что при вычислении `f[i][j]` значение `f[i - 1][j - s[i]]` еще не было обновлено.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## Если требуется количество схем

Нужно вывести не только максимальную общую стоимость, которую можно получить, но и "сколько различных способов выбора могут достичь этой максимальной общей стоимости". Ниже описано, **как подсчитать количество схем** в задаче о рюкзаке 0-1.

### 2D DP для подсчета схем

В качестве примера ниже используется 2D DP.

- Определите состояние:
  - `dp[i][j]` представляет "максимальную стоимость, которую можно получить при рассмотрении первых i предметов с вместимостью (ограничением объема) j".
  - `ways[i][j]` представляет "количество **схем**, соответствующих максимальной стоимости, полученной при рассмотрении первых i предметов с вместимостью j".

- Переход состояния:
  1. Если `i`-й предмет не выбран:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. Если `i`-й предмет выбран (при условии, что $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. Независимо от того, выбирать или нет, окончательный `dp[i][j]` должен принимать большее из двух:
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       то это означает, что "выбор i-го предмета" имеет большее значение:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       это означает, что максимальное значение, полученное двумя методами, одинаково, тогда количество схем следует сложить:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - Если
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       то это означает, что "невыбор i-го предмета" имеет большее значение, и количество схем наследует количество схем при невыборе:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- Начальные условия:
  - `dp[0][j] = 0` означает, что когда есть 0 предметов, максимальное значение, полученное для любой вместимости, равно 0.
  - `ways[0][0] = 1` означает, что случай "0 предметов, вместимость 0" является возможной схемой (т.е. ничего не выбирать), и **количество схем** устанавливается равным 1.
  - Для `j > 0`, когда нет предметов для выбора и вместимость больше 0, невозможно получить какое-либо положительное значение, и соответствующее количество схем равно 0, т.е. `ways[0][j] = 0`.

- Окончательный ответ:
  - `dp[N][S]` - это максимальное значение.
  - `ways[N][S]` - это количество схем для достижения этого максимального значения.
  - Временная сложность: $O(NS)$.
  - Эту задачу также можно оптимизировать с помощью 1D DP.

## Если требуется точно достичь предела объема

- Определите состояние: `f[i][j]` представляет максимальную стоимость, когда первые `i` предметов имеют точно объем $j$.
- Если `i`-й предмет не берется, то `f[i][j] = f[i - 1][j]`
- Если `i`-й предмет берется, то `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- Можно заметить, что в переходе состояния нет отличий от исходной задачи.
- Однако начальные условия отличаются. За исключением `f[0][0] = 0`, остальные `f[0][j]` = $-\infty$, `j` $\in [1, S]$. $-\infty$ представляет невозможное состояние.

## Если предел объема $S$ очень велик (1e9), а количество предметов $N$ и максимальная общая стоимость $V$ относительно малы

- Для таких задач есть решение со сложностью $O(NV)$.
- Определите состояние: `f[i][j]` представляет минимальный объем при выборе нескольких предметов из первых `i` предметов, а общая стоимость равна `j`.
    - Если `i`-й предмет не берется, то `f[i][j] = f[i - 1][j]`
    - Если `i`-й предмет берется, то `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - Возьмите меньшее из двух.
- Начальные условия: `f[0][0] = 0`, остальные `f[0][j]` = $\infty$, `j` $\in [1, V]$. $\infty$ представляет невозможное состояние. Обратите внимание, что это не $-\infty$.
- Окончательный ответ - это наибольшее `j` в `f[N][j]`, такое что `f[N][j] <= S`.

## Если предел объема $S$ и стоимость одного предмета $v_i$ очень велики (порядка 1e9), а количество предметов $N$ очень мало (не более 40)

- Когда $N \leq 20$, все подмножества можно перечислить напрямую грубой силой (временная сложность $O(2^N)$).
- Когда $N \leq 40$, поскольку $2^{40}$ имеет порядок $10^{12}$, прямое перечисление грубой силой также будет относительно большим, поэтому можно использовать **поиск посередине**, чтобы уменьшить сложность примерно до $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$, что можно выполнить за приемлемое время.