---
title: "01 नैपसेक समस्या"
date: 2024-12-24
draft: false
description: "सबसे बुनियादी क्लासिक नैपसेक समस्या।"
summary: "सबसे बुनियादी क्लासिक नैपसेक समस्या।"
tags: [ "एल्गोरिथम", "डायनेमिक प्रोग्रामिंग", "नैपसेक समस्या" ]
categories: [ "एल्गोरिदम और डेटा संरचनाएं" ]
---

## समस्या

$N$ वस्तुएँ हैं। $i$-वीं वस्तु का आयतन $s_i$ है, और इसका मान $v_i$ है।
प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त के तहत, अधिकतम कुल मान $V$ ज्ञात करें जो प्राप्त किया जा सकता है।

## इनपुट प्रारूप

पहली पंक्ति में दो पूर्णांक, $N$ और $S$, एक स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा का प्रतिनिधित्व करते हैं।
निम्नलिखित $N$ पंक्तियों में प्रत्येक में दो पूर्णांक, $s_i$ और $v_i$, एक स्थान से अलग किए गए हैं, जो क्रमशः $i$-वीं वस्तु के आयतन और मान का प्रतिनिधित्व करते हैं।

## आउटपुट प्रारूप

अधिकतम मान का प्रतिनिधित्व करने वाला एक पूर्णांक आउटपुट करें।

## डेटा रेंज

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## इनपुट उदाहरण

```
4 5
1 2
2 4
3 4
4 5
```

## आउटपुट उदाहरण

```
8
```

## समाधान

- स्थिति को परिभाषित करें: `f[i][j]` पहले $i$ वस्तुओं से प्राप्त किए जा सकने वाले अधिकतम मान का प्रतिनिधित्व करता है, जिसकी आयतन सीमा $j$ है।
    - यदि $i$-वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
    - यदि $i$-वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - स्थिति संक्रमण को लागू करते समय, डोमेन रेंज पर ध्यान दें। यदि $j < s_i$, तो $i$-वीं वस्तु लेने के मामले पर विचार न करें। क्योंकि यदि $j - s_i$ ऋणात्मक है, तो सरणी सूचकांक अवैध है।
      इसे इस तरह भी समझाया जा सकता है: $i$-वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है।
- प्रारंभिक स्थिति को परिभाषित करें: पहली $0$ वस्तुओं के लिए, किसी भी आयतन सीमा से $0$ का मान प्राप्त होता है, अर्थात, `f[0][j] = 0`, `j` $\in [0, S]$।
- समय जटिलता: $O(NS)$।

## कोड

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 1D DP ऑप्टिमाइजेशन

- दो-आयामी सरणी को एक-आयामी सरणी में संपीड़ित करने से काफी जगह बच सकती है और कुछ हद तक चलने की गति में सुधार हो सकता है (नुकसान यह है कि यह कुछ समस्या प्रकारों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है)।
- ध्यान दें कि स्थिति संक्रमण में, `f[i][j]` केवल `f[i - 1][j]` और `f[i - 1][j - s[i]]` से संबंधित है। दूसरे शब्दों में, कोड में दो-आयामी सरणी `f` में,
  `f[i][j]` केवल पिछली पंक्ति के उन तत्वों से संबंधित है जो इसके बाईं ओर या उसी कॉलम में हैं। इसलिए, दो-आयामी सरणी को एक-आयामी सरणी या एक रोलिंग सरणी में संपीड़ित किया जा सकता है।
- ध्यान दें कि नीचे दिए गए कोड में, दूसरा लूप उल्टे क्रम में पुनरावृति करता है। ऐसा इसलिए है क्योंकि हम यह सुनिश्चित करना चाहते हैं कि `f[i][j]` की गणना करते समय, `f[i - 1][j - s[i]]` को अभी तक अपडेट नहीं किया गया है।

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## यदि योजनाओं की संख्या आवश्यक है

न केवल अधिकतम कुल मान जो प्राप्त किया जा सकता है, उसे आउटपुट किया जाना चाहिए, बल्कि "कितनी अलग-अलग चयन विधियां इस अधिकतम कुल मान को प्राप्त कर सकती हैं"। निम्नलिखित 01 नैपसेक समस्या में **योजनाओं की संख्या की गणना कैसे करें** का वर्णन करता है।

### योजनाओं की गणना करने के लिए 2D DP

निम्नलिखित 2D DP का उपयोग एक उदाहरण के रूप में समझाने के लिए करता है।

- स्थिति को परिभाषित करें:
  - `dp[i][j]` "क्षमता (आयतन सीमा) j के साथ पहली i वस्तुओं पर विचार करते समय प्राप्त किए जा सकने वाले अधिकतम मान" का प्रतिनिधित्व करता है।
  - `ways[i][j]` "क्षमता j के साथ पहली i वस्तुओं पर विचार करते समय प्राप्त अधिकतम मान के अनुरूप **योजनाओं की संख्या**" का प्रतिनिधित्व करता है।

- स्थिति संक्रमण:
  1. यदि `i`-वीं वस्तु का चयन नहीं किया जाता है:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. यदि `i`-वीं वस्तु का चयन किया जाता है (बशर्ते कि $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. चयन करना है या नहीं, अंतिम `dp[i][j]` को दोनों में से बड़ा लेना चाहिए:
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "i-वीं वस्तु का चयन करने" का मान अधिक है:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि दो विधियों द्वारा प्राप्त अधिकतम मान समान है, तो योजनाओं की संख्या को जोड़ा जाना चाहिए:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "i-वीं वस्तु का चयन नहीं करने" का मान अधिक है, और योजनाओं की संख्या चयन नहीं करने पर योजनाओं की संख्या को विरासत में देती है:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- प्रारंभिक स्थितियाँ:
  - `dp[0][j] = 0` का अर्थ है कि जब 0 वस्तुएँ होती हैं, तो किसी भी क्षमता के लिए प्राप्त अधिकतम मान 0 होता है।
  - `ways[0][0] = 1` का अर्थ है कि "0 वस्तुएँ, क्षमता 0" का मामला एक व्यवहार्य योजना है (अर्थात, कुछ भी नहीं चुनना), और **योजनाओं की संख्या** 1 पर सेट है।
  - `j > 0` के लिए, जब चुनने के लिए कोई वस्तु नहीं होती है और क्षमता 0 से अधिक होती है, तो कोई भी सकारात्मक मान प्राप्त करना असंभव है, और योजनाओं की संबंधित संख्या 0 है, अर्थात, `ways[0][j] = 0`।

- अंतिम उत्तर:
  - `dp[N][S]` अधिकतम मान है।
  - `ways[N][S]` इस अधिकतम मान को प्राप्त करने के लिए योजनाओं की संख्या है।
  - समय जटिलता: $O(NS)$।
  - इस समस्या को 1D DP का उपयोग करके भी अनुकूलित किया जा सकता है।

## यदि आवश्यकता आयतन सीमा तक ठीक से पहुँचने की है

- स्थिति को परिभाषित करें: `f[i][j]` अधिकतम मान का प्रतिनिधित्व करता है जब पहली `i` वस्तुओं का आयतन ठीक $j$ होता है।
- यदि `i`-वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
- यदि `i`-वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- यह ध्यान दिया जा सकता है कि मूल समस्या से स्थिति संक्रमण में कोई अंतर नहीं है।
- हालाँकि, प्रारंभिक स्थितियाँ अलग हैं। `f[0][0] = 0` को छोड़कर, शेष `f[0][j]` = $-\infty$, `j` $\in [1, S]$। $-\infty$ एक असंभव स्थिति का प्रतिनिधित्व करता है।

## यदि आयतन सीमा $S$ बहुत बड़ी है (1e9), जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मान $V$ अपेक्षाकृत छोटे हैं

- ऐसी समस्याओं के लिए, $O(NV)$ की जटिलता वाला एक समाधान है।
- स्थिति को परिभाषित करें: `f[i][j]` पहली `i` वस्तुओं में से कई वस्तुओं का चयन करते समय न्यूनतम आयतन का प्रतिनिधित्व करता है, और कुल मान ठीक `j` है।
    - यदि `i`-वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
    - यदि `i`-वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - दोनों में से छोटा लें।
- प्रारंभिक स्थितियाँ: `f[0][0] = 0`, शेष `f[0][j]` = $\infty$, `j` $\in [1, V]$। $\infty$ एक असंभव स्थिति का प्रतिनिधित्व करता है। ध्यान दें कि यह $-\infty$ नहीं है।
- अंतिम उत्तर `f[N][j]` में सबसे बड़ा `j` है जैसे कि `f[N][j] <= S`।

## यदि आयतन सीमा $S$ और एक एकल वस्तु का मान $v_i$ दोनों बहुत बड़े हैं (1e9 के क्रम में), जबकि वस्तुओं की संख्या $N$ बहुत कम है (40 से अधिक नहीं)

- जब $N \leq 20$, तो सभी उपसमुच्चय को सीधे क्रूर बल द्वारा गिना जा सकता है (समय जटिलता $O(2^N)$)।
- जब $N \leq 40$, चूंकि $2^{40}$ $10^{12}$ के क्रम में है, इसलिए प्रत्यक्ष क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए जटिलता को लगभग $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$ तक कम करने के लिए **बीच में मिलन खोज** का उपयोग किया जा सकता है, जिसे स्वीकार्य समय में पूरा किया जा सकता है।