---
title: "01背包 समस्या"
date: 2024-12-24
draft: false
description: "सबसे बुनियादी क्लासिक बैग समस्या।"
summary: "सबसे बुनियादी क्लासिक बैग समस्या।"
tags: [ "एल्गोरिथम", "डायनेमिक प्रोग्रामिंग", "बैग समस्या" ]
categories: [ "एल्गोरिथम और डेटा संरचना" ]
series: [ "बैग नौ व्याख्यान" ]
series_order: 1
---

## प्रश्न

https://www.acwing.com/problem/content/2/

$N$ वस्तुएँ हैं। $i$वीं वस्तु का आयतन $s_i$ है, और मूल्य $v_i$ है।
प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त पर, प्राप्त किए जा सकने वाले अधिकतम कुल मूल्य $V$ की गणना करें।

## इनपुट प्रारूप

पहली पंक्ति में दो पूर्णांक, $N, S$, रिक्त स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा को दर्शाते हैं।
अगली $N$ पंक्तियों में, प्रत्येक पंक्ति में दो पूर्णांक $s_i, v_i$, रिक्त स्थान से अलग किए गए हैं, जो क्रमशः $i$वीं वस्तु के आयतन और मूल्य को दर्शाते हैं।

## आउटपुट प्रारूप

एक पूर्णांक आउटपुट करें, जो अधिकतम मूल्य को दर्शाता है।

## डेटा रेंज

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## इनपुट नमूना

```
4 5
1 2
2 4
3 4
4 5
```

## आउटपुट नमूना

```
8
```

## समाधान

- स्थिति को परिभाषित करें: `f[i][j]` पहले $i$ वस्तुओं के लिए, आयतन सीमा $j$ के साथ प्राप्त किए जा सकने वाले अधिकतम मूल्य को दर्शाता है।
    - यदि $i$वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
    - यदि $i$वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - स्थिति संक्रमण को लागू करते समय, परिभाषा क्षेत्र की सीमा पर ध्यान दें। यदि $j < s_i$, तो $i$वीं वस्तु लेने की स्थिति पर विचार न करें। क्योंकि यदि $j-s_i$ ऋणात्मक है, तो सरणी सूचकांक अवैध है।
      इसे इस प्रकार भी समझाया जा सकता है: $i$वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है।
- प्रारंभिक स्थिति को परिभाषित करें: पहले $0$ वस्तुओं के लिए, किसी भी आयतन सीमा पर $0$ मूल्य प्राप्त होता है, अर्थात `f[0][j] = 0`, `j` $\in [0, S]$।
- समय जटिलता: $O(NS)$।

## कोड

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## एक-आयामी DP अनुकूलन

- दो-आयामी सरणी को एक-आयामी सरणी में संपीड़ित करने से, स्थान की काफी बचत हो सकती है और एक निश्चित सीमा तक चलने की गति में सुधार हो सकता है (नुकसान यह है कि यह कुछ प्रकार के प्रश्नों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है)
- ध्यान दें कि स्थिति संक्रमण में, `f[i][j]` केवल `f[i - 1][j]` और `f[i - 1][j - s[i]]` से संबंधित है। दूसरे शब्दों में, कोड में दो-आयामी सरणी `f` में,
  `f[i][j]` केवल अपनी पिछली पंक्ति में इसके बाईं ओर या उसी कॉलम के तत्वों से संबंधित है, इसलिए दो-आयामी सरणी को एक-आयामी सरणी या रोलिंग सरणी में संपीड़ित किया जा सकता है।
- ध्यान दें कि नीचे दिए गए कोड में, दूसरी लूप विपरीत क्रम में पुनरावृति करती है, ऐसा इसलिए है क्योंकि हमें यह सुनिश्चित करना है कि `f[i][j]` की गणना करते समय, `f[i - 1][j - s[i]]` को अभी तक अपडेट नहीं किया गया है।

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## यदि योजनाओं की संख्या की आवश्यकता हो

न केवल प्राप्त किए जा सकने वाले अधिकतम कुल मूल्य को आउटपुट करना है, बल्कि यह भी आउटपुट करना है कि "इस अधिकतम कुल मूल्य को प्राप्त करने के लिए कितने अलग-अलग चयन विधियाँ हैं"। नीचे 01 बैग समस्या में **योजनाओं की संख्या को कैसे गिनें** इसका परिचय दिया गया है।

https://www.acwing.com/problem/content/11/

### दो-आयामी DP योजनाओं की संख्या की गणना

नीचे दो-आयामी DP का उपयोग करके एक उदाहरण दिया गया है।

- स्थिति को परिभाषित करें:
  - `dp[i][j]` "पहले i वस्तुओं के लिए, क्षमता (आयतन सीमा) j होने पर, प्राप्त किए जा सकने वाले अधिकतम मूल्य" को दर्शाता है।
  - `ways[i][j]` "पहले i वस्तुओं के लिए, क्षमता j होने पर, अधिकतम मूल्य प्राप्त करते समय संबंधित **योजनाओं की संख्या**" को दर्शाता है।

- स्थिति संक्रमण:
  1. यदि $i$वीं वस्तु का चयन नहीं किया जाता है:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. यदि $i$वीं वस्तु का चयन किया जाता है (यह मानते हुए कि $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. चयन करें या न करें, अंततः `dp[i][j]` को दोनों में से बड़ा मान लेना चाहिए:
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "iवीं वस्तु का चयन करने" का मूल्य अधिक है:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि दोनों तरीकों से प्राप्त अधिकतम मूल्य समान है, तो योजनाओं की संख्या को जोड़ा जाना चाहिए:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "iवीं वस्तु का चयन न करने" का मूल्य अधिक है, योजनाओं की संख्या चयन न करने की योजनाओं की संख्या को विरासत में देती है:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- प्रारंभिक स्थिति:
  - `dp[0][j] = 0` का अर्थ है कि पहले 0 वस्तुओं के लिए, किसी भी क्षमता पर प्राप्त अधिकतम मूल्य 0 है।
  - `ways[0][0] = 1` का अर्थ है कि "पहले 0 वस्तुओं, क्षमता 0" की स्थिति एक व्यवहार्य योजना है (अर्थात कुछ भी न चुनें), **योजनाओं की संख्या** 1 पर सेट है।
  - `j > 0` के लिए, जब चुनने के लिए कोई वस्तु नहीं है और क्षमता 0 से अधिक है, तो कोई सकारात्मक मूल्य प्राप्त करना संभव नहीं है, संबंधित योजनाओं की संख्या 0 है, अर्थात `ways[0][j] = 0`।

- अंतिम उत्तर:
  - `dp[N][S]` अधिकतम मूल्य है।
  - `ways[N][S]` उस अधिकतम मूल्य को प्राप्त करने के लिए योजनाओं की संख्या है।
  - समय जटिलता: $O(NS)$।
  - इस प्रश्न को एक-आयामी DP का उपयोग करके भी अनुकूलित किया जा सकता है।

## यदि आयतन सीमा को ठीक से प्राप्त करने की आवश्यकता हो

- स्थिति को परिभाषित करें: `f[i][j]` पहले `i` वस्तुओं के लिए ठीक आयतन $j$ के अधिकतम मूल्य को दर्शाता है।
- यदि $i$वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
- यदि $i$वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- ध्यान दें कि मूल समस्या के स्थिति संक्रमण में कोई अंतर नहीं है।
- लेकिन प्रारंभिक स्थिति अलग है। `f[0][0] = 0` के अलावा, शेष `f[0][j]` = $-\infty$, `j` $\in [1, S]$। $-\infty$ एक असंभव स्थिति को दर्शाता है।

## यदि आयतन सीमा $S$ विशेष रूप से बड़ी (1e9) है, जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मूल्य $V$ अपेक्षाकृत छोटे हैं

- इस तरह के प्रश्न के लिए, $O(NV)$ की जटिलता वाला एक समाधान है।
- स्थिति को परिभाषित करें: `f[i][j]` पहले `i` वस्तुओं में से कुछ का चयन करने पर, मूल्य का कुल योग ठीक `j` होने पर न्यूनतम आयतन को दर्शाता है।
    - यदि $i$वीं वस्तु नहीं ली जाती है, तो `f[i][j] = f[i - 1][j]`
    - यदि $i$वीं वस्तु ली जाती है, तो `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - दोनों में से छोटा मान लें।
- प्रारंभिक स्थिति: `f[0][0] = 0`, शेष `f[0][j]` = $\infty$, `j` $\in [1, V]$। $\infty$ एक असंभव स्थिति को दर्शाता है। ध्यान दें कि यह $-\infty$ नहीं है।
- अंतिम उत्तर `f[N][j]` में सबसे बड़ा `j` है जिससे `f[N][j] <= S` हो।

## यदि आयतन सीमा $S$ और एकल वस्तु का मूल्य $v_i$ दोनों विशेष रूप से बड़े हैं (1e9 के क्रम में), जबकि वस्तुओं की संख्या $N$ विशेष रूप से छोटी है (अधिकतम 40 से अधिक नहीं)

https://www.acwing.com/solution/content/38250/

- जब $N \leq 20$ होता है, तो सभी उपसमुच्चयों को सीधे क्रूर बल से गिना जा सकता है (समय जटिलता $O(2^N)$)।
- जब $N \leq 40$ होता है, तो $2^{40}$ $10^{12}$ के क्रम में होने के कारण, क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए **मध्य-खोज** का उपयोग किया जा सकता है,
  जटिलता को मोटे तौर पर $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$ तक कम किया जा सकता है,
  जिसे स्वीकार्य समय में पूरा किया जा सकता है।