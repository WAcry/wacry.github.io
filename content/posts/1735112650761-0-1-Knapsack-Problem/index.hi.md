---
title: "01背包 समस्या"
date: 2024-12-24
draft: false
description: "सबसे बुनियादी क्लासिक बैग समस्या।"
summary: "सबसे बुनियादी क्लासिक बैग समस्या।"
tags: [ "एल्गोरिथम", "गतिशील प्रोग्रामिंग", "बैग समस्या" ]
categories: [ "एल्गोरिथम और डेटा संरचना" ]
series: [ "बैग नौ व्याख्यान" ]
series_order: 1
---

## प्रश्न

$N$ वस्तुएँ हैं। $i$वीं वस्तु का आयतन $s_i$ है और मान $v_i$ है।
प्रत्येक वस्तु को केवल एक बार लिया जा सकता है। अधिकतम कुल आयतन सीमा $S$ से अधिक न होने की शर्त के तहत, प्राप्त किया जा सकने वाला अधिकतम कुल मान $V$ ज्ञात कीजिए।

## इनपुट प्रारूप

पहली पंक्ति में दो पूर्णांक हैं, $N, S$, जो स्थान से अलग किए गए हैं, जो क्रमशः वस्तुओं की संख्या और अधिकतम कुल आयतन सीमा को दर्शाते हैं।
इसके बाद $N$ पंक्तियाँ हैं, प्रत्येक पंक्ति में दो पूर्णांक $s_i, v_i$ हैं, जो स्थान से अलग किए गए हैं, जो क्रमशः $i$वीं वस्तु के आयतन और मान को दर्शाते हैं।

## आउटपुट प्रारूप

एक पूर्णांक आउटपुट करें, जो अधिकतम मान को दर्शाता है।

## डेटा सीमा

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## इनपुट नमूना

```
4 5
1 2
2 4
3 4
4 5
```

## आउटपुट नमूना

```
8
```

## समाधान

- स्थिति को परिभाषित करें: `f[i][j]` पहले $i$ वस्तुओं के लिए अधिकतम मान को दर्शाता है, जहां आयतन सीमा $j$ है।
    - यदि $i$वीं वस्तु को नहीं लिया जाता है, तो `f[i][j] = f[i - 1][j]`
    - यदि $i$वीं वस्तु को लिया जाता है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - स्थिति स्थानांतरण को लागू करते समय, परिभाषा डोमेन रेंज पर ध्यान दें। यदि $j < s_i$, तो $i$वीं वस्तु को लेने की स्थिति पर विचार न करें। क्योंकि यदि $j-s_i$ एक ऋणात्मक संख्या है, तो सरणी सूचकांक अवैध है।
      इसे इस प्रकार भी समझा जा सकता है: $i$वीं वस्तु का आयतन आयतन सीमा से अधिक है, इसलिए यह असंभव है।
- प्रारंभिक स्थितियों को परिभाषित करें: पहले $0$ वस्तुओं के लिए, किसी भी आयतन सीमा पर $0$ का मान प्राप्त होता है, अर्थात् `f[0][j] = 0`, `j` $\in [0, S]$।
- समय जटिलता: $O(NS)$।

## कोड

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## एक आयामी DP अनुकूलन

- दो आयामी सरणी को एक आयामी सरणी में संकुचित करके, आप अंतरिक्ष को काफी हद तक बचा सकते हैं और संचालन की गति को एक निश्चित सीमा तक बढ़ा सकते हैं (नुकसान यह है कि यह कुछ प्रश्न प्रकारों की विशेष आवश्यकताओं को पूरा नहीं कर सकता है)।
- ध्यान दें कि स्थिति स्थानांतरण में, `f[i][j]` केवल `f[i - 1][j]` और `f[i - 1][j - s[i]]` से संबंधित है। दूसरे शब्दों में, कोड में दो आयामी सरणी `f` में,
  `f[i][j]` केवल अपनी पिछली पंक्ति के उन तत्वों से संबंधित है जो इसके बाईं ओर या उसी कॉलम में हैं, इसलिए दो आयामी सरणी को एक आयामी सरणी या रोलिंग सरणी में संकुचित किया जा सकता है।
- ध्यान दें कि निम्न कोड में, दूसरी लूप व्युत्क्रम क्रम में पुनरावृति करती है, इसका कारण यह है कि हम यह सुनिश्चित करना चाहते हैं कि `f[i][j]` की गणना करते समय, `f[i - 1][j - s[i]]` को अभी तक अपडेट नहीं किया गया है।

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## यदि योजना संख्याओं की आवश्यकता है

न केवल प्राप्त किए जा सकने वाले अधिकतम कुल मान को आउटपुट करें, बल्कि यह भी आउटपुट करें कि "कितने अलग-अलग चयन विधियों से यह अधिकतम कुल मान प्राप्त किया जा सकता है"। अब 01 बैग समस्या में **योजना संख्याओं को कैसे गिना जाए** इसका परिचय देते हैं।

### दो-आयामी DP के साथ योजना संख्याओं की गणना करना

अब दो-आयामी DP का उदाहरण लेकर समझाते हैं।

- स्थिति को परिभाषित करें:
  - `dp[i][j]` का अर्थ है "पहली i वस्तुओं के लिए, क्षमता (आयतन सीमा) j होने पर प्राप्त किया जा सकने वाला अधिकतम मान"।
  - `ways[i][j]` का अर्थ है "पहली i वस्तुओं के लिए, क्षमता j होने पर अधिकतम मान प्राप्त होने पर संबंधित **योजना संख्याओं** की संख्या"।

- स्थिति स्थानांतरण:
  1. यदि iवीं वस्तु का चयन नहीं किया जाता है:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. यदि iवीं वस्तु का चयन किया जाता है (इस शर्त के साथ कि $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. चयन करें या न करें, अंततः `dp[i][j]` को दोनों में से बड़ा मान लेना चाहिए:
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "iवीं वस्तु को चुनने" का मान बड़ा है:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि दोनों तरीकों से प्राप्त अधिकतम मान समान है, इसलिए योजना संख्याओं को जोड़ना चाहिए:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - यदि
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       तो इसका मतलब है कि "iवीं वस्तु का चयन न करने" का मान बड़ा है, योजना संख्याएं चयन न करने की योजना संख्याओं को प्राप्त करती हैं:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- प्रारंभिक स्थितियां:
  - `dp[0][j] = 0` का अर्थ है कि पहले 0 वस्तुओं के लिए, किसी भी क्षमता से प्राप्त अधिकतम मान 0 है।
  - `ways[0][0] = 1` का अर्थ है कि "पहले 0 वस्तुओं, क्षमता 0" की यह स्थिति एक व्यवहार्य योजना है (अर्थात, कुछ भी न चुनें), **योजना संख्याओं** को 1 पर सेट किया गया है।
  - `j > 0` के लिए, जब कोई वस्तु चुनने के लिए नहीं है, लेकिन क्षमता 0 से अधिक है, तो कोई भी सकारात्मक मान प्राप्त करना संभव नहीं है, संबंधित योजना संख्या 0 है, अर्थात `ways[0][j] = 0`।

- अंतिम उत्तर:
  - `dp[N][S]` अधिकतम मान है।
  - `ways[N][S]` वह योजना संख्या है जो इस अधिकतम मान को प्राप्त करती है।
  - समय जटिलता: $O(NS)$।
  - इस समस्या को एक आयामी DP के साथ भी अनुकूलित किया जा सकता है।

## यदि आयतन सीमा को ठीक से प्राप्त करने की आवश्यकता हो

- स्थिति को परिभाषित करें: `f[i][j]` पहली `i` वस्तुओं के ठीक आयतन $j$ के अधिकतम मान को दर्शाता है।
- यदि iवीं वस्तु को नहीं लिया जाता है, तो `f[i][j] = f[i - 1][j]`
- यदि iवीं वस्तु को लिया जाता है, तो `f[i][j] = f[i - 1][j - s[i]] + v[i]`
- आप ध्यान दे सकते हैं कि मूल समस्या के साथ स्थिति स्थानांतरण में कोई अंतर नहीं है।
- लेकिन प्रारंभिक स्थितियां अलग हैं। `f[0][0] = 0` के अलावा, शेष `f[0][j]` = $-\infty$, `j` $\in [1, S]$। $-\infty$ एक असंभव स्थिति को दर्शाता है।

## यदि आयतन सीमा $S$ विशेष रूप से बड़ी (1e9) है, जबकि वस्तुओं की संख्या $N$ और अधिकतम कुल मान $V$ अपेक्षाकृत छोटे हैं

- ऐसी समस्याओं के लिए, $O(NV)$ की जटिलता वाला समाधान है।
- स्थिति को परिभाषित करें: `f[i][j]` का अर्थ है कि पहले `i` वस्तुओं में से कुछ को चुना गया है, और मानों का योग ठीक `j` होने पर न्यूनतम आयतन।
    - यदि iवीं वस्तु को नहीं लिया जाता है, तो `f[i][j] = f[i - 1][j]`
    - यदि iवीं वस्तु को लिया जाता है, तो `f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - दोनों में से छोटे मान को लें।
- प्रारंभिक स्थितियां: `f[0][0] = 0`, शेष `f[0][j]` = $\infty$, `j` $\in [1, V]$। $\infty$ एक असंभव स्थिति को दर्शाता है। ध्यान दें कि यह $-\infty$ नहीं है।
- अंतिम उत्तर `f[N][j]` में अधिकतम `j` है जिससे `f[N][j] <= S` हो।

## यदि आयतन सीमा $S$ और एकल वस्तु मान $v_i$ दोनों विशेष रूप से बड़े ($1e9$ के क्रम में) हैं, जबकि वस्तुओं की संख्या $N$ विशेष रूप से छोटी है (अधिकतम 40 से अधिक नहीं)

- जब $N \leq 20$ हो, तो सभी उपसमुच्चयों को सीधे क्रूर बल से गिना जा सकता है (समय जटिलता $O(2^N)$)।
- जब $N \leq 40$ हो, तो $2^{40}$ $10^{12}$ के क्रम में होने के कारण, प्रत्यक्ष क्रूर बल भी अपेक्षाकृत बड़ा होगा, इसलिए **आधे में विभाजित खोज** का उपयोग किया जा सकता है, जिससे जटिलता लगभग $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$ तक कम हो जाती है, जिसे स्वीकार्य समय के भीतर पूरा किया जा सकता है।