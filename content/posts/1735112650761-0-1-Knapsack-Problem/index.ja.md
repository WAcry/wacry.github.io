markdown
---
title: "01ナップサック問題"
date: 2024-12-24
draft: false
description: "最も基礎的な古典的ナップサック問題。"
summary: "最も基礎的な古典的ナップサック問題。"
tags: [ "アルゴリズム", "動的計画法", "ナップサック問題" ]
categories: [ "アルゴリズムとデータ構造" ]
series: [ "ナップサック九講" ]
series_order: 1
---

## 問題

$N$ 個の品物があります。$i$ 番目の品物の体積は $s_i$、価値は $v_i$ です。
各品物は一度しか取れません。最大総体積制限 $S$ を超えない範囲で、取得できる最大総価値 $V$ を求めてください。

## 入力形式

1行目に2つの整数 $N, S$ がスペース区切りで与えられます。それぞれ品物の数と最大総体積制限を表します。
続く $N$ 行には、各行に2つの整数 $s_i, v_i$ がスペース区切りで与えられます。それぞれ $i$ 番目の品物の体積と価値を表します。

## 出力形式

最大価値を表す整数を1つ出力してください。

## データ範囲

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 入力例

```
4 5
1 2
2 4
3 4
4 5
```

## 出力例

```
8
```

## 解法

- 状態の定義: `f[i][j]` を、最初の $i$ 個の品物から、体積制限が $j$ のときに得られる最大価値とします。
    - $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
    - $i$ 番目の品物を取る場合、`f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - 状態遷移を実装する際には、定義域の範囲に注意する必要があります。もし $j < s_i$ なら、$i$ 番目の品物を取るケースは考慮しません。なぜなら、$j - s_i$ が負の数になると、配列のインデックスが不正になるからです。
      別の言い方をすると、$i$ 番目の品物の体積が体積制限よりも大きいため、ありえないということです。
- 初期条件の定義: 最初の $0$ 個の品物の場合、体積制限が何であれ、得られる価値は $0$ です。つまり、`f[0][j] = 0`、$j$ $\in [0, S]$。
- 時間計算量: $O(NS)$。

## コード

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 一次元DPによる最適化

- 二次元配列を一次元配列に圧縮することで、空間を大幅に節約し、実行速度をある程度向上させることができます（欠点は、一部のタイプの問題の特別な要件を満たすことができないことです）。
- 状態遷移において、`f[i][j]` は `f[i - 1][j]` と `f[i - 1][j - s[i]]` のみに関連していることに注意してください。言い換えれば、コード内の二次元配列 `f` では、
  `f[i][j]` は、その上の行で、より左側にあるか、同じ列にある要素のみに関連しています。したがって、二次元配列を一次元配列またはローリング配列に圧縮することができます。
- 次のコードでは、2番目のループが逆順に反復処理されていることに注意してください。これは、`f[i][j]` を計算するときに、`f[i - 1][j - s[i]]` がまだ更新されていないことを保証するためです。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## もし解の数を求める場合

取得できる最大総価値を出力するだけでなく、「この最大総価値を達成できる異なる選択方法が何通りあるか」も出力する必要がある場合。以下に、01ナップサック問題で**解の数を数える方法**を紹介します。

### 二次元DPで解の数を数える

以下に、二次元DPを例に説明します。

- 状態の定義：
  - `dp[i][j]` は、「最初の i 個の品物から、容量（体積制限）が j のときに、取得できる最大価値」を表します。
  - `ways[i][j]` は、「最初の i 個の品物から、容量が j で、最大価値を取得するときの**解の数**」を表します。

- 状態遷移：
  1. i 番目の品物を選ばない場合：
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. i 番目の品物を選ぶ場合（前提条件は $ j \ge s_i $）：
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 選ぶか選ばないかに関わらず、最終的な `dp[i][j]` は2つのうち大きい方を取る必要があります。
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       ならば、「i 番目の品物を選ぶ」方が価値が大きいことを意味します。
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       ならば、2つの方法で得られる最大価値が同じであることを意味します。したがって、解の数を加算する必要があります。
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       ならば、「i 番目の品物を選ばない」方が価値が大きいことを意味します。解の数は選ばない場合の解の数を継承します。
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 初期条件：
  - `dp[0][j] = 0` は、最初の0個の品物の場合、どの容量でも得られる最大価値は0であることを意味します。
  - `ways[0][0] = 1` は、「最初の0個の品物、容量が0」という状況が1つの実行可能な解（つまり、何も選ばない）であることを意味し、**解の数**を1に設定します。
  - `j > 0` の場合、選べる品物がないのに容量が0より大きい場合は、正の価値を得ることは不可能であり、対応する解の数は0です。つまり、`ways[0][j] = 0`。

- 最終的な答え：
  - `dp[N][S]` が最大価値です。
  - `ways[N][S]` が、その最大価値を達成する解の数です。
  - 時間計算量：$O(NS)$。
  - この問題は、一次元DPを使用して最適化することもできます。

## もし体積制限にちょうど一致する場合を求める場合

- 状態の定義: `f[i][j]` を、最初の `i` 個の品物で、体積がちょうど $j$ であるときの最大価値とします。
- $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
- $i$ 番目の品物を取る場合、`f[i][j] = f[i - 1][j - s[i]] + v[i]`
- 元の問題の状態遷移と違いがないことに注意してください。
- ただし、初期条件が異なります。`f[0][0] = 0` を除き、残りの `f[0][j]` = $-\infty$、$j$ $\in [1, S]$。$-\infty$ は不可能な状態を表します。

## もし体積制限 $S$ が非常に大きく (1e9)、同時に品物の数 $N$ と最大総価値 $V$ が比較的小さい場合

- このような問題に対して、$O(NV)$ の計算量で解く方法があります。
- 状態の定義: `f[i][j]` を、最初の `i` 個の品物からいくつかを選び、価値の合計がちょうど `j` であるときの最小体積とします。
    - $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
    - $i$ 番目の品物を取る場合、`f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - 2つのうち小さい方を取ります。
- 初期条件: `f[0][0] = 0`、残りの `f[0][j]` = $\infty$、$j$ $\in [1, V]$。$\infty$ は不可能な状態を表します。$-\infty$ ではないことに注意してください。
- 最終的な答えは、`f[N][j] <= S` を満たす最大の `j` です。

## もし体積制限 $S$ と個々の品物の価値 $v_i$ が非常に大きく（$1e9$ オーダー）、同時に品物の数 $N$ が非常に小さい場合（最大でも40以下）

- $N \leq 20$ の場合、すべてのサブセットを直接列挙できます（時間計算量 $O(2^N)$）。
- $N \leq 40$ の場合、$2^{40}$ は $10^{12}$ オーダーであるため、直接列挙すると大きくなりすぎるため、**半分全列挙**を使用できます。
  これにより、計算量を $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$ に削減できます。
  これにより、許容時間内に完了できます。