---
title: "01背包問題"
date: 2024-12-24
draft: false
description: "最も基本的な古典的なナップサック問題。"
summary: "最も基本的な古典的なナップサック問題。"
tags: [ "アルゴリズム", "動的計画法", "ナップサック問題" ]
categories: [ "アルゴリズムとデータ構造" ]
series: [ "ナップサック九講" ]
series_order: 1
---

## 問題

$N$ 個の品物があります。$i$ 番目の品物の体積は $s_i$、価値は $v_i$ です。
各品物は一度しか取ることができません。最大総体積制限 $S$ を超えない範囲で、取得できる最大総価値 $V$ を求めてください。

## 入力形式

1行目に2つの整数 $N, S$ が空白で区切られて与えられます。それぞれ品物の数と最大総体積制限を表します。
続く $N$ 行に、各行に2つの整数 $s_i, v_i$ が空白で区切られて与えられます。それぞれ $i$ 番目の品物の体積と価値を表します。

## 出力形式

最大価値を表す整数を1つ出力します。

## データ範囲

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 入力例

```
4 5
1 2
2 4
3 4
4 5
```

## 出力例

```
8
```

## 解法

- 状態の定義: `f[i][j]` は、最初の $i$ 個の品物で、体積制限が $j$ である場合に得られる最大価値を表します。
    - $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
    - $i$ 番目の品物を選ぶ場合、`f[i][j] = f[i - 1][j - s[i]] + v[i]`
    - 状態遷移を実装する際には、定義域の範囲に注意する必要があります。$j < s_i$ の場合、$i$ 番目の品物を選ぶケースは考慮しません。なぜなら、$j-s_i$ が負の数になる場合、配列の添え字が不正になるからです。
      あるいは、$i$ 番目の品物の体積が体積制限よりも大きいので、不可能であると解釈することもできます。
- 初期条件の定義: 最初の $0$ 個の品物の場合、どのような体積制限でも価値は $0$ になるので、`f[0][j] = 0`、$j$ $\in [0, S]$ です。
- 時間計算量: $O(NS)$。

## コード

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 一次元DPの最適化

- 二次元配列を一次元配列に圧縮することで、大幅な空間削減と一定程度の実行速度向上が可能です（欠点は、一部の特殊な問題要件を満たせないことです）。
- 状態遷移では、`f[i][j]` は `f[i - 1][j]` と `f[i - 1][j - s[i]]` のみに依存することに注意してください。言い換えると、コード中の二次元配列 `f` では、
  `f[i][j]` はその前の行の左側にある要素または同じ列の要素のみに依存するため、二次元配列を一次元配列またはローリング配列に圧縮することができます。
- 下のコードでは、二番目のループが逆順に走査していることに注意してください。これは、`f[i][j]` を計算する際に、`f[i - 1][j - s[i]]` がまだ更新されていないことを保証するためです。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 解法の数を求める場合

取得できる最大総価値を出力するだけでなく、「この最大総価値を達成できる異なる選択方法の数はいくつあるか」を出力する必要があります。以下に、01ナップサック問題で**解法の数を数える方法**を紹介します。

### 二次元DPによる解法数の統計

以下では、二次元DPを例に解説します。

- 状態の定義：
  - `dp[i][j]` は「最初の i 個の品物で、容量（体積制限）が j のときに得られる最大価値」を表します。
  - `ways[i][j]` は「最初の i 個の品物で、容量が j のときに、最大価値を達成する**解法の数**」を表します。

- 状態遷移：
  1. $i$ 番目の品物を選ばない場合：
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. $i$ 番目の品物を選ぶ場合（前提は $ j \ge s_i $）：
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 選ぶか選ばないか、最終的に `dp[i][j]` は2つのうち大きい方を取る必要があります：
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       ならば、「$i$ 番目の品物を選ぶ」方が価値が大きいことを示します：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       ならば、2つの方法で得られる最大価値が同じであることを示します。したがって、解法の数は加算する必要があります：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - もし
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       ならば、「$i$ 番目の品物を選ばない」方が価値が大きいことを示します。解法の数は選ばない場合の解法の数を継承します：
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 初期条件：
  - `dp[0][j] = 0` は、最初の0個の品物の場合、どんな容量でも得られる最大価値は0であることを示します。
  - `ways[0][0] = 1` は、「最初の0個の品物、容量が0」という状態が1つの実行可能な解法であることを示します（つまり何も選ばない）。**解法の数**は1に設定されます。
  - `j > 0` の場合、選べる品物がないときに容量が0より大きければ、どんな正の価値も得られないため、対応する解法の数は0、つまり `ways[0][j] = 0` です。

- 最終的な答え：
  - `dp[N][S]` は最大価値です。
  - `ways[N][S]` は、その最大価値に到達する解法の数です。
  - 時間計算量：$O(NS)$。
  - この問題は、一次元DPで最適化することもできます。

## 体積制限にちょうど一致する場合を求める場合

- 状態の定義: `f[i][j]` は、最初の `i` 個の品物で、体積がちょうど $j$ である場合の最大価値を表します。
- $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
- $i$ 番目の品物を選ぶ場合、`f[i][j] = f[i - 1][j - s[i]] + v[i]`
- 元の問題の状態遷移と違いがないことに注意できます。
- ただし、初期条件が異なります。`f[0][0] = 0` に加え、残りの `f[0][j]` = $-\infty$、`j` $\in [1, S]$。$-\infty$ は不可能な状態を表します。

## 体積制限 $S$ が非常に大きい (1e9) が、品物の数 $N$ と最大総価値 $V$ が比較的小さい場合

- このような問題の場合、計算量が $O(NV)$ の解法があります。
- 状態の定義: `f[i][j]` は、最初の `i` 個の品物からいくつか選び、価値の合計がちょうど `j` になる場合の最小体積を表します。
    - $i$ 番目の品物を取らない場合、`f[i][j] = f[i - 1][j]`
    - $i$ 番目の品物を選ぶ場合、`f[i][j] = f[i - 1][j - v[i]] + s[i]`
    - 2つのうち小さい方を取ります。
- 初期条件: `f[0][0] = 0` で、残りの `f[0][j]` = $\infty$、`j` $\in [1, V]$。$\infty$ は不可能な状態を表します。 $-\infty$ ではありません。
- 最終的な答えは `f[N][j]` の中で `f[N][j] <= S` を満たす最大の `j` になります。

## 体積制限 $S$ と個々の品物の価値 $v_i$ がどちらも非常に大きい（$1e9$ のオーダー）が、品物の数 $N$ が非常に小さい（最大でも40以下）場合

- $N \leq 20$ の場合、すべての部分集合を直接列挙する総当たり法が使えます（時間計算量 $O(2^N)$）。
- $N \leq 40$ の場合、$2^{40}$ が $10^{12}$ オーダーなので、直接的な総当たり法は大きくなりすぎます。そのため、**半分全列挙**を利用することで、計算量を $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$ 程度に減らすことができ、許容できる時間内に完了できます。