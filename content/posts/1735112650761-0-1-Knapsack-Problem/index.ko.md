---
title: "01 배낭 문제"
date: 2024-12-24
draft: false
description: "가장 기초적인 클래식 배낭 문제."
summary: "가장 기초적인 클래식 배낭 문제."
tags: [ "알고리즘", "동적 계획법", "배낭 문제" ]
categories: [ "알고리즘 및 자료 구조" ]
series: [ "배낭 9강" ]
series_order: 1
---

## 문제

$N$개의 물건이 있습니다. $i$번째 물건의 부피는 $s_i$이고, 가치는 $v_i$입니다.
각 물건은 한 번만 가져갈 수 있습니다. 최대 총 부피 제한 $S$를 넘지 않는 전제 하에, 얻을 수 있는 최대 총 가치 $V$를 구하세요.

## 입력 형식

첫 번째 줄에 두 정수 $N, S$가 공백으로 구분되어 주어집니다. 각각 물건의 개수와 최대 총 부피 제한을 나타냅니다.
다음 $N$개의 줄에는 각각 두 정수 $s_i, v_i$가 공백으로 구분되어 주어집니다. 각각 $i$번째 물건의 부피와 가치를 나타냅니다.

## 출력 형식

최대 가치를 나타내는 정수를 출력합니다.

## 데이터 범위

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 입력 예시

```
4 5
1 2
2 4
3 4
4 5
```

## 출력 예시

```
8
```

## 문제 풀이

- 상태 정의: `f[i][j]`는 처음 $i$개의 물건에 대해, 부피 제한이 $j$일 때 얻을 수 있는 최대 가치를 나타냅니다.
    - $i$번째 물건을 선택하지 않는 경우, `f[i][j] = f[i - 1][j]`입니다.
    - $i$번째 물건을 선택하는 경우, `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
    - 상태 전이를 구현할 때, 정의된 범위에 유의해야 합니다. 만약 $j < s_i$라면, $i$번째 물건을 선택하는 경우를 고려하지 않아야 합니다. 왜냐하면 $j - s_i$가 음수가 되면, 배열 인덱스가 유효하지 않기 때문입니다.
      이것을 다음과 같이 설명할 수도 있습니다. $i$번째 물건의 부피가 부피 제한보다 크기 때문에, 불가능합니다.
- 초기 조건 정의: 처음 $0$개의 물건에 대해서는, 어떤 부피 제한이라도 얻을 수 있는 가치는 $0$입니다. 즉, `f[0][j] = 0`, `j` $\in [0, S]$입니다.
- 시간 복잡도: $O(NS)$입니다.

## 코드

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 1차원 DP 최적화

- 2차원 배열을 1차원 배열로 압축하면, 공간을 크게 절약하고 어느 정도 실행 속도를 높일 수 있습니다 (단점은 일부 유형의 문제에 대한 특수한 요구 사항을 충족할 수 없다는 점입니다).
- 상태 전이에서, `f[i][j]`는 `f[i - 1][j]`와 `f[i - 1][j - s[i]]`에만 관련되어 있음에 유의하십시오. 다시 말해, 코드의 2차원 배열 `f`에서,
  `f[i][j]`는 위 행에서 왼쪽 또는 같은 열의 요소와만 관련되어 있으므로, 2차원 배열을 1차원 배열 또는 롤링 배열로 압축할 수 있습니다.
- 아래 코드에서 두 번째 루프가 역순으로 순회하는 이유는 `f[i][j]`를 계산할 때, `f[i - 1][j - s[i]]`가 아직 업데이트되지 않았음을 보장해야 하기 때문입니다.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 해법의 수를 요구하는 경우

얻을 수 있는 최대 총 가치를 출력해야 할 뿐만 아니라, "이 최대 총 가치를 달성할 수 있는 서로 다른 선택 방법이 몇 가지인지"도 출력해야 합니다. 다음은 01 배낭 문제에서 **해법 수를 계산하는 방법**을 소개합니다.

### 2차원 DP로 해법 수 계산하기

다음은 2차원 DP를 예로 들어 설명합니다.

- 상태 정의:
  - `dp[i][j]`는 "처음 i개 물건에 대해 용량(부피 제한)이 j일 때, 얻을 수 있는 최대 가치"를 나타냅니다.
  - `ways[i][j]`는 "처음 i개 물건에 대해 용량이 j이고, 최대 가치를 얻을 때의 **해법 수**"를 나타냅니다.

- 상태 전이:
  1. $i$번째 물건을 선택하지 않는 경우:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. $i$번째 물건을 선택하는 경우 ($j \ge s_i$라는 전제 하에):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 선택하거나 선택하지 않거나, 최종적으로 `dp[i][j]`는 둘 중 더 큰 값을 취해야 합니다.
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       라면 "$i$번째 물건을 선택하는 것"의 가치가 더 크다는 의미입니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       라면 두 가지 방법 모두 최대 가치가 같다는 의미이므로, 해법 수를 누적해야 합니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       라면 "$i$번째 물건을 선택하지 않는 것"의 가치가 더 크다는 의미이며, 해법 수는 선택하지 않을 때의 해법 수를 상속합니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 초기 조건:
  - `dp[0][j] = 0`은 처음 0개 물건에 대해, 어떤 용량이라도 얻을 수 있는 최대 가치가 0임을 나타냅니다.
  - `ways[0][0] = 1`은 "처음 0개 물건, 용량 0"의 경우가 하나의 가능한 해법(아무것도 선택하지 않음)임을 나타냅니다. **해법 수**를 1로 설정합니다.
  - `j > 0`에 대해, 선택할 수 있는 물건이 없을 때 용량이 0보다 크면 어떤 양의 가치도 얻을 수 없으므로 해당하는 해법 수는 0입니다. 즉, `ways[0][j] = 0`입니다.

- 최종 답:
  - `dp[N][S]`는 최대 가치입니다.
  - `ways[N][S]`는 해당 최대 가치를 달성하는 해법 수입니다.
  - 시간 복잡도: $O(NS)$입니다.
  - 이 문제는 1차원 DP를 사용하여 최적화할 수도 있습니다.

## 정확히 부피 제한을 달성해야 하는 경우

- 상태 정의: `f[i][j]`는 처음 `i`개 물건에 대해 정확히 부피 $j$인 최대 가치를 나타냅니다.
- $i$번째 물건을 선택하지 않으면, `f[i][j] = f[i - 1][j]`입니다.
- $i$번째 물건을 선택하면, `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
- 원래 문제의 상태 전이와 차이가 없음을 알 수 있습니다.
- 하지만 초기 조건이 다릅니다. `f[0][0] = 0` 외에, 나머지 `f[0][j]`는 $-\infty`입니다. `j` $\in [1, S]$. $-\infty$는 불가능한 상태를 나타냅니다.

## 부피 제한 $S$가 매우 크고(1e9), 물건 수 $N$과 최대 총 가치 $V$가 비교적 작은 경우

- 이러한 문제의 경우, 복잡도가 $O(NV)$인 해결 방법이 있습니다.
- 상태 정의: `f[i][j]`는 처음 `i`개 물건에서 몇 개를 선택하여 가치 합계가 정확히 `j`일 때의 최소 부피를 나타냅니다.
    - $i$번째 물건을 선택하지 않으면, `f[i][j] = f[i - 1][j]`입니다.
    - $i$번째 물건을 선택하면, `f[i][j] = f[i - 1][j - v[i]] + s[i]`입니다.
    - 둘 중 작은 값을 취합니다.
- 초기 조건: `f[0][0] = 0`, 나머지 `f[0][j]`는 $\infty$입니다. `j` $\in [1, V]$. $\infty$는 불가능한 상태를 나타냅니다. $-\infty$가 아님에 유의하십시오.
- 최종 답은 `f[N][j] <= S`를 만족하는 `f[N][j]` 중 가장 큰 `j`입니다.

## 부피 제한 $S$와 개별 물건의 가치 $v_i$가 모두 매우 크고(1e9 수준), 물건 수 $N$이 특히 작은 경우(최대 40 이하)

- $N \leq 20$일 때는 모든 하위 집합을 직접적으로 열거할 수 있습니다(시간 복잡도 $O(2^N)$).
- $N \leq 40$일 때는 $2^{40}$이 $10^{12}$ 수준이므로, 직접적인 무차별 대입도 비교적 클 수 있으므로 **중간 분할 검색**을 사용할 수 있습니다.
  복잡도를 대략 $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$로 줄일 수 있습니다.
  , 허용 가능한 시간 내에 완료할 수 있습니다.