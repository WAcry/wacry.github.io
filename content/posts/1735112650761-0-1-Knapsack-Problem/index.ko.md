# 01 배낭 문제

**날짜:** 2024-12-24
**초안:** false
**설명:** 가장 기본적인 고전 배낭 문제.
**요약:** 가장 기본적인 고전 배낭 문제.
**태그:** [ "알고리즘", "동적 계획법", "배낭 문제" ]
**카테고리:** [ "알고리즘과 자료구조" ]
**시리즈:** [ "배낭 9강" ]
**시리즈 순서:** 1

## 문제

[문제 링크 삭제됨]

$N$개의 물건이 있습니다. $i$번째 물건의 부피는 $s_i$, 가치는 $v_i$입니다.
각 물건은 한 번만 가져갈 수 있습니다. 최대 총 부피 제한 $S$를 넘지 않는 전제 하에, 얻을 수 있는 최대 총 가치 $V$를 구하세요.

## 입력 형식

첫 번째 줄에 두 정수 $N, S$가 공백으로 구분되어 주어집니다. 각각 물건의 개수와 최대 총 부피 제한을 나타냅니다.
다음 $N$개의 줄에는 각 줄마다 두 정수 $s_i, v_i$가 공백으로 구분되어 주어집니다. 각각 $i$번째 물건의 부피와 가치를 나타냅니다.

## 출력 형식

최대 가치를 나타내는 정수를 출력합니다.

## 데이터 범위

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 입력 예제

```
4 5
1 2
2 4
3 4
4 5
```

## 출력 예제

```
8
```

## 풀이

- 상태 정의: `f[i][j]`는 앞 $i$개의 물건을 고려했을 때, 부피 제한이 $j$일 때 얻을 수 있는 최대 가치를 나타냅니다.
    - 만약 $i$번째 물건을 선택하지 않는다면, `f[i][j] = f[i - 1][j]`입니다.
    - 만약 $i$번째 물건을 선택한다면, `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
    - 상태 전이를 구현할 때, 정의된 범위에 주의해야 합니다. 만약 $j < s_i$라면, $i$번째 물건을 선택하는 경우는 고려하지 않습니다. 왜냐하면 $j - s_i$가 음수가 되어 배열 인덱스가 유효하지 않기 때문입니다.
      다른 말로 설명하면, $i$번째 물건의 부피가 부피 제한보다 크므로 불가능합니다.
- 초기 조건 정의: 앞 0개의 물건에 대해서는 어떤 부피 제한이든 얻을 수 있는 가치는 0입니다. 즉, `f[0][j] = 0`, `j` $\in [0, S]$입니다.
- 시간 복잡도: $O(NS)$.

## 코드

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 1차원 DP 최적화

- 2차원 배열을 1차원 배열로 압축하면 공간을 크게 절약하고 실행 속도를 어느 정도 향상시킬 수 있습니다 (단점은 일부 문제 유형의 특수한 요구 사항을 충족할 수 없다는 것입니다).
- 상태 전이에서 `f[i][j]`는 `f[i - 1][j]`와 `f[i - 1][j - s[i]]`에만 관련되어 있다는 점에 주목하세요. 다시 말해, 코드의 2차원 배열 `f`에서
  `f[i][j]`는 이전 행에서 더 왼쪽에 있거나 같은 열에 있는 요소와만 관련이 있으므로 2차원 배열을 1차원 배열 또는 롤링 배열로 압축할 수 있습니다.
- 아래 코드에서 두 번째 루프가 역순으로 순회하는 이유는 `f[i][j]`를 계산할 때 `f[i - 1][j - s[i]]`가 아직 업데이트되지 않았는지 확인해야 하기 때문입니다.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 만약 해법의 수를 요구한다면

얻을 수 있는 최대 총 가치뿐만 아니라 "이 최대 총 가치를 달성할 수 있는 서로 다른 선택 방법의 수는 몇 가지인가"를 출력해야 합니다. 다음은 01 배낭 문제에서 **해법의 수를 세는 방법**을 소개합니다.

[문제 링크 삭제됨]

### 2차원 DP로 해법의 수 세기

다음은 2차원 DP를 예로 들어 설명합니다.

- 상태 정의:
  - `dp[i][j]`는 "앞 i개의 물건을 고려했을 때, 용량(부피 제한)이 j일 때 얻을 수 있는 최대 가치"를 나타냅니다.
  - `ways[i][j]`는 "앞 i개의 물건을 고려했을 때, 용량이 j이고, 최대 가치를 얻을 때 해당하는 **해법의 수**"를 나타냅니다.

- 상태 전이:
  1. 만약 `i`번째 물건을 선택하지 않는다면:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. 만약 `i`번째 물건을 선택한다면 (전제 조건은 $ j \ge s_i $):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 선택하거나 선택하지 않거나, 최종적으로 `dp[i][j]`는 둘 중 더 큰 값을 가져야 합니다:
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       라면 "i번째 물건을 선택하는 것"이 더 큰 가치를 갖는다는 의미입니다:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       라면 두 가지 방법으로 얻는 최대 가치가 같다는 의미이므로, 해법의 수를 더해야 합니다:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       라면 "i번째 물건을 선택하지 않는 것"이 더 큰 가치를 갖는다는 의미이므로, 해법의 수는 선택하지 않을 때의 해법의 수를 상속합니다:
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 초기 조건:
  - `dp[0][j] = 0`은 앞 0개의 물건에 대해서는 어떤 용량으로도 얻을 수 있는 최대 가치가 0임을 나타냅니다.
  - `ways[0][0] = 1`은 "앞 0개의 물건, 용량이 0"인 경우가 하나의 가능한 해법(즉, 아무것도 선택하지 않음)이므로, **해법의 수**를 1로 설정합니다.
  - `j > 0`에 대해서는 선택할 수 있는 물건이 없는데 용량이 0보다 크면 어떤 양의 가치도 얻을 수 없으므로, 해당하는 해법의 수는 0입니다. 즉, `ways[0][j] = 0`입니다.

- 최종 답:
  - `dp[N][S]`는 최대 가치입니다.
  - `ways[N][S]`는 해당 최대 가치를 달성하는 해법의 수입니다.
  - 시간 복잡도: $O(NS)$.
  - 이 문제는 1차원 DP로 최적화할 수도 있습니다.

## 만약 정확히 부피 제한을 달성하는 경우를 요구한다면

- 상태 정의: `f[i][j]`는 앞 `i`개의 물건을 고려했을 때 정확히 부피 $j$를 갖는 최대 가치를 나타냅니다.
- 만약 `i`번째 물건을 선택하지 않는다면, `f[i][j] = f[i - 1][j]`입니다.
- 만약 `i`번째 물건을 선택한다면, `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
- 원래 문제의 상태 전이와 차이가 없다는 것을 알 수 있습니다.
- 하지만 초기 조건이 다릅니다. `f[0][0] = 0`을 제외하고, 나머지 `f[0][j]` = $-\infty$, `j` $\in [1, S]$입니다. $-\infty$는 불가능한 상태를 나타냅니다.

## 만약 부피 제한 $S$가 매우 크고 (1e9), 동시에 물건의 개수 $N$과 최대 총 가치 $V$가 비교적 작다면

- 이러한 문제에 대해서는 $O(NV)$의 복잡도를 갖는 해법이 있습니다.
- 상태 정의: `f[i][j]`는 앞 `i`개의 물건을 선택하여 가치 총합이 정확히 `j`일 때의 최소 부피를 나타냅니다.
    - 만약 `i`번째 물건을 선택하지 않는다면, `f[i][j] = f[i - 1][j]`입니다.
    - 만약 `i`번째 물건을 선택한다면, `f[i][j] = f[i - 1][j - v[i]] + s[i]`입니다.
    - 둘 중 더 작은 값을 취합니다.
- 초기 조건: `f[0][0] = 0`, 나머지 `f[0][j]` = $\infty$, `j` $\in [1, V]$입니다. $\infty$는 불가능한 상태를 나타냅니다. $-\infty$가 아닙니다.
- 최종 답은 `f[N][j]` 중에서 `f[N][j] <= S`를 만족하는 가장 큰 `j`입니다.

## 만약 부피 제한 $S$와 개별 물건의 가치 $v_i$가 모두 매우 크고($1e9$ 수준), 동시에 물건의 개수 $N$이 매우 작다면 (최대 40 이하)

[문제 링크 삭제됨]

- $N \leq 20$일 때는 모든 부분 집합을 직접 열거할 수 있습니다 (시간 복잡도 $O(2^N)$).
- $N \leq 40$일 때는 $2^{40}$이 $10^{12}$ 수준이므로 직접 열거하면 너무 커지므로 **중간 분할 검색**을 사용할 수 있습니다.
  복잡도를 대략 $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$로 줄일 수 있으며,
  허용 가능한 시간 내에 완료할 수 있습니다.