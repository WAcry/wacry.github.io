---
title: "01 배낭 문제"
date: 2024-12-24
draft: false
description: "가장 기본적인 고전적인 배낭 문제."
summary: "가장 기본적인 고전적인 배낭 문제."
tags: [ "알고리즘", "동적 프로그래밍", "배낭 문제" ]
categories: [ "알고리즘 및 자료 구조" ]
---

## 문제

$N$개의 물건이 있습니다. $i$번째 물건의 부피는 $s_i$이고, 가치는 $v_i$입니다.
각 물건은 한 번만 가져갈 수 있습니다. 최대 총 부피 제한 $S$를 초과하지 않는다는 전제 하에, 얻을 수 있는 최대 총 가치 $V$를 구하세요.

## 입력 형식

첫 번째 줄에는 공백으로 구분된 두 정수 $N$과 $S$가 주어지며, 각각 물건의 개수와 최대 총 부피 제한을 나타냅니다.
다음 $N$개의 줄에는 각각 공백으로 구분된 두 정수 $s_i$와 $v_i$가 주어지며, 각각 $i$번째 물건의 부피와 가치를 나타냅니다.

## 출력 형식

최대 가치를 나타내는 정수를 출력합니다.

## 데이터 범위

$$0 \le N, S \leq 1000$$

$$0 \le s_i, v_i \leq 1000$$

## 입력 예시

```
4 5
1 2
2 4
3 4
4 5
```

## 출력 예시

```
8
```

## 해결 방법

- 상태 정의: `f[i][j]`는 첫 번째 $i$개 물건에서 부피 제한이 $j$일 때 얻을 수 있는 최대 가치를 나타냅니다.
    - $i$번째 물건을 선택하지 않으면 `f[i][j] = f[i - 1][j]`입니다.
    - $i$번째 물건을 선택하면 `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
    - 상태 전이를 구현할 때, 도메인 범위를 주의해야 합니다. 만약 $j < s_i$이면, $i$번째 물건을 선택하는 경우를 고려하지 마십시오. 왜냐하면 $j - s_i$가 음수이면 배열 인덱스가 유효하지 않기 때문입니다.
      이것은 다음과 같이 설명할 수도 있습니다. $i$번째 물건의 부피가 부피 제한보다 크므로 불가능합니다.
- 초기 조건 정의: 첫 번째 $0$개 물건의 경우, 어떤 부피 제한이든 가치는 $0$입니다. 즉, `f[0][j] = 0`, `j` $\in [0, S]$입니다.
- 시간 복잡도: $O(NS)$.

## 코드

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<vector<int>> f(N + 1, vector<int>(S + 1));
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= S; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= s[i]) f[i][j] = max(f[i][j], f[i - 1][j - s[i]] + v[i]);
        }
    }
    cout << f[N][S] << endl;
    return 0;
}
```

## 1차원 DP 최적화

- 2차원 배열을 1차원 배열로 압축하면 공간을 크게 절약하고 실행 속도를 어느 정도 향상시킬 수 있습니다 (단점은 일부 문제 유형의 특수한 요구 사항을 충족할 수 없다는 것입니다).
- 상태 전이에서 `f[i][j]`는 `f[i - 1][j]`와 `f[i - 1][j - s[i]]`에만 관련되어 있다는 점에 유의하십시오. 즉, 코드의 2차원 배열 `f`에서
  `f[i][j]`는 이전 행에서 왼쪽 또는 같은 열에 있는 요소에만 관련됩니다. 따라서 2차원 배열을 1차원 배열 또는 롤링 배열로 압축할 수 있습니다.
- 아래 코드에서 두 번째 루프는 역순으로 반복됩니다. 이는 `f[i][j]`를 계산할 때 `f[i - 1][j - s[i]]`가 아직 업데이트되지 않았는지 확인하기 위해서입니다.

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int N, S;
    cin >> N >> S;
    vector<int> s(N + 1), v(N + 1);
    for (int i = 1; i <= N; i++) cin >> s[i] >> v[i];
    vector<int> f(S + 1);
    for (int i = 1; i <= N; i++) {
        for (int j = S; j >= s[i]; j--) {
            f[j] = max(f[j], f[j - s[i]] + v[i]);
        }
    }
    cout << f[S] << endl;
    return 0;
}
```

## 만약 경우의 수가 필요한 경우

얻을 수 있는 최대 총 가치뿐만 아니라 "이 최대 총 가치를 달성할 수 있는 서로 다른 선택 방법의 수"도 출력해야 합니다. 다음은 01 배낭 문제에서 **경우의 수를 세는 방법**을 설명합니다.

### 2차원 DP로 경우의 수 세기

다음은 2차원 DP를 예로 들어 설명합니다.

- 상태 정의:
  - `dp[i][j]`는 "용량(부피 제한)이 j인 첫 번째 i개 물건을 고려할 때 얻을 수 있는 최대 가치"를 나타냅니다.
  - `ways[i][j]`는 "용량이 j인 첫 번째 i개 물건을 고려할 때 얻은 최대 가치에 해당하는 **경우의 수**"를 나타냅니다.

- 상태 전이:
  1. `i`번째 물건을 선택하지 않은 경우:
     $$
       \text{dp}[i][j] = \text{dp}[i-1][j], 
       \quad
       \text{ways}[i][j] = \text{ways}[i-1][j]
     $$
  2. `i`번째 물건을 선택한 경우 (단, $ j \ge s_i $인 경우):
     $$
       \text{dp}[i][j] 
         = \text{dp}[i-1][j - s_i] + v_i,
       \quad
       \text{ways}[i][j]
         = \text{ways}[i-1][j - s_i]
     $$
  3. 선택 여부에 관계없이 최종 `dp[i][j]`는 둘 중 더 큰 값을 취해야 합니다.
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           > \text{dp}[i-1][j],
       $$
       이면 "i번째 물건을 선택하는 것"이 더 큰 값을 갖는다는 의미입니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j - s_i] + v_i,
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           = \text{dp}[i-1][j],
       $$
       이면 두 방법으로 얻은 최대 가치가 동일하다는 의미입니다. 그러면 경우의 수를 더해야 합니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j], 
         \quad
         \text{ways}[i][j] 
           = \text{ways}[i-1][j] 
             + \text{ways}[i-1][j - s_i].
       $$
     - 만약
       $$
         \text{dp}[i-1][j - s_i] + v_i 
           < \text{dp}[i-1][j],
       $$
       이면 "i번째 물건을 선택하지 않는 것"이 더 큰 값을 갖는다는 의미이며, 경우의 수는 선택하지 않을 때의 경우의 수를 상속합니다.
       $$
         \text{dp}[i][j] = \text{dp}[i-1][j],
         \quad
         \text{ways}[i][j] = \text{ways}[i-1][j].
       $$

- 초기 조건:
  - `dp[0][j] = 0`은 물건이 0개일 때 어떤 용량에 대해서든 얻을 수 있는 최대 가치가 0임을 의미합니다.
  - `ways[0][0] = 1`은 "물건 0개, 용량 0"의 경우가 가능한 경우(즉, 아무것도 선택하지 않음)이며, **경우의 수**는 1로 설정됩니다.
  - `j > 0`의 경우, 선택할 물건이 없고 용량이 0보다 크면 어떤 양수 값도 얻을 수 없으며, 해당 경우의 수는 0입니다. 즉, `ways[0][j] = 0`입니다.

- 최종 답:
  - `dp[N][S]`는 최대 가치입니다.
  - `ways[N][S]`는 이 최대 가치를 달성하는 경우의 수입니다.
  - 시간 복잡도: $O(NS)$.
  - 이 문제는 1차원 DP를 사용하여 최적화할 수도 있습니다.

## 만약 정확히 부피 제한에 도달해야 하는 경우

- 상태 정의: `f[i][j]`는 첫 번째 `i`개 물건이 정확히 부피 $j$를 가질 때의 최대 가치를 나타냅니다.
- `i`번째 물건을 선택하지 않으면 `f[i][j] = f[i - 1][j]`입니다.
- `i`번째 물건을 선택하면 `f[i][j] = f[i - 1][j - s[i]] + v[i]`입니다.
- 상태 전이는 원래 문제와 차이가 없다는 것을 알 수 있습니다.
- 그러나 초기 조건이 다릅니다. `f[0][0] = 0`을 제외하고 나머지 `f[0][j]` = $-\infty$, `j` $\in [1, S]$입니다. $-\infty$는 불가능한 상태를 나타냅니다.

## 만약 부피 제한 $S$가 매우 크고 (1e9), 물건의 개수 $N$과 최대 총 가치 $V$가 비교적 작은 경우

- 이러한 문제의 경우, 복잡도가 $O(NV)$인 해결 방법이 있습니다.
- 상태 정의: `f[i][j]`는 첫 번째 `i`개 물건에서 여러 물건을 선택할 때 총 가치가 정확히 `j`일 때의 최소 부피를 나타냅니다.
    - `i`번째 물건을 선택하지 않으면 `f[i][j] = f[i - 1][j]`입니다.
    - `i`번째 물건을 선택하면 `f[i][j] = f[i - 1][j - v[i]] + s[i]`입니다.
    - 둘 중 더 작은 값을 취합니다.
- 초기 조건: `f[0][0] = 0`, 나머지 `f[0][j]` = $\infty$, `j` $\in [1, V]$입니다. $\infty$는 불가능한 상태를 나타냅니다. $-\infty$가 아님에 유의하십시오.
- 최종 답은 `f[N][j]`에서 `f[N][j] <= S`인 가장 큰 `j`입니다.

## 만약 부피 제한 $S$와 단일 물건의 가치 $v_i$가 모두 매우 크고 (1e9 정도), 물건의 개수 $N$이 매우 작은 경우 (40개 이하)

- $N \leq 20$인 경우, 모든 부분 집합을 무차별 대입으로 직접 열거할 수 있습니다 (시간 복잡도 $O(2^N)$).
- $N \leq 40$인 경우, $2^{40}$은 $10^{12}$ 정도이므로 직접적인 무차별 대입도 비교적 크므로 **중간에서 만나기 검색**을 사용하여 복잡도를 대략 $O\bigl(2^{\frac{N}{2}} \times \log(2^{\frac{N}{2}})\bigr) \approx O(N \cdot 2^{\frac{N}{2}})$로 줄일 수 있으며, 이는 허용 가능한 시간 내에 완료할 수 있습니다.