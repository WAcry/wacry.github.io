---
title: "क्विक सॉर्ट"
date: 2024-12-26
draft: false
description: "क्विक सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।"
summary: "क्विक सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।"
tags: [ "एल्गोरिथम", "सॉर्टिंग एल्गोरिथम", "क्विक सॉर्ट", "विभाजन और जीत एल्गोरिथम" ]
categories: [ "एल्गोरिथम और डेटा संरचना" ]
---

# क्विक सॉर्ट

क्विक सॉर्ट एक तुलना-आधारित अस्थिर सॉर्टिंग एल्गोरिथम है, जो विभाजन और जीत की विचारधारा का उपयोग करता है। इसकी औसत समय जटिलता $O(n\log n)$ है, सबसे खराब स्थिति में $O(n^2)$ है, और स्थान जटिलता $O(1)$ है। यहां, एक पूर्णांक अनुक्रम को छोटे से बड़े क्रम में सॉर्ट करने के उदाहरण के साथ, इसके कार्यान्वयन विवरण और सामान्य त्रुटियों का परिचय दिया गया है।

---

## समस्या विवरण

एक लंबाई $n$ के पूर्णांक अनुक्रम को देखते हुए, इसे क्विक सॉर्ट का उपयोग करके छोटे से बड़े क्रम में सॉर्ट करें और परिणाम आउटपुट करें।

### इनपुट प्रारूप

- पहली पंक्ति में पूर्णांक $n$ इनपुट करें
- दूसरी पंक्ति में $n$ पूर्णांक इनपुट करें, सभी $[1,10^9]$ सीमा में

### आउटपुट प्रारूप

- एक पंक्ति में सॉर्ट किया गया अनुक्रम आउटपुट करें

### डेटा रेंज

$1 \leq n \leq 100000$

### इनपुट नमूना

```
5
3 1 2 4 5
```

### आउटपुट नमूना

```
1 2 3 4 5
```

---

## क्विक सॉर्ट विचार

क्विक सॉर्ट प्रत्येक विभाजन के समय, एक संख्या को आधार संख्या `pivot` के रूप में चुनता है (नीचे मध्य स्थिति की संख्या का चयन किया गया है)।

बाएं और दाएं पॉइंटर्स का उपयोग विपरीत दिशाओं में जाने के लिए करें। बाएं पॉइंटर `L` बाएं से दाएं पहले `pivot` से बड़े या बराबर संख्या की तलाश करता है, और दाएं पॉइंटर `R` दाएं से बाएं पहले `pivot` से छोटे या बराबर संख्या की तलाश करता है, और फिर इन दो संख्याओं को स्वैप करता है।

इस प्रक्रिया को तब तक दोहराते रहें जब तक कि बाएं पॉइंटर और दाएं पॉइंटर ओवरलैप न हो जाएं या बाएं पॉइंटर दाएं पॉइंटर से एक स्थान बड़ा न हो जाए। इसे एक चक्र कहा जाता है।

प्रत्येक पॉइंटर मूवमेंट और स्वैप के बाद, यह सुनिश्चित किया जाता है कि "बायां भाग ≤ pivot, दायां भाग ≥ pivot" की संरचना को तोड़ा नहीं गया है, यानी, अपरिवर्तनीय `[left, L) <= pivot`, `(R, right] >= pivot` है।

निम्नलिखित उदाहरण कोड में, `left` और `right` वर्तमान में संसाधित बंद अंतराल की सीमाएं हैं, और `pivot` अंतराल के मध्य बिंदु पर तत्व लेता है।

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## जटिलता और `pivot` का चयन

चूंकि सबसे खराब स्थिति में क्विक सॉर्ट की जटिलता $O(n^2)$ है, इसलिए `pivot` का चयन बहुत महत्वपूर्ण है। यदि हमेशा पहले या अंतिम तत्व का चयन किया जाता है, तो लगभग क्रमबद्ध सरणी में सबसे खराब स्थिति होने की संभावना अधिक होती है।

मध्य स्थिति के तत्व को लेने के अलावा, `pivot` के रूप में एक तत्व को यादृच्छिक रूप से चुना जा सकता है, या बाएं, मध्य और दाएं तीन तत्वों के माध्यिका को `pivot` के रूप में लिया जा सकता है।

---

## सामान्य त्रुटि उदाहरण

नीचे दिए गए कोड में कई सामान्य त्रुटियां हैं।

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";

    return 0;
}
```

**त्रुटि विश्लेषण:**

1. `pivot` सरणी में एक संख्या होनी चाहिए, न कि एक सूचकांक।
2. क्रमशः `<=` और `>=` के बजाय `<` और `>` का उपयोग करें, अन्यथा बाएं पॉइंटर दाएं पॉइंटर से एक से अधिक स्थान आगे बढ़ सकता है, ताकि सरणी को दो भागों में विभाजित न किया जा सके।
3. `l >= r` पाए जाने के बाद, लूप से तुरंत बाहर निकल जाना चाहिए, और अब स्वैप नहीं करना चाहिए। अन्यथा, यह गारंटी नहीं दी जा सकती है कि बाईं ओर के तत्व `pivot` से बड़े नहीं हैं, और दाईं ओर के तत्व `pivot` से छोटे नहीं हैं।
4. प्रत्येक स्वैप के बाद, `l++` और `r--` को निष्पादित किया जाना चाहिए।
5. `pivot` वास्तव में मध्य-बाएं संख्या लेता है। इसलिए, यदि सरणी को विभाजित करने के लिए $l - 1$ और $l$ का उपयोग किया जाता है, तो सरणी `[1, 2]` पर विचार करें, यह पता लगाना मुश्किल नहीं है कि इससे एक अनंत लूप होगा, लगातार सरणी को 0 और 2 आकार के दो भागों में विभाजित किया जाएगा। इसी तरह, सरणी को अलग करने के लिए $r$ और $l$ का उपयोग करना भी काम नहीं करता है। इसके विपरीत, एक चक्र के अंत में, $r$ निश्चित रूप से $right$ से छोटा होगा, इसलिए सरणी को विभाजित करने के लिए $r$ और $r+1$ का उपयोग किया जा सकता है। पाठक यह देखने के लिए एल्गोरिथम प्रक्रिया का अनुकरण कर सकते हैं कि ऐसा क्यों है। अनंत लूप से बचने का एक और सरल तरीका है कि `pivot` को यादृच्छिक रूप से चुना जाए या केवल दो तत्वों की स्थिति को विशेष रूप से संभाला जाए।
6. इसके अलावा, $l$, $l+1$ का उपयोग करना भी काम नहीं करता है, क्योंकि यह विभाजन परिभाषा के अनुरूप नहीं है। जब $r$, $l$ के बाईं ओर होता है, तो $l$, $l+1$ का उपयोग सरणी को बाईं ओर `pivot` से कम या बराबर और दाईं ओर `pivot` से अधिक या बराबर के दो भागों में सही ढंग से विभाजित नहीं कर सकता है।
7. यह प्रश्न मानता है कि सरणी खाली नहीं है, इसलिए `>` की स्थिति मौजूद नहीं है। लेकिन `>=` का उपयोग करने की सलाह दी जाती है, यह अधिक सुरक्षित है।

---

## पूरक

क्विक सॉर्ट को "क्विक चयन" में भी विकसित किया जा सकता है, जो $O(n)$ की अपेक्षित समय में एक अव्यवस्थित सरणी में $k$ वीं सबसे छोटी संख्या को ढूंढता है। विशिष्ट विचार क्विक सॉर्ट के समान है, सिवाय इसके कि प्रत्येक बार केवल एक तरफ के उप-अंतराल में पुनरावर्ती रूप से जारी रहता है, जिससे समय जटिलता कम हो जाती है।