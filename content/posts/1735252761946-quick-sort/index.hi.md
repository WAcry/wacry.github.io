---
title: "त्वरित सॉर्ट"
date: 2024-12-26
draft: false
description: "त्वरित सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।"
summary: "त्वरित सॉर्ट एल्गोरिथम को सही ढंग से लागू करने के मुख्य बिंदुओं का विश्लेषण।"
tags: [ "एल्गोरिथम", "सॉर्टिंग एल्गोरिथम", "त्वरित सॉर्ट", "विभाजन और जीत एल्गोरिथम" ]
categories: [ "एल्गोरिथम और डेटा संरचना" ]
---

# त्वरित सॉर्ट

त्वरित सॉर्ट एक तुलना-आधारित अस्थिर सॉर्टिंग एल्गोरिथम है, जो विभाजन और जीत की रणनीति का उपयोग करता है। इसका औसत समय जटिलता $O(n\log n)$ है, सबसे खराब स्थिति में $O(n^2)$ है, और स्थान जटिलता $O(1)$ है। निम्नलिखित एक पूर्णांक अनुक्रम को छोटे से बड़े क्रम में सॉर्ट करने का उदाहरण देकर, इसकी कार्यान्वयन बारीकियों और सामान्य त्रुटियों का परिचय दिया गया है।

---

## समस्या विवरण

$n$ लंबाई के एक पूर्णांक अनुक्रम को देखते हुए, त्वरित सॉर्ट का उपयोग करके इसे छोटे से बड़े क्रम में सॉर्ट करें और परिणाम आउटपुट करें।

### इनपुट प्रारूप

- पहली पंक्ति पूर्णांक $n$ का इनपुट है।
- दूसरी पंक्ति में $n$ पूर्णांकों का इनपुट है, जो सभी $[1,10^9]$ रेंज में हैं।

### आउटपुट प्रारूप

- एक पंक्ति में क्रमबद्ध अनुक्रम आउटपुट करें।

### डेटा रेंज

$1 \leq n \leq 100000$

### इनपुट नमूना

```
5
3 1 2 4 5
```

### आउटपुट नमूना

```
1 2 3 4 5
```

---

## त्वरित सॉर्ट विचार

त्वरित सॉर्ट प्रत्येक विभाजन के समय, एक संख्या को आधार संख्या `pivot` के रूप में चुनता है (नीचे मध्य स्थिति की संख्या का चयन किया गया है)।

बाएँ और दाएँ पॉइंटर्स का उपयोग विपरीत दिशाओं में जाने के लिए करें, बायाँ पॉइंटर `L` बाएँ से दाएँ पहले `pivot` से बड़े या बराबर संख्या की तलाश करता है, और दाएँ पॉइंटर `R` दाएँ से बाएँ पहले `pivot` से छोटे या बराबर संख्या की तलाश करता है, और फिर इन दो संख्याओं को स्वैप करें।

जब तक बाएँ पॉइंटर और दाएँ पॉइंटर ओवरलैप नहीं हो जाते या बायाँ पॉइंटर दाएँ पॉइंटर से एक स्थान आगे नहीं बढ़ जाता, तब तक इस प्रक्रिया को बार-बार दोहराएँ। इसे एक चक्र कहा जाता है।

प्रत्येक पॉइंटर शिफ्ट और स्वैप के बाद, यह सुनिश्चित किया जाता है कि संरचना "बाएँ भाग ≤ pivot, दाएँ भाग ≥ pivot" को तोड़ा नहीं गया है, अर्थात एक अपरिवर्तनीय `[left, L) <= pivot`, `(R, right] >= pivot` है।

निम्नलिखित उदाहरण कोड में, `left` और `right` वर्तमान में संसाधित क्लोज्ड इंटरवल की सीमाएँ हैं, और `pivot` इंटरवल के मध्य बिंदु पर तत्व लेता है।

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## जटिलता और `pivot` का चयन

चूंकि सबसे खराब स्थिति में त्वरित सॉर्ट की जटिलता $O(n^2)$ है, इसलिए `pivot` का चयन बहुत महत्वपूर्ण है। यदि हमेशा पहले या अंतिम तत्व का चयन किया जाता है, तो लगभग क्रमबद्ध सरणी में सबसे खराब स्थिति होने की संभावना अधिक होगी।

मध्य स्थिति के तत्व को लेने के अलावा, आप `pivot` के रूप में एक तत्व को यादृच्छिक रूप से भी चुन सकते हैं, या बाएँ, मध्य और दाएँ तीन तत्वों के माध्य को `pivot` के रूप में ले सकते हैं।

---

## सामान्य त्रुटि उदाहरण

नीचे दिए गए कोड में कई सामान्य त्रुटियाँ शामिल हैं।

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

**त्रुटि विश्लेषण:**

1. `pivot` एक संख्या होनी चाहिए जो सरणी में है, न कि एक सूचकांक।
2. क्रमशः `<=` और `>=` के बजाय `<` और `>` का उपयोग करें, अन्यथा बायाँ पॉइंटर दाएँ पॉइंटर से एक से अधिक स्थान आगे बढ़ सकता है, जो सरणी को दो भागों में विभाजित करने में विफल रहेगा।
3. `l >= r` पाए जाने के बाद, लूप से तुरंत बाहर निकल जाना चाहिए, अब स्वैप न करें। अन्यथा यह गारंटी नहीं दी जा सकती है कि बाएँ तत्व `pivot` से अधिक नहीं हैं, और दाएँ तत्व `pivot` से कम नहीं हैं।
4. प्रत्येक स्वैप के बाद, `l++` और `r--` को निष्पादित किया जाना चाहिए।
5. `pivot` वास्तव में बाईं ओर झुकी हुई मध्य संख्या लेता है। यदि $l - 1$ और $l$ का उपयोग सरणी को विभाजित करने के लिए किया जाता है, तो सरणी `[1, 2]` पर विचार करें, यह देखना मुश्किल नहीं है कि एक मृत लूप की ओर ले जाएगा, जो सरणी को बार-बार 0 और 2 आकार के दो भागों में विभाजित करेगा। इसके विपरीत, लूप के अंत में, $r$ आवश्यक रूप से $right$ से कम है, इसलिए सरणी को विभाजित करने के लिए $r$ और $r+1$ का उपयोग किया जा सकता है। पाठक एल्गोरिथम प्रक्रिया का अनुकरण कर सकते हैं ताकि यह देखा जा सके कि ऐसा क्यों है। मृत लूप से बचने का एक और सरल तरीका है कि `pivot` को यादृच्छिक रूप से चुना जाए या केवल दो तत्वों की स्थिति को विशेष रूप से संभाला जाए। इसी तरह, सरणी को अलग करने के लिए $r$ और $l$ का उपयोग करना भी काम नहीं करेगा।
6. इसके अतिरिक्त, $l$, $l+1$ भी काम नहीं करेगा, क्योंकि यह विभाजन परिभाषा के अनुरूप नहीं है। जब $r$ $l$ के बाईं ओर होता है, तो $l$, $l+1$ का उपयोग करके सरणी को दो भागों में सही ढंग से विभाजित नहीं किया जा सकता है, जिसमें बाएँ भाग `pivot` से कम या बराबर हो और दाएँ भाग `pivot` से अधिक या बराबर हो।
7. इस प्रश्न में यह माना जाता है कि सरणी खाली नहीं है, इसलिए `>` की स्थिति मौजूद नहीं है। लेकिन `>=` का उपयोग करना अधिक सुरक्षित है।

---

## पूरक

त्वरित सॉर्ट को "त्वरित चयन" में भी विकसित किया जा सकता है, एक अनियंत्रित सरणी में $k$-वें सबसे छोटे नंबर को $O(n)$ अपेक्षित समय में खोजने के लिए, विशिष्ट विचार त्वरित सॉर्ट के समान है, सिवाय इसके कि यह प्रत्येक बार केवल एक तरफा उप-अंतराल में पुनरावर्ती होता है, इस प्रकार समय जटिलता कम हो जाती है।