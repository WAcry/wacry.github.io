---
title: "퀵 정렬"
date: 2024-12-26
draft: false
description: "퀵 정렬 알고리즘을 올바르게 구현하는 핵심 요점 분석."
summary: "퀵 정렬 알고리즘을 올바르게 구현하는 핵심 요점 분석."
tags: [ "알고리즘", "정렬 알고리즘", "퀵 정렬", "분할 정복 알고리즘" ]
categories: [ "알고리즘 및 자료 구조" ]
---

# 퀵 정렬

퀵 정렬은 비교 기반의 불안정 정렬 알고리즘으로, 분할 정복 아이디어를 사용하며 평균 시간 복잡도는 $O(n\log n)$, 최악의 경우 $O(n^2)$이고, 공간 복잡도는 $O(1)$입니다. 아래에서는 정수 수열을 오름차순으로 정렬하는 예를 통해 구현 세부 사항과 일반적인 오류를 소개합니다.

---

## 문제 설명

길이가 $n$인 정수 수열이 주어질 때, 퀵 정렬을 사용하여 오름차순으로 정렬하고 결과를 출력합니다.

### 입력 형식

- 첫 번째 줄에 정수 $n$을 입력합니다.
- 두 번째 줄에 $[1, 10^9]$ 범위 내의 정수 $n$개를 입력합니다.

### 출력 형식

- 정렬된 수열을 한 줄에 출력합니다.

### 데이터 범위

$1 \leq n \leq 100000$

### 입력 예제

```
5
3 1 2 4 5
```

### 출력 예제

```
1 2 3 4 5
```

---

## 퀵 정렬 아이디어

퀵 정렬은 각 분할 단계에서 임의의 숫자를 기준점 `pivot`으로 선택합니다(여기서는 중간 위치의 숫자를 선택).

왼쪽 포인터 `L`은 왼쪽에서 오른쪽으로 이동하며 `pivot`보다 크거나 같은 첫 번째 숫자를 찾고, 오른쪽 포인터 `R`은 오른쪽에서 왼쪽으로 이동하며 `pivot`보다 작거나 같은 첫 번째 숫자를 찾은 다음 이 두 숫자를 교환합니다.

왼쪽 포인터와 오른쪽 포인터가 겹치거나 왼쪽 포인터가 오른쪽 포인터보다 하나 더 커질 때까지 이 과정을 반복합니다. 이를 한 번의 순환이라고 합니다.

포인터를 이동하고 교환할 때마다 "왼쪽 부분 ≤ pivot, 오른쪽 부분 ≥ pivot" 구조가 손상되지 않도록 보장합니다. 즉, 불변량 `[left, L) <= pivot` 및 `(R, right] >= pivot`을 갖습니다.

다음 예제 코드에서 `left`와 `right`는 현재 처리 중인 닫힌 구간의 경계이고, `pivot`은 구간 중앙의 요소입니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## 복잡도 및 `pivot` 선택

최악의 경우 퀵 정렬의 복잡도는 $O(n^2)$이므로 `pivot` 선택이 매우 중요합니다. 항상 첫 번째 또는 마지막 요소를 선택하면 거의 정렬된 배열에서 최악의 경우가 발생할 가능성이 높습니다.

중간 위치의 요소를 선택하는 것 외에도 임의의 요소를 `pivot`으로 선택하거나 왼쪽, 중간, 오른쪽의 세 요소의 중앙값을 `pivot`으로 선택할 수도 있습니다.

---

## 일반적인 오류 예제

아래 코드는 여러 가지 일반적인 오류를 포함하고 있습니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

**오류 분석:**

1. `pivot`은 배열의 수가 되어야 하며 인덱스가 아닙니다.
2. `<=` 및 `>=` 대신 각각 `<` 및 `>`을 사용해야 합니다. 그렇지 않으면 왼쪽 포인터가 오른쪽 포인터를 1 이상 초과할 수 있으므로 배열을 두 부분으로 나눌 수 없습니다.
3. `l >= r`을 발견하면 즉시 루프를 종료해야 하며, 그렇지 않으면 왼쪽 요소가 `pivot`보다 크지 않고 오른쪽 요소가 `pivot`보다 작지 않다는 것을 보장할 수 없습니다.
4. 각 교환 후에는 `l++` 및 `r--`를 실행해야 합니다.
5. `pivot`은 실제로 중간에서 약간 왼쪽에 있는 수를 취합니다. $l - 1$ 및 $l$을 사용하여 배열을 분할하면 배열 `[1, 2]`를 고려할 때 배열을 크기가 0과 2인 두 부분으로 계속해서 나누는 무한 루프가 발생합니다. 반대로 루프가 끝날 때 $r$은 $right$보다 작아야 하므로 $r$과 $r + 1$을 사용하여 배열을 분할할 수 있습니다. 독자는 알고리즘 프로세스를 시뮬레이션하여 그 이유를 확인할 수 있습니다. 무한 루프를 피하는 또 다른 간단한 방법은 임의의 `pivot`을 선택하거나 두 개의 요소만 있는 경우를 특별히 처리하는 것입니다. 마찬가지로 $r$과 $l$을 사용하여 배열을 구분하는 것도 올바르지 않습니다.
6. 또한 $l$, $l + 1$도 안 됩니다. 이 분할은 $r$이 $l$ 왼쪽에 있을 때 배열을 `pivot`보다 작거나 같은 왼쪽 부분과 `pivot`보다 크거나 같은 오른쪽 부분으로 올바르게 나눌 수 없기 때문에 정의에 맞지 않습니다.
7. 이 문제는 배열이 비어 있지 않다고 가정하므로 `>`의 경우는 없습니다. 그러나 더욱 안전하게 `>=`을 사용하는 것이 좋습니다.

---

## 추가 설명

퀵 정렬은 "퀵 선택"으로도 진화할 수 있으며, $O(n)$의 기대 시간 내에 정렬되지 않은 배열에서 $k$번째로 작은 수를 찾을 수 있습니다. 구체적인 아이디어는 퀵 정렬과 유사하지만, 시간 복잡도를 줄이기 위해 매번 한쪽 하위 구간에서만 재귀적으로 진행합니다.