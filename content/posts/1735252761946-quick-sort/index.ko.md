---
title: "퀵 정렬"
date: 2024-12-26
draft: false
description: "퀵 정렬 알고리즘을 올바르게 구현하기 위한 핵심 사항 분석."
summary: "퀵 정렬 알고리즘을 올바르게 구현하기 위한 핵심 사항 분석."
tags: [ "알고리즘", "정렬 알고리즘", "퀵 정렬", "분할 정복 알고리즘" ]
categories: [ "알고리즘 및 자료 구조" ]
---

퀵 정렬은 비교 기반의 불안정 정렬 알고리즘으로, 분할 정복 방식을 사용하며 평균 시간 복잡도는 $O(n\log n)$이고 최악의 경우 $O(n^2)$입니다. 공간 복잡도는 $O(1)$입니다. 아래에서는 정수 수열을 오름차순으로 정렬하는 예시를 통해 구현 세부 사항과 흔한 오류를 소개합니다.

---

## 문제 설명

길이가 $n$인 정수 수열이 주어졌을 때, 퀵 정렬을 사용하여 오름차순으로 정렬하고 결과를 출력하세요.

### 입력 형식

- 첫 번째 줄에 정수 $n$을 입력합니다.
- 두 번째 줄에 $n$개의 정수를 입력하며, 각 정수는 $[1, 10^9]$ 범위 내에 있습니다.

### 출력 형식

- 정렬된 수열을 한 줄에 출력합니다.

### 데이터 범위

$1 \leq n \leq 100000$

### 입력 예시

```
5
3 1 2 4 5
```

### 출력 예시

```
1 2 3 4 5
```

---

## 퀵 정렬 아이디어

퀵 정렬은 매 분할 시 임의의 수를 기준수 `pivot`으로 선택합니다(아래에서는 중간 위치의 수를 선택).

좌우 포인터를 사용하여 서로 마주보며 이동합니다. 왼쪽 포인터 `L`은 왼쪽에서 오른쪽으로 이동하며 `pivot`보다 크거나 같은 첫 번째 수를 찾고, 오른쪽 포인터 `R`은 오른쪽에서 왼쪽으로 이동하며 `pivot`보다 작거나 같은 첫 번째 수를 찾습니다. 그런 다음 이 두 수를 교환합니다.

이 과정을 왼쪽 포인터와 오른쪽 포인터가 겹치거나 왼쪽 포인터가 오른쪽 포인터보다 한 칸 커질 때까지 반복합니다. 이를 한 번의 순환이라고 합니다.

각 포인터 이동 및 교환 후에는 항상 "왼쪽 부분 ≤ pivot, 오른쪽 부분 ≥ pivot" 구조가 유지되도록 합니다. 즉, 불변량 `[left, L) <= pivot`, `(R, right] >= pivot`이 유지됩니다.

아래 예시 코드에서 `left`와 `right`는 현재 처리 중인 닫힌 구간 경계이고, `pivot`은 구간 중간 지점의 요소를 취합니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## 복잡도 및 `pivot` 선택

최악의 경우 퀵 정렬의 복잡도는 $O(n^2)$이므로 `pivot` 선택이 매우 중요합니다. 항상 첫 번째 또는 마지막 요소를 선택하면 거의 정렬된 배열에서 최악의 경우가 발생할 가능성이 높습니다.

중간 위치의 요소를 선택하는 것 외에도 임의의 요소를 `pivot`으로 선택하거나 왼쪽, 중간, 오른쪽 세 요소의 중앙값을 `pivot`으로 선택할 수 있습니다.

---

## 흔한 오류 예시

아래 코드는 여러 가지 흔한 오류를 포함하고 있습니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    quickSort(a, 0, n - 1);

    for (int i = 0; i < n; i++) cout << a[i] << " ";

    return 0;
}
```

**오류 분석:**

1. `pivot`은 배열의 인덱스가 아닌 배열의 값이어야 합니다.
2. `<=`와 `>=` 대신 각각 `<`와 `>`를 사용해야 합니다. 그렇지 않으면 왼쪽 포인터가 오른쪽 포인터를 한 칸 이상 초과할 수 있으며, 이로 인해 배열을 두 부분으로 나눌 수 없게 됩니다.
3. `l >= r`을 발견한 후에는 즉시 루프를 종료하고 교환을 더 이상 수행하지 않아야 합니다. 그렇지 않으면 왼쪽 요소가 `pivot`보다 크지 않고 오른쪽 요소가 `pivot`보다 작지 않다는 것을 보장할 수 없습니다.
4. 매번 교환 후에는 `l++`와 `r--`를 실행해야 합니다.
5. `pivot`은 실제로 중간에서 약간 왼쪽에 있는 수를 취합니다. 따라서 $l - 1$과 $l$을 사용하여 배열을 분할하면 배열 `[1, 2]`의 경우 무한 루프가 발생하여 배열을 크기가 0과 2인 두 부분으로 계속 분할하게 됩니다. 마찬가지로 $r$과 $l$을 사용하여 배열을 구분하는 것도 불가능합니다. 반대로, 한 번의 순환이 끝나면 $r$은 반드시 $right$보다 작으므로 $r$과 $r+1$을 사용하여 배열을 분할할 수 있습니다. 독자는 알고리즘 과정을 시뮬레이션하여 그 이유를 확인할 수 있습니다. 무한 루프를 피하는 또 다른 간단한 방법은 `pivot`을 임의로 선택하거나 요소가 두 개인 경우를 특별히 처리하는 것입니다.
6. 또한 $l$, $l+1$을 사용하는 것도 불가능합니다. 이 분할은 정의에 맞지 않기 때문입니다. $r$이 $l$ 왼쪽에 있는 경우 $l$, $l+1$을 사용하면 배열을 왼쪽은 `pivot`보다 작거나 같고 오른쪽은 `pivot`보다 크거나 같은 두 부분으로 올바르게 나눌 수 없습니다.
7. 이 문제는 배열이 비어 있지 않다고 가정하므로 `>`의 경우는 존재하지 않습니다. 그러나 `>=`를 사용하는 것이 더 안전합니다.

---

## 추가 설명

퀵 정렬은 "퀵 선택"으로 발전하여 $O(n)$의 기대 시간 내에 정렬되지 않은 배열에서 $k$번째로 작은 수를 찾을 수 있습니다. 구체적인 아이디어는 퀵 정렬과 유사하지만 매번 한쪽 하위 구간에서만 재귀를 계속하여 시간 복잡도를 줄입니다.