---
title: "Быстрая сортировка"
date: 2024-12-26
draft: false
description: "Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки."
summary: "Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки."
tags: [ "алгоритмы", "алгоритмы сортировки", "быстрая сортировка", "алгоритм разделяй и властвуй" ]
categories: [ "Алгоритмы и структуры данных" ]
---

# Быстрая сортировка

Быстрая сортировка — это алгоритм сортировки на основе сравнений, не являющийся устойчивым, использующий принцип «разделяй и властвуй». Средняя временная сложность составляет $O(n\log n)$, в худшем случае — $O(n^2)$, а пространственная сложность — $O(1)$. Ниже на примере сортировки по возрастанию целочисленной последовательности рассмотрим детали реализации и распространенные ошибки.

---

## Описание задачи

Дана целочисленная последовательность длиной $n$. Используйте быструю сортировку для ее сортировки по возрастанию и выведите результат.

### Формат ввода

- В первой строке вводится целое число $n$
- Во второй строке вводятся $n$ целых чисел, каждое в диапазоне $[1,10^9]$

### Формат вывода

- В одной строке выводится отсортированная последовательность

### Ограничения

$1 \leq n \leq 100000$

### Пример ввода

```
5
3 1 2 4 5
```

### Пример вывода

```
1 2 3 4 5
```

---

## Идея быстрой сортировки

При каждом разделении в быстрой сортировке выбирается произвольное число в качестве опорного элемента `pivot` (ниже выбирается число в середине).

Используются левый и правый указатели, движущиеся навстречу друг другу. Левый указатель `L` движется слева направо, ища первое число, большее или равное `pivot`. Правый указатель `R` движется справа налево, ища первое число, меньшее или равное `pivot`. Затем эти два числа меняются местами.

Этот процесс повторяется до тех пор, пока левый и правый указатели не совпадут или левый указатель не станет на одну позицию правее правого. Это называется одной итерацией.

После каждого перемещения указателей и обмена гарантируется, что структура «левая часть ≤ pivot, правая часть ≥ pivot» не нарушается, то есть существует инвариант `[left, L) <= pivot`, `(R, right] >= pivot`.

В приведенном ниже примере кода `left` и `right` — это границы текущего обрабатываемого замкнутого интервала, а `pivot` берется как элемент в середине интервала.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## Сложность и выбор `pivot`

Поскольку в худшем случае быстрая сортировка имеет сложность $O(n^2)$, выбор `pivot` очень важен. Если всегда выбирать первый или последний элемент, то в почти отсортированном массиве с большой вероятностью возникнет худший случай.

Помимо выбора элемента в середине, можно также случайным образом выбрать элемент в качестве `pivot` или взять медиану из трех элементов: левого, среднего и правого.

---

## Примеры распространенных ошибок

Приведенный ниже код содержит несколько распространенных ошибок.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";

    return 0;
}
```

**Анализ ошибок:**

1. `pivot` должен быть числом из массива, а не индексом.
2. Используются `<=` и `>=`, а не `<` и `>`, иначе левый указатель может уйти дальше правого более чем на одну позицию, и массив не будет разделен на две части.
3. После обнаружения `l >= r` следует немедленно выйти из цикла, не выполняя обмен. В противном случае нельзя гарантировать, что левые элементы не больше `pivot`, а правые не меньше `pivot`.
4. После каждого обмена следует выполнять `l++` и `r--`.
5. `pivot` фактически берется как число, расположенное ближе к левой середине. Поэтому, если использовать $l - 1$ и $l$ для разделения массива, то, рассмотрев массив `[1, 2]`, нетрудно заметить, что это приведет к бесконечному циклу, постоянно разделяя массив на две части размером 0 и 2. Аналогично, использование $r$ и $l$ для разделения массива также не подходит. Напротив, в конце итерации $r$ обязательно меньше $right$, поэтому можно использовать $r$ и $r+1$ для разделения массива. Читатель может смоделировать процесс алгоритма, чтобы понять, почему. Другой простой способ избежать бесконечного цикла — это случайный выбор `pivot` или специальная обработка случая, когда есть только два элемента.
6. Кроме того, использование $l$, $l+1$ также не подходит, поскольку такое разделение не соответствует определению. Когда $r$ находится слева от $l$, использование $l$, $l+1$ не может правильно разделить массив на две части: левую, где элементы меньше или равны `pivot`, и правую, где элементы больше или равны `pivot`.
7. В этой задаче предполагается, что массив не пуст, поэтому случая `>` не существует. Однако рекомендуется использовать `>=`, это безопаснее.

---

## Дополнение

Быстрая сортировка также может быть преобразована в «быстрый выбор», который позволяет найти $k$-й наименьший элемент в неупорядоченном массиве за ожидаемое время $O(n)$. Основная идея аналогична быстрой сортировке, но на каждой итерации рекурсия продолжается только в одной из подпоследовательностей, что снижает временную сложность.