---
title: "Быстрая сортировка"
date: 2024-12-26
draft: false
description: "Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки."
summary: "Разбор ключевых моментов правильной реализации алгоритма быстрой сортировки."
tags: [ "Алгоритмы", "Алгоритмы сортировки", "Быстрая сортировка", "Разделяй и властвуй" ]
categories: [ "Алгоритмы и структуры данных" ]
---

# Быстрая сортировка

Быстрая сортировка — это алгоритм сортировки на основе сравнений, использующий принцип «разделяй и властвуй». Средняя временная сложность составляет $O(n\log n)$, в худшем случае — $O(n^2)$, а пространственная сложность — $O(1)$. Ниже на примере сортировки по возрастанию целочисленного массива рассмотрим детали ее реализации и распространенные ошибки.

---

## Описание задачи

Дан целочисленный массив длиной $n$. Необходимо отсортировать его по возрастанию с помощью быстрой сортировки и вывести результат.

### Формат ввода

- В первой строке вводится целое число $n$
- Во второй строке вводится $n$ целых чисел в диапазоне $[1, 10^9]$

### Формат вывода

- В одной строке выводится отсортированная последовательность чисел

### Ограничения

$1 \leq n \leq 100000$

### Пример ввода

```
5
3 1 2 4 5
```

### Пример вывода

```
1 2 3 4 5
```

---

## Идея быстрой сортировки

При каждом разделении быстрой сортировки выбирается опорный элемент `pivot` (здесь используется элемент в середине массива).

Используются два указателя — левый `L` и правый `R`. Левый указатель движется слева направо, пока не найдет число, большее или равное `pivot`. Правый указатель движется справа налево, пока не найдет число, меньшее или равное `pivot`. Затем эти два числа меняются местами.

Этот процесс повторяется до тех пор, пока левый и правый указатели не пересекутся или левый указатель не окажется на одну позицию правее правого указателя. Это называется одной итерацией.

После каждого перемещения указателей и обмена местами гарантируется, что структура «левая часть ≤ pivot, правая часть ≥ pivot» не нарушается, то есть существует инвариант `[left, L) <= pivot`, `(R, right] >= pivot`.

В следующем примере кода `left` и `right` — границы текущего обрабатываемого закрытого интервала, а `pivot` выбирается как элемент в середине интервала.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## Сложность и выбор `pivot`

Поскольку в худшем случае быстрая сортировка имеет сложность $O(n^2)$, выбор `pivot` является критически важным. Если всегда выбирать первый или последний элемент, то для почти отсортированных массивов с высокой вероятностью возникнет худший случай.

Кроме выбора элемента в середине, можно случайно выбирать элемент в качестве `pivot` или выбирать медиану из трех элементов — левого, среднего и правого — в качестве `pivot`.

---

## Примеры распространенных ошибок

В приведенном ниже коде содержится несколько распространенных ошибок.

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

**Анализ ошибок:**

1. `pivot` должен быть числом из массива, а не индексом.
2. Необходимо использовать `<` и `>`, а не `<=` и `>=`, иначе левый указатель может зайти дальше правого более чем на одну позицию, что не позволит разделить массив на две части.
3. Обнаружив `l >= r`, нужно немедленно выйти из цикла, не выполняя обмен. В противном случае нельзя гарантировать, что левые элементы не больше `pivot`, а правые не меньше `pivot`.
4. После каждого обмена необходимо выполнять `l++` и `r--`.
5. `pivot` фактически берется как число, смещенное влево от середины. Если использовать $l - 1$ и $l$ для разделения массива, на примере массива `[1, 2]` легко увидеть, что возникнет бесконечный цикл, непрерывно делящий массив на части размером 0 и 2. Напротив, когда цикл завершается, $r$ обязательно меньше $right$, поэтому можно использовать $r$ и $r+1$ для разделения массива. Читатель может смоделировать выполнение алгоритма, чтобы понять почему. Другой простой способ избежать бесконечного цикла — случайным образом выбирать `pivot` или особым образом обрабатывать случай с двумя элементами. Аналогично, использовать $r$ и $l$ для разделения массива тоже нельзя.
6. Кроме того, нельзя использовать $l$, $l+1$, так как такое разделение не соответствует определению: когда $r$ находится левее $l$, использование $l$, $l+1$ не позволит правильно разделить массив на левую часть, меньшую или равную `pivot`, и правую, большую или равную `pivot`.
7. В этой задаче предполагается, что массив непустой, поэтому ситуации `>` не возникает. Однако рекомендуется использовать `>=`, так как это более безопасно.

---

## Дополнение

Быстрая сортировка также может быть преобразована в "быстрый выбор", позволяющий найти $k$-е наименьшее число в неупорядоченном массиве за ожидаемое время $O(n)$. Основная идея аналогична быстрой сортировке, но рекурсивный вызов продолжается только в одном поддиапазоне, что снижает временную сложность.