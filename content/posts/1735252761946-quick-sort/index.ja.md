---
title: "クイックソート"
date: 2024-12-26
draft: false
description: "クイックソートアルゴリズムを正しく実装するための要点解説。"
summary: "クイックソートアルゴリズムを正しく実装するための要点解説。"
tags: [ "アルゴリズム", "ソートアルゴリズム", "クイックソート", "分割統治法" ]
categories: [ "アルゴリズムとデータ構造" ]
---

# クイックソート

クイックソートは、比較に基づく不安定なソートアルゴリズムであり、分割統治法を採用しています。平均時間計算量は $O(n\log n)$、最悪の場合は $O(n^2)$、空間計算量は $O(1)$ です。以下では、整数数列を昇順にソートする例を挙げて、実装の詳細とよくある間違いについて説明します。

---

## 問題記述

長さ $n$ の整数数列が与えられたとき、クイックソートを用いて昇順にソートし、その結果を出力してください。

### 入力形式

- 1行目に整数 $n$ が入力されます。
- 2行目に $n$ 個の整数が入力されます。各整数は $[1,10^9]$ の範囲内です。

### 出力形式

- ソートされた数列を1行に出力してください。

### データ範囲

$1 \leq n \leq 100000$

### 入力例

```
5
3 1 2 4 5
```

### 出力例

```
1 2 3 4 5
```

---

## クイックソートの考え方

クイックソートは、分割統治を行う際に、任意の数を基準数 `pivot` として選択します（ここでは中央位置の数を選択します）。

左右のポインタを互いに向かって移動させ、左ポインタ `L` は左から右へ `pivot` 以上の最初の数を探し、右ポインタ `R` は右から左へ `pivot` 以下の最初の数を見つけ、その後、これらの2つの数を交換します。

このプロセスを、左ポインタと右ポインタが重なるか、左ポインタが右ポインタより1つ大きくなるまで繰り返します。これを1回のループと呼びます。

各ポインタの移動と交換が完了するたびに、「左部分 ≤ pivot、右部分 ≥ pivot」の構造が損なわれないようにします。つまり、不変条件 `[left, L) <= pivot`、`(R, right] >= pivot` が維持されます。

以下のサンプルコードでは、`left` と `right` が現在処理している閉区間の境界であり、`pivot` は区間の中央にある要素を取得します。

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## 計算量と `pivot` の選択

最悪の場合、クイックソートの計算量は $O(n^2)$ になるため、`pivot` の選択は非常に重要です。常に最初または最後の要素を選択すると、ほぼソート済みの配列では最悪のケースが起こりやすくなります。

中央位置の要素を選択する以外に、ランダムに要素を選択して `pivot` にしたり、左、中央、右の3つの要素の中央値を `pivot` にしたりする方法があります。

---

## よくある間違いの例

以下のコードには、よくある間違いがいくつか含まれています。

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

**エラー分析：**

1. `pivot` は配列内の数であるべきで、インデックスではありません。
2. `<=` と `>=` ではなく、`<` と `>` をそれぞれ使用しないと、左ポインタが右ポインタを1つ以上超える可能性があり、その場合、配列を2つの部分に分割できません。
3. `l >= r` を検出したら、すぐにループを抜け、交換を実行しないようにする必要があります。そうしないと、左側の要素が `pivot` 以下であり、右側の要素が `pivot` 以上であることが保証されません。
4. 交換後、必ず `l++` と `r--` を実行する必要があります。
5. `pivot` は実際には中央より少し左の数を使用します。もし配列を $l - 1$ と $l$ で分割した場合、`[1, 2]` という配列では無限ループが発生し、配列がサイズ 0 と 2 の2つに分割し続けることがわかります。逆に、ループが終了したとき、$r$ は必ず $right$ より小さくなるため、$r$ と $r+1$ を使用して配列を分割することができます。読者は、アルゴリズムのプロセスをシミュレートして、その理由を確認してください。無限ループを避けるもう1つの簡単な方法は、ランダムに `pivot` を選択するか、要素が2つしかない場合を特別に処理することです。同様に、$r$ と $l$ で配列を区別することもできません。
6. また、$l$、$l+1$ も使用できません。なぜなら、この分割は定義に合致せず、$r$ が $l$ の左にある場合、$l$、$l+1$ を使用して配列を、左側が `pivot` 以下、右側が `pivot` 以上の2つの部分に正しく分割することができないからです。
7. この問題では、配列が空でないと仮定しているので、`>` の場合はありません。ただし、`>=` を使用することをお勧めします。より安全です。

---

## 補足

クイックソートは「クイックセレクト」に進化させることもでき、期待値 $O(n)$ の時間内で、順序付けされていない配列から $k$ 番目に小さい数を見つけることができます。具体的な考え方はクイックソートと似ていますが、毎回片側のサブ区間のみで再帰を行うことで、時間計算量を減らします。