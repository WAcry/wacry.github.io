title: "クイックソート"
date: 2024-12-26
draft: false
description: "クイックソートアルゴリズムを正しく実装するための要点解説。"
summary: "クイックソートアルゴリズムを正しく実装するための要点解説。"
tags: [ "アルゴリズム", "ソートアルゴリズム", "クイックソート", "分割統治法" ]
categories: [ "アルゴリズムとデータ構造" ]
---

# クイックソート

クイックソートは、比較に基づく非安定ソートアルゴリズムであり、分割統治法を採用しています。平均時間計算量は $O(n\log n)$、最悪の場合は $O(n^2)$、空間計算量は $O(1)$ です。以下では、整数数列を小さい順にソートする例を基に、実装の詳細とよくある間違いについて説明します。

---

## 問題の説明

長さ $n$ の整数数列が与えられたとき、クイックソートを用いて小さい順にソートし、結果を出力してください。

### 入力形式

- 1行目に整数 $n$ が入力されます。
- 2行目に $n$ 個の整数が入力されます。各整数は $[1,10^9]$ の範囲内です。

### 出力形式

- ソートされた数列を1行に出力します。

### データ範囲

$1 \leq n \leq 100000$

### 入力例

```
5
3 1 2 4 5
```

### 出力例

```
1 2 3 4 5
```

---

## クイックソートの考え方

クイックソートは、分割統治を行う際に、任意の数を基準数 `pivot` として選択します（以下では、中央位置の数を選択します）。

左右のポインタを互いに向かい合わせに進めます。左ポインタ `L` は左から右へ `pivot` 以上の最初の数を見つけ、右ポインタ `R` は右から左へ `pivot` 以下の最初の数を見つけ、それらの数を交換します。

このプロセスを、左ポインタと右ポインタが重なるか、左ポインタが右ポインタより1つ大きくなるまで繰り返します。これを1回のループと呼びます。

ポインタの移動と交換が完了するたびに、「左側部分 ≤ pivot, 右側部分 ≥ pivot」の構造が維持されるようにします。つまり、不変条件 `[left, L) <= pivot`、`(R, right] >= pivot` が成り立ちます。

以下のサンプルコードでは、`left` と `right` は現在処理中の閉区間の境界であり、`pivot` は区間の中央にある要素を取ります。

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left >= right) return;
    
    int pivot = a[(left + right) / 2];
    int l = left, r = right;
    
    while (true) {
        while (a[l] < pivot) l++;
        while (a[r] > pivot) r--;
        if (l >= r) break;
        swap(a[l], a[r]);
        l++; r--;
    }
    
    quickSort(a, left, r);
    quickSort(a, r + 1, right);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    return 0;
}
```

---

## 計算量と `pivot` の選択

最悪の場合、クイックソートの計算量は $O(n^2)$ になるため、`pivot` の選択は非常に重要です。常に最初または最後の要素を選択すると、ほぼソート済みの配列では最悪のケースが発生する可能性が高くなります。

中央位置の要素を選択する以外に、ランダムに要素を `pivot` として選択したり、左、中央、右の3つの要素の中央値を `pivot` として選択することもできます。

---

## よくある間違いの例

以下のコードには、よくある間違いが複数含まれています。

```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int> &a, int left, int right) {
    if (left == right) return; // 7

    int pivot = (left + right) >> 1; // 1
    int l = left, r = right;

    while (true) {
        while (a[l] <= pivot) l++; // 2
        while (a[r] >= pivot) r--; // 2
        swap(a[l], a[r]);
        if (l >= r) break; // 3
        // 4
    }

    quickSort(a, left, l - 1); // 5, 6
    quickSort(a, l, right);    // 5, 6
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    quickSort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) cout << a[i] << " ";

    return 0;
}
```

**間違いの分析：**

1. `pivot` は配列内の数であるべきで、インデックスではありません。
2. `<=` と `>=` ではなく、それぞれ `<` と `>` を使用する必要があります。そうしないと、左ポインタが右ポインタを1つ以上超える可能性があり、配列を2つの部分に分割できなくなります。
3. `l >= r` を検出したら、すぐにループを終了し、交換を実行しないようにする必要があります。そうしないと、左側の要素が `pivot` 以下、右側の要素が `pivot` 以上であることを保証できません。
4. 交換するたびに、`l++` と `r--` を実行する必要があります。
5. `pivot` は実際には中央より左側の数を選択しています。したがって、$l - 1$ と $l$ を使用して配列を分割すると、配列 `[1, 2]` を考慮すると、配列をサイズが0と2の2つの部分に分割し続ける無限ループが発生することがわかります。同様に、$r$ と $l$ を使用して配列を区別することもできません。逆に、1回のループが終了すると、$r$ は必ず $right$ より小さくなるため、$r$ と $r+1$ を使用して配列を分割できます。なぜそうなるのか、アルゴリズムのプロセスをシミュレートしてみてください。無限ループを回避するもう1つの簡単な方法は、`pivot` をランダムに選択するか、要素が2つしかない場合を特別に処理することです。
6. また、$l$, $l+1$ を使用することもできません。この分割は定義に合致せず、$r$ が $l$ の左側にある場合、$l$, $l+1$ を使用して、配列を左側が `pivot` 以下、右側が `pivot` 以上である2つの部分に正しく分割することはできません。
7. この問題では、配列が空でないことを前提としているため、`>` のケースは存在しません。ただし、`>=` を使用することをお勧めします。より安全です。

---

## 補足

クイックソートは「クイック選択」に発展させることもでき、$O(n)$ の期待時間で、順序付けられていない配列の中で $k$ 番目に小さい数を見つけることができます。具体的な考え方はクイックソートと似ていますが、毎回片側のサブ区間のみを再帰的に処理することで、時間計算量を削減します。