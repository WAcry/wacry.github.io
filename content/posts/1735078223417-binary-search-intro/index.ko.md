markdown
---
title: "이분 탐색"
date: 2024-12-24
draft: false
description: "이분 탐색 알고리즘을 우아하게 구현하는 방법."
summary: "이분 탐색 알고리즘을 우아하게 구현하는 방법."
tags: [ "알고리즘", "이분 탐색", "알고리즘 템플릿" ]
categories: [ "알고리즘 및 자료 구조" ]
---

정렬된 해 공간이 두 부분으로 나뉘어 한 부분은 조건을 만족하고 다른 부분은 만족하지 않는 경우, 이분 탐색을 사용하여 정렬된 해 공간에서 임계점을 찾을 수 있습니다.

이분 탐색의 기본 아이디어는 검색 간격을 반복적으로 반으로 줄이는 것입니다. 매번 중간 요소를 확인합니다. 중간 요소가 조건을 만족하지 않으면 간격의 절반을 제거할 수 있습니다. 그렇지 않으면 다른 절반에서 검색을 계속합니다. 매번 검색 간격의 절반이 버려지므로 검색 시간 복잡도는 $O(\log n)$에 도달할 수 있습니다.

## 예제 문제

**문제 설명:**
길이가 $n$인 오름차순으로 정렬된 정수 배열과 $q$개의 쿼리가 주어집니다. 각 쿼리는 정수 $k$를 제공하며, 배열에서 $k$의 "시작 위치"와 "끝 위치"를 찾아야 합니다 (인덱스는 0부터 시작). 배열에 숫자가 없으면 `-1 -1`을 반환합니다.

### 입력 형식

1. 첫 번째 줄: 배열의 길이와 쿼리 수를 나타내는 두 정수 $n$과 $q$입니다.
2. 두 번째 줄: 오름차순으로 정렬된 전체 배열을 나타내는 $n$개의 정수입니다.
3. 다음 $q$줄: 각 줄에는 쿼리 요소를 나타내는 정수 $k$가 포함됩니다.

## 데이터 범위

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 출력 형식

각 쿼리에 대해 배열에서 요소의 시작 및 끝 위치를 한 줄에 출력합니다. 배열에 요소가 없으면 `-1 -1`을 출력합니다.

**예시:**

```
입력:
6 3
1 2 2 3 3 4
3
4
5

출력:
3 4
5 5
-1 -1
```

**설명:**

- 요소 $3$이 나타나는 범위는 $[3, 4]$입니다.
- 요소 $4$는 위치 $5$에서 한 번만 나타납니다.
- 요소 $5$는 배열에 존재하지 않으므로 $-1$ $-1$을 반환합니다.

---

## 해결 방법

- **"시작 위치" 찾기:**
  즉, $k$보다 크거나 같은 첫 번째 위치를 찾는 것입니다. 배열은 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 $k$보다 "작습니다".
    - 오른쪽의 모든 숫자는 $k$보다 "크거나 같습니다".
    - 정답은 오른쪽의 첫 번째 위치입니다.

- **"끝 위치" 찾기:**
  즉, $k$보다 작거나 같은 마지막 위치를 찾는 것입니다. 배열은 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 $k$보다 "작거나 같습니다".
    - 오른쪽의 모든 숫자는 $k$보다 "큽니다".
    - 정답은 왼쪽의 마지막 위치입니다.

---

## 추천 템플릿

다음은 우아하고 오류가 적은 이분 탐색 템플릿입니다.

두 개의 포인터 $l, r$을 정의하고, 불변성은 닫힌 구간 $[0, l]$이 왼쪽 부분에 속하고, 닫힌 구간 $[r, n - 1]$이 오른쪽 부분에 속합니다. $l$과 $r$은 각각 $-1$과 $n$으로 초기화됩니다.

알고리즘이 종료되면 $l$과 $r$은 인접하여 왼쪽 부분의 마지막 요소와 오른쪽 부분의 첫 번째 요소를 가리킵니다.

우리가 원하는 해답이 존재하지 않을 수도 있으므로, 문제에서 해답이 반드시 존재한다고 명시하지 않은 경우, `l` 또는 `r`이 범위를 벗어났는지, 그리고 올바른 값을 가리키는지 확인해야 합니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k의 시작 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽 부분은 모두 < k이고, 오른쪽 부분은 모두 >= k입니다.
        //    정답은 오른쪽 부분의 가장 작은 인덱스입니다.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음을 의미합니다.
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k의 끝 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽 부분은 모두 <= k이고, 오른쪽 부분은 모두 > k입니다.
        //    정답은 왼쪽 부분의 가장 큰 인덱스입니다.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### 장점

1. 이 접근 방식은 엄격하게 정의된 불변성을 가집니다.
2. 추가 처리나 변경 없이 "시작 위치"와 "끝 위치"를 모두 찾는 데 적용됩니다.
3. 일부 접근 방식에서는 `l == r`을 종료 조건으로 사용합니다. $l$과 $r$이 $1$만큼 차이가 나면 $mid$는 $l$ 또는 $r$과 같게 계산됩니다. 올바르게 처리하지 않으면 $l$ 또는 $r$을 $mid$로 업데이트해도 검색 간격이 줄어들지 않아 무한 루프가 발생합니다. 반면, 이 접근 방식은 $l$과 $r$이 인접할 때 종료되므로 $mid$가 $l$보다 작고 $r$보다 크며, $l$ 또는 $r$을 업데이트하면 항상 검색 간격이 줄어듭니다.

---

## STL

C++ STL에서 제공하는 `lower_bound` 및 `upper_bound` 함수를 사용하면 동일한 결과를 얻을 수 있습니다.

- `lower_bound(first, last, val)`은 "val보다 크거나 같은 첫 번째 위치"를 반환합니다.
- `upper_bound(first, last, val)`은 "val보다 큰 첫 번째 위치"를 반환합니다.

예를 들어, `nums = {1,2,3,4,4,4,4,4,5,5,6}`이고, 4가 나타나는 범위를 알고 싶다고 가정해 봅시다.

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4는 0번 나타납니다" << endl;
} else {
    cout << "첫 번째 4는 " << it1 - nums.begin() << "에 있습니다" << endl;
    cout << "마지막 4는 " << it2 - nums.begin() - 1 << "에 있습니다" << endl;
    cout << "4는 " << it2 - it1 << "번 나타납니다" << endl;
}
```

- `it1`은 값이 $4$보다 크거나 같은 첫 번째 위치를 가리킵니다.
- `it2`는 값이 $4$보다 큰 첫 번째 위치를 가리킵니다.
  따라서 `it2 - it1`은 배열에서 $4$가 나타나는 횟수입니다. `it2 - nums.begin() - 1`은 $4$의 오른쪽 경계 위치입니다.

---

## 추가 참고 사항

이분 탐색은 부동 소수점 범위에서 검색(예: 방정식의 근 찾기)과 단봉 함수의 극값을 찾는 삼분 탐색으로 확장될 수도 있습니다.

---

## 연습 문제

LeetCode 33. Search in Rotated Sorted Array

힌트: 먼저 이분 탐색을 사용하여 회전점을 찾은 다음, 이분 탐색을 사용하여 목표 값을 찾습니다.