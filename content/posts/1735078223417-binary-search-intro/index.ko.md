---
title: "이분 탐색"
date: 2024-12-24
draft: false
description: "정수 이분 탐색 알고리즘을 우아하게 구현하는 방법."
summary: "정수 이분 탐색 알고리즘을 우아하게 구현하는 방법."
tags: [ "알고리즘", "이분 탐색", "알고리즘 템플릿" ]
categories: [ "알고리즘 및 자료구조" ]
---

{{< katex >}}

# 이분 탐색

정렬된 해 공간이 왼쪽과 오른쪽 두 부분으로 나뉘어 있고, 한 부분은 조건을 만족하고 다른 부분은 조건을 만족하지 않는 경우, 이분 탐색을 사용하여 정렬된 해 공간에서 임계점을 찾을 수 있습니다.

이분 탐색의 기본 아이디어는 검색 구간을 계속해서 반으로 나누는 것입니다. 매번 중간 요소(중간점)를 검사하고, 중간 요소가 조건을 만족하지 않으면 한쪽 구간을 제외할 수 있습니다. 반대로, 다른 구간에서 계속 검색합니다. 매번 검색 구간의 절반을 버리므로 검색 시간 복잡도는 \\(O(\log n)\\)에 도달할 수 있습니다.

## 예제 문제

**문제 설명:**  
길이가 \\(n\\)인 오름차순으로 정렬된 정수 배열과 \\(q\\)개의 쿼리가 주어집니다. 각 쿼리마다 정수 \\(k\\)가 주어지면, 배열에서 \\(k\\)의 "시작 위치"와 "종료 위치"를 찾아야 합니다(인덱스는 0부터 시작). 배열에 해당 숫자가 없으면 \\(-1\\) \\(-1\\)을 반환합니다.

### 입력 형식

1. 첫 번째 줄: 배열 길이와 쿼리 횟수를 나타내는 두 정수 \\(n\\)과 \\(q\\)입니다.
2. 두 번째 줄: 오름차순으로 정렬된 전체 배열을 나타내는 \\(n\\)개의 정수입니다.
3. 다음 \\(q\\)줄: 각 줄에는 쿼리 요소를 나타내는 정수 \\(k\\)가 포함되어 있습니다.

## 데이터 범위

\\(1 \leq n \leq 100000\\)

\\(1 \leq q \leq 10000\\)

\\(1 \leq k \leq 10000\\)

### 출력 형식

각 쿼리에 대해 배열에서 해당 요소의 시작 및 끝 위치를 한 줄에 출력합니다. 배열에 해당 요소가 없으면 `-1 -1`을 출력합니다.

**예시:**

```
입력:
6 3
1 2 2 3 3 4
3
4
5

출력:
3 4
5 5
-1 -1
```

**설명:**

- 요소 \\(3\\)은 범위 \\([3, 4]\\)에 나타납니다.
- 요소 \\(4\\)는 위치 \\(5\\)에서 한 번만 나타납니다.
- 요소 \\(5\\)는 배열에 없으므로 \\(-1\\) \\(-1\\)을 반환합니다.

---

## 해답

- **"시작 위치" 찾기:**
  즉, \\(k\\)보다 크거나 같은 첫 번째 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 \\(k\\)보다 "작습니다".
    - 오른쪽의 모든 숫자는 \\(k\\)보다 "크거나 같습니다".
    - 답은 오른쪽의 첫 번째 위치입니다.

- **"종료 위치" 찾기:**
  즉, \\(k\\)보다 작거나 같은 마지막 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 \\(k\\)보다 "작거나 같습니다".
    - 오른쪽의 모든 숫자는 \\(k\\)보다 "큽니다".
    - 답은 왼쪽의 마지막 위치입니다.

---

## 추천 템플릿

다음은 우아하고 오류를 범하기 쉽지 않은 이분 탐색 템플릿입니다. \\(l\\)과 \\(r\\)을 점진적으로 가까워지게 하여 반복문이 둘이 인접했을 때 종료되도록 보장합니다.

두 포인터 \\(l, r\\)을 정의합니다. 불변성은 다음과 같습니다. 닫힌 구간 \\([0, l]\\)은 모두 왼쪽 부분에 속하고, 닫힌 구간 \\([r, n - 1]\\)은 모두 오른쪽 부분에 속합니다. \\(l\\)과 \\(r\\)은 각각 \\(-1\\)과 \\(n\\)으로 초기화합니다.

알고리즘이 종료되면 \\(l\\)과 \\(r\\)이 인접하며, 각각 왼쪽 부분의 마지막 요소와 오른쪽 부분의 첫 번째 요소를 가리킵니다.

우리가 원하는 해답이 없을 수도 있기 때문에, 문제에서 반드시 해답이 존재한다고 언급하지 않았다면 `l` 또는 `r`이 범위를 벗어나는지, 올바른 값을 가리키고 있는지 확인해야 합니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k의 시작 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽은 모두 < k이고, 오른쪽은 모두 >= k입니다.
        //    답은 오른쪽 부분의 최소 인덱스입니다.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음을 의미합니다.
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k의 종료 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽은 모두 <= k이고, 오른쪽은 모두 > k입니다.
        //    답은 왼쪽 부분의 최대 인덱스입니다.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### 이렇게 작성하는 이유

1. 이 코드는 엄격하게 정의된 불변성을 가지고 있습니다.
2. "시작 위치"와 "종료 위치"를 찾는 두 가지 경우 모두에 적용할 수 있으며, 추가적인 처리나 변경이 필요하지 않습니다.
3. 일부 코드는 `l == r`을 종료 조건으로 사용합니다. \\(l\\)과 \\(r\\)이 \\(1\\) 차이 나면 \\(mid\\)가 \\(l\\) 또는 \\(r\\)과 같게 계산됩니다. 올바르게 처리하지 않으면 \\(l\\) 또는 \\(r\\)을 \\(mid\\)로 업데이트하면 검색 구간이 줄어들지 않아 무한 루프가 발생합니다. 반대로, 여기서의 코드는 \\(l\\)과 \\(r\\)이 인접할 때 종료되므로 \\(mid\\)가 \\(l\\)보다 작고 \\(r\\)보다 크다는 것을 보장하며, \\(l\\) 또는 \\(r\\)을 업데이트할 때 검색 구간이 반드시 줄어듭니다.

---

## STL

C++ STL에서 제공하는 `lower_bound`와 `upper_bound` 함수를 사용하면 같은 작업을 수행할 수 있습니다.

- `lower_bound(first, last, val)`은 "val보다 크거나 같은 첫 번째 위치"를 반환합니다.
- `upper_bound(first, last, val)`은 "val보다 큰 첫 번째 위치"를 반환합니다.

예를 들어, `nums = {1,2,3,4,4,4,4,4,5,5,6}`이고, 4가 나타나는 구간을 알고 싶다고 가정해 보겠습니다.

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1`은 값이 \\(4\\)보다 크거나 같은 첫 번째 위치를 가리킵니다.
- `it2`는 값이 \\(4\\)보다 큰 첫 번째 위치를 가리킵니다.  
  따라서 `it2 - it1`은 배열에서 \\(4\\)가 나타나는 횟수이고, `it2 - nums.begin() - 1`은 \\(4\\)의 오른쪽 경계입니다.

---

## 추가 설명

이분 탐색은 부동소수점 범위의 검색(예: 방정식의 근을 구하는 방법)과 단봉 함수의 최댓값을 구하는 삼분 탐색으로 확장할 수도 있습니다.
"**정렬된 구간에서 매번 절반을 제외할 수 있다**"라는 핵심 원리를 이해하면 이분 탐색이 다양한 시나리오에서 효율적으로 문제를 해결하는 데 도움이 된다는 것을 알게 될 것입니다.

---

## 연습

LeetCode 33. Search in Rotated Sorted Array

힌트: 첫 번째 단계에서는 이분 탐색을 사용하여 회전점을 찾고, 두 번째 단계에서는 이분 탐색을 사용하여 목표값을 찾습니다.