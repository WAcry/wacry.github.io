---
title: "이분 탐색"
date: 2024-12-24
draft: false
description: "이분 탐색 알고리즘을 우아하게 구현하는 방법."
summary: "이분 탐색 알고리즘을 우아하게 구현하는 방법."
tags: [ "알고리즘", "이분 탐색", "알고리즘 템플릿" ]
categories: [ "알고리즘 및 자료 구조" ]
---

정렬된 해 공간이 좌우 두 부분으로 나뉘어, 한 부분은 조건을 만족하고 다른 부분은 조건을 만족하지 않는 경우, 이분 탐색을 사용하여 정렬된 해 공간에서 임계점을 찾을 수 있습니다.

이분 탐색의 기본 아이디어는 검색 구간을 계속해서 반으로 나누는 것입니다. 매번 중간 요소를 확인하고, 중간 요소가 조건을 만족하지 않으면 한쪽 구간을 제외할 수 있습니다. 반대로, 다른 구간에서 계속 검색합니다. 매번 검색 구간의 절반을 버리기 때문에 검색 시간 복잡도는 $O(\log n)$에 도달할 수 있습니다.

## 예제

**문제 설명:**  
길이가 $n$인 오름차순으로 정렬된 정수 배열과 $q$개의 쿼리가 주어집니다. 각 쿼리는 정수 $k$를 제공하며, 배열에서 $k$의 "시작 위치"와 "종료 위치"(인덱스는 0부터 시작)를 찾아야 합니다. 배열에 해당 숫자가 없으면 `-1 -1`을 반환합니다.

### 입력 형식

1. 첫 번째 줄: 배열 길이와 쿼리 횟수를 나타내는 두 정수 $n$과 $q$입니다.
2. 두 번째 줄: 오름차순으로 정렬된 전체 배열을 나타내는 $n$개의 정수입니다.
3. 다음 $q$줄: 각 줄에는 쿼리 요소를 나타내는 정수 $k$가 포함됩니다.

## 데이터 범위

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 출력 형식

각 쿼리에 대해 배열에서 해당 요소의 시작 및 종료 위치를 한 줄에 출력합니다. 배열에 해당 요소가 없으면 `-1 -1`을 출력합니다.

**예시:**

```
입력:
6 3
1 2 2 3 3 4
3
4
5

출력:
3 4
5 5
-1 -1
```

**설명:**

- 요소 $3$이 나타나는 범위는 $[3, 4]$입니다.
- 요소 $4$는 위치 $5$에서 한 번만 나타납니다.
- 요소 $5$는 배열에 없으므로 $-1$ $-1$을 반환합니다.

---

## 해답

- **"시작 위치" 찾기:**
  즉, $k$보다 크거나 같은 첫 번째 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 $k$보다 "작습니다".
    - 오른쪽의 모든 숫자는 $k$보다 "크거나 같습니다".
    - 답은 오른쪽의 첫 번째 위치입니다.

- **"종료 위치" 찾기:**
  즉, $k$보다 작거나 같은 마지막 위치를 찾습니다. 배열을 두 부분으로 나눌 수 있습니다.
    - 왼쪽의 모든 숫자는 $k$보다 "작거나 같습니다".
    - 오른쪽의 모든 숫자는 $k$보다 "큽니다".
    - 답은 왼쪽의 마지막 위치입니다.

---

## 추천 템플릿

다음은 우아하고 오류가 발생하기 쉬운 이분 탐색 템플릿입니다.

두 개의 포인터 $l, r$을 정의합니다. 불변성은 닫힌 구간 $[0, l]$은 왼쪽 부분에 속하고, 닫힌 구간 $[r, n - 1]$은 오른쪽 부분에 속합니다. $l$과 $r$은 각각 $-1$과 $n$으로 초기화됩니다.

알고리즘이 종료되면 $l$과 $r$은 인접하며, 각각 왼쪽 부분의 마지막 요소와 오른쪽 부분의 첫 번째 요소를 가리킵니다.

우리가 원하는 해답이 존재하지 않을 수 있으므로, 문제에서 해답이 반드시 존재한다고 명시하지 않은 경우, `l` 또는 `r`이 범위를 벗어났는지, 올바른 값을 가리키는지 확인해야 합니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k의 시작 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽은 모두 < k, 오른쪽은 모두 >= k입니다.
        //    답은 오른쪽 부분의 최소 인덱스입니다.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // 만약 r이 범위를 벗어나거나 nums[r] != k이면 k가 존재하지 않음을 의미합니다.
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k의 종료 위치 찾기
        //    배열을 두 부분으로 나눕니다. 왼쪽은 모두 <= k, 오른쪽은 모두 > k입니다.
        //    답은 왼쪽 부분의 최대 인덱스입니다.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }

    return 0;
}
```

### 장점

1. 이 코드는 엄격하게 정의된 불변성을 가지고 있습니다.
2. "시작 위치"와 "종료 위치" 두 가지 경우 모두에 적용할 수 있으며, 추가적인 처리나 변경이 필요하지 않습니다.
3. 일부 코드는 `l == r`을 종료 조건으로 사용합니다. $l$과 $r$이 $1$ 차이가 나면 $mid$가 $l$ 또는 $r$과 같게 계산됩니다. 올바르게 처리하지 않으면 $l$ 또는 $r$을 $mid$로 업데이트하면 검색 구간이 줄어들지 않아 무한 루프가 발생할 수 있습니다. 반대로, 여기의 코드는 $l$과 $r$이 인접할 때 종료되므로 $mid$가 $l$보다 작고 $r$보다 크다는 것을 보장하며, $l$ 또는 $r$을 업데이트할 때 검색 구간이 반드시 줄어듭니다.

---

## STL

C++ STL에서 제공하는 `lower_bound`와 `upper_bound` 함수를 사용하면 동일한 작업을 수행할 수 있습니다.

- `lower_bound(first, last, val)`은 "val보다 크거나 같은 첫 번째 위치"를 반환합니다.
- `upper_bound(first, last, val)`은 "val보다 큰 첫 번째 위치"를 반환합니다.

예를 들어, `nums = {1,2,3,4,4,4,4,4,5,5,6}`이고 4가 나타나는 구간을 알고 싶다고 가정해 봅시다.

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1`은 $4$보다 크거나 같은 첫 번째 값을 가리킵니다.
- `it2`는 $4$보다 큰 첫 번째 값을 가리킵니다.  
  따라서 `it2 - it1`은 배열에서 $4$가 나타나는 횟수이고, `it2 - nums.begin() - 1`은 $4$의 오른쪽 경계 위치입니다.

---

## 추가

이분 탐색은 부동 소수점 범위의 검색(예: 방정식의 근 구하기) 및 삼분 탐색으로 단봉 함수의 최댓값을 구하는 데까지 확장할 수 있습니다.

---

## 연습

LeetCode 33. Search in Rotated Sorted Array

힌트: 첫 번째 단계에서 이분 탐색을 사용하여 회전점을 찾고, 두 번째 단계에서 이분 탐색을 사용하여 목표 값을 찾습니다.