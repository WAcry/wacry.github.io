---
title: "द्विआधारी खोज"
date: 2024-12-24
draft: false
description: "पूर्णांक द्विआधारी खोज एल्गोरिथ्म को सुंदरता से कैसे लागू करें।"
summary: "पूर्णांक द्विआधारी खोज एल्गोरिथ्म को सुंदरता से कैसे लागू करें।"
tags: [ "एल्गोरिथ्म", "द्विआधारी खोज", "एल्गोरिथ्म टेम्पलेट" ]
categories: [ "एल्गोरिथ्म और डेटा संरचनाएँ" ]
---

{{< katex >}}

# द्विआधारी खोज

यदि क्रमित समाधान स्थान को दो भागों, बाएं और दाएं में विभाजित किया जाता है, जहां एक भाग शर्त को पूरा करता है और दूसरा भाग शर्त को पूरा नहीं करता है। फिर एक महत्वपूर्ण बिंदु को खोजने के लिए क्रमित समाधान स्थान में द्विआधारी खोज का उपयोग किया जा सकता है।

द्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधे में विभाजित करना है। प्रत्येक बार मध्य बिंदु तत्व की जाँच करें, यदि मध्य बिंदु तत्व स्थिति को पूरा नहीं करता है, तो आधे अंतराल को हटाया जा सकता है;
अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूँकि प्रत्येक बार खोज अंतराल का आधा हिस्सा छोड़ा जाता है, खोज का समय जटिलता \\(O(\log n)\\) तक पहुँच सकता है।

## उदाहरण प्रश्न

**प्रश्न विवरणः**
एक आरोही क्रमबद्ध लंबाई \\(n\\) पूर्णांक सरणी दी गई है, साथ ही \\(q\\) क्वेरी दी गई हैं। प्रत्येक क्वेरी एक पूर्णांक \\(k\\) देती है, हमें सरणी में \\(
k\\) के "प्रारंभिक स्थिति" और "अंतिम स्थिति" (इंडेक्स 0 से शुरू) को खोजने की आवश्यकता है। यदि संख्या सरणी में मौजूद नहीं है, तो \\(-1\\) \\(-1\\) वापस करें।

### इनपुट प्रारूप

1. पहली पंक्ति: दो पूर्णांक \\(n\\) और \\(q\\), जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या को दर्शाते हैं।
2. दूसरी पंक्ति: \\(n\\) पूर्णांक, जो पूर्ण सरणी को दर्शाते हैं, जिन्हें आरोही क्रम में क्रमबद्ध किया गया है।
3. अगली \\(q\\) पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक \\(k\\) होता है, जो एक क्वेरी तत्व को दर्शाता है।

## डेटा रेंज

\\(1 \leq n \leq 100000\\)

\\(1 \leq q \leq 10000\\)

\\(1 \leq k \leq 10000\\)

### आउटपुट प्रारूप

प्रत्येक क्वेरी के लिए, सरणी में तत्व की प्रारंभिक और अंतिम स्थिति को एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो `-1 -1` आउटपुट करें।

**नमूनाः**

```
इनपुटः
6 3
1 2 2 3 3 4
3
4
5

आउटपुटः
3 4
5 5
-1 -1
```

**व्याख्या:**

- तत्व \\(3\\) की सीमा \\([3, 4]\\) है;
- तत्व \\(4\\) केवल एक बार स्थिति \\(5\\) पर प्रकट होता है;
- तत्व \\(5\\) सरणी में मौजूद नहीं है, इसलिए \\(-1\\) \\(-1\\) वापस करें।

---

## उत्तर

- **"प्रारंभिक स्थिति" का पता लगाएं:**
  यानी पहली स्थिति खोजें जो \\(k\\) से बड़ी या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ \\(k\\) से "छोटी" हैं
    - दाईं ओर की सभी संख्याएँ \\(k\\) से "बड़ी या बराबर" हैं
    - उत्तर दाईं ओर की पहली स्थिति है

- **"अंतिम स्थिति" का पता लगाएं:**
  यानी आखिरी स्थिति खोजें जो \\(k\\) से छोटी या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ \\(k\\) से "छोटी या बराबर" हैं
    - दाईं ओर की सभी संख्याएँ \\(k\\) से "बड़ी" हैं
    - उत्तर बाईं ओर की अंतिम स्थिति है

---

## अनुशंसित टेम्पलेट

नीचे एक सुंदर और त्रुटि-मुक्त द्विआधारी टेम्पलेट दिया गया है। यह \\(l\\) और \\(r\\) को धीरे-धीरे एक साथ लाकर सुनिश्चित करता है कि चक्र दोनों के आसन्न होने पर समाप्त हो:

दो पॉइंटर्स \\(l, r\\) को परिभाषित करें, एक अपरिवर्तनीय है: बंद अंतराल \\([0, l]\\) सभी बाईं ओर के भाग से संबंधित हैं, बंद अंतराल \\([r, n - 1]\\) सभी दाईं ओर के भाग से संबंधित हैं। \\(l\\)
और \\(r\\) दोनों को \\(-1\\) और \\(n\\) पर इनिशियलाइज़ किया जाता है।

जब एल्गोरिथ्म समाप्त होता है, तो \\(l\\) और \\(r\\) आसन्न होते हैं, क्रमशः बाईं ओर के अंतिम तत्व और दाईं ओर के पहले तत्व की ओर इशारा करते हैं।

क्योंकि हम जो हल चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए यदि प्रश्न यह नहीं बताता है कि कोई समाधान निश्चित रूप से मौजूद है, तो हमें यह न्याय करने की आवश्यकता है कि `l` या `r` सीमा से बाहर है या नहीं और क्या यह सही मान की ओर इशारा करता है।

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k की शुरुआती स्थिति खोजें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सब < k, दाईं ओर सब >= k।
        //    उत्तर दाईं ओर का न्यूनतम इंडेक्स है।
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k की अंतिम स्थिति खोजें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सब <= k, दाईं ओर सब > k।
        //    उत्तर बाईं ओर का अधिकतम इंडेक्स है।
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### इसे इस तरह क्यों लिखें

1. इस लेखन में अपरिवर्तनीय की सख्त परिभाषा है।
2. यह "प्रारंभिक स्थिति" और "अंतिम स्थिति" दोनों स्थितियों को खोजने के लिए उपयुक्त है, इसके लिए अतिरिक्त हैंडलिंग और परिवर्तन की आवश्यकता नहीं है।
3. कुछ लेखन `l == r` का उपयोग समाप्ति शर्त के रूप में करते हैं। जब \\(l\\) और \\(r\\) \\(1\\) से भिन्न होते हैं, तो यह \\(mid\\) की गणना \\(l\\) या \\(r\\) के बराबर करेगा। यदि सही तरीके से हैंडल नहीं किया जाता है, तो \\(l\\) या \\(r\\) को \\(mid\\) पर अपडेट करना, खोज अंतराल को कम नहीं करता है, जिससे एक अनंत चक्र होता है। इसके विपरीत, यहां की लेखन शैली \\(l\\) में समाप्त होती है और \\(r\\) आसन्न होते हैं, यह सुनिश्चित करते हैं कि \\(mid\\) \\(l\\) से छोटा है और \\(r\\) से बड़ा है, और जब \\(l\\) या \\(r\\) अपडेट किया जाता है तो खोज अंतराल निश्चित रूप से कम हो जाएगा।

---

## STL

यदि C++ STL द्वारा प्रदान किए गए `lower_bound` और `upper_bound` कार्यों का उपयोग किया जाता है, तो भी वही किया जा सकता है:

- `lower_bound(first, last, val)` "पहला स्थान जो val से बड़ा या उसके बराबर है" वापस करेगा।
- `upper_bound(first, last, val)` "पहला स्थान जो val से बड़ा है" वापस करेगा।

एक उदाहरण के रूप में, मान लीजिए कि `nums = {1,2,3,4,4,4,4,4,5,5,6}` और हम जानना चाहते हैं कि 4 किस अंतराल में दिखाई देता है:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` पहले मान से अधिक या \\(4\\) के बराबर स्थान पर इंगित करता है।
- `it2` पहले मान से अधिक \\(4\\) के स्थान पर इंगित करता है।
तो `it2 - it1` सरणी में \\(4\\) की संख्या है; `it2 - nums.begin() - 1` \\(4\\) की दाहिनी सीमा है।

---

## पूरक

द्विआधारी खोज को फ़्लोटिंग-पॉइंट नंबर रेंज (जैसे समीकरणों की जड़ें खोजना), साथ ही सिंगल-पीक फ़ंक्शंस के अधिकतम मानों को खोजने के लिए त्रिगुट खोज तक भी बढ़ाया जा सकता है।
जब तक आप "क्रमबद्ध अंतराल में, हर बार आधे हिस्से को हटाया जा सकता है" के मूल सिद्धांत को समझते हैं, आप पाएंगे कि द्विआधारी खोज कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकती है।

---

## अभ्यास

LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें

संकेत: पहला चरण घूर्णन बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।