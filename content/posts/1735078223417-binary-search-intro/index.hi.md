---
title: "बाइनरी सर्च"
date: 2024-12-24
draft: false
description: "इंटीजर बाइनरी सर्च एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें"
summary: "इंटीजर बाइनरी सर्च एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें"
tags: [ "एल्गोरिथम", "बाइनरी सर्च", "एल्गोरिथम टेम्पलेट" ]
categories: [ "एल्गोरिथम और डेटा संरचनाएं" ]
---
{{< katex >}}

# बाइनरी सर्च

एक क्रमबद्ध अनुक्रम में किसी विशिष्ट तत्व को खोजने के लिए, आप इसे जल्दी से पूरा करने के लिए बाइनरी सर्च का उपयोग कर सकते हैं। रैखिक खोज की समय जटिलता $O(n)$ की तुलना में, बाइनरी सर्च को केवल $O(\log n)$ समय की आवश्यकता होती है, इसलिए यह बड़े डेटा पैमानों में बहुत कुशल है।

## बाइनरी सर्च का मूल विचार

बाइनरी सर्च का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक तुलना में, मध्य बिंदु तत्व के आकार की तुलना लक्ष्य मान से करें। यदि मध्य बिंदु तत्व शर्त को पूरा नहीं करता है, तो आप आधे अंतराल को खत्म कर सकते हैं; अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग त्याग दिया जाता है, खोज की समय जटिलता $O(\log n)$ तक पहुंच सकती है।

उन समस्याओं के लिए जहां " **व्यवहार्य समाधान को एक क्रमबद्ध अंतराल (शर्त को पूरा करना) और दूसरे क्रमबद्ध अंतराल (शर्त को पूरा नहीं करना) में विभाजित किया जा सकता है**", बाइनरी सर्च बहुत उपयोगी है। उदाहरण के लिए:

- यह जानने के लिए कि क्या किसी क्रमबद्ध सरणी में कोई विशेष तत्व मौजूद है।
- किसी संख्या का "पहला स्थान" या "अंतिम स्थान" ज्ञात करना।

## उदाहरण समस्या: किसी तत्व की प्रारंभिक और अंतिम स्थिति खोजना

**समस्या विवरण:**
एक लंबाई $n$ की पूर्णांक सरणी दी गई है, जिसे आरोही क्रम में क्रमबद्ध किया गया है, साथ ही $q$ प्रश्न भी दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ का "प्रारंभिक स्थान" और "अंतिम स्थान" (अनुक्रमणिका 0 से शुरू होती है) ज्ञात करने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो $-1$ $-1$ लौटाएं।

**इनपुट प्रारूप:**

1. पहली पंक्ति: दो पूर्णांक $n$ और $q$, जो क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं।
2. दूसरी पंक्ति: $n$ पूर्णांक (1 ~ 10000 की सीमा में), जो पूर्ण सरणी का प्रतिनिधित्व करते हैं, और पहले से ही आरोही क्रम में क्रमबद्ध हैं।
3. अगले $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व को दर्शाता है।

**आउटपुट प्रारूप:**
प्रत्येक प्रश्न के लिए, उसी पंक्ति में सरणी में तत्व की प्रारंभिक और अंतिम स्थिति आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो $-1$ $-1$ आउटपुट करें।

**नमूना:**

```
इनपुट:
6 3
1 2 2 3 3 4
3
4
5

आउटपुट:
3 4
5 5
-1 -1
```

स्पष्टीकरण:

- तत्व 3 की सीमा `[3, 4]` है;
- तत्व 4 केवल एक बार दिखाई देता है, स्थिति 5 पर;
- तत्व 5 सरणी में मौजूद नहीं है, इसलिए `-1 -1` लौटाएं।

## बाइनरी सर्च के लिए अनुप्रयोग विचार

इस समस्या में, किसी मान की "बाईं सीमा" और "दाईं सीमा" ज्ञात करने के लिए, हम बाइनरी सर्च पर निर्भर हो सकते हैं। महत्वपूर्ण बात यह है कि खोज अंतराल को कैसे परिभाषित किया जाए, और तुलना परिणाम के आधार पर पॉइंटर्स को कैसे स्थानांतरित किया जाए, इसे समझना।

- **"बाईं सीमा" ज्ञात करना:**
  अर्थात, $k$ से पहले स्थित पहले सबसे बड़े या $k$ के बराबर स्थान को खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "छोटी" हैं।
    - दाईं ओर की सभी संख्याएँ $k$ से "बड़ी या बराबर" हैं।

- **"दाईं सीमा" ज्ञात करना:**
  अर्थात, $k$ से पहले स्थित अंतिम सबसे छोटे या $k$ के बराबर स्थान को खोजें। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "छोटी या बराबर" हैं।
    - दाईं ओर की सभी संख्याएँ $k$ से "बड़ी" हैं।

जब तक आप इन दो अंतरालों को सही ढंग से बनाए रख सकते हैं, तब तक आप बाइनरी सर्च के माध्यम से जल्दी से परिणाम प्राप्त कर सकते हैं।

## अनुशंसित टेम्पलेट: मृत लूप से बचने के लिए बाइनरी लेखन

यहां एक सुरुचिपूर्ण और गैर-गलती-प्रवण बाइनरी टेम्पलेट है। यह $l$ और $r$ को धीरे-धीरे एक-दूसरे के करीब लाने से, यह सुनिश्चित करता है कि लूप हमेशा दोनों के आसन्न होने पर समाप्त होता है:

दो पॉइंटर्स $l$, $r$ को परिभाषित करें, एक अपरिवर्तनीय के साथ: बंद अंतराल $[0, l]$ सभी बाईं ओर के भाग से संबंधित है, और बंद अंतराल $[r, n - 1]$ सभी दाईं ओर के भाग से संबंधित है। $l$ और $r$ दोनों को $-1$ और $n$ पर इनिशियलाइज़ किया गया है।

एल्गोरिथम के समाप्त होने पर, $l$ और $r$ आसन्न होते हैं, जो क्रमशः बाईं ओर के अधिकतम मान और दाईं ओर के न्यूनतम मान को इंगित करते हैं।

चूंकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए $l$ या $r$ लौटाते समय, हमें यह जांचने की आवश्यकता होती है कि संबंधित मान वह मान है जो हम चाहते हैं, और यह आउट ऑफ़ बाउंड है या नहीं।
उदाहरण के लिए, $l$ $\leq k$ के अधिकतम मान को दर्शाता है, और हमें `l != -1 && nums[l] == k` की जांच करने की आवश्यकता है

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k की शुरुआती स्थिति (बाईं सीमा) खोजें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सभी < k हैं, और दाईं ओर सभी >= k हैं।
        //    बाईं सीमा दाईं ओर के भाग का न्यूनतम अनुक्रमणिका है।
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // यदि r सीमा से बाहर है या nums[r] != k है, तो इसका मतलब है कि k मौजूद नहीं है।
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r; // k की बाईं सीमा रिकॉर्ड करें

        // 2. k की समाप्ति स्थिति (दाईं सीमा) खोजें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सभी <= k हैं, और दाईं ओर सभी > k हैं।
        //    दाईं सीमा बाईं ओर के भाग का अधिकतम अनुक्रमणिका है।
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        // चूंकि हमने पहले ही सत्यापित कर लिया है कि k मौजूद है, इसलिए यहां फिर से सत्यापित करने की कोई आवश्यकता नहीं है।
        int rightPos = l; // दाईं सीमा
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### इस तरह लिखने में गलती करना इतना मुश्किल क्यों है?

1. इस लेखन में अपरिवर्तनीय की एक सख्त परिभाषा है।
2. यह बाईं सीमा और दाईं सीमा दोनों को खोज सकता है, और सभी परिदृश्यों पर लागू किया जा सकता है।
3. कुछ लेखन $l == r$ को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ 1 से भिन्न होते हैं, तो $mid$ और `l` या `r` समान होने की गणना की जाएगी। यदि इसे सही ढंग से संभाला नहीं जाता है, तो `l` या `r` को `mid` पर अपडेट करने से खोज अंतराल कम नहीं होगा, जिससे एक डेड लूप हो जाएगा। इसके विपरीत, यहाँ का लेखन $l$ और $r$ के आसन्न होने पर समाप्त होता है, इस समस्या से बचाता है।

## STL समाधान: `lower_bound` और `upper_bound`

यदि आप C++ STL द्वारा प्रदान किए गए `lower_bound` और `upper_bound` फ़ंक्शन का उपयोग करते हैं, तो आप आसानी से उसी काम को पूरा कर सकते हैं:

- `lower_bound(first, last, val)` "मान के पहले से बड़े या बराबर स्थान" को लौटाएगा।
- `upper_bound(first, last, val)` "मान से पहले बड़े स्थान" को लौटाएगा।

एक उदाहरण के रूप में, मान लें कि `nums = {1,2,3,4,4,4,4,4,5,5,6}`, और हम जानना चाहते हैं कि 4 का अंतराल कहाँ है:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    // इसका मतलब है कि सरणी में 4 मौजूद नहीं है
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` पहले मान से बड़े या 4 के बराबर स्थान को इंगित करता है।
- `it2` पहले मान से बड़े 4 के स्थान को इंगित करता है।
   इसलिए `it2 - it1` सरणी में 4 की संख्या है; `it2 - nums.begin() - 1` 4 की दाईं सीमा है।

ये दोनों फ़ंक्शन किसी अंतराल की खोज करते समय या होने की संख्या की गणना करते समय विशेष रूप से सुविधाजनक हैं।

## पूरक

बाइनरी सर्च को फ्लोटिंग-पॉइंट नंबर की सीमा में खोज (जैसे समीकरणों की जड़ों को खोजना), और एकल-शिखर फ़ंक्शन के अधिकतम मान के लिए त्रि-बिंदु खोज तक भी बढ़ाया जा सकता है। जब तक आप " **एक क्रमबद्ध अंतराल में, प्रत्येक बार आप आधे हिस्से को समाप्त कर सकते हैं**" के इस मूल सिद्धांत को समझते हैं, तो आप पाएंगे कि बाइनरी सर्च कई परिदृश्यों में समस्याओं को कुशलतापूर्वक हल करने में आपकी मदद कर सकता है।

## कक्षा के बाद अभ्यास

LeetCode 33. घुमाई हुई क्रमबद्ध सरणी में खोजें

संकेत: पहले चरण में रोटेशन बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग करें, और दूसरे चरण में लक्ष्य मान को खोजने के लिए बाइनरी सर्च का उपयोग करें।