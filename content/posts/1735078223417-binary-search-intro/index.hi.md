---
title: "द्विआधारी खोज"
date: 2024-12-24
draft: false
description: "द्विआधारी खोज एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।"
summary: "द्विआधारी खोज एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।"
tags: [ "एल्गोरिथम", "द्विआधारी खोज", "एल्गोरिथम टेम्पलेट" ]
categories: [ "एल्गोरिथम और डेटा संरचना" ]
---

यदि क्रमित समाधान स्थान को दो भागों में विभाजित किया जाता है, जहाँ एक भाग शर्त को पूरा करता है और दूसरा भाग शर्त को पूरा नहीं करता है, तो क्रमित समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग किया जा सकता है।

द्विआधारी खोज का मूल विचार खोज अंतराल को लगातार आधा करना है। प्रत्येक जाँच में मध्य बिंदु तत्व की जाँच करें, यदि मध्य बिंदु तत्व शर्त को पूरा नहीं करता है, तो आधे अंतराल को समाप्त किया जा सकता है; अन्यथा, दूसरे आधे अंतराल में खोज जारी रखें। चूँकि प्रत्येक बार खोज अंतराल का आधा भाग छोड़ दिया जाता है, इसलिए खोज समय जटिलता $O(\log n)$ तक पहुँच सकती है।

## उदाहरण समस्या

https://www.acwing.com/problem/content/791

**समस्या विवरण:**
एक आरोही क्रम में व्यवस्थित लंबाई $n$ की पूर्णांक सरणी दी गई है, साथ ही $q$ प्रश्न भी दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, हमें सरणी में $k$ की "प्रारंभिक स्थिति" और "अंतिम स्थिति" (सूचकांक 0 से शुरू) ज्ञात करने की आवश्यकता है। यदि सरणी में यह संख्या मौजूद नहीं है, तो `-1 -1` लौटाएँ।

### इनपुट प्रारूप

1. पहली पंक्ति: दो पूर्णांक $n$ और $q$, क्रमशः सरणी की लंबाई और प्रश्नों की संख्या दर्शाते हैं।
2. दूसरी पंक्ति: $n$ पूर्णांक, पूरी सरणी को दर्शाते हैं, जो आरोही क्रम में व्यवस्थित है।
3. अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व को दर्शाता है।

## डेटा सीमा

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### आउटपुट प्रारूप

प्रत्येक प्रश्न के लिए, सरणी में तत्व की प्रारंभिक और अंतिम स्थिति को एक पंक्ति में आउटपुट करें। यदि सरणी में तत्व मौजूद नहीं है, तो `-1 -1` आउटपुट करें।

**नमूना:**

```
इनपुट:
6 3
1 2 2 3 3 4
3
4
5

आउटपुट:
3 4
5 5
-1 -1
```

**स्पष्टीकरण:**

- तत्व $3$ की सीमा $[3, 4]$ है;
- तत्व $4$ केवल एक बार स्थिति $5$ पर दिखाई देता है;
- तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ।

---

## समाधान

- **"प्रारंभिक स्थिति" ज्ञात करना:**
  अर्थात, $k$ से पहले या उसके बराबर पहला स्थान ज्ञात करना। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "कम" हैं
    - दाईं ओर की सभी संख्याएँ $k$ से "अधिक या बराबर" हैं
    - उत्तर दाईं ओर का पहला स्थान है

- **"अंतिम स्थिति" ज्ञात करना:**
  अर्थात, $k$ से पहले या उसके बराबर अंतिम स्थान ज्ञात करना। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "कम या बराबर" हैं
    - दाईं ओर की सभी संख्याएँ $k$ से "अधिक" हैं
    - उत्तर बाईं ओर का अंतिम स्थान है

---

## अनुशंसित टेम्पलेट

नीचे एक सुरुचिपूर्ण और त्रुटि-मुक्त द्विआधारी टेम्पलेट दिया गया है।

दो पॉइंटर्स $l, r$ को परिभाषित करें, जिसमें अपरिवर्तनीय है: बंद अंतराल $[0, l]$ बाईं ओर के भाग से संबंधित है, बंद अंतराल $[r, n - 1]$ दाईं ओर के भाग से संबंधित है। $l$ और $r$ दोनों को $-1$ और $n$ के रूप में इनिशियलाइज़ किया गया है।

जब एल्गोरिथम समाप्त होता है, तो $l$ और $r$ आसन्न होते हैं, क्रमशः बाईं ओर के भाग के अंतिम तत्व और दाईं ओर के भाग के पहले तत्व की ओर इशारा करते हैं।

चूँकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, इसलिए यदि समस्या में यह नहीं बताया गया है कि एक समाधान निश्चित रूप से मौजूद है, तो हमें यह जाँचने की आवश्यकता है कि क्या `l` या `r` सीमा से बाहर है, क्या यह सही मान की ओर इशारा करता है।

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k की प्रारंभिक स्थिति ज्ञात करें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सभी < k, दाईं ओर सभी >= k।
        //    उत्तर दाईं ओर के भाग का न्यूनतम सूचकांक है।
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k की अंतिम स्थिति ज्ञात करें
        //    सरणी को दो भागों में विभाजित करें, बाईं ओर सभी <= k, दाईं ओर सभी > k।
        //    उत्तर बाईं ओर के भाग का अधिकतम सूचकांक है।
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }

    return 0;
}
```

### लाभ

1. इस लेखन में अपरिवर्तनीय की सख्त परिभाषा है।
2. यह "प्रारंभिक स्थिति" और "अंतिम स्थिति" दोनों स्थितियों को खोजने के लिए उपयुक्त है, इसके लिए अतिरिक्त प्रसंस्करण और परिवर्तन की आवश्यकता नहीं है।
3. कुछ लेखन `l == r` को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो यह $mid$ और $l$ या $r$ के बराबर की गणना करेगा। यदि सही ढंग से संसाधित नहीं किया जाता है, तो $l$ या $r$ को $mid$ में अपडेट करने से, खोज अंतराल कम नहीं होता है, जिससे एक अनंत लूप हो जाएगा। इसके विपरीत, यहाँ का लेखन $l$ और $r$ के आसन्न होने पर समाप्त होता है, यह सुनिश्चित करता है कि $mid$ $l$ से छोटा है और $r$ से बड़ा है, $l$ या $r$ को अपडेट करते समय खोज अंतराल निश्चित रूप से कम हो जाएगा।

---

## STL

यदि C++ STL द्वारा प्रदान किए गए `lower_bound` और `upper_bound` फ़ंक्शंस का उपयोग किया जाता है, तो वही काम पूरा किया जा सकता है:

- `lower_bound(first, last, val)` "val से पहले या उसके बराबर पहले स्थान" को लौटाएगा
- `upper_bound(first, last, val)` "val से पहले पहले स्थान" को लौटाएगा

उदाहरण के लिए, मान लीजिए `nums = {1,2,3,4,4,4,4,4,5,5,6}`, हम जानना चाहते हैं कि 4 किस अंतराल में दिखाई देता है:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` पहले मान की ओर इशारा करता है जो $4$ से पहले या उसके बराबर है।
- `it2` पहले मान की ओर इशारा करता है जो $4$ से अधिक है।
  इसलिए `it2 - it1` सरणी में $4$ की संख्या है; `it2 - nums.begin() - 1` $4$ की दाहिनी सीमा की स्थिति है।

---

## पूरक

द्विआधारी खोज को फ़्लोटिंग-पॉइंट संख्या सीमा (जैसे समीकरणों की जड़ों को खोजना) और एकल-शिखर फ़ंक्शन के अधिकतम मान को खोजने के लिए त्रि-आयामी खोज तक भी बढ़ाया जा सकता है।

---

## अभ्यास

LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें

संकेत: पहला चरण रोटेशन बिंदु को खोजने के लिए द्विआधारी खोज का उपयोग करना है, और दूसरा चरण लक्ष्य मान को खोजने के लिए द्विआधारी खोज का उपयोग करना है।