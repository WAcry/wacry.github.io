---
title: "बाइनरी सर्च"
date: 2024-12-24
draft: false
description: "बाइनरी सर्च एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।"
summary: "बाइनरी सर्च एल्गोरिथम को सुरुचिपूर्ण ढंग से कैसे लागू करें।"
tags: [ "एल्गोरिथम", "बाइनरी सर्च", "एल्गोरिथम टेम्पलेट" ]
categories: [ "एल्गोरिथम और डेटा संरचनाएं" ]
---

यदि किसी क्रमित समाधान स्थान को दो भागों में विभाजित किया जाता है, जहाँ एक भाग एक शर्त को संतुष्ट करता है और दूसरा नहीं, तो क्रमित समाधान स्थान में महत्वपूर्ण बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग किया जा सकता है।

बाइनरी सर्च का मूल विचार खोज अंतराल को बार-बार आधा करना है। प्रत्येक बार, मध्य तत्व की जाँच की जाती है। यदि मध्य तत्व शर्त को संतुष्ट नहीं करता है, तो अंतराल का आधा भाग समाप्त किया जा सकता है; अन्यथा, खोज दूसरे आधे भाग में जारी रहती है। चूंकि प्रत्येक बार खोज अंतराल का आधा भाग छोड़ दिया जाता है, इसलिए खोज समय जटिलता $O(\log n)$ तक पहुँच सकती है।

## उदाहरण समस्या

**समस्या विवरण:**
$n$ लंबाई की एक आरोही क्रम में सॉर्ट की गई पूर्णांक सरणी दी गई है, और $q$ प्रश्न दिए गए हैं। प्रत्येक प्रश्न एक पूर्णांक $k$ देता है, और हमें सरणी में $k$ की "शुरुआती स्थिति" और "अंतिम स्थिति" (सूचकांक 0 से शुरू होते हैं) खोजने की आवश्यकता है। यदि संख्या सरणी में मौजूद नहीं है, तो `-1 -1` लौटाएँ।

### इनपुट प्रारूप

1. पहली पंक्ति: दो पूर्णांक $n$ और $q$, क्रमशः सरणी की लंबाई और प्रश्नों की संख्या का प्रतिनिधित्व करते हैं।
2. दूसरी पंक्ति: $n$ पूर्णांक, पूरी सरणी का प्रतिनिधित्व करते हैं, जो पहले से ही आरोही क्रम में सॉर्ट की गई है।
3. अगली $q$ पंक्तियाँ: प्रत्येक पंक्ति में एक पूर्णांक $k$ होता है, जो एक प्रश्न तत्व का प्रतिनिधित्व करता है।

## डेटा रेंज

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### आउटपुट प्रारूप

प्रत्येक प्रश्न के लिए, सरणी में तत्व की शुरुआती और अंतिम स्थिति को एक ही पंक्ति में आउटपुट करें। यदि तत्व सरणी में मौजूद नहीं है, तो `-1 -1` आउटपुट करें।

**उदाहरण:**

```
इनपुट:
6 3
1 2 2 3 3 4
3
4
5

आउटपुट:
3 4
5 5
-1 -1
```

**स्पष्टीकरण:**

- वह सीमा जहाँ तत्व $3$ दिखाई देता है, $[3, 4]$ है;
- तत्व $4$ केवल एक बार, स्थिति $5$ पर दिखाई देता है;
- तत्व $5$ सरणी में मौजूद नहीं है, इसलिए $-1$ $-1$ लौटाएँ।

---

## समाधान

- **"शुरुआती स्थिति" खोजना:**
  अर्थात, पहली स्थिति खोजना जो $k$ से अधिक या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "कम" हैं
    - दाईं ओर की सभी संख्याएँ $k$ से "अधिक या बराबर" हैं
    - उत्तर दाईं ओर की पहली स्थिति है

- **"अंतिम स्थिति" खोजना:**
  अर्थात, अंतिम स्थिति खोजना जो $k$ से कम या उसके बराबर हो। सरणी को दो भागों में विभाजित किया जा सकता है:
    - बाईं ओर की सभी संख्याएँ $k$ से "कम या बराबर" हैं
    - दाईं ओर की सभी संख्याएँ $k$ से "अधिक" हैं
    - उत्तर बाईं ओर की अंतिम स्थिति है

---

## अनुशंसित टेम्पलेट

नीचे एक सुरुचिपूर्ण और कम त्रुटि-प्रवण बाइनरी सर्च टेम्पलेट दिया गया है।

दो पॉइंटर्स $l, r$ को परिभाषित करें, जिसमें अपरिवर्तनीय है: बंद अंतराल $[0, l]$ बाएं भाग से संबंधित है, और बंद अंतराल $[r, n - 1]$ दाएं भाग से संबंधित है। $l$ और $r$ को क्रमशः $-1$ और $n$ पर इनिशियलाइज़ किया गया है।

जब एल्गोरिथम समाप्त हो जाता है, तो $l$ और $r$ आसन्न होते हैं, जो क्रमशः बाएं भाग के अंतिम तत्व और दाएं भाग के पहले तत्व की ओर इशारा करते हैं।

क्योंकि हम जो समाधान चाहते हैं वह मौजूद नहीं हो सकता है, यदि समस्या यह नहीं बताती है कि एक समाधान निश्चित रूप से मौजूद है, तो हमें यह जांचने की आवश्यकता है कि क्या `l` या `r` सीमा से बाहर है और क्या यह सही मान की ओर इशारा करता है।

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k की शुरुआती स्थिति ज्ञात करें
        //    सरणी को दो भागों में विभाजित करें, बायां भाग सभी < k है, और दायां भाग सभी >= k है।
        //    उत्तर दाएं भाग का सबसे छोटा सूचकांक है।
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // यदि r सीमा से बाहर है या nums[r] != k, तो इसका मतलब है कि k मौजूद नहीं है
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k की अंतिम स्थिति ज्ञात करें
        //    सरणी को दो भागों में विभाजित करें, बायां भाग सभी <= k है, और दायां भाग सभी > k है।
        //    उत्तर बाएं भाग का सबसे बड़ा सूचकांक है।
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### फायदे

1. इस दृष्टिकोण में सख्ती से परिभाषित अपरिवर्तनीय हैं।
2. यह अतिरिक्त हैंडलिंग या परिवर्तनों के बिना "शुरुआती स्थिति" और "अंतिम स्थिति" दोनों को खोजने पर लागू होता है।
3. कुछ दृष्टिकोण `l == r` को समाप्ति शर्त के रूप में उपयोग करते हैं। जब $l$ और $r$ में $1$ का अंतर होता है, तो $mid$ की गणना $l$ या $r$ के बराबर होने के लिए की जाएगी। यदि सही ढंग से हैंडल नहीं किया जाता है, तो $l$ या $r$ को $mid$ में अपडेट करने से खोज अंतराल कम नहीं होगा, जिससे एक अनंत लूप हो जाएगा। इसके विपरीत, यह दृष्टिकोण तब समाप्त होता है जब $l$ और $r$ आसन्न होते हैं, यह सुनिश्चित करते हुए कि $mid$ $l$ से कम और $r$ से अधिक है, और $l$ या $r$ को अपडेट करने से हमेशा खोज अंतराल कम हो जाएगा।

---

## STL

यदि आप C++ STL द्वारा प्रदान किए गए `lower_bound` और `upper_bound` फ़ंक्शंस का उपयोग करते हैं, तो आप वही चीज़ प्राप्त कर सकते हैं:

- `lower_bound(first, last, val)` "पहली स्थिति लौटाएगा जो val से अधिक या उसके बराबर है"
- `upper_bound(first, last, val)` "पहली स्थिति लौटाएगा जो val से अधिक है"

उदाहरण के लिए, मान लीजिए `nums = {1,2,3,4,4,4,4,4,5,5,6}`, और हम वह सीमा जानना चाहते हैं जहाँ 4 दिखाई देता है:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 0 बार दिखाई देता है" << endl;
} else {
    cout << "पहला 4 " << it1 - nums.begin() << " पर है" << endl;
    cout << "अंतिम 4 " << it2 - nums.begin() - 1 << " पर है" << endl;
    cout << "4 " << it2 - it1 << " बार दिखाई देता है" << endl;
}
```

- `it1` उस पहली स्थिति की ओर इशारा करता है जहाँ मान $4$ से अधिक या उसके बराबर है।
- `it2` उस पहली स्थिति की ओर इशारा करता है जहाँ मान $4$ से अधिक है।
  इसलिए, `it2 - it1` सरणी में $4$ के दिखाई देने की संख्या है; `it2 - nums.begin() - 1` $4$ की दाईं सीमा की स्थिति है।

---

## अतिरिक्त नोट्स

बाइनरी सर्च को फ्लोटिंग-पॉइंट रेंज में खोजने के लिए भी बढ़ाया जा सकता है (जैसे किसी समीकरण की जड़ें खोजना) और यूनिमोडल फ़ंक्शंस के एक्सट्रीमा को खोजने के लिए टर्नरी सर्च।

---

## अभ्यास

LeetCode 33. रोटेटेड सॉर्टेड ऐरे में खोजें

संकेत: सबसे पहले, रोटेशन बिंदु को खोजने के लिए बाइनरी सर्च का उपयोग करें, और फिर लक्ष्य मान को खोजने के लिए बाइनरी सर्च का उपयोग करें।