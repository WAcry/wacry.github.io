---
title: "二分搜索"
date: 2024-12-24
draft: false
description: "如何优雅地实现二分搜索算法。"
summary: "如何优雅地实现二分搜索算法。"
tags: [ "算法", "二分搜索", "分治算法" ]
---

如果有序解空间被分成左右两部分，其中一个部分满足条件，另一个部分不满足条件。那么能够使用二分搜索来在有序解空间中查找临界点。

二分搜索的基本思路是不断地将搜索区间对半分。每次检查中点元素，如果中点元素不满足条件，就可以排除一半区间；
反之，则在另一半区间继续搜索。由于每次都抛弃一半的搜索区间，搜索时间复杂度可达到 $O(\log n)$。

## 例题

https://www.acwing.com/problem/content/791

**题目描述：**  
给定一个升序排列的长度为 $n$ 的整数数组，还有 $q$ 个查询。每个查询给出一个整数 $k$，我们需要找出在数组中 $
k$ 的「起始位置」和「终止位置」（下标从 0 开始）。如果数组中不存在这个数，则返回 `-1 -1`。

### 输入格式

1. 第一行：两个整数 $n$ 和 $q$，分别表示数组长度和查询次数。
2. 第二行：$n$ 个整数，表示完整数组，已按升序排列。
3. 接下来 $q$ 行：每行包含一个整数 $k$，表示一个查询元素。

## 数据范围

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 输出格式

对每个查询，在一行里输出该元素在数组中的起始和结束位置。如果数组中不存在该元素，则输出 `-1 -1`。

**样例：**

```
输入：
6 3
1 2 2 3 3 4
3
4
5

输出：
3 4
5 5
-1 -1
```

**解释：**

- 元素 $3$ 出现的范围为 $[3, 4]$；
- 元素 $4$ 只出现了一次，在位置 $5$；
- 元素 $5$ 在数组里不存在，因此返回 $-1$ $-1$。

---

## 解答

- **找「起始位置」：**
  即找第一个大于等于 $k$ 的位置。可以把数组分成两部分：
    - 左边所有数都「小于」 $k$
    - 右边所有数都「大于等于」 $k$
    - 答案为右边的第一个位置

- **找「终止位置」：**
  即找最后一个小于等于 $k$ 的位置。可以把数组分成两部分：
    - 左边所有数都「小于等于」 $k$
    - 右边所有数都「大于」 $k$
    - 答案为左边的最后一个位置

---

## 推荐模板

下面是一种优雅且不易犯错的二分模板。

定义两个指针 $l, r$，有不变量：闭区间 $[0, l]$ 都属于左半部分，闭区间 $[r, n - 1]$ 都属于右半部分。$l$
和 $r$ 都初始化为 $-1$ 和 $n$。

算法终止时，$l$ 和 $r$ 相邻，分别指向左半部分的最后一个元素和右半部分的第一个元素。

因为我们想要的解可能不存在，所以如果题目没有说明一定存在解，我们需要判断一下 `l` 或 `r` 是否越界，是否指向正确的值。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. 找 k 的起始位置
        //    将数组分成两部分，左边都 < k，右边都 >= k。
        //    答案为右半部分的最小下标。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // 如果 r 越界或者 nums[r] != k，说明不存在 k
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. 找 k 的终止位置
        //    将数组分成两部分，左边都 <= k，右边都 > k。
        //    答案为左半部分的最大下标。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }

    return 0;
}
```

### 优势

1. 这个写法有严格定义的不变量。
2. 它同时适用于找「起始位置」和「终止位置」两种情况，不需要额外的处理和变化。
3. 有一些写法使用 `l == r` 作为终止条件。当 $l$ 和 $r$ 相差 $1$ 时，会计算出 $mid$ 和 $l$ 或 $r$
   相等。如果没有正确处理，更新 $l$ 或 $r$ 为 $mid$，搜索区间没有缩小，会导致死循环。相反地，这里的写法在 $l$
   和 $r$ 相邻时终止，保证 $mid$ 小于 $l$ 且大于 $r$，更新 $l$ 或 $r$ 时搜索区间一定会缩小。

---

## STL

如果使用 C++ STL 提供的 `lower_bound` 和 `upper_bound` 函数，也能完成同样的事情：

- `lower_bound(first, last, val)` 会返回「第一个大于等于 val 的位置」
- `upper_bound(first, last, val)` 会返回「第一个大于 val 的位置」

举个例子，假设 `nums = {1,2,3,4,4,4,4,4,5,5,6}`，我们想知道 4 出现的区间：

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` 指向第一个值大于等于 $4$ 的位置。
- `it2` 指向第一个值大于 $4$ 的位置。  
  所以 `it2 - it1` 就是 $4$ 在数组中出现的次数；`it2 - nums.begin() - 1` 就是 $4$ 的右边界的位置。

---

## 补充

二分搜索还可以扩展到浮点数范围的搜索（如求方程根）、以及三分搜索求单峰函数的最值。

---

## 练习

LeetCode 33. Search in Rotated Sorted Array

提示：第一步使用二分搜索找到旋转点，第二步再使用二分搜索找到目标值。