---
title: "二分搜索"
date: 2024-12-24
draft: false
description: "如何优雅地实现整数二分搜索算法"
summary: "如何优雅地实现整数二分搜索算法"
tags: [ "算法", "二分搜索", "算法模板" ]
categories: [ "算法与数据结构" ]
---
{{< katex >}}

# 二分搜索

在一个有序序列中寻找特定元素，可以用二分搜索来快速完成。与线性搜索的时间复杂度 $O(n)$ 相比，二分搜索只需要 $O(\log n)$
的时间，因此在数据规模较大的情况下非常高效。

## 二分搜索的核心思想

二分搜索的基本思路是不断地将搜索区间对半分。每次比较中点元素与目标值的大小，如果中点元素不满足条件，就可以排除一半区间；反之，则在另一半区间继续搜索。由于每次都抛弃一半的搜索区间，搜索时间复杂度可达到 $O(\log n)$。

对「**可行解可以被分为一个有序区间（满足条件）和另一个有序区间（不满足条件）**」的问题，二分搜索是非常好用的。比如：

- 在有序数组中找是否存在某个元素
- 找到某个数出现的「第一位置」或「最后位置」

## 例题：找元素的起始位置和终止位置

**题目描述：**  
给定一个升序排列的长度为 $n$ 的整数数组，还有 $q$ 个查询。每个查询给出一个整数 $k$，我们需要找出在数组中 $k$
的「起始位置」和「终止位置」（下标从 0 开始）。如果数组中不存在这个数，则返回 $-1$ $-1$。

**输入格式：**

1. 第一行：两个整数 $n$ 和 $q$，分别表示数组长度和查询次数。
2. 第二行：$n$ 个整数（1 ~ 10000 范围内），表示完整数组，已按升序排列。
3. 接下来 $q$ 行：每行包含一个整数 $k$，表示一个查询元素。

**输出格式：**  
对每个查询，在一行里输出该元素在数组中的起始和结束位置。如果数组中不存在该元素，则输出 $-1$ $-1$。

**样例：**

```
输入：
6 3
1 2 2 3 3 4
3
4
5

输出：
3 4
5 5
-1 -1
```

解释：

- 元素 3 出现的范围为 `[3, 4]`；
- 元素 4 只出现了一次，在位置 5；
- 元素 5 在数组里不存在，因此返回 `-1 -1`。

## 二分搜索的应用思路

在这个问题中，为了找到某个值的「左边界」和「右边界」，我们都可以依赖二分搜索。关键是理解如何定义搜索区间，以及如何根据比较结果来移动指针。

- **找「左边界」：**  
  即找第一个大于等于 $k$ 的位置。可以把数组分成两部分：
    - 左边所有数都「小于」 $k$
    - 右边所有数都「大于等于」 $k$

- **找「右边界」：**  
  即找最后一个小于等于 $k$ 的位置。可以把数组分成两部分：
    - 左边所有数都「小于等于」 $k$
    - 右边所有数都「大于」 $k$

只要能正确维护这两种区间，就能通过二分快速得出结果。

## 推荐模板：避免死循环的二分写法

下面是一种优雅且不易犯错的二分模板。它通过让 $l$ 和 $r$ 逐步靠拢，保证循环一定在两者相邻时结束：

定义两个指针 $l, r$，有不变量：闭区间 $[0, l]$ 都属于左半部分，闭区间 $[r, n - 1]$ 都属于右半部分。$l$ 和 $r$
都初始化为 $-1$ 和 $n$。

算法终止时，$l$ 和 $r$ 相邻，分别指向左半部分的最大值和右半部分的最小值。

因为我们想要的解可能不存在，所以返回 $l$ 或者 $r$ 时，需要检验对应的值是否是我们想要的值，是否越界。
比如，$l$ 表示 $\leq k$ 的最大值，而我们需要检验 `l != -1 && nums[l] == k`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. 找 k 的起始位置（左边界）
        //    将数组分成两部分，左边都 < k，右边都 >= k。
        //    左边界就是右边那部分的最小下标。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // 如果 r 超界或者 nums[r] != k，说明不存在 k
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r; // 记录 k 的左边界

        // 2. 找 k 的终止位置（右边界）
        //    将数组分成两部分，左边都 <= k，右边都 > k。
        //    右边界就是左边那部分的最大下标。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        // 因为我们已经检验过 k 存在，这里不需要再次检验
        int rightPos = l; // 右边界
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### 为什么这样写不容易错？

1. 这个写法有严格定义的不变量。
2. 它既能找到左边界，又能找到右边界，可以适用于所有场景。
3. 有一些写法使用 $l == r$ 作为终止条件。当 $l$ 和 $r$ 相差 1 时，会计算出 $mid$ 和 `l` 或 `r` 相等。如果没有正确处理，更新
   `l` 或 `r` 为 `mid`，搜索区间没有缩小，会导致死循环。相反地，这里的写法在 $l$ 和 $r$ 相邻时终止，避免了这个问题。

## STL 解法：`lower_bound` 和 `upper_bound`

如果使用 C++ STL 提供的 `lower_bound` 和 `upper_bound` 函数，也能轻松完成同样的事情：

- `lower_bound(first, last, val)` 会返回「第一个大于等于 val 的位置」
- `upper_bound(first, last, val)` 会返回「第一个大于 val 的位置」

举个例子，假设 `nums = {1,2,3,4,4,4,4,4,5,5,6}`，我们想知道 4 出现的区间：

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    // 说明数组里不存在 4
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` 指向第一个值大于等于 4 的位置。
- `it2` 指向第一个值大于 4 的位置。  
  所以 `it2 - it1` 就是 4 在数组中出现的次数；`it2 - nums.begin() - 1` 就是 4 的右边界。

这两个函数在查找区间或统计出现次数的时候尤其方便。

## 补充

二分搜索还可以扩展到浮点数范围的搜索（如求方程根）、以及三分搜索求单峰函数的最值。只要你理解了「**在有序区间中，每次都能排除一半
**」这一核心原理，你就会发现二分搜索能帮你在很多场景下高效解决问题。

## 课后练习

LeetCode 33. Search in Rotated Sorted Array

提示：第一步使用二分搜索找到旋转点，第二步再使用二分搜索找到目标值。