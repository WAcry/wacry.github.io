---
title: "二分搜尋"
date: 2024-12-24
draft: false
description: "如何優雅地實現整數二分搜尋演算法"
summary: "如何優雅地實現整數二分搜尋演算法"
tags: [ "演算法", "二分搜尋", "演算法模板" ]
categories: [ "演算法與資料結構" ]
---
{{< katex >}}

# 二分搜尋

在一個有序序列中尋找特定元素，可以用二分搜尋來快速完成。與線性搜尋的時間複雜度 $O(n)$ 相比，二分搜尋只需要 $O(\log n)$ 的時間，因此在資料規模較大的情況下非常高效。

## 二分搜尋的核心思想

二分搜尋的基本思路是不斷地將搜尋區間對半分。每次比較中點元素與目標值的大小，如果中點元素不滿足條件，就可以排除一半區間；反之，則在另一半區間繼續搜尋。由於每次都拋棄一半的搜尋區間，搜尋時間複雜度可達到 $O(\log n)$。

對「**可行解可以被分為一個有序區間（滿足條件）和另一個有序區間（不滿足條件）**」的問題，二分搜尋是非常好用的。比如：

- 在有序陣列中找是否存在某個元素
- 找到某個數出現的「第一位置」或「最後位置」

## 例題：找元素的起始位置和終止位置

**題目描述：**  
給定一個升序排列的長度為 $n$ 的整數陣列，還有 $q$ 個查詢。每個查詢給出一個整數 $k$，我們需要找出在陣列中 $k$ 的「起始位置」和「終止位置」（下標從 0 開始）。如果陣列中不存在這個數，則返回 $-1$ $-1$。

**輸入格式：**

1. 第一行：兩個整數 $n$ 和 $q$，分別表示陣列長度和查詢次數。
2. 第二行：$n$ 個整數（1 ~ 10000 範圍內），表示完整陣列，已按升序排列。
3. 接下來 $q$ 行：每行包含一個整數 $k$，表示一個查詢元素。

**輸出格式：**  
對每個查詢，在一行裡輸出該元素在陣列中的起始和結束位置。如果陣列中不存在該元素，則輸出 $-1$ $-1$。

**範例：**

```
輸入：
6 3
1 2 2 3 3 4
3
4
5

輸出：
3 4
5 5
-1 -1
```

解釋：

- 元素 3 出現的範圍為 `[3, 4]`；
- 元素 4 只出現了一次，在位置 5；
- 元素 5 在陣列裡不存在，因此返回 `-1 -1`。

## 二分搜尋的應用思路

在這個問題中，為了找到某個值的「左邊界」和「右邊界」，我們都可以依賴二分搜尋。關鍵是理解如何定義搜尋區間，以及如何根據比較結果來移動指標。

- **找「左邊界」：**  
  即找第一個大於等於 $k$ 的位置。可以把陣列分成兩部分：
    - 左邊所有數都「小於」 $k$
    - 右邊所有數都「大於等於」 $k$

- **找「右邊界」：**  
  即找最後一個小於等於 $k$ 的位置。可以把陣列分成兩部分：
    - 左邊所有數都「小於等於」 $k$
    - 右邊所有數都「大於」 $k$

只要能正確維護這兩種區間，就能透過二分快速得出結果。

## 推薦模板：避免死循環的二分寫法

下面是一種優雅且不易犯錯的二分模板。它透過讓 $l$ 和 $r$ 逐步靠攏，保證循環一定在兩者相鄰時結束：

定義兩個指標 $l, r$，有不變量：閉區間 $[0, l]$ 都屬於左半部分，閉區間 $[r, n - 1]$ 都屬於右半部分。$l$ 和 $r$ 都初始化為 $-1$ 和 $n$。

演算法終止時，$l$ 和 $r$ 相鄰，分別指向左半部分的最大值和右半部分的最小值。

因為我們想要的解可能不存在，所以返回 $l$ 或者 $r$ 時，需要檢驗對應的值是否是我們想要的值，是否越界。
比如，$l$ 表示 $\leq k$ 的最大值，而我們需要檢驗 `l != -1 && nums[l] == k`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. 找 k 的起始位置（左邊界）
        //    將陣列分成兩部分，左邊都 < k，右邊都 >= k。
        //    左邊界就是右邊那部分的最小下標。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // 如果 r 超界或者 nums[r] != k，說明不存在 k
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r; // 記錄 k 的左邊界

        // 2. 找 k 的終止位置（右邊界）
        //    將陣列分成兩部分，左邊都 <= k，右邊都 > k。
        //    右邊界就是左邊那部分的最大下標。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        // 因為我們已經檢驗過 k 存在，這裡不需要再次檢驗
        int rightPos = l; // 右邊界
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### 為什麼這樣寫不容易錯？

1. 這個寫法有嚴格定義的不變量。
2. 它既能找到左邊界，又能找到右邊界，可以適用於所有場景。
3. 有一些寫法使用 $l == r$ 作為終止條件。當 $l$ 和 $r$ 相差 1 時，會計算出 $mid$ 和 `l` 或 `r` 相等。如果沒有正確處理，更新 `l` 或 `r` 為 `mid`，搜尋區間沒有縮小，會導致死循環。相反地，這裡的寫法在 $l$ 和 $r$ 相鄰時終止，避免了這個問題。

## STL 解法：`lower_bound` 和 `upper_bound`

如果使用 C++ STL 提供的 `lower_bound` 和 `upper_bound` 函數，也能輕鬆完成同樣的事情：

- `lower_bound(first, last, val)` 會返回「第一個大於等於 val 的位置」
- `upper_bound(first, last, val)` 會返回「第一個大於 val 的位置」

舉個例子，假設 `nums = {1,2,3,4,4,4,4,4,5,5,6}`，我們想知道 4 出現的區間：

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    // 說明陣列裡不存在 4
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` 指向第一個值大於等於 4 的位置。
- `it2` 指向第一個值大於 4 的位置。  
  所以 `it2 - it1` 就是 4 在陣列中出現的次數；`it2 - nums.begin() - 1` 就是 4 的右邊界。

這兩個函數在查找區間或統計出現次數的時候尤其方便。

## 補充

二分搜尋還可以擴展到浮點數範圍的搜尋（如求方程根）、以及三分搜尋求單峰函數的最值。只要你理解了「**在有序區間中，每次都能排除一半
**」這一核心原理，你就會發現二分搜尋能幫你在很多場景下高效解決問題。

## 課後練習

LeetCode 33. Search in Rotated Sorted Array

提示：第一步使用二分搜尋找到旋轉點，第二步再使用二分搜尋找到目標值。