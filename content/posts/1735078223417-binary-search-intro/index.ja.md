---
title: "二分探索"
date: 2024-12-24
draft: false
description: "二分探索アルゴリズムをエレガントに実装する方法。"
summary: "二分探索アルゴリズムをエレガントに実装する方法。"
tags: [ "アルゴリズム", "二分探索", "アルゴリズムテンプレート" ]
categories: [ "アルゴリズムとデータ構造" ]
---

# 二分探索

もし、順序付けられた解空間が左右の二つの部分に分けられ、一方の部分が条件を満たし、もう一方の部分が条件を満たさない場合、二分探索を使用して順序付けられた解空間で臨界点を見つけることができます。

二分探索の基本的な考え方は、探索区間を絶えず半分に分割することです。毎回、中点の要素をチェックし、もし中点の要素が条件を満たさない場合は、区間の半分を排除することができます。そうでない場合は、もう半分の区間で探索を続けます。毎回探索区間の半分を破棄するため、探索時間計算量は $O(\log n)$ に達することができます。

## 例題

**問題の説明：**  
長さ $n$ の昇順にソートされた整数配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内の $k$ の「開始位置」と「終了位置」（インデックスは 0 から始まる）を見つける必要があります。もし配列中にこの数が存在しない場合は、`-1 -1` を返します。

### 入力形式

1. 1行目：2つの整数 $n$ と $q$ が与えられます。それぞれ配列の長さとクエリの回数を表します。
2. 2行目：$n$ 個の整数が与えられます。これは完全な配列を表し、昇順にソートされています。
3. 次の $q$ 行：各行には整数 $k$ が含まれており、これはクエリ要素を表します。

## データ範囲

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 出力形式

各クエリに対し、配列内の要素の開始位置と終了位置を1行に出力します。もし配列中にその要素が存在しない場合は、`-1 -1` を出力します。

**サンプル：**

```
入力：
6 3
1 2 2 3 3 4
3
4
5

出力：
3 4
5 5
-1 -1
```

**解説：**

- 要素 $3$ が出現する範囲は $[3, 4]$ です。
- 要素 $4$ は1度だけ出現し、位置 $5$ にあります。
- 要素 $5$ は配列中に存在しないため、$-1$ $-1$ を返します。

---

## 解答

- **「開始位置」を見つける：**
  これは、最初の $k$ 以上となる位置を見つけることです。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ より「小さい」。
    - 右側のすべての数は $k$ 以上である。
    - 答えは右側の最初の位置です。

- **「終了位置」を見つける：**
  これは、最後の $k$ 以下となる位置を見つけることです。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ 以下である。
    - 右側のすべての数は $k$ より「大きい」。
    - 答えは左側の最後の位置です。

---

## おすすめテンプレート

以下は、エレガントで間違いにくい二分探索のテンプレートです。これは、$l$ と $r$ を徐々に近づけることで、ループが両者の隣接時に必ず終了することを保証します。

2つのポインタ $l, r$ を定義し、不変条件は：閉区間 $[0, l]$ はすべて左側の部分に属し、閉区間 $[r, n - 1]$ はすべて右側の部分に属する。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化します。

アルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左側の最後の要素と右側の最初の要素を指します。

探している解が存在しない可能性があるため、問題に必ず解が存在すると記載されていない場合は、`l` または `r` が範囲外に出ていないか、正しい値を指しているかを確認する必要があります。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k の開始位置を探す
        //    配列を2つの部分に分割し、左側はすべて < k、右側はすべて >= k。
        //    答えは右側の最小インデックス。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // もし r が範囲外か nums[r] != k の場合、k が存在しない
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k の終了位置を探す
        //    配列を2つの部分に分割し、左側はすべて <= k、右側はすべて > k。
        //    答えは左側の最大インデックス。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### この書き方をする理由

1. この書き方には、厳密に定義された不変条件があります。
2. これは、「開始位置」と「終了位置」の両方を求める場合に適用でき、追加の処理や変更は必要ありません。
3. 一部の書き方では、`l == r` を終了条件として使用しています。$l$ と $r$ が $1$ だけ異なる場合、$mid$ が $l$ または $r$ と同じ値になることがあります。もし適切に処理しないと、$l$ または $r$ を $mid$ に更新したときに、検索区間が縮小せず、無限ループにつながる可能性があります。逆に、ここの書き方は、$l$ と $r$ が隣接したときに終了するため、$mid$ が $l$ より小さく $r$ より大きいことを保証し、$l$ または $r$ を更新すると検索区間が必ず縮小します。

---

## STL

もし C++ STL で提供される `lower_bound` と `upper_bound` 関数を使用すると、同じことを実現できます。

- `lower_bound(first, last, val)` は「最初の val 以上の位置」を返します。
- `upper_bound(first, last, val)` は「最初の val より大きい位置」を返します。

例として、もし `nums = {1,2,3,4,4,4,4,4,5,5,6}` で、4 が出現する区間を知りたいとします。

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` は、最初の値が $4$ 以上の位置を指します。
- `it2` は、最初の値が $4$ より大きい位置を指します。
なので、`it2 - it1` は配列中で $4$ が出現する回数であり、 `it2 - nums.begin() - 1` は $4$ の右境界です。

---

## 補足

二分探索は、浮動小数点数の範囲での探索（例えば、方程式の根を求める）や、単峰関数の最大値を求めるための三分探索にも拡張できます。
「**順序付けられた区間内で、毎回半分を排除できる**」というコアな原理を理解すれば、二分探索が多くの場面で効率的に問題を解決できることに気づくでしょう。

---

## 練習

LeetCode 33. Search in Rotated Sorted Array

ヒント：最初に二分探索を使用して回転点を見つけ、次に二分探索を使用して目標値を見つけます。