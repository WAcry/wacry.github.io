---
title: "二分探索"
date: 2024-12-24
draft: false
description: "二分探索アルゴリズムをエレガントに実装する方法。"
summary: "二分探索アルゴリズムをエレガントに実装する方法。"
tags: [ "アルゴリズム", "二分探索", "アルゴリズムテンプレート" ]
categories: [ "アルゴリズムとデータ構造" ]
---

順序付けられた解空間が、ある条件を満たす部分と満たさない部分の2つに分割できる場合、二分探索を使用して、順序付けられた解空間における臨界点を見つけることができます。

二分探索の基本的な考え方は、探索間隔を繰り返し半分にすることです。毎回、中央の要素がチェックされます。中央の要素が条件を満たさない場合、間隔の半分を排除できます。それ以外の場合は、もう半分で探索が続行されます。探索間隔の半分が毎回破棄されるため、探索時間計算量は $O(\log n)$ に達することができます。

## 例題

**問題の説明:**
長さ $n$ の昇順にソートされた整数配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内の $k$ の「開始位置」と「終了位置」を見つける必要があります（インデックスは0から始まります）。数値が配列に存在しない場合は、`-1 -1` を返します。

### 入力形式

1. 1行目：配列の長さとクエリの数をそれぞれ表す2つの整数 $n$ と $q$。
2. 2行目：昇順にソート済みの完全な配列を表す $n$ 個の整数。
3. 次の $q$ 行：各行には、クエリ要素を表す整数 $k$ が含まれます。

## データ範囲

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 出力形式

各クエリについて、配列内の要素の開始位置と終了位置を1行に出力します。要素が配列に存在しない場合は、`-1 -1` を出力します。

**例:**

```
入力:
6 3
1 2 2 3 3 4
3
4
5

出力:
3 4
5 5
-1 -1
```

**説明:**

- 要素 $3$ が出現する範囲は $[3, 4]$ です。
- 要素 $4$ は位置 $5$ に1回だけ出現します。
- 要素 $5$ は配列に存在しないため、$-1$ $-1$ を返します。

---

## 解法

- **「開始位置」の検索:**
  つまり、$k$ 以上である最初の位置を見つけることです。配列は2つの部分に分割できます。
    - 左側のすべての数値は $k$ より「小さい」
    - 右側のすべての数値は $k$ 「以上」
    - 答えは右側の最初の位置です

- **「終了位置」の検索:**
  つまり、$k$ 以下である最後の位置を見つけることです。配列は2つの部分に分割できます。
    - 左側のすべての数値は $k$ 「以下」
    - 右側のすべての数値は $k$ より「大きい」
    - 答えは左側の最後の位置です

---

## 推奨テンプレート

以下は、エレガントでエラーが発生しにくい二分探索テンプレートです。

2つのポインタ $l, r$ を定義します。不変条件は、閉区間 $[0, l]$ が左側の部分に属し、閉区間 $[r, n - 1]$ が右側の部分に属することです。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化されます。

アルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左側の最後の要素と右側の最初の要素を指します。

探している解が存在しない可能性があるため、問題で解が必ず存在すると述べられていない場合は、$l$ または $r$ が範囲外であるかどうか、および正しい値を指しているかどうかを確認する必要があります。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k の開始位置を見つける
        //    配列を2つの部分に分割します。左側の部分はすべて < k で、右側の部分はすべて >= k です。
        //    答えは右側の最小インデックスです。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // r が範囲外であるか、nums[r] != k の場合、k が存在しないことを意味します
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k の終了位置を見つける
        //    配列を2つの部分に分割します。左側の部分はすべて <= k で、右側の部分はすべて > k です。
        //    答えは左側の最大インデックスです。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### 利点

1. このアプローチには、厳密に定義された不変条件があります。
2. 追加の処理や変更なしに、「開始位置」と「終了位置」の両方の検索に適用できます。
3. 一部のアプローチでは、終了条件として `l == r` を使用します。$l$ と $r$ の差が $1$ の場合、$mid$ は $l$ または $r$ と等しくなるように計算されます。正しく処理しないと、$l$ または $r$ を $mid$ に更新しても探索間隔が縮小されず、無限ループが発生します。対照的に、このアプローチは $l$ と $r$ が隣接したときに終了するため、$mid$ が $l$ より小さく、$r$ より大きくなり、$l$ または $r$ を更新すると常に探索間隔が縮小されます。

---

## STL

C++ STL が提供する `lower_bound` および `upper_bound` 関数を使用すると、同じことを実現できます。

- `lower_bound(first, last, val)` は「val 以上である最初の位置」を返します。
- `upper_bound(first, last, val)` は「val より大きい最初の位置」を返します。

たとえば、`nums = {1,2,3,4,4,4,4,4,5,5,6}` で、4 が出現する範囲を知りたいとします。

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 は 0 回出現します" << endl;
} else {
    cout << "最初の 4 は " << it1 - nums.begin() << " にあります" << endl;
    cout << "最後の 4 は " << it2 - nums.begin() - 1 << " にあります" << endl;
    cout << "4 は " << it2 - it1 << " 回出現します" << endl;
}
```

- `it1` は、値が $4$ 以上である最初の位置を指します。
- `it2` は、値が $4$ より大きい最初の位置を指します。
  したがって、`it2 - it1` は配列内で $4$ が出現する回数です。`it2 - nums.begin() - 1` は $4$ の右境界の位置です。

---

## 追加の注意

二分探索は、浮動小数点範囲での検索（方程式の根を見つけるなど）や、単峰関数の極値を見つけるための三分割探索にも拡張できます。

---

## 練習

LeetCode 33. Search in Rotated Sorted Array

ヒント：最初に、二分探索を使用して回転点を見つけ、次に二分探索を使用してターゲット値を見つけます。