---
title: "二分探索"
date: 2024-12-24
draft: false
description: "二分探索アルゴリズムをエレガントに実装する方法。"
summary: "二分探索アルゴリズムをエレガントに実装する方法。"
tags: [ "アルゴリズム", "二分探索", "アルゴリズムテンプレート" ]
categories: [ "アルゴリズムとデータ構造" ]
---

もし順序付けられた解空間が左右の2つの部分に分割され、一方の部分が条件を満たし、もう一方の部分が条件を満たさない場合、二分探索を使用して順序付けられた解空間で臨界点を見つけることができます。

二分探索の基本的な考え方は、検索範囲を半分に分割し続けることです。毎回、中央の要素をチェックし、中央の要素が条件を満たさない場合は、範囲の半分を排除できます。そうでない場合は、もう半分の範囲で検索を続けます。毎回検索範囲の半分を破棄するため、検索時間計算量は $O(\log n)$ に達することができます。

## 例題

**問題の説明：**  
昇順にソートされた長さ $n$ の整数配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内で $k$ の「開始位置」と「終了位置」（インデックスは 0 から開始）を見つける必要があります。配列にこの数が存在しない場合は、`-1 -1` を返します。

### 入力形式

1. 1行目：2つの整数 $n$ と $q$。それぞれ配列の長さとクエリの回数を表します。
2. 2行目：$n$ 個の整数。昇順にソートされた完全な配列を表します。
3. 次の $q$ 行：各行には整数 $k$ が含まれ、クエリ要素を表します。

## データ範囲

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### 出力形式

各クエリについて、配列内の要素の開始位置と終了位置を1行に出力します。配列に要素が存在しない場合は、`-1 -1` を出力します。

**サンプル：**

```
入力：
6 3
1 2 2 3 3 4
3
4
5

出力：
3 4
5 5
-1 -1
```

**説明：**

- 要素 $3$ が出現する範囲は $[3, 4]$ です。
- 要素 $4$ は1回だけ出現し、位置 $5$ にあります。
- 要素 $5$ は配列に存在しないため、$-1$ $-1$ を返します。

---

## 解答

- **「開始位置」を見つける：**
  つまり、$k$ 以上の最初の位置を見つけます。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ より「小さい」
    - 右側のすべての数は $k$ 以上
    - 答えは右側の最初の位置です

- **「終了位置」を見つける：**
  つまり、$k$ 以下の最後の位置を見つけます。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ 以下
    - 右側のすべての数は $k$ より「大きい」
    - 答えは左側の最後の位置です

---

## おすすめテンプレート

以下は、エレガントでエラーを起こしにくい二分探索テンプレートです。

2つのポインタ $l, r$ を定義します。不変条件は、閉区間 $[0, l]$ が左半分に属し、閉区間 $[r, n - 1]$ が右半分に属することです。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化されます。

アルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左半分の最後の要素と右半分の最初の要素を指します。

必要な解が存在しない可能性があるため、問題に必ず解が存在すると明記されていない場合は、$l$ または $r$ が範囲外かどうか、正しい値を指しているかどうかを判断する必要があります。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k の開始位置を見つける
        //    配列を2つの部分に分割し、左側はすべて < k、右側はすべて >= k。
        //    答えは右半分の最小インデックス。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // もし r が範囲外または nums[r] != k なら、k は存在しない
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k の終了位置を見つける
        //    配列を2つの部分に分割し、左側はすべて <= k、右側はすべて > k。
        //    答えは左半分の最大インデックス。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }

    return 0;
}
```

### 利点

1. この書き方には厳密に定義された不変条件があります。
2. 「開始位置」と「終了位置」の両方のケースに適用でき、追加の処理や変更は必要ありません。
3. 一部の書き方では、終了条件として `l == r` を使用します。$l$ と $r$ が $1$ 異なる場合、$mid$ は $l$ または $r$ と等しく計算されます。正しく処理しないと、$l$ または $r$ を $mid$ に更新すると、検索範囲が縮小せず、無限ループが発生します。対照的に、ここの書き方では、$l$ と $r$ が隣接すると終了するため、$mid$ が $l$ より小さく、$r$ より大きいことが保証され、$l$ または $r$ を更新すると検索範囲が必ず縮小します。

---

## STL

C++ STL が提供する `lower_bound` 関数と `upper_bound` 関数を使用すると、同じことを実行できます。

- `lower_bound(first, last, val)` は「val 以上の最初の位置」を返します。
- `upper_bound(first, last, val)` は「val より大きい最初の位置」を返します。

例として、`nums = {1,2,3,4,4,4,4,4,5,5,6}` と仮定し、4 が出現する範囲を知りたいとします。

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` は、値が $4$ 以上の最初の位置を指します。
- `it2` は、値が $4$ より大きい最初の位置を指します。
  したがって、`it2 - it1` は配列内で $4$ が出現する回数です。`it2 - nums.begin() - 1` は $4$ の右境界の位置です。

---

## 補足

二分探索は、浮動小数点数の範囲の検索（方程式の根を求めるなど）や、単峰関数の最大値を求めるための三分探索にも拡張できます。

---

## 練習

LeetCode 33. Search in Rotated Sorted Array

ヒント：最初のステップで二分探索を使用して回転点を見つけ、2番目のステップで二分探索を使用して目標値を見つけます。