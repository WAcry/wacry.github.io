---
title: "二分探索"
date: 2024-12-24
draft: false
description: "整数二分探索アルゴリズムをエレガントに実装する方法。"
summary: "整数二分探索アルゴリズムをエレガントに実装する方法。"
tags: [ "アルゴリズム", "二分探索", "アルゴリズムテンプレート" ]
categories: [ "アルゴリズムとデータ構造" ]
---

{{< katex >}}

# 二分探索

もしソートされた解空間が左右の2つの部分に分割され、片方の部分が条件を満たし、もう片方の部分が条件を満たさない場合、二分探索を使用してソートされた解空間で臨界点を見つけることができます。

二分探索の基本的な考え方は、探索範囲を継続的に半分に分割することです。毎回、中点要素をチェックし、中点要素が条件を満たさない場合は、範囲の半分を排除できます。そうでない場合は、もう半分の範囲で検索を続けます。毎回探索範囲の半分を破棄するため、検索時間計算量は \\(O(\log n)\\) に達することができます。

## 例題

**問題記述：**  
長さ \\(n\\) の昇順にソートされた整数の配列と、\\(q\\) 個のクエリが与えられます。各クエリは整数 \\(k\\) を提供し、配列内の \\(k\\) の「開始位置」と「終了位置」（インデックスは0から開始）を見つける必要があります。配列内にこの数が存在しない場合は、\\(-1\\) \\(-1\\) を返します。

### 入力形式

1. 1行目：配列の長さとクエリ回数をそれぞれ表す2つの整数 \\(n\\) と \\(q\\)。
2. 2行目：\\(n\\) 個の整数。完全な配列を表し、昇順にソートされています。
3. 続く \\(q\\) 行：各行にクエリ要素を表す整数 \\(k\\) が含まれています。

## データ範囲

\\(1 \leq n \leq 100000\\)

\\(1 \leq q \leq 10000\\)

\\(1 \leq k \leq 10000\\)

### 出力形式

各クエリについて、要素が配列内の開始位置と終了位置を1行に出力します。配列内にその要素が存在しない場合は、`-1 -1` を出力します。

**サンプル：**

```
入力：
6 3
1 2 2 3 3 4
3
4
5

出力：
3 4
5 5
-1 -1
```

**説明：**

- 要素 \\(3\\) が出現する範囲は \\([3, 4]\\) です。
- 要素 \\(4\\) は一度しか出現せず、位置 \\(5\\) にあります。
- 要素 \\(5\\) は配列内に存在しないため、\\(-1\\) \\(-1\\) を返します。

---

## 解答

- **「開始位置」を探す：**
  つまり、\\(k\\) 以上である最初の位置を探します。配列を2つの部分に分割できます：
    - 左側のすべての数値は \\(k\\) よりも「小さい」
    - 右側のすべての数値は \\(k\\) 以上である
    - 答えは右側の最初の位置です

- **「終了位置」を探す：**
  つまり、\\(k\\) 以下である最後の位置を探します。配列を2つの部分に分割できます：
    - 左側のすべての数値は \\(k\\) 以下である
    - 右側のすべての数値は \\(k\\) より「大きい」
    - 答えは左側の最後の位置です

---

## おすすめテンプレート

以下は、エレガントで間違いにくい二分探索テンプレートです。\\(l\\) と \\(r\\) を徐々に近づけることで、ループが両者が隣接したときに必ず終了することを保証します。

2つのポインタ \\(l, r\\) を定義し、不変条件を設定します：閉区間 \\([0, l]\\) はすべて左半分に属し、閉区間 \\([r, n - 1]\\) はすべて右半分に属します。\\(l\\)
と \\(r\\) は両方とも \\(-1\\) と \\(n\\) に初期化されます。

アルゴリズムが終了すると、\\(l\\) と \\(r\\) は隣接し、それぞれ左半分の最後の要素と右半分の最初の要素を指します。

探している解が存在しない可能性があるため、問題で必ず解が存在することが示されていない場合は、`l` または `r` が範囲外であるかどうか、正しい値を指しているかどうかを判断する必要があります。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k の開始位置を探す
        //    配列を2つの部分に分割する。左側はすべて < k、右側はすべて >= k。
        //    答えは右半分の最小インデックス。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // r が範囲外であるか、nums[r] != k の場合は、k が存在しないことを示す
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. k の終了位置を探す
        //    配列を2つの部分に分割する。左側はすべて <= k、右側はすべて > k。
        //    答えは左半分の最大インデックス。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### なぜこのように書くのか

1. この書き方には厳密に定義された不変条件があります。
2. これは、「開始位置」と「終了位置」の両方の状況に同時に適用でき、追加の処理や変更は必要ありません。
3. 一部の書き方では、終了条件として `l == r` を使用します。\\(l\\) と \\(r\\) の差が \\(1\\) の場合、\\(mid\\) は \\(l\\) または \\(r\\)
   と同じになります。正しく処理しないと、\\(l\\) または \\(r\\) が \\(mid\\) に更新され、検索範囲が縮小せず、無限ループが発生します。対照的に、ここでの書き方では、\\(l\\)
   と \\(r\\) が隣接したときに終了するため、\\(mid\\) が \\(l\\) より小さく、\\(r\\) より大きいことが保証され、\\(l\\) または \\(r\\)
   を更新すると検索範囲が必ず縮小されます。

---

## STL

C++ STL が提供する `lower_bound` と `upper_bound` 関数を使用すれば、同じことを完了できます：

- `lower_bound(first, last, val)` は「最初の val 以上の位置」を返します
- `upper_bound(first, last, val)` は「最初の val より大きい位置」を返します

たとえば、`nums = {1,2,3,4,4,4,4,4,5,5,6}` と仮定し、4 が出現する範囲を知りたいとします：

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` は \\(4\\) 以上の最初の値を指します。
- `it2` は \\(4\\) より大きい最初の値を指します。
  したがって、`it2 - it1` は、\\(4\\) が配列に出現する回数です。`it2 - nums.begin() - 1` は、\\(4\\) の右境界です。

---

## 補足

二分探索は、浮動小数点数の範囲での探索（方程式の根の探索など）や、単峰関数の最大値を求めるための三分探索にも拡張できます。
「**ソートされた範囲では、毎回半分を排除できる**」という中核原理を理解すれば、二分探索が多くのシナリオで効率的に問題を解決するのに役立つことがわかります。

---

## 練習

LeetCode 33. Search in Rotated Sorted Array

ヒント：最初に二分探索を使用して回転点を見つけ、次に二分探索を使用してターゲット値を見つけます。