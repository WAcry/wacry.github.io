---
title: "二分探索"
date: 2024-12-24
draft: false
description: "整数二分探索アルゴリズムをエレガントに実装する方法"
summary: "整数二分探索アルゴリズムをエレガントに実装する方法"
tags: [ "アルゴリズム", "二分探索", "アルゴリズムテンプレート" ]
categories: [ "アルゴリズムとデータ構造" ]
---
{{< katex >}}

# 二分探索

ソートされたシーケンス内で特定の要素を探すには、二分探索を使用すると迅速に完了できます。線形探索の時間計算量 $O(n)$ と比較して、二分探索は $O(\log n)$ の時間しか必要としないため、データ規模が大きい場合に非常に効率的です。

## 二分探索の中核となる考え方

二分探索の基本的な考え方は、検索範囲を絶えず半分に分割することです。毎回、中央の要素と目標値の大きさを比較し、中央の要素が条件を満たさない場合は、範囲の半分を排除できます。そうでない場合は、残りの範囲で検索を続けます。毎回検索範囲の半分を破棄するため、検索の時間計算量は $O(\log n)$ に達することができます。

「**実行可能な解が、ソートされた1つの範囲（条件を満たす）と別のソートされた範囲（条件を満たさない）に分割できる**」という問題に対して、二分探索は非常に便利です。例えば：

- ソートされた配列内に特定の要素が存在するかどうかを検索する
- ある数の「最初の位置」または「最後の位置」を見つける

## 例題：要素の開始位置と終了位置を探す

**問題の説明：**
長さ $n$ の昇順にソートされた整数の配列と、$q$ 個のクエリが与えられます。各クエリは整数 $k$ を与え、配列内の $k$ の「開始位置」と「終了位置」（インデックスは0から開始）を見つける必要があります。配列内にこの数が存在しない場合は、$-1$ $-1$ を返します。

**入力形式：**

1.  最初の行：配列の長さとクエリの回数を表す2つの整数 $n$ と $q$。
2.  2行目：$n$ 個の整数（1〜10000の範囲内）で、完全な配列を表し、昇順にソートされています。
3.  次の $q$ 行：各行には、クエリ要素を表す整数 $k$ が含まれています。

**出力形式：**
各クエリに対して、配列内の要素の開始位置と終了位置を1行に出力します。配列内に要素が存在しない場合は、$-1$ $-1$ を出力します。

**例：**

```
入力：
6 3
1 2 2 3 3 4
3
4
5

出力：
3 4
5 5
-1 -1
```

説明：

- 要素 3 が出現する範囲は `[3, 4]` です。
- 要素 4 は 1 回だけ出現し、位置 5 にあります。
- 要素 5 は配列に存在しないため、`-1 -1` を返します。

## 二分探索の応用アイデア

この問題では、ある値の「左境界」と「右境界」を見つけるために、二分探索を利用できます。重要なのは、検索範囲をどのように定義し、比較結果に基づいてポインターをどのように移動するかを理解することです。

- **「左境界」を見つける：**
  つまり、最初に $k$ 以上の位置を探します。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ 「より小さい」
    - 右側のすべての数は $k$ 「以上」

- **「右境界」を見つける：**
  つまり、最後に $k$ 以下の位置を探します。配列を2つの部分に分割できます。
    - 左側のすべての数は $k$ 「以下」
    - 右側のすべての数は $k$ 「より大きい」

これらの2つの範囲を正しく維持できれば、二分探索によって迅速に結果を得ることができます。

## おすすめテンプレート：デッドロックを避ける二分探索の書き方

以下は、エレガントで間違いにくい二分探索のテンプレートです。$l$ と $r$ を徐々に近づけることで、ループが両者が隣接するときに必ず終了するようにします。

2つのポインタ $l$, $r$ を定義し、不変量があります：閉区間 $[0, l]$ はすべて左半分に属し、閉区間 $[r, n - 1]$ はすべて右半分に属します。$l$ と $r$ はそれぞれ $-1$ と $n$ に初期化されます。

アルゴリズムが終了すると、$l$ と $r$ は隣接し、それぞれ左半分の最大値と右半分の最小値を指します。

目的の解が存在しない可能性があるため、$l$ または $r$ を返すときは、対応する値が目的の値であるか、範囲外かどうかを確認する必要があります。例えば、$l$ は $\leq k$ の最大値を表しますが、`l != -1 && nums[l] == k` を検証する必要があります。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. k の開始位置（左境界）を検索
        //    配列を2つの部分に分割し、左側はすべて < k、右側はすべて >= k。
        //    左境界は、右側の部分の最小インデックスです。
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid;
            else l = mid;
        }

        // r が範囲外か nums[r] != k の場合、k が存在しない
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r; // k の左境界を記録

        // 2. k の終了位置（右境界）を検索
        //    配列を2つの部分に分割し、左側はすべて <= k、右側はすべて > k。
        //    右境界は、左側の部分の最大インデックスです。
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        // k が存在することを既に検証しているので、ここで再度検証する必要はありません
        int rightPos = l; // 右境界
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### この書き方が間違いにくい理由

1.  この書き方には、厳密に定義された不変量があります。
2.  左境界と右境界の両方を見つけることができるため、すべてのシナリオに適用できます。
3.  いくつかの書き方では、$l == r$ を終了条件として使用します。$l$ と $r$ が 1 違う場合、$mid$ は `l` または `r` と同じになります。正しく処理せずに `l` または `r` を `mid` に更新すると、検索範囲が縮小されず、デッドロックが発生します。逆に、ここの書き方では、$l$ と $r$ が隣接したときに終了するため、この問題が回避されます。

## STL 解法：`lower_bound` と `upper_bound`

C++ STL が提供する `lower_bound` 関数と `upper_bound` 関数を使用すると、同じことを簡単に完了できます。

- `lower_bound(first, last, val)` は「最初に val 以上の位置」を返します。
- `upper_bound(first, last, val)` は「最初に val より大きい位置」を返します。

例えば、`nums = {1,2,3,4,4,4,4,4,5,5,6}` で、4 が出現する範囲を知りたいとします。

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    // 配列に 4 が存在しない場合
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` は、最初に値が 4 以上である位置を指します。
- `it2` は、最初に値が 4 より大きい位置を指します。
  したがって、`it2 - it1` が配列内で 4 が出現する回数であり、`it2 - nums.begin() - 1` が 4 の右境界です。

これらの 2 つの関数は、範囲を検索したり、出現回数をカウントしたりする場合に特に便利です。

## 補足

二分探索は、浮動小数点数範囲の探索（例えば、方程式の根を求める）、および単峰関数の最大値を求めるための三分探索にも拡張できます。「**ソートされた範囲内で、毎回半分を排除できる**」という中核となる原理を理解すれば、二分探索が多くのシナリオで問題を効率的に解決するのに役立つことがわかるでしょう。

## 宿題

LeetCode 33. Search in Rotated Sorted Array

ヒント：最初のステップで二分探索を使用して回転点を見つけ、2番目のステップで二分探索を使用して目標値を見つけます。