---
title: "Двоичный Поиск"
date: 2024-12-24
draft: false
description: "Как элегантно реализовать алгоритм двоичного поиска для целых чисел."
summary: "Как элегантно реализовать алгоритм двоичного поиска для целых чисел."
tags: [ "Алгоритмы", "Двоичный поиск", "Шаблоны алгоритмов" ]
categories: [ "Алгоритмы и структуры данных" ]
---

{{< katex >}}

# Двоичный Поиск

Если упорядоченное пространство решений можно разделить на две части, где одна часть удовлетворяет условию, а другая не удовлетворяет, то можно использовать двоичный поиск для нахождения критической точки в упорядоченном пространстве решений.

Основная идея двоичного поиска состоит в постоянном делении поискового интервала пополам. Каждый раз проверяется средний элемент, и если средний элемент не удовлетворяет условию, можно исключить половину интервала; в противном случае поиск продолжается в другой половине интервала. Поскольку каждый раз отбрасывается половина поискового интервала, временная сложность поиска может достигать \\(O(\log n)\\).

## Пример задачи

**Описание задачи:**
Дан отсортированный по возрастанию массив целых чисел длины \\(n\\), а также \\(q\\) запросов. Каждый запрос задает целое число \\(k\\), и нам нужно найти "начальную позицию" и "конечную позицию" числа \\(k\\) в массиве (индексы начинаются с 0). Если число не найдено в массиве, вернуть \\(-1\\) \\(-1\\).

### Формат ввода

1. Первая строка: два целых числа \\(n\\) и \\(q\\), представляющие длину массива и количество запросов соответственно.
2. Вторая строка: \\(n\\) целых чисел, представляющих полный массив, уже отсортированный по возрастанию.
3. Следующие \\(q\\) строк: каждая строка содержит целое число \\(k\\), представляющее элемент запроса.

## Диапазон данных

\\(1 \leq n \leq 100000\\)

\\(1 \leq q \leq 10000\\)

\\(1 \leq k \leq 10000\\)

### Формат вывода

Для каждого запроса выведите начальную и конечную позиции элемента в массиве в одной строке. Если элемент не существует в массиве, выведите `-1 -1`.

**Пример:**

```
Ввод:
6 3
1 2 2 3 3 4
3
4
5

Вывод:
3 4
5 5
-1 -1
```

**Объяснение:**

- Элемент \\(3\\) встречается в диапазоне \\([3, 4]\\);
- Элемент \\(4\\) встречается только один раз в позиции \\(5\\);
- Элемента \\(5\\) нет в массиве, поэтому возвращаем \\(-1\\) \\(-1\\).

---

## Решение

- **Найти "начальную позицию":**
  То есть найти первую позицию, где число больше или равно \\(k\\). Можно разделить массив на две части:
    - Слева все числа "меньше" \\(k\\)
    - Справа все числа "больше или равны" \\(k\\)
    - Ответ - первое положение справа

- **Найти "конечную позицию":**
  То есть найти последнюю позицию, где число меньше или равно \\(k\\). Можно разделить массив на две части:
    - Слева все числа "меньше или равны" \\(k\\)
    - Справа все числа "больше" \\(k\\)
    - Ответ - последнее положение слева

---

## Рекомендуемый шаблон

Ниже представлен элегантный и устойчивый к ошибкам шаблон двоичного поиска. Он гарантирует завершение цикла, когда \\(l\\) и \\(r\\) станут соседними, за счет их постепенного сближения:

Определим два указателя \\(l, r\\), имеем инвариант: закрытый интервал \\([0, l]\\) принадлежит левой части, закрытый интервал \\([r, n - 1]\\) принадлежит правой части. \\(l\\) и \\(r\\) инициализируются как \\(-1\\) и \\(n\\).

Когда алгоритм завершается, \\(l\\) и \\(r\\) являются соседними, указывая на последний элемент левой части и первый элемент правой части соответственно.

Поскольку желаемое решение может не существовать, нам нужно проверить, не выходят ли `l` или `r` за пределы границ и не указывают ли они на правильные значения, если в условии задачи не сказано, что решение обязательно существует.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. Найти начальную позицию k
        //    Разделить массив на две части, слева все < k, справа все >= k.
        //    Ответ - минимальный индекс правой части.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // Если r выходит за границы или nums[r] != k, значит, k не существует
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. Найти конечную позицию k
        //    Разделить массив на две части, слева все <= k, справа все > k.
        //    Ответ - максимальный индекс левой части.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### Почему так написано

1. Этот подход имеет строго определенные инварианты.
2. Он одновременно подходит для поиска "начальной позиции" и "конечной позиции", не требуя дополнительных обработок и изменений.
3. Некоторые подходы используют `l == r` в качестве условия завершения. Когда \\(l\\) и \\(r\\) отличаются на \\(1\\), вычисляется, что \\(mid\\) равен \\(l\\) или \\(r\\). Если это не обработано правильно и \\(l\\) или \\(r\\) обновляется до \\(mid\\), то поисковый интервал не уменьшится, что приведет к бесконечному циклу. Напротив, этот подход завершается, когда \\(l\\) и \\(r\\) становятся соседними, гарантируя, что \\(mid\\) меньше \\(l\\) и больше \\(r\\), и при обновлении \\(l\\) или \\(r\\) поисковый интервал обязательно уменьшается.

---

## STL

Если использовать функции `lower_bound` и `upper_bound`, предоставляемые C++ STL, можно выполнить ту же задачу:

- `lower_bound(first, last, val)` возвращает "позицию первого элемента, большего или равного val"
- `upper_bound(first, last, val)` возвращает "позицию первого элемента, большего val"

Например, предположим, что `nums = {1,2,3,4,4,4,4,4,5,5,6}`, и мы хотим знать диапазон, где появляется 4:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` указывает на первую позицию со значением, большим или равным \\(4\\).
- `it2` указывает на первую позицию со значением, большим \\(4\\).
  Поэтому `it2 - it1` - это количество раз, когда \\(4\\) встречается в массиве; `it2 - nums.begin() - 1` - это правая граница \\(4\\).

---

## Дополнение

Двоичный поиск также можно расширить для поиска в диапазоне чисел с плавающей точкой (например, поиск корня уравнения), а также для троичного поиска для нахождения экстремума унимодальной функции.
Как только вы поймете ключевой принцип "в упорядоченном интервале каждый раз можно исключить половину", вы обнаружите, что двоичный поиск может помочь вам эффективно решать проблемы во многих ситуациях.

---

## Упражнение

LeetCode 33. Search in Rotated Sorted Array

Подсказка: на первом шаге используйте двоичный поиск, чтобы найти точку вращения, а на втором шаге используйте двоичный поиск, чтобы найти целевое значение.