---
title: "Двоичный поиск"
date: 2024-12-24
draft: false
description: "Как элегантно реализовать алгоритм двоичного поиска."
summary: "Как элегантно реализовать алгоритм двоичного поиска."
tags: [ "алгоритмы", "двоичный поиск", "шаблоны алгоритмов" ]
categories: [ "Алгоритмы и структуры данных" ]
---

Если упорядоченное пространство решений разделено на левую и правую части, где одна часть удовлетворяет условию, а другая нет, то можно использовать двоичный поиск для нахождения критической точки в упорядоченном пространстве решений.

Основная идея двоичного поиска заключается в постоянном делении интервала поиска пополам. При каждой проверке проверяется средний элемент, и если средний элемент не удовлетворяет условию, то можно исключить половину интервала; в противном случае поиск продолжается в другой половине интервала. Поскольку каждый раз отбрасывается половина интервала поиска, временная сложность поиска может достигать $O(\log n)$.

## Пример задачи

**Описание задачи:**
Дан отсортированный по возрастанию массив целых чисел длиной $n$, а также $q$ запросов. Каждый запрос задает целое число $k$, и нам нужно найти «начальную позицию» и «конечную позицию» $k$ в массиве (индексы начинаются с 0). Если этого числа нет в массиве, вернуть `-1 -1`.

### Формат ввода

1. Первая строка: два целых числа $n$ и $q$, представляющие длину массива и количество запросов соответственно.
2. Вторая строка: $n$ целых чисел, представляющих полный массив, отсортированный по возрастанию.
3. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса.

## Диапазон данных

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### Формат вывода

Для каждого запроса выведите в одной строке начальную и конечную позиции элемента в массиве. Если элемента нет в массиве, выведите `-1 -1`.

**Пример:**

```
Ввод:
6 3
1 2 2 3 3 4
3
4
5

Вывод:
3 4
5 5
-1 -1
```

**Пояснение:**

- Диапазон появления элемента $3$ равен $[3, 4]$;
- Элемент $4$ встречается только один раз, в позиции $5$;
- Элемента $5$ нет в массиве, поэтому возвращается $-1$ $-1$.

---

## Решение

- **Поиск «начальной позиции»:**
  То есть поиск первой позиции, где значение больше или равно $k$. Можно разделить массив на две части:
    - Все числа слева «меньше» $k$
    - Все числа справа «больше или равны» $k$
    - Ответ — первая позиция справа

- **Поиск «конечной позиции»:**
  То есть поиск последней позиции, где значение меньше или равно $k$. Можно разделить массив на две части:
    - Все числа слева «меньше или равны» $k$
    - Все числа справа «больше» $k$
    - Ответ — последняя позиция слева

---

## Рекомендуемый шаблон

Ниже представлен элегантный и не склонный к ошибкам шаблон двоичного поиска.

Определим два указателя $l, r$, с инвариантом: замкнутый интервал $[0, l]$ принадлежит левой части, замкнутый интервал $[r, n - 1]$ принадлежит правой части. $l$ и $r$ инициализируются как $-1$ и $n$.

Когда алгоритм завершается, $l$ и $r$ становятся соседними, указывая на последний элемент левой части и первый элемент правой части соответственно.

Поскольку желаемое решение может не существовать, если в условии задачи не указано, что решение обязательно существует, нам нужно проверить, не выходят ли `l` или `r` за границы, и указывают ли они на правильное значение.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. Поиск начальной позиции k
        //    Разделяем массив на две части, слева все < k, справа все >= k.
        //    Ответ - минимальный индекс правой части.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // Если r выходит за границы или nums[r] != k, значит k не существует
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. Поиск конечной позиции k
        //    Разделяем массив на две части, слева все <= k, справа все > k.
        //    Ответ - максимальный индекс левой части.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }

    return 0;
}
```

### Преимущества

1. Этот подход имеет строго определенные инварианты.
2. Он подходит как для поиска «начальной позиции», так и для поиска «конечной позиции», не требуя дополнительных обработок и изменений.
3. Некоторые подходы используют `l == r` в качестве условия завершения. Когда $l$ и $r$ отличаются на $1$, вычисляется $mid$, равный $l$ или $r$. Если это не обработано правильно, обновление $l$ или $r$ до $mid$ приведет к тому, что интервал поиска не уменьшится, что приведет к бесконечному циклу. Напротив, этот подход завершается, когда $l$ и $r$ соседние, гарантируя, что $mid$ меньше $l$ и больше $r$, и при обновлении $l$ или $r$ интервал поиска обязательно уменьшится.

---

## STL

Если использовать функции `lower_bound` и `upper_bound`, предоставляемые C++ STL, можно добиться того же результата:

- `lower_bound(first, last, val)` вернет «первую позицию, где значение больше или равно val»
- `upper_bound(first, last, val)` вернет «первую позицию, где значение больше val»

Например, предположим, что `nums = {1,2,3,4,4,4,4,4,5,5,6}`, и мы хотим узнать интервал, в котором появляется 4:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` указывает на первую позицию, где значение больше или равно $4$.
- `it2` указывает на первую позицию, где значение больше $4$.
  Следовательно, `it2 - it1` — это количество раз, когда $4$ появляется в массиве; `it2 - nums.begin() - 1` — это позиция правой границы $4$.

---

## Дополнение

Двоичный поиск также можно расширить на поиск в диапазоне чисел с плавающей точкой (например, для нахождения корней уравнения), а также на тернарный поиск для нахождения экстремумов унимодальных функций.

---

## Упражнение

LeetCode 33. Search in Rotated Sorted Array

Подсказка: на первом шаге используйте двоичный поиск, чтобы найти точку поворота, а на втором шаге используйте двоичный поиск, чтобы найти целевое значение.