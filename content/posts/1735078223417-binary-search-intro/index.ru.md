---
title: "Двоичный поиск"
date: 2024-12-24
draft: false
description: "Как элегантно реализовать алгоритм целочисленного двоичного поиска"
summary: "Как элегантно реализовать алгоритм целочисленного двоичного поиска"
tags: [ "Алгоритм", "Двоичный поиск", "Шаблон алгоритма" ]
categories: [ "Алгоритмы и структуры данных" ]
---
{{< katex >}}

# Двоичный поиск

Для поиска конкретного элемента в отсортированной последовательности можно использовать двоичный поиск для быстрого завершения. По сравнению с линейным поиском со сложностью $O(n)$, двоичному поиску требуется всего $O(\log n)$ времени, поэтому он очень эффективен в условиях больших объемов данных.

## Основная идея двоичного поиска

Основная идея двоичного поиска заключается в непрерывном делении поискового интервала пополам. При каждом сравнении сравнивается значение среднего элемента с целевым значением. Если средний элемент не удовлетворяет условию, можно исключить половину интервала; в противном случае поиск продолжается в другой половине интервала. Поскольку при каждой итерации отбрасывается половина поискового интервала, временная сложность поиска может достигать $O(\log n)$.

Двоичный поиск очень полезен для задач, где " **набор допустимых решений можно разделить на один отсортированный интервал (удовлетворяющий условию) и другой отсортированный интервал (не удовлетворяющий условию)**". Например:

- Найти, существует ли какой-либо элемент в отсортированном массиве
- Найти "первую позицию" или "последнюю позицию" появления некоторого числа

## Пример: Поиск начальной и конечной позиции элементов

**Описание задачи:**  
Дан отсортированный по возрастанию массив целых чисел длиной $n$, а также $q$ запросов. Каждый запрос задает целое число $k$, и нам нужно найти "начальную позицию" и "конечную позицию" $k$ в массиве (индекс начинается с 0). Если этого числа нет в массиве, вернуть $-1$ $-1$.

**Формат ввода:**

1. Первая строка: два целых числа $n$ и $q$, обозначающие длину массива и количество запросов соответственно.
2. Вторая строка: $n$ целых чисел (в диапазоне от 1 до 10000), представляющих полный массив, уже отсортированный по возрастанию.
3. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса.

**Формат вывода:**
Для каждого запроса выведите начальную и конечную позиции элемента в массиве в одной строке. Если элемента нет в массиве, выведите $-1$ $-1$.

**Пример:**

```
Ввод:
6 3
1 2 2 3 3 4
3
4
5

Вывод:
3 4
5 5
-1 -1
```

Пояснения:

- Диапазон появления элемента 3 равен `[3, 4]`;
- Элемент 4 появляется только один раз, в позиции 5;
- Элемент 5 отсутствует в массиве, поэтому возвращается `-1 -1`.

## Идеи применения двоичного поиска

В этой задаче для поиска "левой границы" и "правой границы" некоторого значения мы можем использовать двоичный поиск. Ключевым моментом является понимание того, как определять поисковый интервал и как перемещать указатели в зависимости от результата сравнения.

- **Поиск "левой границы":**
  То есть поиск первой позиции, которая больше или равна $k$. Можно разделить массив на две части:
    - Все числа слева "меньше" $k$
    - Все числа справа "больше или равны" $k$

- **Поиск "правой границы":**
  То есть поиск последней позиции, которая меньше или равна $k$. Можно разделить массив на две части:
    - Все числа слева "меньше или равны" $k$
    - Все числа справа "больше" $k$

Пока вы можете правильно поддерживать эти два интервала, вы можете быстро получить результаты с помощью двоичного поиска.

## Рекомендуемый шаблон: написание двоичного поиска для предотвращения бесконечного цикла

Ниже приведен элегантный и безошибочный шаблон двоичного поиска. Он постепенно сближает $l$ и $r$, гарантируя, что цикл заканчивается, когда они становятся соседними:

Определите два указателя $l, r$ с инвариантом: замкнутый интервал $[0, l]$ относится к левой половине, а замкнутый интервал $[r, n - 1]$ относится к правой половине. $l$ и $r$ инициализируются как $-1$ и $n$.

Когда алгоритм завершится, $l$ и $r$ будут соседними, указывая на максимальное значение левой половины и минимальное значение правой половины соответственно.

Поскольку желаемое решение может не существовать, при возврате $l$ или $r$ необходимо проверить, является ли соответствующее значение нужным нам значением и не выходит ли оно за границы.
Например, $l$ представляет собой максимальное значение $\leq k$, и нам нужно проверить `l != -1 && nums[l] == k`

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. Поиск начальной позиции k (левой границы)
        //    Разделите массив на две части, все слева < k, все справа >= k.
        //    Левая граница - это минимальный индекс правой части.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid;
            else l = mid;
        }

        // Если r выходит за границы или nums[r] != k, это означает, что k не существует.
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r; // Запись левой границы k

        // 2. Поиск конечной позиции k (правой границы)
        //    Разделите массив на две части, все слева <= k, все справа > k.
        //    Правая граница - это максимальный индекс левой части.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        // Поскольку мы уже проверили, что k существует, здесь повторная проверка не нужна.
        int rightPos = l; // Правая граница
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### Почему такой код менее подвержен ошибкам?

1. Эта запись имеет строго определенные инварианты.
2. Она может находить как левую, так и правую границы и подходит для всех сценариев.
3. Некоторые записи используют $l == r$ в качестве условия завершения. Когда $l$ и $r$ отличаются на 1, $mid$ будет вычислен как равный `l` или `r`. Если не обработать это правильно и обновить
   `l` или `r` до `mid`, то поисковый интервал не сократится, что приведет к бесконечному циклу. Напротив, эта запись завершается, когда $l$ и $r$ являются соседними, избегая этой проблемы.

## Решение с использованием STL: `lower_bound` и `upper_bound`

Если вы используете функции `lower_bound` и `upper_bound`, предоставляемые C++ STL, вы также можете легко выполнить ту же задачу:

- `lower_bound(first, last, val)` вернет "первую позицию, значение которой больше или равно val"
- `upper_bound(first, last, val)` вернет "первую позицию, значение которой больше val"

Например, предположим, что `nums = {1,2,3,4,4,4,4,4,5,5,6}`, и мы хотим узнать интервал появления 4:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    // Это означает, что 4 отсутствует в массиве
    cout << "4 appears 0 times" << endl;
} else {
    cout << "first 4 is at " << it1 - nums.begin() << endl;
    cout << "last 4 is at " << it2 - nums.begin() - 1 << endl;
    cout << "4 appears " << it2 - it1 << " times" << endl;
}
```

- `it1` указывает на первую позицию, значение которой больше или равно 4.
- `it2` указывает на первую позицию, значение которой больше 4.
   Следовательно, `it2 - it1` — это количество раз, когда 4 встречается в массиве; `it2 - nums.begin() - 1` — это правая граница 4.

Эти две функции особенно удобны для поиска интервалов или подсчета количества появлений.

## Дополнительно

Двоичный поиск также можно расширить до поиска в диапазоне чисел с плавающей запятой (например, поиска корней уравнений) и поиска наибольшего значения унимодальных функций с помощью тернарного поиска. Пока вы понимаете " **основной принцип исключения половины в упорядоченном интервале
**", вы обнаружите, что двоичный поиск может помочь вам эффективно решать проблемы во многих сценариях.

## Домашнее задание

LeetCode 33. Search in Rotated Sorted Array

Подсказка: на первом шаге используйте двоичный поиск, чтобы найти точку поворота, а на втором шаге используйте двоичный поиск, чтобы найти целевое значение.
```