---
title: "Бинарный поиск"
date: 2024-12-24
draft: false
description: "Как элегантно реализовать алгоритм бинарного поиска."
summary: "Как элегантно реализовать алгоритм бинарного поиска."
tags: [ "Алгоритм", "Бинарный поиск", "Шаблон алгоритма" ]
categories: [ "Алгоритмы и структуры данных" ]
---

Если упорядоченное пространство решений разделено на две части, где одна часть удовлетворяет условию, а другая нет, то бинарный поиск можно использовать для нахождения критической точки в упорядоченном пространстве решений.

Основная идея бинарного поиска заключается в многократном делении интервала поиска пополам. Каждый раз проверяется средний элемент. Если средний элемент не удовлетворяет условию, половину интервала можно отбросить; в противном случае поиск продолжается в другой половине. Поскольку каждый раз отбрасывается половина интервала поиска, временная сложность поиска может достигать $O(\log n)$.

## Пример задачи

**Описание задачи:**
Дан отсортированный по возрастанию целочисленный массив длиной $n$ и $q$ запросов. Каждый запрос задает целое число $k$, и нам нужно найти "начальную позицию" и "конечную позицию" $k$ в массиве (индексы начинаются с 0). Если числа нет в массиве, вернуть `-1 -1`.

### Формат ввода

1. Первая строка: два целых числа $n$ и $q$, представляющие длину массива и количество запросов соответственно.
2. Вторая строка: $n$ целых чисел, представляющих полный массив, уже отсортированный в порядке возрастания.
3. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса.

## Диапазон данных

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### Формат вывода

Для каждого запроса выведите начальную и конечную позиции элемента в массиве в одной строке. Если элемента нет в массиве, выведите `-1 -1`.

**Пример:**

```
Ввод:
6 3
1 2 2 3 3 4
3
4
5

Вывод:
3 4
5 5
-1 -1
```

**Пояснение:**

- Диапазон, где появляется элемент $3$, равен $[3, 4]$;
- Элемент $4$ появляется только один раз, в позиции $5$;
- Элемента $5$ нет в массиве, поэтому возвращаем $-1$ $-1$.

---

## Решение

- **Нахождение "Начальной позиции":**
  То есть, нахождение первой позиции, которая больше или равна $k$. Массив можно разделить на две части:
    - Все числа слева "меньше" $k$
    - Все числа справа "больше или равны" $k$
    - Ответом является первая позиция справа

- **Нахождение "Конечной позиции":**
  То есть, нахождение последней позиции, которая меньше или равна $k$. Массив можно разделить на две части:
    - Все числа слева "меньше или равны" $k$
    - Все числа справа "больше" $k$
    - Ответом является последняя позиция слева

---

## Рекомендуемый шаблон

Ниже приведен элегантный и менее подверженный ошибкам шаблон бинарного поиска.

Определим два указателя $l, r$, с инвариантом: замкнутый интервал $[0, l]$ принадлежит левой части, а замкнутый интервал $[r, n - 1]$ принадлежит правой части. $l$ и $r$ инициализируются значениями $-1$ и $n$ соответственно.

Когда алгоритм завершается, $l$ и $r$ становятся соседними, указывая на последний элемент левой части и первый элемент правой части соответственно.

Поскольку искомое решение может не существовать, если в условии задачи не указано, что решение обязательно существует, нам нужно проверить, не выходят ли `l` или `r` за границы и указывает ли он на правильное значение.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. Найти начальную позицию k
        //    Разделить массив на две части, левая часть - все < k, а правая часть - все >= k.
        //    Ответом является наименьший индекс правой части.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // Если r выходит за границы или nums[r] != k, это означает, что k не существует
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. Найти конечную позицию k
        //    Разделить массив на две части, левая часть - все <= k, а правая часть - все > k.
        //    Ответом является наибольший индекс левой части.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### Преимущества

1. Этот подход имеет строго определенные инварианты.
2. Он применим как для нахождения "начальной позиции", так и для "конечной позиции" без дополнительной обработки или изменений.
3. Некоторые подходы используют `l == r` в качестве условия завершения. Когда $l$ и $r$ отличаются на $1$, $mid$ будет вычислен равным $l$ или $r$. Если не обработать это правильно, обновление $l$ или $r$ до $mid$ не сократит интервал поиска, что приведет к бесконечному циклу. В отличие от этого, этот подход завершается, когда $l$ и $r$ являются соседними, гарантируя, что $mid$ меньше $l$ и больше $r$, и обновление $l$ или $r$ всегда будет сокращать интервал поиска.

---

## STL

Если вы используете функции `lower_bound` и `upper_bound`, предоставляемые C++ STL, вы можете достичь того же самого:

- `lower_bound(first, last, val)` вернет "первую позицию, которая больше или равна val"
- `upper_bound(first, last, val)` вернет "первую позицию, которая больше val"

Например, предположим, что `nums = {1,2,3,4,4,4,4,4,5,5,6}`, и мы хотим узнать диапазон, где появляется 4:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 появляется 0 раз" << endl;
} else {
    cout << "первая 4 находится в " << it1 - nums.begin() << endl;
    cout << "последняя 4 находится в " << it2 - nums.begin() - 1 << endl;
    cout << "4 появляется " << it2 - it1 << " раз" << endl;
}
```

- `it1` указывает на первую позицию, где значение больше или равно $4$.
- `it2` указывает на первую позицию, где значение больше $4$.
  Следовательно, `it2 - it1` - это количество раз, когда $4$ появляется в массиве; `it2 - nums.begin() - 1` - это позиция правой границы $4$.

---

## Дополнительные замечания

Бинарный поиск также может быть расширен для поиска в диапазонах с плавающей точкой (например, для нахождения корней уравнения) и троичного поиска для нахождения экстремумов унимодальных функций.

---

## Практика

LeetCode 33. Search in Rotated Sorted Array

Подсказка: Сначала используйте бинарный поиск, чтобы найти точку поворота, а затем используйте бинарный поиск, чтобы найти целевое значение.