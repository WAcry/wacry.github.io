---
title: "Двоичный поиск"
date: 2024-12-24
draft: false
description: "Как элегантно реализовать алгоритм двоичного поиска."
summary: "Как элегантно реализовать алгоритм двоичного поиска."
tags: [ "алгоритмы", "двоичный поиск", "шаблон алгоритма" ]
categories: [ "Алгоритмы и структуры данных" ]
---

Если упорядоченное пространство решений разделено на левую и правую части, где одна часть удовлетворяет условию, а другая нет, тогда для поиска критической точки в упорядоченном пространстве решений можно использовать двоичный поиск.

Основная идея двоичного поиска заключается в непрерывном делении интервала поиска пополам. При каждой проверке элемента в середине, если элемент не удовлетворяет условию, можно исключить половину интервала;
в противном случае, поиск продолжается в другой половине интервала. Поскольку каждый раз отбрасывается половина интервала поиска, временная сложность поиска может достигать $O(\log n)$.

## Пример задачи

**Описание задачи:**
Задан целочисленный массив длины $n$, отсортированный по возрастанию, а также $q$ запросов. Каждый запрос предоставляет целое число $k$, и нам нужно найти «начальную позицию» и «конечную позицию» $k$ в массиве (индексы начинаются с 0). Если этого числа нет в массиве, вернуть `-1 -1`.

### Формат ввода

1. Первая строка: два целых числа $n$ и $q$, представляющие длину массива и количество запросов соответственно.
2. Вторая строка: $n$ целых чисел, представляющих полный массив, отсортированный по возрастанию.
3. Следующие $q$ строк: каждая строка содержит целое число $k$, представляющее элемент запроса.

## Диапазон данных

$1 \leq n \leq 100000$

$1 \leq q \leq 10000$

$1 \leq k \leq 10000$

### Формат вывода

Для каждого запроса выведите в одной строке начальную и конечную позиции этого элемента в массиве. Если элемента нет в массиве, выведите `-1 -1`.

**Пример:**

```
Ввод:
6 3
1 2 2 3 3 4
3
4
5

Вывод:
3 4
5 5
-1 -1
```

**Объяснение:**

- Диапазон появления элемента $3$ равен $[3, 4]$;
- Элемент $4$ встречается только один раз в позиции $5$;
- Элемент $5$ отсутствует в массиве, поэтому возвращается $-1$ $-1$.

---

## Решение

- **Поиск «начальной позиции»:**
  То есть, поиск первой позиции, которая больше или равна $k$. Массив можно разделить на две части:
    - Все числа слева «меньше», чем $k$
    - Все числа справа «больше или равны», чем $k$
    - Ответом будет первая позиция справа

- **Поиск «конечной позиции»:**
  То есть, поиск последней позиции, которая меньше или равна $k$. Массив можно разделить на две части:
    - Все числа слева «меньше или равны», чем $k$
    - Все числа справа «больше», чем $k$
    - Ответом будет последняя позиция слева

---

## Рекомендуемый шаблон

Ниже представлен элегантный и не подверженный ошибкам шаблон двоичного поиска. Он гарантирует, что цикл завершится, когда $l$ и $r$ станут соседними, за счет их постепенного сближения:

Определим два указателя $l, r$ с инвариантом: закрытый интервал $[0, l]$ принадлежит левой половине, закрытый интервал $[r, n - 1]$ принадлежит правой половине. $l$
и $r$ инициализируются значениями $-1$ и $n$ соответственно.

Когда алгоритм завершится, $l$ и $r$ будут соседними, указывая на последний элемент левой половины и первый элемент правой половины, соответственно.

Поскольку желаемое решение может не существовать, то, если в условии не сказано, что решение существует всегда, нужно проверить, не выходят ли `l` или `r` за границы и указывают ли они на правильное значение.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> nums(n);
    for(int i = 0; i < n; i++) cin >> nums[i];

    while(q--) {
        int k;
        cin >> k;

        // 1. Находим начальную позицию k
        //    Делим массив на две части, слева все < k, справа все >= k.
        //    Ответ - минимальный индекс правой половины.
        int l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] >= k) r = mid; 
            else l = mid;
        }

        // Если r выходит за границы или nums[r] != k, значит k не существует
        if (r == n || nums[r] != k) {
            cout << -1 << " " << -1 << endl;
            continue;
        }

        int leftPos = r;

        // 2. Находим конечную позицию k
        //    Делим массив на две части, слева все <= k, справа все > k.
        //    Ответ - максимальный индекс левой половины.
        l = -1, r = n;
        while(l < r - 1) {
            int mid = (l + r) / 2;
            if(nums[mid] <= k) l = mid;
            else r = mid;
        }

        int rightPos = l;
        cout << leftPos << " " << rightPos << endl;
    }
    return 0;
}
```

### Почему так написано

1. В этой записи строго определены инварианты.
2. Она подходит как для поиска «начальной позиции», так и для поиска «конечной позиции», не требуя дополнительных манипуляций и изменений.
3. Некоторые записи используют `l == r` в качестве условия завершения. Когда $l$ и $r$ отличаются на $1$, вычисленное $mid$ может оказаться равным $l$ или $r$.
   Если это не обработать правильно, то, при обновлении $l$ или $r$ до $mid$, интервал поиска не сузится, что приведет к бесконечному циклу. Напротив, здесь запись завершается, когда $l$
   и $r$ соседние, гарантируя, что $mid$ меньше $l$ и больше $r$, при обновлении $l$ или $r$ интервал поиска обязательно уменьшится.

---

## STL

Если использовать функции `lower_bound` и `upper_bound`, предоставляемые C++ STL, можно сделать то же самое:

- `lower_bound(first, last, val)` вернет «первую позицию, где значение больше или равно val»
- `upper_bound(first, last, val)` вернет «первую позицию, где значение больше val»

Например, допустим `nums = {1,2,3,4,4,4,4,4,5,5,6}`, и мы хотим узнать диапазон, в котором встречается 4:

```cpp
vector<int> nums = {1,2,3,4,4,4,4,4,5,5,6};
auto it1 = lower_bound(nums.begin(), nums.end(), 4);
auto it2 = upper_bound(nums.begin(), nums.end(), 4);

if (it1 == nums.end() || *it1 != 4) {
    cout << "4 появляется 0 раз" << endl;
} else {
    cout << "первая 4 находится в " << it1 - nums.begin() << endl;
    cout << "последняя 4 находится в " << it2 - nums.begin() - 1 << endl;
    cout << "4 появляется " << it2 - it1 << " раз" << endl;
}
```

- `it1` указывает на первую позицию со значением больше или равным $4$.
- `it2` указывает на первую позицию со значением больше $4$.
   Таким образом, `it2 - it1` это количество раз, когда $4$ встречается в массиве; `it2 - nums.begin() - 1` это правая граница $4$.

---

## Дополнение

Двоичный поиск также может быть расширен на поиск в диапазоне вещественных чисел (например, поиск корней уравнений), а также на тернарный поиск для поиска экстремумов унимодальных функций.
Если вы поймете основную идею «**в упорядоченном интервале можно исключать половину каждый раз**», то увидите, что двоичный поиск может помочь эффективно решить задачи во многих сценариях.

---

## Упражнения

LeetCode 33. Search in Rotated Sorted Array

Подсказка: на первом шаге используйте двоичный поиск для поиска точки поворота, на втором шаге используйте двоичный поиск для поиска целевого значения.